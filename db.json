{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/custom.css","path":"css/custom.css","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/2.png","path":"img/2.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/3.png","path":"img/3.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/4.png","path":"img/4.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.png","path":"img/404.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/5.png","path":"img/5.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/Smile.png","path":"img/Smile.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/error-page.png","path":"img/error-page.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/girl8.png","path":"img/girl8.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/github.png","path":"img/github.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/newYear.jpg","path":"img/newYear.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/view1.jpg","path":"img/view1.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/view4.png","path":"img/view4.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/view9.jpg","path":"img/view9.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/planet/08b3b5bc32e74acfbfe530412b967092.png","path":"img/planet/08b3b5bc32e74acfbfe530412b967092.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/planet/20220710171444857.jpeg","path":"img/planet/20220710171444857.jpeg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/planet/4d5b121d880511ebb6edd017c2d2eca2.png","path":"img/planet/4d5b121d880511ebb6edd017c2d2eca2.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/planet/542dfb27880511ebb6edd017c2d2eca2.png","path":"img/planet/542dfb27880511ebb6edd017c2d2eca2.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/planet/6f1c9694f05b42099e17eef497806c87.png","path":"img/planet/6f1c9694f05b42099e17eef497806c87.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/planet/8fe66274880f11ebb6edd017c2d2eca2.png","path":"img/planet/8fe66274880f11ebb6edd017c2d2eca2.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/girl/girl1.png","path":"img/girl/girl1.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/planet/c89083824f074c0bad71a976de306a83.png","path":"img/planet/c89083824f074c0bad71a976de306a83.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/girl/girl2.png","path":"img/girl/girl2.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/girl/girl3.png","path":"img/girl/girl3.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/girl/girl4.png","path":"img/girl/girl4.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/girl/girl5.png","path":"img/girl/girl5.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/girl/view18.jpg","path":"img/girl/view18.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view.png","path":"img/wallpaper/view.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/girl/view30.jpg","path":"img/girl/view30.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view10.jpg","path":"img/wallpaper/view10.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view13.jpg","path":"img/wallpaper/view13.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view17.png","path":"img/wallpaper/view17.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view18.png","path":"img/wallpaper/view18.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view19.png","path":"img/wallpaper/view19.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view20.png","path":"img/wallpaper/view20.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view22.png","path":"img/wallpaper/view22.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view23.png","path":"img/wallpaper/view23.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view25.png","path":"img/wallpaper/view25.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view26.png","path":"img/wallpaper/view26.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view27.png","path":"img/wallpaper/view27.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view29.png","path":"img/wallpaper/view29.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view31.jpg","path":"img/wallpaper/view31.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view33.png","path":"img/wallpaper/view33.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view35.png","path":"img/wallpaper/view35.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view36.png","path":"img/wallpaper/view36.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view4.jpg","path":"img/wallpaper/view4.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view37.png","path":"img/wallpaper/view37.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view4.png","path":"img/wallpaper/view4.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view40.png","path":"img/wallpaper/view40.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view47.png","path":"img/wallpaper/view47.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view46.png","path":"img/wallpaper/view46.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view49.png","path":"img/wallpaper/view49.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view5.png","path":"img/wallpaper/view5.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view8.jpg","path":"img/wallpaper/view8.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wallpaper/view9.jpg","path":"img/wallpaper/view9.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_data/widget.yml","hash":"6ff0b9f4c59568fcaba7cc11e2797f95115c602e","modified":1729690224757},{"_id":"source/_data/link.yml","hash":"7542b4f6bdf9cf9baf4f3deab27017cd873430ca","modified":1730443285666},{"_id":"source/_posts/.gitignore","hash":"58a6d42b59e126114604701e70c266069f29584e","modified":1757552611441},{"_id":"source/_posts/Buffer.md","hash":"44f82ff1bd008a113accb019cef295049156b86d","modified":1758550868397},{"_id":"source/_posts/ElasticSearch.md","hash":"8a0c052545ef966b3b99d05ee3cfa33e51878aa2","modified":1758534046500},{"_id":"source/_posts/DateConverter.md","hash":"694f29ea494518578b08868fa5c47973375dbc7e","modified":1760013126148},{"_id":"source/_posts/Linux.md","hash":"5a63117be0500a30a9ad2cd66833a32b95a44148","modified":1758434740257},{"_id":"source/_posts/Nginx.md","hash":"ebf51a0141489a5b7d87618f4b4f364aaca72311","modified":1760441251927},{"_id":"source/_posts/Obsidian.md","hash":"60a577e140e4b13f50bb1523ea725e0581f7a5f5","modified":1745485085178},{"_id":"source/_posts/OptionalCheck.md","hash":"21147e52e88cc4de4d0019688eb1fd415b48d909","modified":1758460779404},{"_id":"source/_posts/RabbitMQ.md","hash":"a6dc187ab34abf91ed13c43bd9698c4f01cf5d7b","modified":1760346067985},{"_id":"source/_posts/SpringSecurity.md","hash":"53732ecf1da1ad45e0975cc712c0dba10565a934","modified":1763045419309},{"_id":"source/_posts/Serializable.md","hash":"f3d49b540b22cab6097e641b3ff3cee0c1be7fc9","modified":1760439354683},{"_id":"source/_posts/SpringCloud.md","hash":"c8016b3f5d2ca670adcdb6734ed807f26c0aaeda","modified":1757992722849},{"_id":"source/_posts/bitByte.md","hash":"c0efdb621edaf93c70e9fa4b72bdbd3475106b7b","modified":1745730063948},{"_id":"source/_posts/annotation.md","hash":"8fa5769bce96f116f7d9e89c6962c0707e601ed7","modified":1760357706121},{"_id":"source/_posts/SessionCookie.md","hash":"8d4973846ff05ed012d8847e087cd37d3ba488bc","modified":1757478407619},{"_id":"source/_posts/cacheManager.md","hash":"328a779a5206a8cd6104bfcc7633a62ece352e8f","modified":1760533199276},{"_id":"source/_posts/encrypt.md","hash":"3f50fbf1c0c900ec72a1f933ed397ec0395f9cb7","modified":1760949919827},{"_id":"source/_posts/doubleTable.md","hash":"07f7eae20000983357fbff122c91ad3ebd3bfa2d","modified":1757551185100},{"_id":"source/_posts/docker.md","hash":"743e8f0a81dd016d66e69527148dbf92b217ece8","modified":1758258318521},{"_id":"source/_posts/frontEnd.md","hash":"f315e4c9e187a9dac6afa6dc1e8b6dfb8cf1fe5c","modified":1760441344270},{"_id":"source/_posts/mybatis.md","hash":"eb8b09b8d63478ea381bd2cdc1c369055a8d5a4b","modified":1757551251364},{"_id":"source/_posts/proxy.md","hash":"8d37403f50b2989849ac563873a50aebc982d680","modified":1760428354112},{"_id":"source/_posts/git.md","hash":"28bcba365b63631114651c48c700ed5040001d6c","modified":1758195923479},{"_id":"source/categories/index.md","hash":"a0faf8ab751326234506c2a2e6bdbc8ea96bc677","modified":1730433060429},{"_id":"source/_posts/spring.md","hash":"c9b6679d72abc74463a0590b9f73a92ae5c067b8","modified":1757551071738},{"_id":"source/_posts/stackHeap.md","hash":"e8cfbb97c3a4241077b352f98312399e64aa75e1","modified":1745730261949},{"_id":"source/_posts/webDev.md","hash":"29c96b115c2902b45aa1f8f4d0ab6bb2ccf8481f","modified":1745728321111},{"_id":"source/_posts/stream.md","hash":"5296f801f02acbfa02aaf944f2d9e09b788ab0ab","modified":1760447161539},{"_id":"source/about/index.md","hash":"7bfdd5c3da3e8b9fc4e87779d978d8255715884a","modified":1744354748988},{"_id":"source/gallery/girl.md","hash":"60acc2139512a94474996e558e55139ef0779d27","modified":1730447867357},{"_id":"source/css/kslink.css","hash":"bfb77cc4cb323f728ef21cf8b5a177eab8483aeb","modified":1730383275021},{"_id":"source/link/index.md","hash":"8040d0308381350745eb32c408c099be5cd12d4d","modified":1730383304046},{"_id":"source/css/custom.css","hash":"e773bb914eca90079a5a9f218d44144e96be3562","modified":1730373963493},{"_id":"source/js/kslink.js","hash":"bbe0d8c457a028632a02fc49830f3ef6e84c3da2","modified":1730383254498},{"_id":"source/movies/index.md","hash":"2d73d91a8f128e2f62d902e392571352bfe8976e","modified":1744354675988},{"_id":"source/js/universe.js","hash":"ea22ec4b15698ad46493cf57cb3809cfae4bbf3d","modified":1729686782503},{"_id":"source/gallery/index.md","hash":"2173f31ad626fabc6670a3795c562c1c18890c19","modified":1744355586091},{"_id":"source/music/index.md","hash":"dc94943d8efadaa4dd0687c80aa810d991f424c0","modified":1744354647720},{"_id":"source/js/newYear.js","hash":"dd00d7d6a72046e61c9a653deb76bd3b542e9791","modified":1729690650177},{"_id":"source/tags/index.md","hash":"9b178b0ad32bb3c641da5346f9f2a09c9d8d3d55","modified":1730458906869},{"_id":"source/_posts/.obsidian/app.json","hash":"433f2b367ac8961d4d881c98ccb3977a710c8ec8","modified":1764131587724},{"_id":"source/_posts/.obsidian/appearance.json","hash":"ed600346d156af5f78395f893847c62ed7e9716f","modified":1758588449482},{"_id":"source/gallery/wallpaper.md","hash":"e6519db4b050a9aa490ba366594ff2f98149985d","modified":1730448770233},{"_id":"source/gallery/planet.md","hash":"70f5296377d99361c1695ae9f31e0cd6dc27f0af","modified":1730447730241},{"_id":"source/_posts/.obsidian/community-plugins.json","hash":"461a9fedabde7e454780365ed1dcd0f43c0ce10f","modified":1758588452598},{"_id":"source/_posts/.obsidian/daily-notes.json","hash":"644db5d51503f6d36d6475767dd5768e5f0cd6a3","modified":1736395744209},{"_id":"source/_posts/.obsidian/canvas.json","hash":"dadad86ac618bb0613a85daa542207e762815cec","modified":1736396023885},{"_id":"source/_posts/.obsidian/templates.json","hash":"22c111be5cd6ce85c5c4c16108b61ddba7d1a679","modified":1736395994279},{"_id":"source/_posts/.obsidian/core-plugins.json","hash":"a9d74f3ac72738992e5ad6ed3a4a1721ba0e9c12","modified":1758588449296},{"_id":"source/_posts/.obsidian/types.json","hash":"f7343a0d309f4ea15db8adcfd80dd1113a23d873","modified":1736396734078},{"_id":"source/_posts/Template/hexoTemplate.md","hash":"c4b1e499cf6cf572d04af08cc6e951bfc0b0d230","modified":1743215565423},{"_id":"source/_posts/.obsidian/graph.json","hash":"fbdf2a9ccf4ea589a9593696d09065f4976f8eee","modified":1743246157917},{"_id":"source/_posts/.obsidian/hotkeys.json","hash":"bfa9faa4c957541f967a48917c6a698b10a68196","modified":1743145755813},{"_id":"source/_posts/.obsidian/workspaces.json","hash":"3d0ad60c06d171f5e1c932eb7a440e4d222dfd43","modified":1736395627378},{"_id":"source/_posts/.obsidian/workspace.json","hash":"f52e5c84be3567e6832c087eba91f0c7b6c9dff9","modified":1764134370549},{"_id":"source/_posts/diary/2025-03-29.md","hash":"1cf8109b5fa438940cd1fdc9ed600bca8581c890","modified":1743245818286},{"_id":"source/_posts/diary/2025-05-12.md","hash":"fc94220d74a38936c2062640dd3f8d1a7292864b","modified":1764134333817},{"_id":"source/css/_layout/sun_moon.styl","hash":"6d7b2f48e04dca561eaec6d8f5b02140106d0377","modified":1729689675590},{"_id":"source/_posts/diary/2025-05-14.md","hash":"747871a68a0fea329536c189ca75a05539291343","modified":1764133797850},{"_id":"source/_posts/diary/2025-05-15.md","hash":"886a1cd22fb9bd7857d132521ee4efd916155748","modified":1763994793943},{"_id":"source/_posts/diary/2025-05-13.md","hash":"b0ca9125f7d7f7cfbb49b10588ba3fa46602bf67","modified":1764050889701},{"_id":"source/_posts/diary/2025-05-17.md","hash":"e4012e55948046b13783d3345cbb42c8044ffe89","modified":1764000530243},{"_id":"source/_posts/whiteBoard/canvas.canvas","hash":"74c189ccb48fd6e56f414a4bfd4223e182376e60","modified":1744792072308},{"_id":"source/_posts/diary/2025-05-16.md","hash":"3aa8e5d125d55168b779c93664065e4daf992354","modified":1763997829347},{"_id":"source/_posts/diary/2025-09-08.md","hash":"319de2b3f0b50e50c56fba275ad67de0da227b39","modified":1763009063050},{"_id":"source/_posts/diary/2025-05-18.md","hash":"1b7a9396be272173d683dbe9525b0c628cc7f543","modified":1747557416838},{"_id":"source/_posts/whiteBoard/未命名.canvas","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1743246175774},{"_id":"source/_posts/diary/2025-09-10.md","hash":"a1e283216edc67401d6b6c5096f70bcf6f51af8d","modified":1760448594322},{"_id":"source/_posts/diary/2025-09-11.md","hash":"44c3f369de752671aa88126dd9ab70a89e8ce077","modified":1757933782832},{"_id":"source/_posts/.obsidian/plugins/any-block/data.json","hash":"7965719ef2a54131186c0e29c57879c5d017858d","modified":1743215503223},{"_id":"source/_posts/.obsidian/plugins/any-block/manifest.json","hash":"417bb9ca64e2f7ec430c703445cc5eb114a1e0d0","modified":1743215492393},{"_id":"source/_posts/.obsidian/plugins/calendar/data.json","hash":"76c1ed10b72143ee63835579c6fedb942bf87250","modified":1758588448719},{"_id":"source/_posts/.obsidian/plugins/code-language-completer/data.json","hash":"ab7df2cb5bfb277884c2520d28a676af4c268924","modified":1762948265924},{"_id":"source/_posts/.obsidian/plugins/code-language-completer/manifest.json","hash":"42f3094dc4d632f5d13609d6c2e7148961d93052","modified":1740722966250},{"_id":"source/_posts/.obsidian/plugins/any-block/styles.css","hash":"9941a9cc51f02fe9083ea64bfa530264e29ce5fa","modified":1743215498926},{"_id":"source/_posts/.obsidian/plugins/calendar/manifest.json","hash":"4b3165bbfe96681d93dd48398eb543eb57f87175","modified":1736397548702},{"_id":"source/_posts/.obsidian/plugins/code-language-completer/main.js","hash":"dfb91f1920a6669cfedc865b0358d0d6ec942018","modified":1740722967683},{"_id":"source/_posts/.obsidian/plugins/obsidian-admonition/data.json","hash":"e063e48498fecd4554b53d7af84ec82d07a0db99","modified":1758588450472},{"_id":"source/_posts/.obsidian/plugins/image-converter/image-converter-image-alignments.json","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1758606458627},{"_id":"source/_posts/.obsidian/plugins/obsidian-admonition/styles.css","hash":"9817f240d92bf308a37918ffc89504a3637d7412","modified":1743216423715},{"_id":"source/_posts/.obsidian/plugins/obsidian-admonition/manifest.json","hash":"848194a1b7d3cabef550228ca9d5deba1697311d","modified":1743216419854},{"_id":"source/_posts/.obsidian/plugins/image-converter/manifest.json","hash":"77f054e3dea9e77e604034235cf8cc64891fa21d","modified":1744791719123},{"_id":"source/_posts/.obsidian/plugins/obsidian-auto-link-title/styles.css","hash":"ab566e8ba2a21c8f92b056d37e7d5264888c145a","modified":1743144335101},{"_id":"source/_posts/.obsidian/plugins/obsidian-auto-link-title/manifest.json","hash":"beb1486b4543f629435cdc3db9a36e854131cffb","modified":1743144332244},{"_id":"source/_posts/.obsidian/plugins/obsidian-auto-link-title/main.js","hash":"1fe27965911f0aa064f4614a91fef673a4db8b06","modified":1743144334344},{"_id":"source/_posts/.obsidian/plugins/obsidian-git/obsidian_askpass.sh","hash":"312b00428062ed16be019747f8bb3b05e92a98e3","modified":1757811240850},{"_id":"source/_posts/.obsidian/plugins/obsidian-git/manifest.json","hash":"7e82c7b210b29f6aa1ded28c5205dba6360f7445","modified":1757425078915},{"_id":"source/_posts/.obsidian/plugins/obsidian-git/data.json","hash":"b058fc644d0c2191d28db84d76a9c5b03257b3aa","modified":1757425097853},{"_id":"source/_posts/.obsidian/plugins/obsidian-linter/manifest.json","hash":"69a9fea74fabe8b15cabf944cfb2125ab929f64f","modified":1743144429869},{"_id":"source/_posts/.obsidian/plugins/obsidian-linter/data.json","hash":"eadb6fcde667103f4eab04a3840fe264a81a8692","modified":1758588452148},{"_id":"source/_posts/.obsidian/plugins/obsidian-emoji-toolbar/data.json","hash":"b8d55ce88e9e54920ac6316e35797f701065db7b","modified":1743244172716},{"_id":"source/_posts/.obsidian/plugins/obsidian-git/styles.css","hash":"cf35b081e1a13e804bf324e02496ff262f14bcc1","modified":1757425083638},{"_id":"source/_posts/.obsidian/plugins/obsidian-reading-time/main.js","hash":"3d33002baf4dd8079b9431822f3c0c94319991b8","modified":1736400408165},{"_id":"source/_posts/.obsidian/plugins/obsidian-linter/styles.css","hash":"36c364eedeb8c32fd270d13b2f68bce06e35c047","modified":1743144434310},{"_id":"source/_posts/.obsidian/plugins/obsidian-reading-time/manifest.json","hash":"4dd83119c4beb8efc855484c3322cf18f546ce78","modified":1736400406302},{"_id":"source/_posts/.obsidian/plugins/obsidian-emoji-toolbar/manifest.json","hash":"2adcd7f8cf803b24b039bc44d8ff37963e786c66","modified":1740723793205},{"_id":"source/_posts/.obsidian/plugins/obsidian-style-settings/data.json","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1740724273992},{"_id":"source/_posts/.obsidian/plugins/obsidian-style-settings/manifest.json","hash":"e67cc5ac8708ab42af7f724abdb2191fd1841f23","modified":1740723998769},{"_id":"source/_posts/.obsidian/plugins/obsidian-emoji-toolbar/styles.css","hash":"d0a600067e73927b65ca884446eeb5ea721886aa","modified":1740723795901},{"_id":"source/_posts/.obsidian/plugins/omnisearch/data.json","hash":"1955f32e6c19ed4b3f331edc63fd1d6543623b8a","modified":1758588453643},{"_id":"source/_posts/.obsidian/plugins/omnisearch/manifest.json","hash":"517d9850956a1d46b8e5752743c15851a12278ad","modified":1744791750273},{"_id":"source/_posts/.obsidian/plugins/pexels-banner/data.json","hash":"20b8649535805c7cdc592cdb8644b9bb85c0fbb0","modified":1758588448738},{"_id":"source/_posts/.obsidian/plugins/obsidian-outliner/manifest.json","hash":"9ad3de8d6f99773fbc875ad760d4c17b74d2a7a3","modified":1740723394234},{"_id":"source/_posts/.obsidian/plugins/obsidian-style-settings/styles.css","hash":"10f9e526bd19f716ce95cd7183c42cae055a1475","modified":1740724000470},{"_id":"source/_posts/.obsidian/plugins/quote-of-the-day/data.json","hash":"ed0e41fe7f2be43010e8f893bd50c6c9ec9cf15b","modified":1743215907868},{"_id":"source/_posts/.obsidian/plugins/omnisearch/styles.css","hash":"dbcd8e28346c1a0624ec80f300068db0c68c7e5b","modified":1744791758196},{"_id":"source/_posts/.obsidian/plugins/obsidian-outliner/styles.css","hash":"f27da75773dc1843c76bc3cd114959c48e3e370a","modified":1740723396316},{"_id":"source/_posts/.obsidian/plugins/pexels-banner/manifest.json","hash":"8e7f4cbe07ec5e2f496f546bf6a124f2778629ec","modified":1736399536915},{"_id":"source/_posts/.obsidian/plugins/pexels-banner/styles.css","hash":"960bcd8b2200204b2d67af7aa1ed7530ea4e12ef","modified":1736399541613},{"_id":"source/_posts/.obsidian/plugins/table-editor-obsidian/data.json","hash":"94c879cd5c6a819bd39c4de9d25919dcf08764a0","modified":1758588448697},{"_id":"source/_posts/.obsidian/plugins/quote-of-the-day/manifest.json","hash":"0ea4c5d69f62ff02573208ead7144163067a1566","modified":1743215518145},{"_id":"source/_posts/.obsidian/plugins/quote-of-the-day/main.js","hash":"9459175c02b64048f1bcf5d616193c471edc71fd","modified":1743215519859},{"_id":"source/_posts/.obsidian/plugins/quote-of-the-day/styles.css","hash":"c9a78b3bdd14ec8463e769ae491b8b31a4178382","modified":1743215521636},{"_id":"source/_posts/.obsidian/plugins/various-complements/data.json","hash":"9ff6db3f7bee3173fbddb43f8ba9c60443975c94","modified":1744722719036},{"_id":"source/_posts/.obsidian/plugins/table-editor-obsidian/styles.css","hash":"a03f657e10903825a3c4b2c2ff67b378b33df136","modified":1736397360176},{"_id":"source/_posts/.obsidian/plugins/various-complements/histories.json","hash":"c09b7428b0079fdbba3b4cf311d5781d99dd0967","modified":1744703990282},{"_id":"source/_posts/.obsidian/plugins/various-complements/manifest.json","hash":"4479dbddf833a3c05621518a02429a9e878a8a63","modified":1743144958644},{"_id":"source/_posts/.obsidian/plugins/table-editor-obsidian/manifest.json","hash":"b9c844ea413b92c807b7cbcbe2f9bf3973c1b622","modified":1736397355850},{"_id":"source/_posts/.obsidian/plugins/tokei/data.json","hash":"40919448aa0022a4d6f3e2b3325edcf63d2bc23e","modified":1740722897771},{"_id":"source/_posts/.obsidian/plugins/tokei/manifest.json","hash":"a23b6335396ef8d991e180178f1f9f9838fd268b","modified":1736400039234},{"_id":"source/_posts/.obsidian/themes/Minimal/manifest.json","hash":"3ab769b9487a00988bb0de1b2b4676e24805ca2e","modified":1736393626458},{"_id":"source/_posts/.obsidian/themes/Blue Topaz/manifest.json","hash":"03dccb4a4fe13da76b4a88dfc352f96ee6e872ad","modified":1736396672487},{"_id":"source/_posts/.obsidian/themes/Obsidian Nord/manifest.json","hash":"8bf923f083d545ff9f64afdc7695e47b56ec32ee","modified":1743246209367},{"_id":"source/_posts/.obsidian/plugins/tokei/styles.css","hash":"4b262f8d11f1456313439351aca73bdba6f5b756","modified":1736400043306},{"_id":"source/_posts/.obsidian/themes/Things/manifest.json","hash":"4e2dd336fedfdc5145a6607bcb3a2a4cb1fdcaed","modified":1736396880873},{"_id":"source/_posts/.obsidian/themes/Obsidian Nord/theme.css","hash":"5ab68ff9a9746f8ca33c470e26967b2398dd7565","modified":1743246209370},{"_id":"source/_posts/.obsidian/themes/Things/theme.css","hash":"96b07059344e59fe52ec6ca3a7e1cf7cad55c0e0","modified":1736396880880},{"_id":"source/_posts/.obsidian/plugins/image-converter/styles.css","hash":"cb3917d7ebad669dcaa75d3e14f0302deb99209e","modified":1744791736302},{"_id":"source/_posts/.obsidian/plugins/obsidian-outliner/main.js","hash":"1610183663284e46f64aaddd919187d8c4ca1309","modified":1740723395251},{"_id":"themes/butterfly/package.json","hash":"8f4797ba54f34ded0980634042b4981429c7db7c","modified":1729655655809},{"_id":"themes/butterfly/.github/FUNDING.yml","hash":"3b572099a992e30267f5fe4cd3c582ff7ac9f083","modified":1729655655695},{"_id":"themes/butterfly/README_CN.md","hash":"1c711ba472f83b539434d37e6cd34168b96c6072","modified":1729655655703},{"_id":"themes/butterfly/README.md","hash":"14986f184ddbd5094bcc6cdd97597ac5e6f45283","modified":1729655655702},{"_id":"themes/butterfly/plugins.yml","hash":"022abbb708b283b6b27541a2d150a17789ff8ee2","modified":1729655655810},{"_id":"themes/butterfly/languages/en.yml","hash":"a2c938b1ef69195aec10c90dc7d1871953548e01","modified":1729655655707},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1729655655701},{"_id":"themes/butterfly/languages/ja.yml","hash":"a281d3cc3e117e90597b783dc5569dba3976d2eb","modified":1729655655708},{"_id":"themes/butterfly/languages/default.yml","hash":"a2c938b1ef69195aec10c90dc7d1871953548e01","modified":1729655655706},{"_id":"themes/butterfly/languages/ko.yml","hash":"c7d861c58f204f47a5b4d6e118e1f1e8fb8a852f","modified":1729655655709},{"_id":"themes/butterfly/layout/archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1729655655713},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"e0bf36edf18cf3380b900be7528b536252990c26","modified":1729655655710},{"_id":"themes/butterfly/layout/index.pug","hash":"a93004cc8ec8050df603d32a6e6e02cd96fd9875","modified":1729655655806},{"_id":"themes/butterfly/layout/category.pug","hash":"a7e9805a781e34e38d27462e6ce2a5821c34bb9f","modified":1729655655714},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"bd7ee35aa30964493d2729ef105bb86331b096c3","modified":1729655655712},{"_id":"themes/butterfly/languages/zh-HK.yml","hash":"bac3063ad2892be232f7d91361c28585a3cc7eb5","modified":1729655655711},{"_id":"themes/butterfly/layout/tag.pug","hash":"ca5333bd262cb58c195c844b593a0eed0c721766","modified":1729655655808},{"_id":"themes/butterfly/layout/page.pug","hash":"c839d8ae0d801ff21425fc6358d83e7995c0b221","modified":1729655655806},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1729655655699},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"10ce05c8dbde09f53bdabe40b5388de9ccc71a31","modified":1729655655696},{"_id":"themes/butterfly/layout/post.pug","hash":"97f46fd254a34a24133ac41ec1a30abc5ee13495","modified":1729655655807},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1729655655698},{"_id":"themes/butterfly/scripts/events/404.js","hash":"039fc75f363d79669b0b2177d929cdff6f2ef7a4","modified":1729655655813},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1729655655814},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"63ad2249ad09fb3fe21bd5ff9adefb304a7ab24a","modified":1729655655697},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1729655655815},{"_id":"themes/butterfly/scripts/common/postDesc.js","hash":"272613a71d16f0de6dac883be4839259f774be76","modified":1729655655811},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"a5243ef225fcd2bed112c2d0c21d9667d11a927d","modified":1729655655815},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1729655655700},{"_id":"themes/butterfly/scripts/events/merge_config.js","hash":"c01ebae2480196857462df99caac4481f211048d","modified":1729655655817},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"bac639c404588ea62e601ef0bcd368c3bd0119af","modified":1729655655817},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1729655655818},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"7a293094ced8b8b73611929962d8974367a6d2d9","modified":1729655655822},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5ed2d7ef240c927fe1b7a7fb5bf9e55e2bfd55a5","modified":1729655655820},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"0df22d7dbfa766a65cb6032a1f003348f4307cfe","modified":1729655655820},{"_id":"themes/butterfly/scripts/helpers/getArchiveLength.js","hash":"bf77635e920eaf52bceebc95f87c7c87a7ca8038","modified":1729655655823},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"0cdf781a8c14d7b50d309e69f282ec7b178804bb","modified":1729655655823},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"fcbfd530a0d24e9dd8ff15bae5f58635606f8d46","modified":1729655655825},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"950b7d0966429bf0f9e6c5e1161e50e545e320b4","modified":1729655655826},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"2f44e1b3ccd170b256eae178299d6fa933a8d490","modified":1729655655828},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"0f4e2b0db2456fa29296042ff79b77c73d62418c","modified":1729655655824},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"45367c4ce827329867dbcc750ec125da9ccb2cfd","modified":1729655655827},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"25eefe10189caf3910a0e5d5b2f2043ae9255531","modified":1729655655830},{"_id":"themes/butterfly/scripts/tag/chartjs.js","hash":"195ba802d7e8406c155124a9c939a2318f82938b","modified":1729655655829},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"3b36505e152f76ebba7456a763fbbd466b9dbdcf","modified":1729655655830},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"5d08c3552f7d3c80a724ca628bff66321abe2e5a","modified":1729655655832},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"c863d2732ce4bdc084f2d0db92f50f80328c1007","modified":1729655655833},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1729655655835},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"289f85847c58f0b2b7d98a68e370a2896edb8949","modified":1729655655834},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"cf0bc17d0180231167cc6aa8a00fc64f198cb9f9","modified":1729655655834},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"35d54adc92e717cc32e13515122b025fd1a98ea2","modified":1729655655836},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"40bc9a065e3a1423e0e66f4911e00713ca9f5e9e","modified":1729655655837},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"3c486b149e28edd1a06843f05a5c355000991b82","modified":1729655655838},{"_id":"themes/butterfly/source/css/custom.css","hash":"c740ca541ed48e9bb3db0a6032e6b3807e7dcff3","modified":1730445809885},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"514b7df58d1197a9224dc8981cbb9a4a9a6429b5","modified":1729655655839},{"_id":"themes/butterfly/source/js/utils.js","hash":"83ac0eb9f39e5aa6b519ce2e21c1f978e2543235","modified":1729655655901},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"fdb5482d04a75bd79946ad1ed291d281d0e9362d","modified":1729655655900},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1729655655884},{"_id":"themes/butterfly/source/js/main.js","hash":"c5d0d0a3ff0090a4aaa26e03f8d21ba59de31903","modified":1729732591620},{"_id":"themes/butterfly/source/css/var.styl","hash":"a5b7497ca871742070cf16b09706c9e9cf27ec2d","modified":1729655655885},{"_id":"themes/butterfly/source/img/404.png","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1729655655886},{"_id":"themes/butterfly/source/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1729655655892},{"_id":"themes/butterfly/source/img/github.png","hash":"b1186e442b60b9642aecfc19e1995b6f41e16b9c","modified":1729660441552},{"_id":"themes/butterfly/source/img/Smile.png","hash":"ec62ebd591dc58e92953aa462b22c04010f4388e","modified":1729677533713},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1729655655895},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"875f6710d2b286461d13df349fff82c9f8ee501e","modified":1729655655715},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"47b117c1fb42ba6ca022655969f8d846609fc511","modified":1729655655716},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"0b4cfca89a743530b17a1e0a0f562790d842f882","modified":1729690035389},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"f5c8057a63c78a176ea88131e9ea6de73ea72484","modified":1729690031458},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"f05e0f3bdfd34e41c1e5615672cf54864fd9c9e5","modified":1729655655729},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"10d834891758e25becb005fd69ef2bb602c6ea79","modified":1729655655741},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"f28e1f91551a855c1f0deadf9d9293c46731f8ea","modified":1729655655744},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"814053dd7499284a5c185382eb43c8f8db25baf2","modified":1729655655843},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"7119f2f2943de71999d3dd6ba5c60cde846f114b","modified":1729655655898},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"d12340a7df4601b9a23f070e16645861aeb3bb0a","modified":1729655655842},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"2a0bbef173cbc478e11faa9c3bae1ae10d7c98db","modified":1729655655844},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"ba174889e770ae9f6683379b9eae9d8c94253080","modified":1729655655851},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"a51edfd3e499e7d38c32241c40e8e4d371efca73","modified":1729655655850},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"4cc02bcbaa4a1933a82a9ea57a603fe2d059fc77","modified":1729655655852},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"a2b783230a9143de69004cfc914d9f55e6fc1660","modified":1729655655899},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1729655655853},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"d7b988d8588207086670f39aa49fce442c429f7a","modified":1729655655854},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"094108f2a4e351a2fa496d6bd3e2388151416b3f","modified":1729655655855},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"ef8e8549fe7ad4b99793844a93b4a89f77f417d5","modified":1729655655858},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"d9cdf564a822a585e67fd5bac8573ba87eeb3743","modified":1729655655859},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"4c64cd9225437cbb83f411dc7531527b33730923","modified":1729655655856},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"110e76cc4d28a16c94bf8c47efc620edbe3a470a","modified":1729655655858},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1729655655856},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"7d68c2b499738a5097f027d95812032537f0a471","modified":1729655655861},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"205ccc7d0ec6ce1193b46bc0c9ce0385594581fb","modified":1729655655865},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"a0f5835f04358122e8b1d38dd3e8da09a1b5b431","modified":1729655655860},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"c4cda7b0c99015df29ce00fdfddd2f7679653754","modified":1729655655867},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"084dc4dfb41f55e237a9d6cf8c2f5dba729b83be","modified":1729655655861},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5abe5480d83ff8b452a780a484d50a44091475bf","modified":1729655655866},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"992d192db7d1c96e995b85ed11c20c571d33fbad","modified":1729655655869},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"fac159f30b3ead431aa76cfaca14a41d951e556f","modified":1729655655868},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"dcff804c4c237e1e908481b44c1ac4e39ac0da34","modified":1729655655868},{"_id":"themes/butterfly/source/css/_page/shuoshuo.styl","hash":"67aebae13e5a8abcc943b39db2370dc847b4e084","modified":1729655655870},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"d8a8275a68a1421c4c09b604cf78bea16c1d0463","modified":1729655655872},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"7543bb688876a946538d66b991c71b94b5216277","modified":1729655655871},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"6c4cbdadd9a49029fe0c59e29808d873e5b6b6ee","modified":1729655655873},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"02433ffe2ec6922811dd64b5f04cc8dfb3d65e30","modified":1729655655863},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"10c9124173a613b6d3b44871ebd33b5fb466a2c9","modified":1729655655875},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"09d2ca801d1a01ecaa3b2c4baaea02d7a6b89fce","modified":1729655655864},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1729655655876},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"1f2b86df86df81c3a59377b29102314ffc73dfa6","modified":1729655655874},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1729655655877},{"_id":"themes/butterfly/source/css/_tags/series.styl","hash":"fa585dd476c6d82167ef4fd5406f6d991dce5a88","modified":1729655655880},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"216f52fefc2274b542b549d8470503e6f1a308fb","modified":1729655655878},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"ec92892f6a23d06856ec457cf41003ca67689d80","modified":1729655655875},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"d27dbccaf3de1c9158d19e4fd49a25953cb5778d","modified":1729655655877},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1729655655883},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"4929382bd60788d34752a66e2fe764ef797a72a0","modified":1729655655879},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"611f5fb41ce17d2d2d5dd10ca8ad8dde1af5cdf2","modified":1729655655881},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"572f91e85c267fbc0ed3ebaf3917ff40ba52b4a0","modified":1729655655882},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"940a4c2472924237055a34a51606c8b49cd51a21","modified":1729655655718},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"f3e0cf1e7f889f622338870b24b790e55de8d44e","modified":1729655655719},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"464dd34a1a9af9b46499f5cfd5aab807be354b3f","modified":1729655655720},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"c175cfc4acd56e567f258c8c0482069ce8391840","modified":1729655655720},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1729655655721},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"f17ab71e9333d05806d07029453a5b03d0a3e0cc","modified":1729655655725},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"733184f88e3a586a5fcc9d193ad500556b6c8eed","modified":1729655655726},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"a2f7d69ca7ec58f24fe7d4e04ae21d5b62b01567","modified":1729655655731},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"a7c929b90ae52b78b39b1728e3ab0e3db1cb7b9a","modified":1729655655722},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1729655655724},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"d76ce71ba106e350670c021a3dcae57547d01830","modified":1729655655732},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"83ed05ef1e39f2ee70c3fba2cf96e488d8ffec66","modified":1729655655723},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"79f1556b29f902891cb6d5548a9d9211565a78d8","modified":1729655655727},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"9d2d539555bab495959b9df734ed5c43a9f9e5a9","modified":1729655655733},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"e2d31e0f450ad42c47f7ee96375799342bf2f19b","modified":1729655655729},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1729655655737},{"_id":"themes/butterfly/layout/includes/page/404.pug","hash":"15d32c511e4875066fcbe9cb84c3ada07b5a7c41","modified":1729655655736},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"7d799c4694adb6e265e3f4b975d7f7f6a7021a17","modified":1729655655728},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1729655655737},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"ef7afe0df7a3746744ac8185da7163b7406120ca","modified":1729655655734},{"_id":"themes/butterfly/layout/includes/mixins/indexPostUI.pug","hash":"7c3b5bb3a731f075667430e97bb51d8822105488","modified":1729655655735},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1729655655738},{"_id":"themes/butterfly/layout/includes/page/shuoshuo.pug","hash":"cf14b482787139c7d121d31160482a21ae483eb7","modified":1729655655739},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"db92f25ff3fd061882f81bf74ca560ff66983a0c","modified":1729655655743},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"79ad31eb72a9e14007770b18a426406a25315b38","modified":1729655655740},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"e5b5eb5833d5c324c3d29164235313800d5dedba","modified":1729655655784},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"b96c232e5178d927987791d9ae386dd83679535a","modified":1729655655742},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1729655655770},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1729655655794},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"ed79fef5b5025415ea12eaed970f3fe7f6ef9596","modified":1729655655747},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1729655655796},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"88f979a0b1a19eeb0db229247833bf9c6865c3b9","modified":1729655655786},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1729655655796},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"01ef6240a136c0df4478fabd3844b21cda970d16","modified":1729655655785},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1729655655798},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"a11455e294d32d2795eb1ee9d54a2906f064a1cb","modified":1729655655792},{"_id":"themes/butterfly/layout/includes/third-party/umami_analytics.pug","hash":"4a309a47274c218d65f3a1f6462a21bd6c2f839d","modified":1729655655793},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"d8753772889b5d0f4d15639ed6af5e91e53b1d03","modified":1729655655799},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1729655655798},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"d48d77af1670bd568d784794408bf524a448bfcc","modified":1729655655801},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1729655655802},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1729655655804},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"a22caf6c81bab67780182ccba982ebd7ab1a8a5a","modified":1729655655797},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1729655655802},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1729655655800},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"9f02598b5e4296aec6470639d4bac4c9ac46392e","modified":1729655655846},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"0144919df09c62c9c8526d985c7465eb92ad6f5c","modified":1729655655804},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"8df529f71e25f1c0a00e533de7944ed3d1ba7bd8","modified":1729655655805},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1729655655846},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"00b4073dbe0687a80e6d58c104c6f59ec01a84fd","modified":1729655655746},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"763cf396c4d71cf25ef25e9e15f421c90b3e9272","modified":1729655655849},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"cbfbcf34a24d21ba2b21cf9eedb76f4c3c563c5a","modified":1729655655750},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"d59d43a8caad801222608a341f6845c6f8d1b265","modified":1729655655746},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"077ec530831be1d80e93da380406b9f5abd0918a","modified":1729655655848},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"dfad5c3f8dcd8820d10b3b5268b638456afa6ca2","modified":1729655655849},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1729655655751},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1729655655752},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1729655655750},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"b03ee8625149191f9d5d057bbc9824b68d8dd0c4","modified":1729655655749},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"b5db4203a1392385838c73549ddeae0a4be67eba","modified":1729655655752},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"8d7f62dd8d057046bb55b411c16022802e69429c","modified":1729655655756},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"7884883ec15792f7e54daacb3c62b851dde2b66a","modified":1729655655753},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"e8438941085def0591a72fc9b0d705dbf107f54f","modified":1729655655757},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1729655655754},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"23d97d4334d741daa76886776f6b33016efc0d6e","modified":1729655655756},{"_id":"themes/butterfly/layout/includes/third-party/math/chartjs.pug","hash":"7650f6584fde8f7f9d1ba7057dc2e6befc1cd9a8","modified":1729655655772},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"b83db9fa64d42a0bfd97efb660e09be3f166a144","modified":1729655655773},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d41b60f48f94516e17c5fc20dc027db3213a089","modified":1729655655758},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"1a9e0239add2759b78511ea51b7a6630b2f75095","modified":1729655655773},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"ca2fc5928ca292f29fd8333c73733344994096fb","modified":1729655655775},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"451391d5367cae3f89efce2c37d431c5434b127a","modified":1729655655774},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"364d1fd655baca9132038ef1e312abde2c0bc7de","modified":1729655655760},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"f09689ed85e17e53abe87b435e92edbf1dbf7173","modified":1729655655759},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6fd3f88d0b8a944ab42191fd26f0602e877bc2d9","modified":1729655655761},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"203ed485c522b1d5a6fb6f05ed52e1d80a748384","modified":1729655655761},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"8d42378000ef74b81342efacd65b1906cfa325dd","modified":1729655655763},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"63587292f1cc8495b7a700085ce3f7b86a955920","modified":1729655655762},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"db6713d2b90eb8183f86ac92c26761a8501c0ddb","modified":1729655655764},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1729655655765},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"09c2ef4bc6d005f96dfa48b1d9af1ec095c5266d","modified":1729655655765},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"7f450664e6323a076ae59c393b0f22167cfa82e5","modified":1729655655766},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"15799610d20789f1b895d607f94140745eaee110","modified":1729655655767},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"e45ad0fb64761821259eb905e66e2768f5d3d2e9","modified":1729655655767},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1729655655787},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"f5a8d34b94c00476bf5bcb94c313a943b2a7154a","modified":1729655655769},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"75bf205ccb0b84481c93aad53984a5b7c75f3741","modified":1729655655770},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"013756ff3363344987cc00fc9bd833baf193c341","modified":1729655655787},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"2622b4cf9189fa23e4a422aaf9ef272e4f2c6137","modified":1729655655789},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"f8557548d2ad8dd149c562193991c6c6cda02415","modified":1729655655788},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1729655655790},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"efef352c1d122409575386bf3894dce8e87032e2","modified":1729655655792},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"e51e896ccb13900de38dc81cf44dc789e2418a12","modified":1729655655791},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"b6f7ddce953770660370dc147828151a63d208de","modified":1729655655776},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"adde60871bb8cf1a307ba822e8f602884a4e5f31","modified":1729655655779},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"dd7aef682b3164d45aa5bb56c646e549a903537a","modified":1729655655778},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/common.pug","hash":"fc6e154482978c709c613e6ba1c68249db050193","modified":1729655655777},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"81a7cfd0485bb77a6ea857208377c998cd1eceec","modified":1729655655782},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"398489f574b8d2c0c804ecf2d6294f349331b533","modified":1729655655781},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ba16e30bd223f7312e6a01415665f27f9c98c26d","modified":1729655655783},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1729655655780},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"f93269eed585ebe6328265d2dd6b171cefba08cf","modified":1729655655784},{"_id":"source/_posts/.obsidian/plugins/calendar/main.js","hash":"7206c7c4127f0fbf67958bc7f8d2f3b73e28efbc","modified":1736397550832},{"_id":"source/_posts/.obsidian/plugins/obsidian-style-settings/main.js","hash":"3c11145851ba6fbddf059f17336e720342261754","modified":1740723999851},{"_id":"source/_posts/.obsidian/plugins/pexels-banner/main.js","hash":"abf04233ff1a24fff3eca057d31b3014ec3c4894","modified":1736399539767},{"_id":"themes/butterfly/source/img/wallpaper/view40.png","hash":"6e3dfa4284d84ad5c80f61e5300ddae25ab4f80c","modified":1670032464000},{"_id":"source/_posts/.obsidian/plugins/tokei/main.js","hash":"1ba89bd95797dfdeaa7bcf5697365917918499ca","modified":1736400041607},{"_id":"source/_posts/.obsidian/plugins/various-complements/main.js","hash":"aa2fc6658f4f4a8711e7615122c196ae178dc4b9","modified":1743144965334},{"_id":"source/_posts/.obsidian/plugins/table-editor-obsidian/main.js","hash":"ebe7c19a7896b68dd50e03ece7b05b195a82957e","modified":1736397358627},{"_id":"themes/butterfly/source/img/view4.png","hash":"3f8e7c45a9d7a93e9cb67803781cdde629a690c8","modified":1670031986000},{"_id":"themes/butterfly/source/img/wallpaper/view4.jpg","hash":"3f8e7c45a9d7a93e9cb67803781cdde629a690c8","modified":1670031986000},{"_id":"themes/butterfly/source/img/wallpaper/view4.png","hash":"3f8e7c45a9d7a93e9cb67803781cdde629a690c8","modified":1730441618234},{"_id":"source/_posts/.obsidian/themes/Minimal/theme.css","hash":"0d3ad7eab8794c165c04b0bb31e5a8a725682b32","modified":1736393626473},{"_id":"themes/butterfly/source/img/wallpaper/view8.jpg","hash":"656aeab08e990027499456e53c79635817beb6dd","modified":1670031974000},{"_id":"source/_posts/.obsidian/plugins/omnisearch/main.js","hash":"b64c983f6247b7724e3d2be9f18fff93db602475","modified":1744791756670},{"_id":"themes/butterfly/source/img/girl/girl4.png","hash":"b0c357006920fa073bffeb8dc55eadf426d628c6","modified":1730441618777},{"_id":"themes/butterfly/source/img/girl/girl5.png","hash":"cd126e62bbe45abcd7b1af5b0269c8e96fe29117","modified":1730441618777},{"_id":"themes/butterfly/source/img/wallpaper/view13.jpg","hash":"5e16f92f79e88576f09678a5128c75bce0c57acb","modified":1670032578000},{"_id":"themes/butterfly/source/img/wallpaper/view26.png","hash":"e0144294b0e8ff7d1f3632370911df3345185037","modified":1670032330000},{"_id":"themes/butterfly/source/img/planet/20220710171444857.jpeg","hash":"c13577aac6fa336e4ed9779cb575d56fda7555d2","modified":1730441619346},{"_id":"themes/butterfly/source/img/girl/girl1.png","hash":"b3d54165fc6525ea13972603fe26f4f9b601213a","modified":1730441618751},{"_id":"themes/butterfly/source/img/wallpaper/view19.png","hash":"097431599f35349fd6d772f75b0e21c05156aa54","modified":1670032524000},{"_id":"source/_posts/多线程并发JUC.xmind","hash":"e3562d466d012a978fff894a0bd969272b294acb","modified":1757504746264},{"_id":"source/_posts/.obsidian/plugins/obsidian-linter/main.js","hash":"f52d41d3fa50e3d4705919bcd4d8446f735fc144","modified":1743144432651},{"_id":"themes/butterfly/source/img/wallpaper/view36.png","hash":"7a89e257da16fbe8a53d1ccc0112f6fcafde78f6","modified":1670032536000},{"_id":"source/_posts/assets/pixel-banner-image.png","hash":"ef3339ca7eb9657d042a45e34c40d60e10e8e60d","modified":1736399615279},{"_id":"source/_posts/.obsidian/plugins/obsidian-git/main.js","hash":"fcf2feebc7ed7f5361033db8567fa112b1795220","modified":1757425082929},{"_id":"themes/butterfly/source/img/wallpaper/view23.png","hash":"ef3339ca7eb9657d042a45e34c40d60e10e8e60d","modified":1670032380000},{"_id":"themes/butterfly/source/img/girl/view18.jpg","hash":"bdebcd4f8c16526e90cca5c860d97b1e627222b5","modified":1670032574000},{"_id":"themes/butterfly/source/img/girl8.png","hash":"33415434ff7e112ad45e1a7aae1b334a768ad423","modified":1730442052592},{"_id":"themes/butterfly/source/img/wallpaper/view20.png","hash":"302f6ac7f575fd46dbaf0b1e17d613538d533bc0","modified":1670032520000},{"_id":"themes/butterfly/source/img/wallpaper/view35.png","hash":"302f6ac7f575fd46dbaf0b1e17d613538d533bc0","modified":1730441618239},{"_id":"themes/butterfly/source/img/planet/542dfb27880511ebb6edd017c2d2eca2.png","hash":"076aee3714c980906eed8b9dffe177649089ccb6","modified":1730441619345},{"_id":"themes/butterfly/source/img/planet/c89083824f074c0bad71a976de306a83.png","hash":"a53a6261cf038a96af624d1b04d6de9b7b5fa9bf","modified":1730441619346},{"_id":"source/_posts/.obsidian/themes/Blue Topaz/theme.css","hash":"29f752695a1c49173d3bb70e8f6c10cc2f398e96","modified":1736396672528},{"_id":"source/_posts/.obsidian/plugins/obsidian-admonition/main.js","hash":"97774b4e1643d680e42a5e6651f2661a25ae155e","modified":1743216422305},{"_id":"themes/butterfly/source/img/3.png","hash":"e3de9ea2e549f7facbc32aa3b409db077378f4a1","modified":1670032390000},{"_id":"themes/butterfly/source/img/view9.jpg","hash":"8ad0b32593df581bf3480382162adf5a302dfb0a","modified":1670032366000},{"_id":"themes/butterfly/source/img/wallpaper/view9.jpg","hash":"8ad0b32593df581bf3480382162adf5a302dfb0a","modified":1670032366000},{"_id":"themes/butterfly/source/img/wallpaper/view10.jpg","hash":"e1ef142e2f0b04cc842f27ce4bd2ae4b14ad7d20","modified":1670032438000},{"_id":"themes/butterfly/source/img/girl/view30.jpg","hash":"df6b2d56a08fe568fbce190e5b01c2ff30529f65","modified":1730441618156},{"_id":"themes/butterfly/source/img/girl/girl2.png","hash":"1b9b04f0b9280619cf48eeafe08ccdd953f06943","modified":1730441618758},{"_id":"themes/butterfly/source/img/wallpaper/view27.png","hash":"5d0e57b78699580dd583c8d50c9842991b5256c2","modified":1670032324000},{"_id":"themes/butterfly/source/img/5.png","hash":"a416480cab88b35b310768d7a3a07262d1c3c533","modified":1670032360000},{"_id":"themes/butterfly/source/img/wallpaper/view25.png","hash":"ca16d2b13ebe2a2529a112fa6dd8c2b2830fe0c1","modified":1670032444000},{"_id":"themes/butterfly/source/img/view1.jpg","hash":"ddb81f9e34a344c1c0005a5c86cd9e829be8ca19","modified":1670032356000},{"_id":"themes/butterfly/source/img/2.png","hash":"0b732b35a6ac8c8cc1d798f0d85fe119f3f1a994","modified":1730441618234},{"_id":"source/_posts/.obsidian/plugins/obsidian-emoji-toolbar/main.js","hash":"849321a370f8699e4063f7fb0e9b815bb3a834bf","modified":1740723794648},{"_id":"themes/butterfly/source/img/wallpaper/view.png","hash":"0b732b35a6ac8c8cc1d798f0d85fe119f3f1a994","modified":1670032566000},{"_id":"themes/butterfly/source/img/wallpaper/view31.jpg","hash":"47511105ba1db4f9a2976d93eb8929d04234c2d7","modified":1730441618195},{"_id":"themes/butterfly/source/img/wallpaper/view47.png","hash":"0b732b35a6ac8c8cc1d798f0d85fe119f3f1a994","modified":1670032566000},{"_id":"source/_posts/.obsidian/plugins/image-converter/main.js","hash":"3c34a34b7bb0bc61f7aa7f1437400ec3adb29d55","modified":1744791733537},{"_id":"themes/butterfly/source/img/planet/6f1c9694f05b42099e17eef497806c87.png","hash":"dc635001128e265e4debe62302ff85ad64f336c6","modified":1730441619296},{"_id":"themes/butterfly/source/img/newYear.jpg","hash":"1616a7577733fd0a97e2294b5b71a228dbb28bbd","modified":1670032564000},{"_id":"themes/butterfly/source/img/wallpaper/view5.png","hash":"1616a7577733fd0a97e2294b5b71a228dbb28bbd","modified":1730441618253},{"_id":"themes/butterfly/source/img/wallpaper/view18.png","hash":"d51bd56da48c40caa75880b68c84fba8cde9053e","modified":1670032596000},{"_id":"themes/butterfly/source/img/wallpaper/view37.png","hash":"5e8b0984a7165f91690f1fb449448417e228bd85","modified":1670032600000},{"_id":"themes/butterfly/source/img/girl/girl3.png","hash":"2420a143471b630bacf74e260f5187326e4a6181","modified":1730441618778},{"_id":"themes/butterfly/source/img/planet/4d5b121d880511ebb6edd017c2d2eca2.png","hash":"e4b110f71621b3d1217c1b75a1140d03177358e2","modified":1730441619290},{"_id":"themes/butterfly/source/img/planet/08b3b5bc32e74acfbfe530412b967092.png","hash":"6d0fcdabccbf2b8f44095c761604bcfe601636b5","modified":1730441619313},{"_id":"themes/butterfly/source/img/wallpaper/view17.png","hash":"f9d1fe2468f1df97a660ea0005c9904b0a9dcceb","modified":1670032514000},{"_id":"themes/butterfly/source/img/4.png","hash":"f65c4e57511004793c0a459796edb130d4a70456","modified":1670032372000},{"_id":"themes/butterfly/source/img/wallpaper/view49.png","hash":"f65c4e57511004793c0a459796edb130d4a70456","modified":1670032372000},{"_id":"themes/butterfly/source/img/wallpaper/view33.png","hash":"3c9863a3405270c73a250a50e70b4bf595f883f3","modified":1670032436000},{"_id":"themes/butterfly/source/img/wallpaper/view46.png","hash":"fb6251c29943b90423a7d95f9de772a952bc2b66","modified":1670032312000},{"_id":"themes/butterfly/source/img/planet/8fe66274880f11ebb6edd017c2d2eca2.png","hash":"9b260faa220fc3a337c4a39286cbe46b9d069669","modified":1730441619347},{"_id":"themes/butterfly/source/img/wallpaper/view22.png","hash":"7442a6b438ec2763d3b39755385f04e1cfa8749f","modified":1670032114000},{"_id":"source/_posts/.obsidian/plugins/any-block/main.js","hash":"b165140e1929798ed02a1e45aa330e2271cc4e6a","modified":1743215496654},{"_id":"themes/butterfly/source/img/wallpaper/view29.png","hash":"9f7c09112c9da7443d84feb22300339529ae98be","modified":1670032320000},{"_id":"public/css/custom.css","hash":"5c5b88b1ac2795363d9a8acf80aff9639a5a774d","modified":1758606608580},{"_id":"public/css/kslink.css","hash":"c411b382eb75feed5f3fc6ffba48eef9ca72a794","modified":1758606608580},{"_id":"public/js/universe.js","hash":"fb0de0b3d7842d41b46dd113723dc77f82a4d530","modified":1758606608580},{"_id":"public/js/newYear.js","hash":"f363d155f4125c972110db335c91ad1d3d9e7adf","modified":1758606608580},{"_id":"public/js/kslink.js","hash":"3d5424275bd7649b1f0ca669e055db896831b712","modified":1758606608580},{"_id":"public/categories/index.html","hash":"7d54702fd564e5e42f5a68dd1352b978758f6a2c","modified":1764409586611},{"_id":"public/about/index.html","hash":"6a4e0ae0656d0ff71b215a8dc961c658de8171c0","modified":1764409586611},{"_id":"public/gallery/index.html","hash":"2d8dae327c0bda6941796c14aa53100be9b74037","modified":1764409586611},{"_id":"public/gallery/girl.html","hash":"93661ad77a1bb5d186124c393909251ce7581bee","modified":1764409586611},{"_id":"public/movies/index.html","hash":"8e45483ec7b5f5a34b6f2fea865f8dde87ddb640","modified":1764409586611},{"_id":"public/404.html","hash":"d29aeff1410b757cc6c40f82fc8ef7b3218f00e2","modified":1764409586611},{"_id":"public/link/index.html","hash":"d2f5f78b785287fd6f44d2de98bde649d2acc139","modified":1764409586611},{"_id":"public/tags/index.html","hash":"b37025f481103fce9ff5ad8ff6b6eaaf5a51f686","modified":1764409586611},{"_id":"public/gallery/wallpaper.html","hash":"32c423b778bef03a15cd0c1d8a3a3bb16dbcb59a","modified":1764409586611},{"_id":"public/music/index.html","hash":"e13db110194453354234ac4a94831b1c19d76603","modified":1764409586611},{"_id":"public/gallery/planet.html","hash":"44d8d6dfc16f548eef3fe5b41cded027872db12f","modified":1764409586611},{"_id":"public/2025/09/17/Buffer/index.html","hash":"c2e5bde08f4e884cd7d4ddc6098a117f28dce774","modified":1764409586611},{"_id":"public/2025/09/09/SpringSecurity/index.html","hash":"9c833bb05d9b5dc12c87752a05499b1826f1e472","modified":1764409586611},{"_id":"public/2025/04/15/cacheManager/index.html","hash":"5976e5fb0e4960ff0412c6987c4289b99f8f4874","modified":1764409586611},{"_id":"public/2025/03/22/webDev/index.html","hash":"0547d2aaaeadd85eda0a267da23650c736185b57","modified":1764409586611},{"_id":"public/2025/03/06/SpringCloud/index.html","hash":"113f2e7f3043fad100f656ebe94fd845bceebf93","modified":1764409586611},{"_id":"public/2025/02/24/ElasticSearch/index.html","hash":"6fc13b8c3c4e8dddee071bc806ec33516a3fb1f6","modified":1764409586611},{"_id":"public/2025/02/17/RabbitMQ/index.html","hash":"37efc85ad93503752c603c09b7112e7e73b20a99","modified":1764409586611},{"_id":"public/2024/12/31/OptionalCheck/index.html","hash":"b43a393a6c222363af004cd9961587fafa0c8aae","modified":1764409586611},{"_id":"public/2024/12/28/SessionCookie/index.html","hash":"3ce18967c3c5069fae932006dc60eb7bfb185725","modified":1764409586611},{"_id":"public/2024/12/06/encrypt/index.html","hash":"c096eb7e4b485111510130cabc39e2d662900514","modified":1764409586611},{"_id":"public/2024/12/18/mybatis/index.html","hash":"5d51d49d9ce7b82317e2a99853889ba65794450b","modified":1758606608580},{"_id":"public/2024/12/02/bitByte/index.html","hash":"d9a1b2e3d38c96644ea03efcd6b7275a6b508b0d","modified":1764409586611},{"_id":"public/2024/12/02/stackHeap/index.html","hash":"9fed0e6623d66715ab636e1cd4d10ed8d2fa93c1","modified":1764409586611},{"_id":"public/2024/11/29/proxy/index.html","hash":"ef275ca925c84217f2aea16cd167ba4b57896c3e","modified":1764409586611},{"_id":"public/2024/11/28/stream/index.html","hash":"8d16251ede7043201e2ec39f8dbc264728f11602","modified":1764409586611},{"_id":"public/2024/11/25/git/index.html","hash":"595a57e257dfa3e5ebadd36f4a7a34c38dafca32","modified":1764409586611},{"_id":"public/2024/11/25/Linux/index.html","hash":"b0f8364bf783d10b4b86d4dc8d24d4220d740dde","modified":1764409586611},{"_id":"public/2024/11/23/DateConverter/index.html","hash":"82c718a1722bddc66cfd3c67728f03e5c66e5592","modified":1764409586611},{"_id":"public/2024/11/25/docker/index.html","hash":"507a42107c8981928681483c8544e6ba0f18862d","modified":1764409586611},{"_id":"public/2024/11/19/Serializable/index.html","hash":"5dcaa9e0f73dcb1bb8af9dba5b692e42a183f4d6","modified":1764409586611},{"_id":"public/2024/11/12/doubleTable/index.html","hash":"a93c96f77e4990c7178d77a6f0c4ecff444dff7d","modified":1764409586611},{"_id":"public/2024/11/04/spring/index.html","hash":"c4a27120586c774870043800072044c1fb2e2aa9","modified":1758606608580},{"_id":"public/2024/10/30/frontEnd/index.html","hash":"da92384bf76470fa6796956802c3f5d893164fee","modified":1764409586611},{"_id":"public/2024/10/23/Nginx/index.html","hash":"6ea529cbf52e6718503c52b3f2a5b3fd080e4531","modified":1764409586611},{"_id":"public/2024/11/01/annotation/index.html","hash":"eb967fb3113063182f5c206840fb0fe434fe65e3","modified":1764409586611},{"_id":"public/artitalk/index.html","hash":"bf7a53daae662522242b3d53c41283abd7954a8a","modified":1764409586611},{"_id":"public/archives/index.html","hash":"f704e41bd47484ecb3f2a8cd59ea38508f76a87b","modified":1764409586611},{"_id":"public/archives/page/2/index.html","hash":"9275ce4b9d469cd11e2417d3e36eb48721072633","modified":1764409586611},{"_id":"public/archives/page/3/index.html","hash":"fb5a59572677a0bfee86a6f909efff693a98892e","modified":1764409586611},{"_id":"public/archives/2024/index.html","hash":"33a3237a6cffc80fb987ec058bb9e098bf079156","modified":1764409586611},{"_id":"public/archives/2024/page/2/index.html","hash":"7ce222c3b997a15ec890d7929dc5a4332f113d6e","modified":1764409586611},{"_id":"public/archives/2024/11/index.html","hash":"056d56e26d4f5a18227dc9f5664cd2d21f57156a","modified":1764409586611},{"_id":"public/archives/2024/10/index.html","hash":"6ba95aee18acc95216936310cb6be9352348cfda","modified":1764409586611},{"_id":"public/archives/2024/12/index.html","hash":"79ce5af9a5b57990312c947a792bb0e8bf624981","modified":1764409586611},{"_id":"public/archives/2025/index.html","hash":"30bd3779b905fd5984bee5102a35f3eb90657829","modified":1764409586611},{"_id":"public/archives/2025/03/index.html","hash":"0fbbc5d9c0c69e5a3098f3f5290c32ebde52261d","modified":1764409586611},{"_id":"public/archives/2025/02/index.html","hash":"c2559ef262d713afb74b1bacbe1a99e5643ab2b0","modified":1764409586611},{"_id":"public/archives/2025/04/index.html","hash":"be215e6b34383f630d7ad2db5f2bc877b4edcb19","modified":1764409586611},{"_id":"public/archives/2025/09/index.html","hash":"025ef1de3ca4a511a07e30a2cd082d26435dddbd","modified":1764409586611},{"_id":"public/page/2/index.html","hash":"f0a019d097329bcdad3df9ac812e788cafd9c096","modified":1764409586611},{"_id":"public/page/3/index.html","hash":"deaf63ff17b21ba5197c08a4ec49be00a3a82f53","modified":1764409586611},{"_id":"public/categories/编程/index.html","hash":"c6fde3aeca437f7ae8b8f3e86adc8aa5c698f6cc","modified":1764409586611},{"_id":"public/categories/编程/page/3/index.html","hash":"e0c5fffccb870bedb1dedaa37ffdcae45efa6316","modified":1764409586611},{"_id":"public/index.html","hash":"ab94e7e96a07882cf0786f4dde951c46e55f59e5","modified":1764409586611},{"_id":"public/categories/编程/page/2/index.html","hash":"e039224cc36ef47044e6d5685df3109cb6a49808","modified":1764409586611},{"_id":"public/tags/Buffer/index.html","hash":"336094b37cc9e20cbcb178fc0b973524126d4954","modified":1764409586611},{"_id":"public/tags/ZeroCopy/index.html","hash":"a2b53bd297705276bdc93700a24cde521fada392","modified":1764409586611},{"_id":"public/tags/Kernel/index.html","hash":"473cb58b77ebf6d49e94a385b45175a0ead85a95","modified":1764409586611},{"_id":"public/tags/Converter/index.html","hash":"4a5d69feb6a8f13edd43cdc169a427954811d3cb","modified":1764409586611},{"_id":"public/tags/Date/index.html","hash":"bd8f1880504f748f982e4ae1772d95c047ac44f1","modified":1764409586611},{"_id":"public/tags/DateTimeFormatter/index.html","hash":"f0dc973ce635453560bd46e89d7e3c63949c19c3","modified":1764409586611},{"_id":"public/tags/LocalDateTime/index.html","hash":"ef9340dace40777bfe152987d0789681a98bab1a","modified":1764409586611},{"_id":"public/tags/ElasticSearch/index.html","hash":"0954bfb2837073039470f470ca7d16effb616a18","modified":1764409586611},{"_id":"public/tags/Nginx/index.html","hash":"ab6a3316af645c32fef7310a9806a3dd31e28777","modified":1764409586611},{"_id":"public/tags/chuangTu/index.html","hash":"ee4943e30c9cd614817cb18ea9b698bda64b0e8a","modified":1764409586611},{"_id":"public/tags/Linux/index.html","hash":"a35bfb7020569787b15395025c01462c7eeaeb26","modified":1764409586611},{"_id":"public/tags/Cors/index.html","hash":"4942c420d64401f662aded98f8ad14e4cf5ec804","modified":1764409586611},{"_id":"public/tags/RabbitMQ/index.html","hash":"c6e87e9b4093d232657869526148932024f5462a","modified":1764409586611},{"_id":"public/tags/SnowflakeId/index.html","hash":"90e35fd61af932050c76726fa575c301076bfeea","modified":1764409586611},{"_id":"public/tags/RocketMQ/index.html","hash":"867db745068c875d552fe3ed4428602d37d8cd98","modified":1764409586611},{"_id":"public/tags/Serializable/index.html","hash":"e5cdda69a56cfd93c19fe2fe5b4cb943d543f14f","modified":1764409586611},{"_id":"public/tags/SpringCloud/index.html","hash":"3d17ddf99b6f029da279fd51153a55dff36f3ed9","modified":1764409586611},{"_id":"public/tags/session/index.html","hash":"e367c625552413ce6767b68f75af2d67998da57a","modified":1764409586611},{"_id":"public/tags/cookie/index.html","hash":"1c3e33445da5b21838405588d91615bcd4540c50","modified":1764409586611},{"_id":"public/tags/SpringSecurity/index.html","hash":"8615d8a728cca6110fa22eacc4372835d262fd8e","modified":1764409586611},{"_id":"public/tags/Annotation/index.html","hash":"1e59915836e67c6006b4fb5db1fac2b04dd3405b","modified":1764409586611},{"_id":"public/tags/byte/index.html","hash":"9b14fee1b122a74926bf9d95d5fc4f7c4c4e2f20","modified":1764409586611},{"_id":"public/tags/bit/index.html","hash":"de82a7a8aafa7305669b4451a9fa9ac9eb3a2d59","modified":1764409586611},{"_id":"public/tags/Cache/index.html","hash":"b1eb7bf674702010ebf762664caf8db6606d3b20","modified":1764409586611},{"_id":"public/tags/Docker/index.html","hash":"fad1da349aafb6e8472eef3a48a73750ad7138f7","modified":1764409586611},{"_id":"public/tags/encrypt/index.html","hash":"4aaf7fc7640a1914ceee4e1fe5c61b98ef0f9352","modified":1764409586611},{"_id":"public/tags/Redis/index.html","hash":"b5c3d6ec1af88b4a25bf6ebf21077cedde04f52b","modified":1764409586611},{"_id":"public/tags/Web/index.html","hash":"198ca0cd13ffb8f3f2a4a08ec9949dcf322117bd","modified":1764409586611},{"_id":"public/tags/Servlet/index.html","hash":"6909c55b50f0c3502367ecda1be94b3faa757c4b","modified":1764409586611},{"_id":"public/tags/CORS/index.html","hash":"be3f0812bc6bfd159a04a49217addfa4ca79712b","modified":1764409586611},{"_id":"public/tags/proxy/index.html","hash":"8d56cb627db7022b3726a3c3529fa236552ed9bf","modified":1764409586611},{"_id":"public/tags/mysql/index.html","hash":"39c961c2a78e286c734dd861060c09994ca8ae38","modified":1764409586611},{"_id":"public/tags/mybatis/index.html","hash":"72e62cf14d5fbe3656c1ee3b306aee293abe1d7b","modified":1764409586611},{"_id":"public/tags/spring/index.html","hash":"ed0547905c6dbe96a3c51a6deaedab3ef38556c5","modified":1764409586611},{"_id":"public/tags/springBoot/index.html","hash":"085ccd96aa118ae92d44130f71479231904291a4","modified":1764409586611},{"_id":"public/tags/Git/index.html","hash":"cb9515d1c9f67f4461e30f8197753e155c26ca17","modified":1764409586611},{"_id":"public/tags/stream/index.html","hash":"86cc13e9a5835793cd7bb34d559fb309b1675b0d","modified":1764409586611},{"_id":"public/tags/heap/index.html","hash":"466167143cbf0be01e7fc67fc48a03185a86c14e","modified":1764409586611},{"_id":"public/tags/stack/index.html","hash":"b955a3627b52e66fb3d120f5504c47bd4a21917b","modified":1764409586611},{"_id":"public/tags/Jvm/index.html","hash":"db0dd4d3352e552343533f30bafe85e7a3656321","modified":1764409586611},{"_id":"public/img/Smile.png","hash":"ec62ebd591dc58e92953aa462b22c04010f4388e","modified":1758606608580},{"_id":"public/img/404.png","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1758606608580},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1758606608580},{"_id":"public/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1758606608580},{"_id":"public/img/github.png","hash":"b1186e442b60b9642aecfc19e1995b6f41e16b9c","modified":1758606608580},{"_id":"public/live2dw/assets/exp/f01.exp.json","hash":"84073a497ddb6e56c6cfc244a0fb217ba473abf9","modified":1758606608580},{"_id":"public/live2dw/assets/exp/f04.exp.json","hash":"35e746ede62e7090e7dfb08561d77772f58b4153","modified":1758606608580},{"_id":"public/live2dw/assets/exp/f02.exp.json","hash":"241b6afafa2e25c6d7a54692a8b5aa060a137ab1","modified":1758606608580},{"_id":"public/live2dw/assets/exp/f03.exp.json","hash":"fbf7729e504f14f83f976827fcf62301a6579a34","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/flickHead_00.mtn","hash":"f64c79c9171660db5c440bef229ac2e35a1597d5","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/flickHead_01.mtn","hash":"a1011d6bf397bcd3c3c968d9616f88fe1ffbc83c","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/idle_02.mtn","hash":"7f5d2cf8706007c8659938eba132a68c470a4c26","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/idle_01.mtn","hash":"88c2494655dbb712b842f03232b619f381753d52","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/flickHead_02.mtn","hash":"d3c9c0acb4dc25a2274f3b9faa71e5ce60ad92e4","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/idle_00.mtn","hash":"378b4577217c604c9d28ab4edf8b707c8d8c2fbb","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/pinchIn_01.mtn","hash":"a5fefb45115695db72b9499e627a51b2b9394f2c","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/pinchIn_00.mtn","hash":"70978b4c983f6a9fd6d3d9c24571586f7d6eac30","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/pinchIn_02.mtn","hash":"aa0d66ca9b06c374577fd7e64e89756de1e1f2ae","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/shake_00.mtn","hash":"5185d02c7ab9f0bec3d4a890b54b2378e553373d","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/pinchOut_00.mtn","hash":"e07fe8fd8c2810e3c1d28b730bd49c8c25849bad","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/pinchOut_02.mtn","hash":"b323fd350d334b33bbdfb31194ae664089986c27","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/shake_01.mtn","hash":"e812985a56796e122018f9d57d1606a4866ff7d1","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/pinchOut_01.mtn","hash":"e05df948d08b17f34c993a9c1f901190509d5db0","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/tapBody_00.mtn","hash":"835aa3d4a8fbd26c0bb66b164a19464fa3f17a99","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/shake_02.mtn","hash":"2702970805e07777974c383613e631730982bcff","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/tapBody_01.mtn","hash":"78fca17436ab5e065e27f419f135aa6c0a0b52ef","modified":1758606608580},{"_id":"public/live2dw/assets/shizuku.physics.json","hash":"6484d646e79a44c83784c6ae434cf7349746c5c8","modified":1758606608580},{"_id":"public/live2dw/assets/mtn/tapBody_02.mtn","hash":"a75acb51c1191ce5050d3ee1af6f2dcc787c7c5e","modified":1758606608580},{"_id":"public/live2dw/assets/snd/flickHead_00.mp3","hash":"356388d939006b03cf9e6158c603b58d4800bec1","modified":1758606608580},{"_id":"public/js/utils.js","hash":"c93d1833add96e2d26c9272bd443a5f35ae5b6b4","modified":1758606608580},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1758606608580},{"_id":"public/js/search/local-search.js","hash":"4e11d033fb58563f5e1b497f1a6f1c62d3501ee6","modified":1758606608580},{"_id":"public/js/search/algolia.js","hash":"e5821f78381af9f0f646952a7dd118daab2a79a6","modified":1758606608580},{"_id":"public/js/main.js","hash":"8898c6aca090caa525e0684fc2777f8a65d763ac","modified":1758606608580},{"_id":"public/css/index.css","hash":"c853384c5ab411503615a42b95ff9eb71df9aabb","modified":1758606608580},{"_id":"public/js/tw_cn.js","hash":"7ef59df188ea523da89f4caf69c5c0f14e78da69","modified":1758606608580},{"_id":"public/live2dw/assets/shizuku.pose.json","hash":"ac5505efbf80ba0a2e5783d67fe232bc5c6f1f80","modified":1758606608580},{"_id":"public/live2dw/assets/shizuku.model.json","hash":"19a05bd41b806a935cea42c2000626fc82da2536","modified":1758606608580},{"_id":"public/live2dw/assets/snd/flickHead_02.mp3","hash":"5f63477ce63f2073e24d68fea906fe136fe6349e","modified":1758606608580},{"_id":"public/live2dw/assets/snd/pinchIn_01.mp3","hash":"d5c8cc6f61b56222a83a5174f75006f83c3b88da","modified":1758606608580},{"_id":"public/live2dw/assets/snd/flickHead_01.mp3","hash":"436d0bbccf6e7a2744447554947eee4563608970","modified":1758606608580},{"_id":"public/live2dw/assets/snd/pinchIn_00.mp3","hash":"f9baa3b7cadec20b714135fc49cfab3ff6adeeb4","modified":1758606608580},{"_id":"public/live2dw/assets/snd/shake_00.mp3","hash":"f65dd58e7b44ec5c865d13c190316070b625b5fe","modified":1758606608580},{"_id":"public/live2dw/assets/snd/shake_02.mp3","hash":"8882b94bce00f09232588b7301badb105fa8acab","modified":1758606608580},{"_id":"public/live2dw/assets/snd/tapBody_00.mp3","hash":"003e68a59a9c8392e230f34c91860efbd946277a","modified":1758606608580},{"_id":"public/live2dw/assets/snd/shake_01.mp3","hash":"c1e0e8a07ff268ee06c2b7825d1b645e193f21b9","modified":1758606608580},{"_id":"public/live2dw/assets/snd/tapBody_02.mp3","hash":"15e7815ed0a0e5164e18e0c53b97aedc742a134d","modified":1758606608580},{"_id":"public/live2dw/assets/snd/tapBody_01.mp3","hash":"5314b50f153df71559e51e2586581c006df00722","modified":1758606608580},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1758606608580},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_03.png","hash":"07f568a2bb8045b6bdff7783fb4daf62c821f9ab","modified":1758606608580},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_00.png","hash":"21bdb28b31783e23b26b3aa061e90be4088665aa","modified":1758606608580},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_05.png","hash":"0cd00007fb8bff62a2eb08e1d7c43abab8722224","modified":1758606608580},{"_id":"public/live2dw/assets/snd/pinchOut_00.mp3","hash":"0654f38f6e9fd623eaf8be11b5d58c9d12991949","modified":1758606608580},{"_id":"public/live2dw/assets/snd/pinchIn_02.mp3","hash":"5b63e02607571ac601c500995e836e6c861b1c62","modified":1758606608580},{"_id":"public/live2dw/assets/snd/pinchOut_01.mp3","hash":"8a081030fd53c07bffe3edd48f87a371ca77296b","modified":1758606608580},{"_id":"public/live2dw/assets/snd/pinchOut_02.mp3","hash":"554edb2f3838cbdc27d1a9c6b8a9cb6eb465cbdd","modified":1758606608580},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1758606608580},{"_id":"public/img/wallpaper/view40.png","hash":"6e3dfa4284d84ad5c80f61e5300ddae25ab4f80c","modified":1758606608580},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_01.png","hash":"3d0e745f3e560071ee08beeecde186e5ea35d99e","modified":1758606608580},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_04.png","hash":"f764d594841905db8b2998dd61c329866125ad97","modified":1758606608580},{"_id":"public/img/view4.png","hash":"3f8e7c45a9d7a93e9cb67803781cdde629a690c8","modified":1758606608580},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1758606608580},{"_id":"public/img/wallpaper/view4.jpg","hash":"3f8e7c45a9d7a93e9cb67803781cdde629a690c8","modified":1758606608580},{"_id":"public/img/wallpaper/view4.png","hash":"3f8e7c45a9d7a93e9cb67803781cdde629a690c8","modified":1758606608580},{"_id":"public/live2dw/assets/moc/shizuku.1024/texture_02.png","hash":"055eb2da9c13e9116be93a1e60c0ea2b660af864","modified":1758606608580},{"_id":"public/img/wallpaper/view8.jpg","hash":"656aeab08e990027499456e53c79635817beb6dd","modified":1758606608580},{"_id":"public/img/girl/girl4.png","hash":"b0c357006920fa073bffeb8dc55eadf426d628c6","modified":1758606608580},{"_id":"public/img/wallpaper/view13.jpg","hash":"5e16f92f79e88576f09678a5128c75bce0c57acb","modified":1758606608580},{"_id":"public/img/girl/girl5.png","hash":"cd126e62bbe45abcd7b1af5b0269c8e96fe29117","modified":1758606608580},{"_id":"public/img/wallpaper/view26.png","hash":"e0144294b0e8ff7d1f3632370911df3345185037","modified":1758606608580},{"_id":"public/img/girl/girl1.png","hash":"b3d54165fc6525ea13972603fe26f4f9b601213a","modified":1758606608580},{"_id":"public/img/wallpaper/view19.png","hash":"097431599f35349fd6d772f75b0e21c05156aa54","modified":1758606608580},{"_id":"public/img/planet/20220710171444857.jpeg","hash":"c13577aac6fa336e4ed9779cb575d56fda7555d2","modified":1758606608580},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1758606608580},{"_id":"public/img/wallpaper/view36.png","hash":"7a89e257da16fbe8a53d1ccc0112f6fcafde78f6","modified":1758606608580},{"_id":"public/live2dw/assets/moc/shizuku.moc","hash":"c2670a0f75830edc89d7fe6d074de4ee67e8dc5d","modified":1758606608580},{"_id":"public/img/wallpaper/view23.png","hash":"ef3339ca7eb9657d042a45e34c40d60e10e8e60d","modified":1758606608580},{"_id":"public/img/girl/view18.jpg","hash":"bdebcd4f8c16526e90cca5c860d97b1e627222b5","modified":1758606608580},{"_id":"public/img/girl8.png","hash":"33415434ff7e112ad45e1a7aae1b334a768ad423","modified":1758606608580},{"_id":"public/img/wallpaper/view20.png","hash":"302f6ac7f575fd46dbaf0b1e17d613538d533bc0","modified":1758606608580},{"_id":"public/img/wallpaper/view35.png","hash":"302f6ac7f575fd46dbaf0b1e17d613538d533bc0","modified":1758606608580},{"_id":"public/img/planet/542dfb27880511ebb6edd017c2d2eca2.png","hash":"076aee3714c980906eed8b9dffe177649089ccb6","modified":1758606608580},{"_id":"public/img/planet/c89083824f074c0bad71a976de306a83.png","hash":"a53a6261cf038a96af624d1b04d6de9b7b5fa9bf","modified":1758606608580},{"_id":"public/img/3.png","hash":"e3de9ea2e549f7facbc32aa3b409db077378f4a1","modified":1758606608580},{"_id":"public/img/view9.jpg","hash":"8ad0b32593df581bf3480382162adf5a302dfb0a","modified":1758606608580},{"_id":"public/img/wallpaper/view9.jpg","hash":"8ad0b32593df581bf3480382162adf5a302dfb0a","modified":1758606608580},{"_id":"public/img/wallpaper/view10.jpg","hash":"e1ef142e2f0b04cc842f27ce4bd2ae4b14ad7d20","modified":1758606608580},{"_id":"public/img/girl/view30.jpg","hash":"df6b2d56a08fe568fbce190e5b01c2ff30529f65","modified":1758606608580},{"_id":"public/img/girl/girl2.png","hash":"1b9b04f0b9280619cf48eeafe08ccdd953f06943","modified":1758606608580},{"_id":"public/img/wallpaper/view27.png","hash":"5d0e57b78699580dd583c8d50c9842991b5256c2","modified":1758606608580},{"_id":"public/img/5.png","hash":"a416480cab88b35b310768d7a3a07262d1c3c533","modified":1758606608580},{"_id":"public/img/wallpaper/view25.png","hash":"ca16d2b13ebe2a2529a112fa6dd8c2b2830fe0c1","modified":1758606608580},{"_id":"public/img/view1.jpg","hash":"ddb81f9e34a344c1c0005a5c86cd9e829be8ca19","modified":1758606608580},{"_id":"public/img/2.png","hash":"0b732b35a6ac8c8cc1d798f0d85fe119f3f1a994","modified":1758606608580},{"_id":"public/img/wallpaper/view.png","hash":"0b732b35a6ac8c8cc1d798f0d85fe119f3f1a994","modified":1758606608580},{"_id":"public/img/wallpaper/view47.png","hash":"0b732b35a6ac8c8cc1d798f0d85fe119f3f1a994","modified":1758606608580},{"_id":"public/img/wallpaper/view31.jpg","hash":"47511105ba1db4f9a2976d93eb8929d04234c2d7","modified":1758606608580},{"_id":"public/img/planet/6f1c9694f05b42099e17eef497806c87.png","hash":"dc635001128e265e4debe62302ff85ad64f336c6","modified":1758606608580},{"_id":"public/img/newYear.jpg","hash":"1616a7577733fd0a97e2294b5b71a228dbb28bbd","modified":1758606608580},{"_id":"public/img/wallpaper/view5.png","hash":"1616a7577733fd0a97e2294b5b71a228dbb28bbd","modified":1758606608580},{"_id":"public/img/wallpaper/view18.png","hash":"d51bd56da48c40caa75880b68c84fba8cde9053e","modified":1758606608580},{"_id":"public/img/wallpaper/view37.png","hash":"5e8b0984a7165f91690f1fb449448417e228bd85","modified":1758606608580},{"_id":"public/img/girl/girl3.png","hash":"2420a143471b630bacf74e260f5187326e4a6181","modified":1758606608580},{"_id":"public/img/planet/4d5b121d880511ebb6edd017c2d2eca2.png","hash":"e4b110f71621b3d1217c1b75a1140d03177358e2","modified":1758606608580},{"_id":"public/img/planet/08b3b5bc32e74acfbfe530412b967092.png","hash":"6d0fcdabccbf2b8f44095c761604bcfe601636b5","modified":1758606608580},{"_id":"public/img/wallpaper/view17.png","hash":"f9d1fe2468f1df97a660ea0005c9904b0a9dcceb","modified":1758606608580},{"_id":"public/img/4.png","hash":"f65c4e57511004793c0a459796edb130d4a70456","modified":1758606608580},{"_id":"public/img/wallpaper/view49.png","hash":"f65c4e57511004793c0a459796edb130d4a70456","modified":1758606608580},{"_id":"public/img/wallpaper/view33.png","hash":"3c9863a3405270c73a250a50e70b4bf595f883f3","modified":1758606608580},{"_id":"public/img/wallpaper/view46.png","hash":"fb6251c29943b90423a7d95f9de772a952bc2b66","modified":1758606608580},{"_id":"public/img/planet/8fe66274880f11ebb6edd017c2d2eca2.png","hash":"9b260faa220fc3a337c4a39286cbe46b9d069669","modified":1758606608580},{"_id":"public/img/wallpaper/view22.png","hash":"7442a6b438ec2763d3b39755385f04e1cfa8749f","modified":1758606608580},{"_id":"public/img/wallpaper/view29.png","hash":"9f7c09112c9da7443d84feb22300339529ae98be","modified":1758606608580},{"_id":"source/_posts/ServerModels.md","hash":"8ba22b453c9c6affd41eac782fa79bbd578df3ac","modified":1760441927141},{"_id":"source/_posts/diary/2025-09-23.md","hash":"8e8818ee9752421de0c7510aa462cfb8f70bc59b","modified":1758967869014},{"_id":"source/_posts/Mybatis.md","hash":"eb8b09b8d63478ea381bd2cdc1c369055a8d5a4b","modified":1757551251364},{"_id":"source/_posts/Spring.md","hash":"05473521ea07ef8f2f0460c32353378ec312e8a1","modified":1760327832023},{"_id":"source/_posts/diary/2025-10-14.md","hash":"8151a8fe50b8d7ccb0de9276506754771b127aec","modified":1764000799917},{"_id":"source/_posts/diary/2025-09-30.md","hash":"faf1fd1bad4cc1db257645c86aefeb9fc64090e9","modified":1760012722169},{"_id":"source/_posts/diary/2025-10-15.md","hash":"c448f14f89d50b902aecea57956b91cecf2e6c5e","modified":1764055668639},{"_id":"source/_posts/diary/2025-11-18.md","hash":"a4f447b8ef39b78dc34ea78cca28817c2b04a5d6","modified":1763951762427},{"_id":"source/_posts/diary/2025-10-21.md","hash":"4621479cf7ce9079e7e3a20dd995b4d97fa7b6b1","modified":1764057273664},{"_id":"source/_posts/diary/2025-10-16.md","hash":"8d606613c485a200b5a3f861a848a532e6c70bbf","modified":1764070352675},{"_id":"source/_posts/diary/2025-11-24.md","hash":"b36eb6b639fc1a2a8812dfdc2d6286a579694a33","modified":1764057139367},{"_id":"public/2025/09/25/ServerModels/index.html","hash":"b352738e29a8f15a7f07af8042c244e65d8bc0c6","modified":1764409586611},{"_id":"public/2024/12/18/Mybatis/index.html","hash":"3eaa97c7510b2af7f99e8c92580f5246bb4c4ecf","modified":1764409586611},{"_id":"public/2024/11/04/Spring/index.html","hash":"a34a28a345573d030e9c7bc603d70d71e4b64d00","modified":1764409586611},{"_id":"public/tags/IO/index.html","hash":"c2a6528dd9a1d060e8ed1aa3512117d7c8366292","modified":1764409586611},{"_id":"public/tags/InputStream/index.html","hash":"44197bac8c24d3213fcac44ed2647d80be7926d7","modified":1764409586611},{"_id":"public/tags/OutputStream/index.html","hash":"1dd0b7cf5d2575d03d8417afd4791cac5b17f21a","modified":1764409586611},{"_id":"public/tags/Server/index.html","hash":"f4eccffe56176e3c4e8bb944094fcdefb05c9407","modified":1764409586611},{"_id":"public/tags/NetworkModels/index.html","hash":"ffd492548e06c2469d72c801c4be3ed9c7ae3f77","modified":1764409586611},{"_id":"public/tags/XSS/index.html","hash":"ec58ba0a48e183b5e405390501cdb62b7af98045","modified":1764409586611},{"_id":"public/tags/CSRF/index.html","hash":"8046e2d9522f93e719c68afd9af7e2729a8893b6","modified":1764409586611},{"_id":"public/tags/BeanFactory/index.html","hash":"9acb24a6019a77b540602e04c636bf80dc5cc4ac","modified":1764409586611},{"_id":"public/tags/AOP/index.html","hash":"8f1bc5dbb51482efb760e758844af1e32e744990","modified":1764409586611}],"Category":[{"name":"编程","_id":"cmfw4z08u0004uomwep9t6btj"}],"Data":[{"_id":"widget","data":{"top":[{"class_name":null,"id_name":"newYear","name":null,"icon":null,"order":1,"html":"<div id=\"newYear-main\"><div class=\"mask\"></div> <p class=\"title\"></p> <div class=\"newYear-time\"></div> <p class=\"today\" style=\"text-align: right;\"></p> </div>"}]}},{"_id":"link","data":[{"name":"OpenAI","link":"https://www.openai.com/","avatar":"https://example.com/avatar.jpg","descr":"AI research and development organization","siteshot":"","url":"https://www.openai.com"},{"name":"GitHub","link":"https://github.com/","avatar":"https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png","descr":"Where the world builds software"}]}],"Page":[{"title":"分类","type":"categories","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ntype: \"categories\"\nlayout: \"categories\"\ncomments: false\n---\n","date":"2025-04-11T06:59:16.245Z","updated":"2024-11-01T03:51:00.429Z","path":"categories/index.html","_id":"cmfw4z08d0000uomwa5vwd87d","content":"","cover":"/img/4.png","cover_type":"img","excerpt":"","more":""},{"_content":"/* 添加友链按钮 */\n/* 快速填写格式 */\n.addBtn {\n    display: flex;\n    justify-content: center;\n    flex-wrap: wrap;\n}\n.addBtn button {\n    transition: .2s;\n    display: flex;\n    margin: 5px auto;\n    color: var(--global-bg);\n    padding: 15px;\n    border-radius: 40px;\n    background: var(--search-result-title);\n    align-items: center;\n}\n\nbutton {\n    padding: 0;\n    outline: 0;\n    border: none;\n    background: 0 0;\n    cursor: pointer;\n    touch-action: manipulation;\n}\n.fa-solid, .fas {\n    font-family: \"Font Awesome 6 Free\";\n    font-weight: 900;\n}\n.addBtn i {\n    font-size: 1.3rem;\n    margin-right: 10px;\n}\n.addBtn button:hover {\n    background: var(--theme-color);\n    color: #fff;\n}","source":"css/kslink.css","raw":"/* 添加友链按钮 */\n/* 快速填写格式 */\n.addBtn {\n    display: flex;\n    justify-content: center;\n    flex-wrap: wrap;\n}\n.addBtn button {\n    transition: .2s;\n    display: flex;\n    margin: 5px auto;\n    color: var(--global-bg);\n    padding: 15px;\n    border-radius: 40px;\n    background: var(--search-result-title);\n    align-items: center;\n}\n\nbutton {\n    padding: 0;\n    outline: 0;\n    border: none;\n    background: 0 0;\n    cursor: pointer;\n    touch-action: manipulation;\n}\n.fa-solid, .fas {\n    font-family: \"Font Awesome 6 Free\";\n    font-weight: 900;\n}\n.addBtn i {\n    font-size: 1.3rem;\n    margin-right: 10px;\n}\n.addBtn button:hover {\n    background: var(--theme-color);\n    color: #fff;\n}","date":"2024-10-31T14:01:15.021Z","updated":"2024-10-31T14:01:15.021Z","path":"css/kslink.css","layout":"false","title":"","comments":1,"_id":"cmfw4z08p0002uomwdfp0hqb1","content":"/* 添加友链按钮 */\n/* 快速填写格式 */\n.addBtn {\n    display: flex;\n    justify-content: center;\n    flex-wrap: wrap;\n}\n.addBtn button {\n    transition: .2s;\n    display: flex;\n    margin: 5px auto;\n    color: var(--global-bg);\n    padding: 15px;\n    border-radius: 40px;\n    background: var(--search-result-title);\n    align-items: center;\n}\n\nbutton {\n    padding: 0;\n    outline: 0;\n    border: none;\n    background: 0 0;\n    cursor: pointer;\n    touch-action: manipulation;\n}\n.fa-solid, .fas {\n    font-family: \"Font Awesome 6 Free\";\n    font-weight: 900;\n}\n.addBtn i {\n    font-size: 1.3rem;\n    margin-right: 10px;\n}\n.addBtn button:hover {\n    background: var(--theme-color);\n    color: #fff;\n}"},{"title":"关于","type":"about","date":"2024-10-23T03:29:59.000Z","_content":"\n<div class=\"about-page\">\n\n</div>\n\n<style>\n    .about-page{\n     height: 1000px;\n  }\n</style>\n\n","source":"about/index.md","raw":"---\ntitle: 关于\ntype: \"about\"\ndate: 2024-10-23 11:29:59\n---\n\n<div class=\"about-page\">\n\n</div>\n\n<style>\n    .about-page{\n     height: 1000px;\n  }\n</style>\n\n","updated":"2025-04-11T06:59:08.988Z","path":"about/index.html","comments":1,"layout":"page","_id":"cmfw4z08y0006uomwab2g1847","content":"<div class=\"about-page\">\n\n</div>\n\n<style>\n    .about-page{\n     height: 1000px;\n  }\n</style>\n\n","cover":"/img/2.png","cover_type":"img","excerpt":"","more":"<div class=\"about-page\">\n\n</div>\n\n<style>\n    .about-page{\n     height: 1000px;\n  }\n</style>\n\n"},{"_content":"var leonus = {\n    linkCom: e => {\n        var t = document.querySelector(\".el-textarea__inner\");\n        \"bf\" == e ? (t.value = \"```yml\\n\", t.value += \"- name: \\n  link: \\n  avatar: \\n  descr: \\n  siteshot: \", t.value += \"\\n```\", t.setSelectionRange(15, 15)) : (t.value = \"站点名称：\\n站点地址：\\n头像链接：\\n站点描述：\\n站点截图：\", t.setSelectionRange(5, 5)), t.focus()\n    },\n    owoBig: () => {\n        if (!document.getElementById(\"post-comment\") || document.body.clientWidth < 768) return;\n        let e = 1,\n            t = \"\",\n            o = document.createElement(\"div\"),\n            n = document.querySelector(\"body\");\n        o.id = \"owo-big\", n.appendChild(o), new MutationObserver((l => {\n            for (let a = 0; a < l.length; a++) {\n                let i = l[a].addedNodes,\n                    s = \"\";\n                if (2 == i.length && \"OwO-body\" == i[1].className) s = i[1];\n                else {\n                    if (1 != i.length || \"tk-comment\" != i[0].className) continue;\n                    s = i[0]\n                }\n                s.onmouseover = l => {\n                    e && (\"OwO-body\" == s.className && \"IMG\" == l.target.tagName || \"tk-owo-emotion\" == l.target.className) && (e = 0, t = setTimeout((() => {\n                        let e = 3 * l.path[0].clientHeight,\n                            t = 3 * l.path[0].clientWidth,\n                            a = l.x - l.offsetX - (t - l.path[0].clientWidth) / 2,\n                            i = l.y - l.offsetY;\n                        a + t > n.clientWidth && (a -= a + t - n.clientWidth + 10), a < 0 && (a = 10), o.style.cssText = `display:flex; height:${e}px; width:${t}px; left:${a}px; top:${i}px;`, o.innerHTML = `<img src=\"${l.target.src}\">`\n                    }), 300))\n                }, s.onmouseout = () => {\n                    o.style.display = \"none\", e = 1, clearTimeout(t)\n                }\n            }\n        })).observe(document.getElementById(\"post-comment\"), {\n            subtree: !0,\n            childList: !0\n        })\n    },\n};","source":"js/kslink.js","raw":"var leonus = {\n    linkCom: e => {\n        var t = document.querySelector(\".el-textarea__inner\");\n        \"bf\" == e ? (t.value = \"```yml\\n\", t.value += \"- name: \\n  link: \\n  avatar: \\n  descr: \\n  siteshot: \", t.value += \"\\n```\", t.setSelectionRange(15, 15)) : (t.value = \"站点名称：\\n站点地址：\\n头像链接：\\n站点描述：\\n站点截图：\", t.setSelectionRange(5, 5)), t.focus()\n    },\n    owoBig: () => {\n        if (!document.getElementById(\"post-comment\") || document.body.clientWidth < 768) return;\n        let e = 1,\n            t = \"\",\n            o = document.createElement(\"div\"),\n            n = document.querySelector(\"body\");\n        o.id = \"owo-big\", n.appendChild(o), new MutationObserver((l => {\n            for (let a = 0; a < l.length; a++) {\n                let i = l[a].addedNodes,\n                    s = \"\";\n                if (2 == i.length && \"OwO-body\" == i[1].className) s = i[1];\n                else {\n                    if (1 != i.length || \"tk-comment\" != i[0].className) continue;\n                    s = i[0]\n                }\n                s.onmouseover = l => {\n                    e && (\"OwO-body\" == s.className && \"IMG\" == l.target.tagName || \"tk-owo-emotion\" == l.target.className) && (e = 0, t = setTimeout((() => {\n                        let e = 3 * l.path[0].clientHeight,\n                            t = 3 * l.path[0].clientWidth,\n                            a = l.x - l.offsetX - (t - l.path[0].clientWidth) / 2,\n                            i = l.y - l.offsetY;\n                        a + t > n.clientWidth && (a -= a + t - n.clientWidth + 10), a < 0 && (a = 10), o.style.cssText = `display:flex; height:${e}px; width:${t}px; left:${a}px; top:${i}px;`, o.innerHTML = `<img src=\"${l.target.src}\">`\n                    }), 300))\n                }, s.onmouseout = () => {\n                    o.style.display = \"none\", e = 1, clearTimeout(t)\n                }\n            }\n        })).observe(document.getElementById(\"post-comment\"), {\n            subtree: !0,\n            childList: !0\n        })\n    },\n};","date":"2024-10-31T14:00:54.498Z","updated":"2024-10-31T14:00:54.498Z","path":"js/kslink.js","layout":"false","title":"","comments":1,"_id":"cmfw4z0900008uomwcto78y9v","content":"var leonus = {\n    linkCom: e => {\n        var t = document.querySelector(\".el-textarea__inner\");\n        \"bf\" == e ? (t.value = \"```yml\\n\", t.value += \"- name: \\n  link: \\n  avatar: \\n  descr: \\n  siteshot: \", t.value += \"\\n```\", t.setSelectionRange(15, 15)) : (t.value = \"站点名称：\\n站点地址：\\n头像链接：\\n站点描述：\\n站点截图：\", t.setSelectionRange(5, 5)), t.focus()\n    },\n    owoBig: () => {\n        if (!document.getElementById(\"post-comment\") || document.body.clientWidth < 768) return;\n        let e = 1,\n            t = \"\",\n            o = document.createElement(\"div\"),\n            n = document.querySelector(\"body\");\n        o.id = \"owo-big\", n.appendChild(o), new MutationObserver((l => {\n            for (let a = 0; a < l.length; a++) {\n                let i = l[a].addedNodes,\n                    s = \"\";\n                if (2 == i.length && \"OwO-body\" == i[1].className) s = i[1];\n                else {\n                    if (1 != i.length || \"tk-comment\" != i[0].className) continue;\n                    s = i[0]\n                }\n                s.onmouseover = l => {\n                    e && (\"OwO-body\" == s.className && \"IMG\" == l.target.tagName || \"tk-owo-emotion\" == l.target.className) && (e = 0, t = setTimeout((() => {\n                        let e = 3 * l.path[0].clientHeight,\n                            t = 3 * l.path[0].clientWidth,\n                            a = l.x - l.offsetX - (t - l.path[0].clientWidth) / 2,\n                            i = l.y - l.offsetY;\n                        a + t > n.clientWidth && (a -= a + t - n.clientWidth + 10), a < 0 && (a = 10), o.style.cssText = `display:flex; height:${e}px; width:${t}px; left:${a}px; top:${i}px;`, o.innerHTML = `<img src=\"${l.target.src}\">`\n                    }), 300))\n                }, s.onmouseout = () => {\n                    o.style.display = \"none\", e = 1, clearTimeout(t)\n                }\n            }\n        })).observe(document.getElementById(\"post-comment\"), {\n            subtree: !0,\n            childList: !0\n        })\n    },\n};"},{"_content":"let newYearTimer = null;\nvar newYear = () => {\n    clearTimeout(newYearTimer);\n    if (!document.querySelector('#newYear')) return;\n    // 新年时间戳 and 星期对象\n    let newYear = new Date('2025-01-28 00:00:00').getTime() / 1000,\n        week = { 0: '周日', 1: '周一', 2: '周二', 3: '周三', 4: '周四', 5: '周五', 6: '周六' }\n\n    time();\n\n    // 补零函数\n    function nol(h) { return h > 9 ? h : '0' + h; };\n\n    function time() {\n        // 现在 时间对象\n        let now = new Date();\n\n        // 右下角 今天\n        document.querySelector('#newYear .today').innerHTML = now.getFullYear() + '-' + (now.getMonth() + 1) + '-' + now.getDate() + ' ' + week[now.getDay()]\n\n        // 现在与新年相差秒数\n        let second = newYear - Math.round(now.getTime() / 1000);\n\n        // 小于0则表示已经过年\n        if (second < 0) {\n            document.querySelector('#newYear .title').innerHTML = 'Happy New Year!';\n            document.querySelector('#newYear .newYear-time').innerHTML = '<span class=\"happyNewYear\">新年快乐</p>';\n        } else {\n            // 大于0则还未过年\n            document.querySelector('#newYear .title').innerHTML = '距离2025年春节：'\n\n            // 大于一天则直接渲染天数\n            if (second > 86400) {\n                document.querySelector('#newYear .newYear-time').innerHTML = `<span class=\"day\">${Math.ceil(second / 86400)}<span class=\"unit\">天</span></span>`\n            } else {\n                // 小于一天则使用时分秒计时。\n                let h = nol(parseInt(second / 3600));\n                second %= 3600;\n                let m = nol(parseInt(second / 60));\n                second %= 60;\n                let s = nol(second);\n                document.querySelector('#newYear .newYear-time').innerHTML = `<span class=\"time\">${h}:${m}:${s}</span></span>`;\n                // 计时\n                newYearTimer = setTimeout(time, 1000);\n            }\n        }\n    }\n\n    // 元宝飘落\n    jQuery(document).ready(function ($) {\n        $('#newYear').wpSuperSnow({\n            flakes: ['https://tuchuang.voooe.cn/images/2023/01/02/yb1.webp', 'https://tuchuang.voooe.cn/images/2023/01/02/yb2.webp', 'https://tuchuang.voooe.cn/images/2023/01/02/yb3.webp'],\n            totalFlakes: '100',\n            zIndex: '999999',\n            maxSize: '30',\n            maxDuration: '20',\n            useFlakeTrans: false\n        });\n    });\n}\n// Pjax适配：若没有开启Pjax这里直接是newYear()即可\n// 开了Pjax的用以下两句\ndocument.addEventListener('pjax:complete', newYear);\ndocument.addEventListener('DOMContentLoaded', newYear);","source":"js/newYear.js","raw":"let newYearTimer = null;\nvar newYear = () => {\n    clearTimeout(newYearTimer);\n    if (!document.querySelector('#newYear')) return;\n    // 新年时间戳 and 星期对象\n    let newYear = new Date('2025-01-28 00:00:00').getTime() / 1000,\n        week = { 0: '周日', 1: '周一', 2: '周二', 3: '周三', 4: '周四', 5: '周五', 6: '周六' }\n\n    time();\n\n    // 补零函数\n    function nol(h) { return h > 9 ? h : '0' + h; };\n\n    function time() {\n        // 现在 时间对象\n        let now = new Date();\n\n        // 右下角 今天\n        document.querySelector('#newYear .today').innerHTML = now.getFullYear() + '-' + (now.getMonth() + 1) + '-' + now.getDate() + ' ' + week[now.getDay()]\n\n        // 现在与新年相差秒数\n        let second = newYear - Math.round(now.getTime() / 1000);\n\n        // 小于0则表示已经过年\n        if (second < 0) {\n            document.querySelector('#newYear .title').innerHTML = 'Happy New Year!';\n            document.querySelector('#newYear .newYear-time').innerHTML = '<span class=\"happyNewYear\">新年快乐</p>';\n        } else {\n            // 大于0则还未过年\n            document.querySelector('#newYear .title').innerHTML = '距离2025年春节：'\n\n            // 大于一天则直接渲染天数\n            if (second > 86400) {\n                document.querySelector('#newYear .newYear-time').innerHTML = `<span class=\"day\">${Math.ceil(second / 86400)}<span class=\"unit\">天</span></span>`\n            } else {\n                // 小于一天则使用时分秒计时。\n                let h = nol(parseInt(second / 3600));\n                second %= 3600;\n                let m = nol(parseInt(second / 60));\n                second %= 60;\n                let s = nol(second);\n                document.querySelector('#newYear .newYear-time').innerHTML = `<span class=\"time\">${h}:${m}:${s}</span></span>`;\n                // 计时\n                newYearTimer = setTimeout(time, 1000);\n            }\n        }\n    }\n\n    // 元宝飘落\n    jQuery(document).ready(function ($) {\n        $('#newYear').wpSuperSnow({\n            flakes: ['https://tuchuang.voooe.cn/images/2023/01/02/yb1.webp', 'https://tuchuang.voooe.cn/images/2023/01/02/yb2.webp', 'https://tuchuang.voooe.cn/images/2023/01/02/yb3.webp'],\n            totalFlakes: '100',\n            zIndex: '999999',\n            maxSize: '30',\n            maxDuration: '20',\n            useFlakeTrans: false\n        });\n    });\n}\n// Pjax适配：若没有开启Pjax这里直接是newYear()即可\n// 开了Pjax的用以下两句\ndocument.addEventListener('pjax:complete', newYear);\ndocument.addEventListener('DOMContentLoaded', newYear);","date":"2024-10-23T13:37:30.177Z","updated":"2024-10-23T13:37:30.177Z","path":"js/newYear.js","layout":"false","title":"","comments":1,"_id":"cmfw4z093000auomwgc35dt04","content":"let newYearTimer = null;\nvar newYear = () => {\n    clearTimeout(newYearTimer);\n    if (!document.querySelector('#newYear')) return;\n    // 新年时间戳 and 星期对象\n    let newYear = new Date('2025-01-28 00:00:00').getTime() / 1000,\n        week = { 0: '周日', 1: '周一', 2: '周二', 3: '周三', 4: '周四', 5: '周五', 6: '周六' }\n\n    time();\n\n    // 补零函数\n    function nol(h) { return h > 9 ? h : '0' + h; };\n\n    function time() {\n        // 现在 时间对象\n        let now = new Date();\n\n        // 右下角 今天\n        document.querySelector('#newYear .today').innerHTML = now.getFullYear() + '-' + (now.getMonth() + 1) + '-' + now.getDate() + ' ' + week[now.getDay()]\n\n        // 现在与新年相差秒数\n        let second = newYear - Math.round(now.getTime() / 1000);\n\n        // 小于0则表示已经过年\n        if (second < 0) {\n            document.querySelector('#newYear .title').innerHTML = 'Happy New Year!';\n            document.querySelector('#newYear .newYear-time').innerHTML = '<span class=\"happyNewYear\">新年快乐</p>';\n        } else {\n            // 大于0则还未过年\n            document.querySelector('#newYear .title').innerHTML = '距离2025年春节：'\n\n            // 大于一天则直接渲染天数\n            if (second > 86400) {\n                document.querySelector('#newYear .newYear-time').innerHTML = `<span class=\"day\">${Math.ceil(second / 86400)}<span class=\"unit\">天</span></span>`\n            } else {\n                // 小于一天则使用时分秒计时。\n                let h = nol(parseInt(second / 3600));\n                second %= 3600;\n                let m = nol(parseInt(second / 60));\n                second %= 60;\n                let s = nol(second);\n                document.querySelector('#newYear .newYear-time').innerHTML = `<span class=\"time\">${h}:${m}:${s}</span></span>`;\n                // 计时\n                newYearTimer = setTimeout(time, 1000);\n            }\n        }\n    }\n\n    // 元宝飘落\n    jQuery(document).ready(function ($) {\n        $('#newYear').wpSuperSnow({\n            flakes: ['https://tuchuang.voooe.cn/images/2023/01/02/yb1.webp', 'https://tuchuang.voooe.cn/images/2023/01/02/yb2.webp', 'https://tuchuang.voooe.cn/images/2023/01/02/yb3.webp'],\n            totalFlakes: '100',\n            zIndex: '999999',\n            maxSize: '30',\n            maxDuration: '20',\n            useFlakeTrans: false\n        });\n    });\n}\n// Pjax适配：若没有开启Pjax这里直接是newYear()即可\n// 开了Pjax的用以下两句\ndocument.addEventListener('pjax:complete', newYear);\ndocument.addEventListener('DOMContentLoaded', newYear);"},{"_content":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }\n\n  /* 背景宇宙星光  */\n#universe{\n    display: block;\n    position: fixed;\n    margin: 0;\n    padding: 0;\n    border: 0;\n    outline: 0;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */\n    z-index: -1;\n  }\n\n  /* 新年侧边栏 */\n\n#newYear {\n    color: white;\n    padding: 0 !important;\n}\n\n#newYear p,\n#newYear h3 {\n    font-weight: normal;\n    color: inherit;\n    margin: 0;\n}\n\n#newYear .item-headline {\n    display: none;\n}\n\n#newYear-main {\n    min-height: 160px;\n    padding: 1rem;\n    position: relative;\n    border-radius: 12px;\n    /* background-image: url(https://tuchuang.voooe.cn/images/2023/01/02/tunian.webp); */\n    background-image: url('/img/newYear.jpg'); \n    background-size: cover;\n    background-position: center;\n}\n\n#newYear-main * {\n    position: relative;\n    line-height: 1.3;\n}\n\n#newYear-main .newYear-time {\n    font-weight: bold;\n    text-align: center;\n}\n\n#newYear-main .time,\n#newYear-main .happyNewYear {\n    font-size: 3.5rem;\n    margin: 1rem 0;\n    display: block;\n}\n\n#newYear-main .day {\n    font-size: 5rem;\n}\n\n#newYear-main .day .unit {\n    font-size: 1rem;\n}\n\n#newYear-main .mask {\n    position: absolute;\n    left: 0;\n    top: 0;\n    height: 100%;\n    width: 100%;\n    background-color: rgba(0, 0, 0, .1);\n}\n","source":"css/custom.css","raw":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }\n\n  /* 背景宇宙星光  */\n#universe{\n    display: block;\n    position: fixed;\n    margin: 0;\n    padding: 0;\n    border: 0;\n    outline: 0;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */\n    z-index: -1;\n  }\n\n  /* 新年侧边栏 */\n\n#newYear {\n    color: white;\n    padding: 0 !important;\n}\n\n#newYear p,\n#newYear h3 {\n    font-weight: normal;\n    color: inherit;\n    margin: 0;\n}\n\n#newYear .item-headline {\n    display: none;\n}\n\n#newYear-main {\n    min-height: 160px;\n    padding: 1rem;\n    position: relative;\n    border-radius: 12px;\n    /* background-image: url(https://tuchuang.voooe.cn/images/2023/01/02/tunian.webp); */\n    background-image: url('/img/newYear.jpg'); \n    background-size: cover;\n    background-position: center;\n}\n\n#newYear-main * {\n    position: relative;\n    line-height: 1.3;\n}\n\n#newYear-main .newYear-time {\n    font-weight: bold;\n    text-align: center;\n}\n\n#newYear-main .time,\n#newYear-main .happyNewYear {\n    font-size: 3.5rem;\n    margin: 1rem 0;\n    display: block;\n}\n\n#newYear-main .day {\n    font-size: 5rem;\n}\n\n#newYear-main .day .unit {\n    font-size: 1rem;\n}\n\n#newYear-main .mask {\n    position: absolute;\n    left: 0;\n    top: 0;\n    height: 100%;\n    width: 100%;\n    background-color: rgba(0, 0, 0, .1);\n}\n","date":"2024-10-31T11:26:03.493Z","updated":"2024-10-31T11:26:03.493Z","path":"css/custom.css","layout":"false","title":"","comments":1,"_id":"cmfw4z09a000euomwd7obejii","content":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }\n\n  /* 背景宇宙星光  */\n#universe{\n    display: block;\n    position: fixed;\n    margin: 0;\n    padding: 0;\n    border: 0;\n    outline: 0;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */\n    z-index: -1;\n  }\n\n  /* 新年侧边栏 */\n\n#newYear {\n    color: white;\n    padding: 0 !important;\n}\n\n#newYear p,\n#newYear h3 {\n    font-weight: normal;\n    color: inherit;\n    margin: 0;\n}\n\n#newYear .item-headline {\n    display: none;\n}\n\n#newYear-main {\n    min-height: 160px;\n    padding: 1rem;\n    position: relative;\n    border-radius: 12px;\n    /* background-image: url(https://tuchuang.voooe.cn/images/2023/01/02/tunian.webp); */\n    background-image: url('/img/newYear.jpg'); \n    background-size: cover;\n    background-position: center;\n}\n\n#newYear-main * {\n    position: relative;\n    line-height: 1.3;\n}\n\n#newYear-main .newYear-time {\n    font-weight: bold;\n    text-align: center;\n}\n\n#newYear-main .time,\n#newYear-main .happyNewYear {\n    font-size: 3.5rem;\n    margin: 1rem 0;\n    display: block;\n}\n\n#newYear-main .day {\n    font-size: 5rem;\n}\n\n#newYear-main .day .unit {\n    font-size: 1rem;\n}\n\n#newYear-main .mask {\n    position: absolute;\n    left: 0;\n    top: 0;\n    height: 100%;\n    width: 100%;\n    background-color: rgba(0, 0, 0, .1);\n}\n"},{"title":"图册","date":"2024-11-01T02:31:53.000Z","_content":"{% galleryGroup '风景' 'view' '/gallery/wallpaper' https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg %}\n{% galleryGroup '美女' 'girl' '/gallery/girl' http://api.btstu.cn/sjbz/?lx=suiji %}\n{% galleryGroup '星球' 'planet' '/gallery/planet' https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/view9.png %}\n![](https://cdn.seovx.com/?mom=302)\n\n\n<div class=\"about-page\">\n\n</div>\n\n<style>\n    .about-page{\n     height: 1000px;\n  }\n</style>\n<style>\n\n</style>\n\n","source":"gallery/index.md","raw":"---\ntitle: 图册\ndate: 2024-11-01 10:31:53\n---\n{% galleryGroup '风景' 'view' '/gallery/wallpaper' https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg %}\n{% galleryGroup '美女' 'girl' '/gallery/girl' http://api.btstu.cn/sjbz/?lx=suiji %}\n{% galleryGroup '星球' 'planet' '/gallery/planet' https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/view9.png %}\n![](https://cdn.seovx.com/?mom=302)\n\n\n<div class=\"about-page\">\n\n</div>\n\n<style>\n    .about-page{\n     height: 1000px;\n  }\n</style>\n<style>\n\n</style>\n\n","updated":"2025-04-11T07:13:06.091Z","path":"gallery/index.html","comments":1,"layout":"page","_id":"cmfw4z09e000guomw94jn9oz4","content":"<figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">风景</div>\n  <p>view</p>\n  <a href='/gallery/wallpaper'></a>\n  </figcaption>\n  </figure>\n  \n<figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='http://api.btstu.cn/sjbz/?lx=suiji' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">美女</div>\n  <p>girl</p>\n  <a href='/gallery/girl'></a>\n  </figcaption>\n  </figure>\n  \n<figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/view9.png' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">星球</div>\n  <p>planet</p>\n  <a href='/gallery/planet'></a>\n  </figcaption>\n  </figure>\n  \n<p><img src=\"https://cdn.seovx.com/?mom=302\" alt=\"\"></p>\n<div class=\"about-page\">\n\n</div>\n\n<style>\n    .about-page{\n     height: 1000px;\n  }\n</style>\n<style>\n\n</style>\n\n","cover":"/img/3.png","cover_type":"img","excerpt":"","more":"<figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">风景</div>\n  <p>view</p>\n  <a href='/gallery/wallpaper'></a>\n  </figcaption>\n  </figure>\n  \n<figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='http://api.btstu.cn/sjbz/?lx=suiji' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">美女</div>\n  <p>girl</p>\n  <a href='/gallery/girl'></a>\n  </figcaption>\n  </figure>\n  \n<figure class=\"gallery-group\">\n  <img class=\"gallery-group-img no-lightbox\" src='https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/view9.png' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">星球</div>\n  <p>planet</p>\n  <a href='/gallery/planet'></a>\n  </figcaption>\n  </figure>\n  \n<p><img src=\"https://cdn.seovx.com/?mom=302\" alt=\"\"></p>\n<div class=\"about-page\">\n\n</div>\n\n<style>\n    .about-page{\n     height: 1000px;\n  }\n</style>\n<style>\n\n</style>\n\n"},{"title":"girl","date":"2024-11-01T02:31:53.000Z","_content":"\n![](/img/girl/view18.jpg) \n![](/img/girl/girl3.png) \n![](/img/girl/view30.jpg) \n![](/img/girl/girl4.png) \n","source":"gallery/girl.md","raw":"---\ntitle: girl\ndate: 2024-11-01 10:31:53\n---\n\n![](/img/girl/view18.jpg) \n![](/img/girl/girl3.png) \n![](/img/girl/view30.jpg) \n![](/img/girl/girl4.png) \n","updated":"2024-11-01T07:57:47.357Z","path":"gallery/girl.html","comments":1,"layout":"page","_id":"cmfw4z09i000luomwdcn91ide","content":"<p><img src=\"/img/girl/view18.jpg\" alt=\"\"><br><img src=\"/img/girl/girl3.png\" alt=\"\"><br><img src=\"/img/girl/view30.jpg\" alt=\"\"><br><img src=\"/img/girl/girl4.png\" alt=\"\"> </p>\n","cover":"/img/view9.jpg","cover_type":"img","excerpt":"","more":"<p><img src=\"/img/girl/view18.jpg\" alt=\"\"><br><img src=\"/img/girl/girl3.png\" alt=\"\"><br><img src=\"/img/girl/view30.jpg\" alt=\"\"><br><img src=\"/img/girl/girl4.png\" alt=\"\"> </p>\n"},{"_content":"function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById(\"universe\"),o=!0,a=\"180,184,240\",r=\"226,225,142\",d=\"226,225,224\",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute(\"width\",n),s.setAttribute(\"height\",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle=\"rgba(\"+a+\",\"+this.opacity+\")\",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle=\"rgba(\"+d+\",\"+this.opacity+\")\",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle=\"rgba(\"+d+\",\"+(this.opacity-this.opacity/20*t)+\")\",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle=\"rgba(\"+r+\",\"+this.opacity+\")\",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener(\"resize\",f,!1),function(){h=s.getContext(\"2d\");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};\ndark()","source":"js/universe.js","raw":"function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById(\"universe\"),o=!0,a=\"180,184,240\",r=\"226,225,142\",d=\"226,225,224\",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute(\"width\",n),s.setAttribute(\"height\",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle=\"rgba(\"+a+\",\"+this.opacity+\")\",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle=\"rgba(\"+d+\",\"+this.opacity+\")\",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle=\"rgba(\"+d+\",\"+(this.opacity-this.opacity/20*t)+\")\",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle=\"rgba(\"+r+\",\"+this.opacity+\")\",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener(\"resize\",f,!1),function(){h=s.getContext(\"2d\");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};\ndark()","date":"2024-10-23T12:33:02.503Z","updated":"2024-10-23T12:33:02.503Z","path":"js/universe.js","layout":"false","title":"","comments":1,"_id":"cmfw4z09m000ouomw47404o2x","content":"function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById(\"universe\"),o=!0,a=\"180,184,240\",r=\"226,225,142\",d=\"226,225,224\",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute(\"width\",n),s.setAttribute(\"height\",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle=\"rgba(\"+a+\",\"+this.opacity+\")\",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle=\"rgba(\"+d+\",\"+this.opacity+\")\",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle=\"rgba(\"+d+\",\"+(this.opacity-this.opacity/20*t)+\")\",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle=\"rgba(\"+r+\",\"+this.opacity+\")\",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener(\"resize\",f,!1),function(){h=s.getContext(\"2d\");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};\ndark()"},{"title":"电影","date":"2024-10-23T03:29:59.000Z","_content":"\n<div class=\"movie-page\">\n \n</div>\n\n<!-- CSS 样式 -->\n<style>\n  .movie-page{\n     height: 1000px;\n  }\n</style>\n\n<script>\n  \n</script>\n","source":"movies/index.md","raw":"---\ntitle: 电影\ndate: 2024-10-23 11:29:59\n---\n\n<div class=\"movie-page\">\n \n</div>\n\n<!-- CSS 样式 -->\n<style>\n  .movie-page{\n     height: 1000px;\n  }\n</style>\n\n<script>\n  \n</script>\n","updated":"2025-04-11T06:57:55.988Z","path":"movies/index.html","comments":1,"layout":"page","_id":"cmfw4z09q000suomwcj1b4tzh","content":"<div class=\"movie-page\">\n\n</div>\n\n<!-- CSS 样式 -->\n<style>\n  .movie-page{\n     height: 1000px;\n  }\n</style>\n\n<script>\n\n</script>\n","cover":"/img/5.png","cover_type":"img","excerpt":"","more":"<div class=\"movie-page\">\n\n</div>\n\n<!-- CSS 样式 -->\n<style>\n  .movie-page{\n     height: 1000px;\n  }\n</style>\n\n<script>\n\n</script>\n"},{"title":"链接","date":"2024-10-23T03:29:59.000Z","_content":"\n<div class=\"addBtn\"><button onclick=\"leonus.linkCom()\"><i class=\"fa-solid fa-circle-plus\"></i>快速申请 (默认样式)</button> <button onclick=\"leonus.linkCom(&quot;bf&quot;)\"><i class=\"fa-solid fa-circle-plus\"></i>快速申请 (Butterfly)</button></div>\n<link rel=\"stylesheet\" href=\"/css/kslink.css\">\n<script src=\"/js/kslink.js\"></script>","source":"link/index.md","raw":"---\ntitle: 链接\ndate: 2024-10-23 11:29:59\n---\n\n<div class=\"addBtn\"><button onclick=\"leonus.linkCom()\"><i class=\"fa-solid fa-circle-plus\"></i>快速申请 (默认样式)</button> <button onclick=\"leonus.linkCom(&quot;bf&quot;)\"><i class=\"fa-solid fa-circle-plus\"></i>快速申请 (Butterfly)</button></div>\n<link rel=\"stylesheet\" href=\"/css/kslink.css\">\n<script src=\"/js/kslink.js\"></script>","updated":"2024-10-31T14:01:44.046Z","path":"link/index.html","comments":1,"layout":"page","_id":"cmfw4z09s000wuomw3lfae8ki","content":"<p><div class=\"addBtn\"><button onclick=\"leonus.linkCom()\"><i class=\"fa-solid fa-circle-plus\"></i>快速申请 (默认样式)</button> <button onclick=\"leonus.linkCom(&quot;bf&quot;)\"><i class=\"fa-solid fa-circle-plus\"></i>快速申请 (Butterfly)</button></div></p>\n<p><link rel=\"stylesheet\" href=\"/css/kslink.css\"></p>\n<script src=\"/js/kslink.js\"></script>","cover":"/img/2.png","cover_type":"img","excerpt":"","more":"<p><div class=\"addBtn\"><button onclick=\"leonus.linkCom()\"><i class=\"fa-solid fa-circle-plus\"></i>快速申请 (默认样式)</button> <button onclick=\"leonus.linkCom(&quot;bf&quot;)\"><i class=\"fa-solid fa-circle-plus\"></i>快速申请 (Butterfly)</button></div></p>\n<p><link rel=\"stylesheet\" href=\"/css/kslink.css\"></p>\n<script src=\"/js/kslink.js\"></script>"},{"title":"标签","type":"tags","layout":"tags","comments":0,"_content":"\n","source":"tags/index.md","raw":"---\ntitle: 标签\ntype: \"tags\"\nlayout: \"tags\"\ncomments: false\n---\n\n","date":"2024-11-01T11:01:46.869Z","updated":"2024-11-01T11:01:46.869Z","path":"tags/index.html","_id":"cmfw4z09v0011uomwhmoz1gtd","content":"","cover":"/img/5.png","cover_type":"img","excerpt":"","more":""},{"title":"音乐","date":"2024-10-23T03:29:59.000Z","_content":"<!-- 音乐播放器 -->\n<div class=\"music-page\">\n  {% meting \"2474029461\" \"netease\" \"playlist\" \n\"autoplay\" \n\"mutex:false\" \n\"listmaxheight:800px\" \n\"preload:auto\" \n\"theme:#f9d3e3\" %}\n</div>\n\n<style>\n  body {\n    background: linear-gradient(to right, #c9d6ff, #e2e2e2);\n    background-attachment: fixed;\n    font-family: 'Lora', 'Helvetica Neue', Helvetica, Arial, sans-serif;\n  }\n  \n .music-page {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin-top: 50px;\n    padding: 20px;\n    background: rgba(255, 255, 255, 0.8);\n    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);\n    backdrop-filter: blur(8.5px);\n    border-radius: 15px;\n    width: 80%;\n    margin-left: auto;\n    margin-right: auto;\n    height: 1000px;\n  }\n\n  h1, h2 {\n    text-align: center;\n    color: #6a11cb;\n    margin-top: 20px;\n  }\n\n  .aplayer {\n    border-radius: 10px;\n    overflow: hidden;\n  }\n</style>\n\n<script>\n // js 修改部分\n document.addEventListener('DOMContentLoaded', function() {\n  const player = document.querySelector('.music-page');\n  player.style.opacity = 0;\n  player.style.transition = \"opacity 2s\";\n  setTimeout(() => {\n    player.style.opacity = 1;\n  }, 200);\n});\n</script>","source":"music/index.md","raw":"---\ntitle: 音乐\ndate: 2024-10-23 11:29:59\n---\n<!-- 音乐播放器 -->\n<div class=\"music-page\">\n  {% meting \"2474029461\" \"netease\" \"playlist\" \n\"autoplay\" \n\"mutex:false\" \n\"listmaxheight:800px\" \n\"preload:auto\" \n\"theme:#f9d3e3\" %}\n</div>\n\n<style>\n  body {\n    background: linear-gradient(to right, #c9d6ff, #e2e2e2);\n    background-attachment: fixed;\n    font-family: 'Lora', 'Helvetica Neue', Helvetica, Arial, sans-serif;\n  }\n  \n .music-page {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin-top: 50px;\n    padding: 20px;\n    background: rgba(255, 255, 255, 0.8);\n    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);\n    backdrop-filter: blur(8.5px);\n    border-radius: 15px;\n    width: 80%;\n    margin-left: auto;\n    margin-right: auto;\n    height: 1000px;\n  }\n\n  h1, h2 {\n    text-align: center;\n    color: #6a11cb;\n    margin-top: 20px;\n  }\n\n  .aplayer {\n    border-radius: 10px;\n    overflow: hidden;\n  }\n</style>\n\n<script>\n // js 修改部分\n document.addEventListener('DOMContentLoaded', function() {\n  const player = document.querySelector('.music-page');\n  player.style.opacity = 0;\n  player.style.transition = \"opacity 2s\";\n  setTimeout(() => {\n    player.style.opacity = 1;\n  }, 200);\n});\n</script>","updated":"2025-04-11T06:57:27.720Z","path":"music/index.html","comments":1,"layout":"page","_id":"cmfw4z09x0015uomwf4o26yhm","content":"<!-- 音乐播放器 -->\n<div class=\"music-page\">\n  \n    <div id=\"aplayer-TKJxlVXN\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"2474029461\" data-server=\"netease\" data-type=\"playlist\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"false\" data-listmaxheight=\"800px\" data-preload=\"auto\" data-theme=\"#f9d3e3\"\n    ></div>\n</div>\n\n<style>\n  body {\n    background: linear-gradient(to right, #c9d6ff, #e2e2e2);\n    background-attachment: fixed;\n    font-family: 'Lora', 'Helvetica Neue', Helvetica, Arial, sans-serif;\n  }\n\n .music-page {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin-top: 50px;\n    padding: 20px;\n    background: rgba(255, 255, 255, 0.8);\n    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);\n    backdrop-filter: blur(8.5px);\n    border-radius: 15px;\n    width: 80%;\n    margin-left: auto;\n    margin-right: auto;\n    height: 1000px;\n  }\n\n  h1, h2 {\n    text-align: center;\n    color: #6a11cb;\n    margin-top: 20px;\n  }\n\n  .aplayer {\n    border-radius: 10px;\n    overflow: hidden;\n  }\n</style>\n\n<script>\n // js 修改部分\n document.addEventListener('DOMContentLoaded', function() {\n  const player = document.querySelector('.music-page');\n  player.style.opacity = 0;\n  player.style.transition = \"opacity 2s\";\n  setTimeout(() => {\n    player.style.opacity = 1;\n  }, 200);\n});\n</script>","cover":"/img/view9.jpg","cover_type":"img","excerpt":"","more":"<!-- 音乐播放器 -->\n<div class=\"music-page\">\n  \n    <div id=\"aplayer-TKJxlVXN\" class=\"aplayer aplayer-tag-marker meting-tag-marker\"\n         data-id=\"2474029461\" data-server=\"netease\" data-type=\"playlist\" data-mode=\"circulation\" data-autoplay=\"true\" data-mutex=\"false\" data-listmaxheight=\"800px\" data-preload=\"auto\" data-theme=\"#f9d3e3\"\n    ></div>\n</div>\n\n<style>\n  body {\n    background: linear-gradient(to right, #c9d6ff, #e2e2e2);\n    background-attachment: fixed;\n    font-family: 'Lora', 'Helvetica Neue', Helvetica, Arial, sans-serif;\n  }\n\n .music-page {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin-top: 50px;\n    padding: 20px;\n    background: rgba(255, 255, 255, 0.8);\n    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);\n    backdrop-filter: blur(8.5px);\n    border-radius: 15px;\n    width: 80%;\n    margin-left: auto;\n    margin-right: auto;\n    height: 1000px;\n  }\n\n  h1, h2 {\n    text-align: center;\n    color: #6a11cb;\n    margin-top: 20px;\n  }\n\n  .aplayer {\n    border-radius: 10px;\n    overflow: hidden;\n  }\n</style>\n\n<script>\n // js 修改部分\n document.addEventListener('DOMContentLoaded', function() {\n  const player = document.querySelector('.music-page');\n  player.style.opacity = 0;\n  player.style.transition = \"opacity 2s\";\n  setTimeout(() => {\n    player.style.opacity = 1;\n  }, 200);\n});\n</script>"},{"title":"wallpaper","date":"2024-11-01T02:31:53.000Z","_content":"{% gallery %}\n![](/img/wallpaper/view23.png) \n![](/img/wallpaper/view4.jpg) \n![](/img/wallpaper/view5.png) \n![](/img/wallpaper/view35.png) \n![](/img/wallpaper/view10.jpg) \n![](/img/wallpaper/view17.png) \n![](/img/wallpaper/view18.png) \n![](/img/wallpaper/view19.png) \n![](/img/wallpaper/view20.png) \n![](/img/wallpaper/view22.png) \n![](/img/wallpaper/view25.png) \n![](/img/wallpaper/view26.png) \n![](/img/wallpaper/view27.png) \n![](/img/wallpaper/view29.png) \n![](/img/wallpaper/view33.png) \n![](/img/wallpaper/view35.png) \n![](/img/wallpaper/view36.png) \n![](/img/wallpaper/view37.png) \n![](/img/wallpaper/view40.png) \n![](/img/wallpaper/view46.png) \n![](/img/wallpaper/view47.png) \n![](/img/wallpaper/view49.png) \n{% endgallery %}\n","source":"gallery/wallpaper.md","raw":"---\ntitle: wallpaper \ndate: 2024-11-01 10:31:53\n---\n{% gallery %}\n![](/img/wallpaper/view23.png) \n![](/img/wallpaper/view4.jpg) \n![](/img/wallpaper/view5.png) \n![](/img/wallpaper/view35.png) \n![](/img/wallpaper/view10.jpg) \n![](/img/wallpaper/view17.png) \n![](/img/wallpaper/view18.png) \n![](/img/wallpaper/view19.png) \n![](/img/wallpaper/view20.png) \n![](/img/wallpaper/view22.png) \n![](/img/wallpaper/view25.png) \n![](/img/wallpaper/view26.png) \n![](/img/wallpaper/view27.png) \n![](/img/wallpaper/view29.png) \n![](/img/wallpaper/view33.png) \n![](/img/wallpaper/view35.png) \n![](/img/wallpaper/view36.png) \n![](/img/wallpaper/view37.png) \n![](/img/wallpaper/view40.png) \n![](/img/wallpaper/view46.png) \n![](/img/wallpaper/view47.png) \n![](/img/wallpaper/view49.png) \n{% endgallery %}\n","updated":"2024-11-01T08:12:50.233Z","path":"gallery/wallpaper.html","comments":1,"layout":"page","_id":"cmfw4z09y0018uomwezxu472u","content":"<div class=\"gallery-container\" data-type=\"data\" data-button=\"\">\n      <div class=\"gallery-items\">[{\"url\":\"/img/wallpaper/view23.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view4.jpg\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view5.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view35.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view10.jpg\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view17.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view18.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view19.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view20.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view22.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view25.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view26.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view27.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view29.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view33.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view35.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view36.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view37.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view40.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view46.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view47.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view49.png\",\"alt\":\"\"}]</div>\n    </div>\n","cover":"/img/3.png","cover_type":"img","excerpt":"","more":"<div class=\"gallery-container\" data-type=\"data\" data-button=\"\">\n      <div class=\"gallery-items\">[{\"url\":\"/img/wallpaper/view23.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view4.jpg\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view5.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view35.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view10.jpg\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view17.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view18.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view19.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view20.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view22.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view25.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view26.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view27.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view29.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view33.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view35.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view36.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view37.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view40.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view46.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view47.png\",\"alt\":\"\"},{\"url\":\"/img/wallpaper/view49.png\",\"alt\":\"\"}]</div>\n    </div>\n"},{"title":"planet","date":"2024-11-01T02:31:53.000Z","_content":"\n{% gallery %}\n![](/img/planet/08b3b5bc32e74acfbfe530412b967092.png) \n![](/img/planet/20220710171444857.jpeg) \n![](/img/planet/542dfb27880511ebb6edd017c2d2eca2.png) \n![](/img/planet/c89083824f074c0bad71a976de306a83.png) \n![](\\img\\planet\\8fe66274880f11ebb6edd017c2d2eca2.png) \n![](\\img\\planet\\4d5b121d880511ebb6edd017c2d2eca2.png) \n{% endgallery %}\n","source":"gallery/planet.md","raw":"---\ntitle: planet\ndate: 2024-11-01 10:31:53\n---\n\n{% gallery %}\n![](/img/planet/08b3b5bc32e74acfbfe530412b967092.png) \n![](/img/planet/20220710171444857.jpeg) \n![](/img/planet/542dfb27880511ebb6edd017c2d2eca2.png) \n![](/img/planet/c89083824f074c0bad71a976de306a83.png) \n![](\\img\\planet\\8fe66274880f11ebb6edd017c2d2eca2.png) \n![](\\img\\planet\\4d5b121d880511ebb6edd017c2d2eca2.png) \n{% endgallery %}\n","updated":"2024-11-01T07:55:30.241Z","path":"gallery/planet.html","comments":1,"layout":"page","_id":"cmfw4z0a1001cuomwha961slb","content":"<div class=\"gallery-container\" data-type=\"data\" data-button=\"\">\n      <div class=\"gallery-items\">[{\"url\":\"/img/planet/08b3b5bc32e74acfbfe530412b967092.png\",\"alt\":\"\"},{\"url\":\"/img/planet/20220710171444857.jpeg\",\"alt\":\"\"},{\"url\":\"/img/planet/542dfb27880511ebb6edd017c2d2eca2.png\",\"alt\":\"\"},{\"url\":\"/img/planet/c89083824f074c0bad71a976de306a83.png\",\"alt\":\"\"},{\"url\":\"\\\\img\\\\planet\\\\8fe66274880f11ebb6edd017c2d2eca2.png\",\"alt\":\"\"},{\"url\":\"\\\\img\\\\planet\\\\4d5b121d880511ebb6edd017c2d2eca2.png\",\"alt\":\"\"}]</div>\n    </div>\n","cover":"/img/2.png","cover_type":"img","excerpt":"","more":"<div class=\"gallery-container\" data-type=\"data\" data-button=\"\">\n      <div class=\"gallery-items\">[{\"url\":\"/img/planet/08b3b5bc32e74acfbfe530412b967092.png\",\"alt\":\"\"},{\"url\":\"/img/planet/20220710171444857.jpeg\",\"alt\":\"\"},{\"url\":\"/img/planet/542dfb27880511ebb6edd017c2d2eca2.png\",\"alt\":\"\"},{\"url\":\"/img/planet/c89083824f074c0bad71a976de306a83.png\",\"alt\":\"\"},{\"url\":\"\\\\img\\\\planet\\\\8fe66274880f11ebb6edd017c2d2eca2.png\",\"alt\":\"\"},{\"url\":\"\\\\img\\\\planet\\\\4d5b121d880511ebb6edd017c2d2eca2.png\",\"alt\":\"\"}]</div>\n    </div>\n"}],"Post":[{"banner":"[[pixel-banner-image.png]]","title":"深入缓冲区: 理解PageCache, Socket与零拷贝","date":"2025-09-17T02:51:00.000Z","_content":"\n\t良言难劝该死的鬼, 慈悲不度自绝人💔\n\n# 深入缓冲区: 理解PageCache, Socket与零拷贝\n- 内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。\n\n代码通常如下，一般会需要两个系统调用：read()  write()\n## 用户态与内核态\n- 内核态：操作系统内核运行的空间，权限最高，可以直接操作硬件资源, 像文件管理, 进程管理, 内存管理这类 \n\t- 凡是与系统态级别的资源有关的操作（如文件管理、进程管理、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成\n- 用户态：应用程序运行的空间，权限受限，不能直接操控硬件，必须通过系统调用向内核请求服务。  \n- 关键点：应用与硬件之间的数据交互，必须经过内核的参与。  \n- 进入内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查）\n![17583324712651758332470345.png|700x176](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17583324712651758332470345.png)\n## 缓冲区(Buffer)\n### 页缓存（Page Cache）\n- 定义：内核为磁盘文件数据提供的缓存区，一页差不多4KB; 核心概念 -> 用读内存替换读磁盘\n- 作用：降低磁盘 I/O 开销。 \n  - 读：文件若已存在于 Page Cache，`read()` 会直接从内存返回\n  - 写：数据先写入 Page Cache，再由内核异步写回磁盘（延迟写）  \n- 当要从硬盘读取GB大小的文件时, DMA拷贝文件时, 也会使用PageCache缓存文件, 但是这时候内存缓存空间也会被占用, 导致其他热点文件无法使用PageCache, 最终磁盘IO能力下降\n### Socket 缓冲区\n- 位置：内核态，用于存放即将发送或接收的网络数据\n- 作用：维持数据传输的速率和稳定性，确保不会丢包\n- 应用：应用层的 `send/recv` 实际是向 Socket 缓冲区写入或读取数据\n### 用户缓冲区\n- 位置：用户态的内存空间\n- 举例: 像`BufferedInputStream`就是一种伪用户缓冲区\n- 作用：应用程序处理数据的中转区\n- 缺陷：与内核缓冲区之间的数据交互需要额外的 CPU 拷贝\n## DMA\n- DMA 是 直接内存访问 的缩写  Directly Memory Access \n- 它是一个硬件上的小芯片，一定程度上替代了CPU的职责, 减少了CPU的性能消耗, 从而提高 CPU 利用效率\n- 在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务\n## 文件传输方式对比\n### 1. 普通 I/O (`read` + `write`)\n1. 磁盘数据 → DMA 拷贝 → Page Cache。  \n2. Page Cache → CPU 拷贝 → 用户缓冲区。  \n3. 用户缓冲区 → CPU 拷贝 → Socket 缓冲区。  \n4. Socket 缓冲区 → DMA 拷贝 → 网卡。  \n![17580782241251758078223678.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580782241251758078223678.png)\n### 2. `mmap` + `write`（用户态零拷贝）\n- **将磁盘上的物理文件直接映射到用户态的内存地址中, 相当于一片共享空间**  \n- 用 mmap() 替换 read() 系统调用函数 buf = mmap(file, len)\n1. `mmap` 将文件页映射到用户态地址空间，应用可直接操作 Page Cache。  \n2. 写 socket 时：Page Cache → CPU 拷贝 → Socket 缓冲区 → DMA 拷贝 → 网卡。 \n![17580783321201758078331448.png|700x439](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580783321201758078331448.png)\n### 3. `sendfile`(网络零拷贝)\n1. 磁盘数据 → DMA 拷贝 → Page Cache。  \n2. Page Cache 的页直缓冲区描述符和数据长度传到 socket 缓冲区(元数据传递，无实际数据拷贝)\n3. PageCache → DMA 拷贝 → 网卡。  \n![17582840954991758284095244.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17582840954991758284095244.png)\n### 4. Direct I/O\n- 绕过 Page Cache，应用直接与磁盘交互。  \n- 优点：避免双重缓存（例如数据库有自己的缓存机制）。  \n- 缺点：每次读写都要访问磁盘，性能较低。  \n## 用户态零拷贝至网络传输的流程\n1. 用户进程调用mmap方法, 将用户态切换至内核态, 然后建立起用户缓冲区和内核缓冲区(PageCache)的内存地址映射, 也就是所谓的共享区域\n2. CPU调度DMA控制器将磁盘数据拷贝至内核缓冲区; 这是用户如果要修改文件的话, 先将内核态切换为用户态;\n3. 用户对数据进行修改后调用write(), 再将用户态切回内核态;\n4. CPU将内核缓冲区(PageCache)的数据拷贝至Socket缓冲区;\n5. CPU调度DMA将数据从Socket缓冲区拷贝至网卡;\n## 用户态零拷贝和网络零拷贝的区别\n- **mmap**(MappedByteBuffer) → 用户态可直接访问，**适合文件处理**，减少用户态 ↔ 内核态拷贝。\n- **sendfile** → **文件直接发往网络**，Java 层无法访问数据, 也无法修改, 只能用于**网络传输**。\n- 选择哪种方式取决于 你要做的 I/O 类型：\n    - 文件处理 / 修改 → mmap\n    - 文件传输 / 网络发送 → sendfile\n![17580801240121758080123618.png|700x176](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580801240121758080123618.png)\n## 总结\n- 三大缓冲区：用户缓冲区, 内核缓冲区分为 页缓冲区(PageCache) 和 Socket缓冲区\n- 零拷贝的本质：**减少用户态与内核态的上下文切换**和**内存拷贝的次数** \n- Kafka、Nginx、 RocketMQ等高性能框架，均大量使用**零拷贝技术**来提升I/O效率(减少IO次数)\n- RocketMQ 内部主要是使用基于 mmap 实现的零拷贝(其实就是调用上述提到的 api)，用来读写文件，这也是 RocketMQ 为什么快的一个很重要原因。\n- 零拷贝 无论是mmap还是sendfile都用到了PageCache技术","source":"_posts/Buffer.md","raw":"---\nbanner: \"[[pixel-banner-image.png]]\"\ntitle: \"深入缓冲区: 理解PageCache, Socket与零拷贝\"\ntags:\n  - ZeroCopy\n  - Buffer\n  - Kernel\ncategories: 编程\ndate: 2025-09-17T10:51:00\n---\n\n\t良言难劝该死的鬼, 慈悲不度自绝人💔\n\n# 深入缓冲区: 理解PageCache, Socket与零拷贝\n- 内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。\n\n代码通常如下，一般会需要两个系统调用：read()  write()\n## 用户态与内核态\n- 内核态：操作系统内核运行的空间，权限最高，可以直接操作硬件资源, 像文件管理, 进程管理, 内存管理这类 \n\t- 凡是与系统态级别的资源有关的操作（如文件管理、进程管理、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成\n- 用户态：应用程序运行的空间，权限受限，不能直接操控硬件，必须通过系统调用向内核请求服务。  \n- 关键点：应用与硬件之间的数据交互，必须经过内核的参与。  \n- 进入内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查）\n![17583324712651758332470345.png|700x176](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17583324712651758332470345.png)\n## 缓冲区(Buffer)\n### 页缓存（Page Cache）\n- 定义：内核为磁盘文件数据提供的缓存区，一页差不多4KB; 核心概念 -> 用读内存替换读磁盘\n- 作用：降低磁盘 I/O 开销。 \n  - 读：文件若已存在于 Page Cache，`read()` 会直接从内存返回\n  - 写：数据先写入 Page Cache，再由内核异步写回磁盘（延迟写）  \n- 当要从硬盘读取GB大小的文件时, DMA拷贝文件时, 也会使用PageCache缓存文件, 但是这时候内存缓存空间也会被占用, 导致其他热点文件无法使用PageCache, 最终磁盘IO能力下降\n### Socket 缓冲区\n- 位置：内核态，用于存放即将发送或接收的网络数据\n- 作用：维持数据传输的速率和稳定性，确保不会丢包\n- 应用：应用层的 `send/recv` 实际是向 Socket 缓冲区写入或读取数据\n### 用户缓冲区\n- 位置：用户态的内存空间\n- 举例: 像`BufferedInputStream`就是一种伪用户缓冲区\n- 作用：应用程序处理数据的中转区\n- 缺陷：与内核缓冲区之间的数据交互需要额外的 CPU 拷贝\n## DMA\n- DMA 是 直接内存访问 的缩写  Directly Memory Access \n- 它是一个硬件上的小芯片，一定程度上替代了CPU的职责, 减少了CPU的性能消耗, 从而提高 CPU 利用效率\n- 在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务\n## 文件传输方式对比\n### 1. 普通 I/O (`read` + `write`)\n1. 磁盘数据 → DMA 拷贝 → Page Cache。  \n2. Page Cache → CPU 拷贝 → 用户缓冲区。  \n3. 用户缓冲区 → CPU 拷贝 → Socket 缓冲区。  \n4. Socket 缓冲区 → DMA 拷贝 → 网卡。  \n![17580782241251758078223678.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580782241251758078223678.png)\n### 2. `mmap` + `write`（用户态零拷贝）\n- **将磁盘上的物理文件直接映射到用户态的内存地址中, 相当于一片共享空间**  \n- 用 mmap() 替换 read() 系统调用函数 buf = mmap(file, len)\n1. `mmap` 将文件页映射到用户态地址空间，应用可直接操作 Page Cache。  \n2. 写 socket 时：Page Cache → CPU 拷贝 → Socket 缓冲区 → DMA 拷贝 → 网卡。 \n![17580783321201758078331448.png|700x439](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580783321201758078331448.png)\n### 3. `sendfile`(网络零拷贝)\n1. 磁盘数据 → DMA 拷贝 → Page Cache。  \n2. Page Cache 的页直缓冲区描述符和数据长度传到 socket 缓冲区(元数据传递，无实际数据拷贝)\n3. PageCache → DMA 拷贝 → 网卡。  \n![17582840954991758284095244.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17582840954991758284095244.png)\n### 4. Direct I/O\n- 绕过 Page Cache，应用直接与磁盘交互。  \n- 优点：避免双重缓存（例如数据库有自己的缓存机制）。  \n- 缺点：每次读写都要访问磁盘，性能较低。  \n## 用户态零拷贝至网络传输的流程\n1. 用户进程调用mmap方法, 将用户态切换至内核态, 然后建立起用户缓冲区和内核缓冲区(PageCache)的内存地址映射, 也就是所谓的共享区域\n2. CPU调度DMA控制器将磁盘数据拷贝至内核缓冲区; 这是用户如果要修改文件的话, 先将内核态切换为用户态;\n3. 用户对数据进行修改后调用write(), 再将用户态切回内核态;\n4. CPU将内核缓冲区(PageCache)的数据拷贝至Socket缓冲区;\n5. CPU调度DMA将数据从Socket缓冲区拷贝至网卡;\n## 用户态零拷贝和网络零拷贝的区别\n- **mmap**(MappedByteBuffer) → 用户态可直接访问，**适合文件处理**，减少用户态 ↔ 内核态拷贝。\n- **sendfile** → **文件直接发往网络**，Java 层无法访问数据, 也无法修改, 只能用于**网络传输**。\n- 选择哪种方式取决于 你要做的 I/O 类型：\n    - 文件处理 / 修改 → mmap\n    - 文件传输 / 网络发送 → sendfile\n![17580801240121758080123618.png|700x176](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580801240121758080123618.png)\n## 总结\n- 三大缓冲区：用户缓冲区, 内核缓冲区分为 页缓冲区(PageCache) 和 Socket缓冲区\n- 零拷贝的本质：**减少用户态与内核态的上下文切换**和**内存拷贝的次数** \n- Kafka、Nginx、 RocketMQ等高性能框架，均大量使用**零拷贝技术**来提升I/O效率(减少IO次数)\n- RocketMQ 内部主要是使用基于 mmap 实现的零拷贝(其实就是调用上述提到的 api)，用来读写文件，这也是 RocketMQ 为什么快的一个很重要原因。\n- 零拷贝 无论是mmap还是sendfile都用到了PageCache技术","slug":"Buffer","published":1,"updated":"2025-09-22T14:21:08.397Z","comments":1,"layout":"post","photos":[],"_id":"cmfw4z08i0001uomw9v4zd9qr","content":"<pre><code>良言难劝该死的鬼, 慈悲不度自绝人💔\n</code></pre><h1 id=\"深入缓冲区-理解PageCache-Socket与零拷贝\"><a href=\"#深入缓冲区-理解PageCache-Socket与零拷贝\" class=\"headerlink\" title=\"深入缓冲区: 理解PageCache, Socket与零拷贝\"></a>深入缓冲区: 理解PageCache, Socket与零拷贝</h1><ul>\n<li>内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</li>\n</ul>\n<p>代码通常如下，一般会需要两个系统调用：read()  write()</p>\n<h2 id=\"用户态与内核态\"><a href=\"#用户态与内核态\" class=\"headerlink\" title=\"用户态与内核态\"></a>用户态与内核态</h2><ul>\n<li>内核态：操作系统内核运行的空间，权限最高，可以直接操作硬件资源, 像文件管理, 进程管理, 内存管理这类 <ul>\n<li>凡是与系统态级别的资源有关的操作（如文件管理、进程管理、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</li>\n</ul>\n</li>\n<li>用户态：应用程序运行的空间，权限受限，不能直接操控硬件，必须通过系统调用向内核请求服务。  </li>\n<li>关键点：应用与硬件之间的数据交互，必须经过内核的参与。  </li>\n<li>进入内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查）<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17583324712651758332470345.png\" alt=\"17583324712651758332470345.png|700x176\"><h2 id=\"缓冲区-Buffer\"><a href=\"#缓冲区-Buffer\" class=\"headerlink\" title=\"缓冲区(Buffer)\"></a>缓冲区(Buffer)</h2><h3 id=\"页缓存（Page-Cache）\"><a href=\"#页缓存（Page-Cache）\" class=\"headerlink\" title=\"页缓存（Page Cache）\"></a>页缓存（Page Cache）</h3></li>\n<li>定义：内核为磁盘文件数据提供的缓存区，一页差不多4KB; 核心概念 -&gt; 用读内存替换读磁盘</li>\n<li>作用：降低磁盘 I/O 开销。 <ul>\n<li>读：文件若已存在于 Page Cache，<code>read()</code> 会直接从内存返回</li>\n<li>写：数据先写入 Page Cache，再由内核异步写回磁盘（延迟写）  </li>\n</ul>\n</li>\n<li>当要从硬盘读取GB大小的文件时, DMA拷贝文件时, 也会使用PageCache缓存文件, 但是这时候内存缓存空间也会被占用, 导致其他热点文件无法使用PageCache, 最终磁盘IO能力下降<h3 id=\"Socket-缓冲区\"><a href=\"#Socket-缓冲区\" class=\"headerlink\" title=\"Socket 缓冲区\"></a>Socket 缓冲区</h3></li>\n<li>位置：内核态，用于存放即将发送或接收的网络数据</li>\n<li>作用：维持数据传输的速率和稳定性，确保不会丢包</li>\n<li>应用：应用层的 <code>send/recv</code> 实际是向 Socket 缓冲区写入或读取数据<h3 id=\"用户缓冲区\"><a href=\"#用户缓冲区\" class=\"headerlink\" title=\"用户缓冲区\"></a>用户缓冲区</h3></li>\n<li>位置：用户态的内存空间</li>\n<li>举例: 像<code>BufferedInputStream</code>就是一种伪用户缓冲区</li>\n<li>作用：应用程序处理数据的中转区</li>\n<li>缺陷：与内核缓冲区之间的数据交互需要额外的 CPU 拷贝<h2 id=\"DMA\"><a href=\"#DMA\" class=\"headerlink\" title=\"DMA\"></a>DMA</h2></li>\n<li>DMA 是 直接内存访问 的缩写  Directly Memory Access </li>\n<li>它是一个硬件上的小芯片，一定程度上替代了CPU的职责, 减少了CPU的性能消耗, 从而提高 CPU 利用效率</li>\n<li>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务<h2 id=\"文件传输方式对比\"><a href=\"#文件传输方式对比\" class=\"headerlink\" title=\"文件传输方式对比\"></a>文件传输方式对比</h2><h3 id=\"1-普通-I-O-read-write\"><a href=\"#1-普通-I-O-read-write\" class=\"headerlink\" title=\"1. 普通 I/O (read + write)\"></a>1. 普通 I/O (<code>read</code> + <code>write</code>)</h3></li>\n</ul>\n<ol>\n<li>磁盘数据 → DMA 拷贝 → Page Cache。  </li>\n<li>Page Cache → CPU 拷贝 → 用户缓冲区。  </li>\n<li>用户缓冲区 → CPU 拷贝 → Socket 缓冲区。  </li>\n<li>Socket 缓冲区 → DMA 拷贝 → 网卡。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580782241251758078223678.png\" alt=\"17580782241251758078223678.png\"><h3 id=\"2-mmap-write（用户态零拷贝）\"><a href=\"#2-mmap-write（用户态零拷贝）\" class=\"headerlink\" title=\"2. mmap + write（用户态零拷贝）\"></a>2. <code>mmap</code> + <code>write</code>（用户态零拷贝）</h3></li>\n</ol>\n<ul>\n<li><strong>将磁盘上的物理文件直接映射到用户态的内存地址中, 相当于一片共享空间</strong>  </li>\n<li>用 mmap() 替换 read() 系统调用函数 buf = mmap(file, len)</li>\n</ul>\n<ol>\n<li><code>mmap</code> 将文件页映射到用户态地址空间，应用可直接操作 Page Cache。  </li>\n<li>写 socket 时：Page Cache → CPU 拷贝 → Socket 缓冲区 → DMA 拷贝 → 网卡。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580783321201758078331448.png\" alt=\"17580783321201758078331448.png|700x439\"><h3 id=\"3-sendfile-网络零拷贝\"><a href=\"#3-sendfile-网络零拷贝\" class=\"headerlink\" title=\"3. sendfile(网络零拷贝)\"></a>3. <code>sendfile</code>(网络零拷贝)</h3></li>\n<li>磁盘数据 → DMA 拷贝 → Page Cache。  </li>\n<li>Page Cache 的页直缓冲区描述符和数据长度传到 socket 缓冲区(元数据传递，无实际数据拷贝)</li>\n<li>PageCache → DMA 拷贝 → 网卡。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17582840954991758284095244.png\" alt=\"17582840954991758284095244.png\"><h3 id=\"4-Direct-I-O\"><a href=\"#4-Direct-I-O\" class=\"headerlink\" title=\"4. Direct I/O\"></a>4. Direct I/O</h3></li>\n</ol>\n<ul>\n<li>绕过 Page Cache，应用直接与磁盘交互。  </li>\n<li>优点：避免双重缓存（例如数据库有自己的缓存机制）。  </li>\n<li>缺点：每次读写都要访问磁盘，性能较低。  <h2 id=\"用户态零拷贝至网络传输的流程\"><a href=\"#用户态零拷贝至网络传输的流程\" class=\"headerlink\" title=\"用户态零拷贝至网络传输的流程\"></a>用户态零拷贝至网络传输的流程</h2></li>\n</ul>\n<ol>\n<li>用户进程调用mmap方法, 将用户态切换至内核态, 然后建立起用户缓冲区和内核缓冲区(PageCache)的内存地址映射, 也就是所谓的共享区域</li>\n<li>CPU调度DMA控制器将磁盘数据拷贝至内核缓冲区; 这是用户如果要修改文件的话, 先将内核态切换为用户态;</li>\n<li>用户对数据进行修改后调用write(), 再将用户态切回内核态;</li>\n<li>CPU将内核缓冲区(PageCache)的数据拷贝至Socket缓冲区;</li>\n<li>CPU调度DMA将数据从Socket缓冲区拷贝至网卡;<h2 id=\"用户态零拷贝和网络零拷贝的区别\"><a href=\"#用户态零拷贝和网络零拷贝的区别\" class=\"headerlink\" title=\"用户态零拷贝和网络零拷贝的区别\"></a>用户态零拷贝和网络零拷贝的区别</h2></li>\n</ol>\n<ul>\n<li><strong>mmap</strong>(MappedByteBuffer) → 用户态可直接访问，<strong>适合文件处理</strong>，减少用户态 ↔ 内核态拷贝。</li>\n<li><strong>sendfile</strong> → <strong>文件直接发往网络</strong>，Java 层无法访问数据, 也无法修改, 只能用于<strong>网络传输</strong>。</li>\n<li>选择哪种方式取决于 你要做的 I/O 类型：<ul>\n<li>文件处理 / 修改 → mmap</li>\n<li>文件传输 / 网络发送 → sendfile<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580801240121758080123618.png\" alt=\"17580801240121758080123618.png|700x176\"><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2></li>\n</ul>\n</li>\n<li>三大缓冲区：用户缓冲区, 内核缓冲区分为 页缓冲区(PageCache) 和 Socket缓冲区</li>\n<li>零拷贝的本质：<strong>减少用户态与内核态的上下文切换</strong>和<strong>内存拷贝的次数</strong> </li>\n<li>Kafka、Nginx、 RocketMQ等高性能框架，均大量使用<strong>零拷贝技术</strong>来提升I/O效率(减少IO次数)</li>\n<li>RocketMQ 内部主要是使用基于 mmap 实现的零拷贝(其实就是调用上述提到的 api)，用来读写文件，这也是 RocketMQ 为什么快的一个很重要原因。</li>\n<li>零拷贝 无论是mmap还是sendfile都用到了PageCache技术</li>\n</ul>\n","cover":"/img/4.png","cover_type":"img","excerpt":"","more":"<pre><code>良言难劝该死的鬼, 慈悲不度自绝人💔\n</code></pre><h1 id=\"深入缓冲区-理解PageCache-Socket与零拷贝\"><a href=\"#深入缓冲区-理解PageCache-Socket与零拷贝\" class=\"headerlink\" title=\"深入缓冲区: 理解PageCache, Socket与零拷贝\"></a>深入缓冲区: 理解PageCache, Socket与零拷贝</h1><ul>\n<li>内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</li>\n</ul>\n<p>代码通常如下，一般会需要两个系统调用：read()  write()</p>\n<h2 id=\"用户态与内核态\"><a href=\"#用户态与内核态\" class=\"headerlink\" title=\"用户态与内核态\"></a>用户态与内核态</h2><ul>\n<li>内核态：操作系统内核运行的空间，权限最高，可以直接操作硬件资源, 像文件管理, 进程管理, 内存管理这类 <ul>\n<li>凡是与系统态级别的资源有关的操作（如文件管理、进程管理、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</li>\n</ul>\n</li>\n<li>用户态：应用程序运行的空间，权限受限，不能直接操控硬件，必须通过系统调用向内核请求服务。  </li>\n<li>关键点：应用与硬件之间的数据交互，必须经过内核的参与。  </li>\n<li>进入内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查）<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17583324712651758332470345.png\" alt=\"17583324712651758332470345.png|700x176\"><h2 id=\"缓冲区-Buffer\"><a href=\"#缓冲区-Buffer\" class=\"headerlink\" title=\"缓冲区(Buffer)\"></a>缓冲区(Buffer)</h2><h3 id=\"页缓存（Page-Cache）\"><a href=\"#页缓存（Page-Cache）\" class=\"headerlink\" title=\"页缓存（Page Cache）\"></a>页缓存（Page Cache）</h3></li>\n<li>定义：内核为磁盘文件数据提供的缓存区，一页差不多4KB; 核心概念 -&gt; 用读内存替换读磁盘</li>\n<li>作用：降低磁盘 I/O 开销。 <ul>\n<li>读：文件若已存在于 Page Cache，<code>read()</code> 会直接从内存返回</li>\n<li>写：数据先写入 Page Cache，再由内核异步写回磁盘（延迟写）  </li>\n</ul>\n</li>\n<li>当要从硬盘读取GB大小的文件时, DMA拷贝文件时, 也会使用PageCache缓存文件, 但是这时候内存缓存空间也会被占用, 导致其他热点文件无法使用PageCache, 最终磁盘IO能力下降<h3 id=\"Socket-缓冲区\"><a href=\"#Socket-缓冲区\" class=\"headerlink\" title=\"Socket 缓冲区\"></a>Socket 缓冲区</h3></li>\n<li>位置：内核态，用于存放即将发送或接收的网络数据</li>\n<li>作用：维持数据传输的速率和稳定性，确保不会丢包</li>\n<li>应用：应用层的 <code>send/recv</code> 实际是向 Socket 缓冲区写入或读取数据<h3 id=\"用户缓冲区\"><a href=\"#用户缓冲区\" class=\"headerlink\" title=\"用户缓冲区\"></a>用户缓冲区</h3></li>\n<li>位置：用户态的内存空间</li>\n<li>举例: 像<code>BufferedInputStream</code>就是一种伪用户缓冲区</li>\n<li>作用：应用程序处理数据的中转区</li>\n<li>缺陷：与内核缓冲区之间的数据交互需要额外的 CPU 拷贝<h2 id=\"DMA\"><a href=\"#DMA\" class=\"headerlink\" title=\"DMA\"></a>DMA</h2></li>\n<li>DMA 是 直接内存访问 的缩写  Directly Memory Access </li>\n<li>它是一个硬件上的小芯片，一定程度上替代了CPU的职责, 减少了CPU的性能消耗, 从而提高 CPU 利用效率</li>\n<li>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务<h2 id=\"文件传输方式对比\"><a href=\"#文件传输方式对比\" class=\"headerlink\" title=\"文件传输方式对比\"></a>文件传输方式对比</h2><h3 id=\"1-普通-I-O-read-write\"><a href=\"#1-普通-I-O-read-write\" class=\"headerlink\" title=\"1. 普通 I/O (read + write)\"></a>1. 普通 I/O (<code>read</code> + <code>write</code>)</h3></li>\n</ul>\n<ol>\n<li>磁盘数据 → DMA 拷贝 → Page Cache。  </li>\n<li>Page Cache → CPU 拷贝 → 用户缓冲区。  </li>\n<li>用户缓冲区 → CPU 拷贝 → Socket 缓冲区。  </li>\n<li>Socket 缓冲区 → DMA 拷贝 → 网卡。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580782241251758078223678.png\" alt=\"17580782241251758078223678.png\"><h3 id=\"2-mmap-write（用户态零拷贝）\"><a href=\"#2-mmap-write（用户态零拷贝）\" class=\"headerlink\" title=\"2. mmap + write（用户态零拷贝）\"></a>2. <code>mmap</code> + <code>write</code>（用户态零拷贝）</h3></li>\n</ol>\n<ul>\n<li><strong>将磁盘上的物理文件直接映射到用户态的内存地址中, 相当于一片共享空间</strong>  </li>\n<li>用 mmap() 替换 read() 系统调用函数 buf = mmap(file, len)</li>\n</ul>\n<ol>\n<li><code>mmap</code> 将文件页映射到用户态地址空间，应用可直接操作 Page Cache。  </li>\n<li>写 socket 时：Page Cache → CPU 拷贝 → Socket 缓冲区 → DMA 拷贝 → 网卡。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580783321201758078331448.png\" alt=\"17580783321201758078331448.png|700x439\"><h3 id=\"3-sendfile-网络零拷贝\"><a href=\"#3-sendfile-网络零拷贝\" class=\"headerlink\" title=\"3. sendfile(网络零拷贝)\"></a>3. <code>sendfile</code>(网络零拷贝)</h3></li>\n<li>磁盘数据 → DMA 拷贝 → Page Cache。  </li>\n<li>Page Cache 的页直缓冲区描述符和数据长度传到 socket 缓冲区(元数据传递，无实际数据拷贝)</li>\n<li>PageCache → DMA 拷贝 → 网卡。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17582840954991758284095244.png\" alt=\"17582840954991758284095244.png\"><h3 id=\"4-Direct-I-O\"><a href=\"#4-Direct-I-O\" class=\"headerlink\" title=\"4. Direct I/O\"></a>4. Direct I/O</h3></li>\n</ol>\n<ul>\n<li>绕过 Page Cache，应用直接与磁盘交互。  </li>\n<li>优点：避免双重缓存（例如数据库有自己的缓存机制）。  </li>\n<li>缺点：每次读写都要访问磁盘，性能较低。  <h2 id=\"用户态零拷贝至网络传输的流程\"><a href=\"#用户态零拷贝至网络传输的流程\" class=\"headerlink\" title=\"用户态零拷贝至网络传输的流程\"></a>用户态零拷贝至网络传输的流程</h2></li>\n</ul>\n<ol>\n<li>用户进程调用mmap方法, 将用户态切换至内核态, 然后建立起用户缓冲区和内核缓冲区(PageCache)的内存地址映射, 也就是所谓的共享区域</li>\n<li>CPU调度DMA控制器将磁盘数据拷贝至内核缓冲区; 这是用户如果要修改文件的话, 先将内核态切换为用户态;</li>\n<li>用户对数据进行修改后调用write(), 再将用户态切回内核态;</li>\n<li>CPU将内核缓冲区(PageCache)的数据拷贝至Socket缓冲区;</li>\n<li>CPU调度DMA将数据从Socket缓冲区拷贝至网卡;<h2 id=\"用户态零拷贝和网络零拷贝的区别\"><a href=\"#用户态零拷贝和网络零拷贝的区别\" class=\"headerlink\" title=\"用户态零拷贝和网络零拷贝的区别\"></a>用户态零拷贝和网络零拷贝的区别</h2></li>\n</ol>\n<ul>\n<li><strong>mmap</strong>(MappedByteBuffer) → 用户态可直接访问，<strong>适合文件处理</strong>，减少用户态 ↔ 内核态拷贝。</li>\n<li><strong>sendfile</strong> → <strong>文件直接发往网络</strong>，Java 层无法访问数据, 也无法修改, 只能用于<strong>网络传输</strong>。</li>\n<li>选择哪种方式取决于 你要做的 I/O 类型：<ul>\n<li>文件处理 / 修改 → mmap</li>\n<li>文件传输 / 网络发送 → sendfile<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580801240121758080123618.png\" alt=\"17580801240121758080123618.png|700x176\"><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2></li>\n</ul>\n</li>\n<li>三大缓冲区：用户缓冲区, 内核缓冲区分为 页缓冲区(PageCache) 和 Socket缓冲区</li>\n<li>零拷贝的本质：<strong>减少用户态与内核态的上下文切换</strong>和<strong>内存拷贝的次数</strong> </li>\n<li>Kafka、Nginx、 RocketMQ等高性能框架，均大量使用<strong>零拷贝技术</strong>来提升I/O效率(减少IO次数)</li>\n<li>RocketMQ 内部主要是使用基于 mmap 实现的零拷贝(其实就是调用上述提到的 api)，用来读写文件，这也是 RocketMQ 为什么快的一个很重要原因。</li>\n<li>零拷贝 无论是mmap还是sendfile都用到了PageCache技术</li>\n</ul>\n"},{"title":" 日期格式和消息转换器","date":"2024-11-23T01:52:54.000Z","_content":"\n# 日期格式和消息转换器\n\n> 你会遇见很多星星, 而我只会心动💓一个月亮\n\n---\n## Date 和 LocalDate 的区别\n### 1. 基本概念\n- Date：是 Java 1引入的日期时间类，底层存储的是一个UTC时间戳（即自 1970-01-01 00:00:00 UTC 到今日**精确到毫秒的时间戳**）。\n- LocalDate：是 Java 8 引入的新日期时间 API，表示一个纯日期（年月日），不包含时间信息和时区信息，具有不可变性和线程安全性。\n### 2. 系统时钟影响\n - 不管是Date还是LocalDate, 在new 对象时都是根据本地系统时钟(时区)来设置时间的\n### 3. 数据库存储差异\n- Date 通常与数据库中的 **timestamp** 或 **datetime** 类型直接映射，数据库和应用服务器时区不一致时，可能出现时间偏移问题。\n- LocalDate一般映射为数据库的 **date** 类型，**仅存储日期字符串**，不涉及时间和时区，因此不会出现时间偏移问题。\n- **存储时，MySQL 会将当前会话时区下的时间值转换成 UTC（协调世界时）进行内部存储。当查询 `TIMESTAMP` 字段时，MySQL 又会将存储的 UTC 时间转换回当前会话所设置的时区来显示。**\n### 4. 区别\n- 不可变性与线程安全:\n\t- Date 是可变对象，线程不安全。 占用4-7字节\n\t- LocalDate 是不可变对象的字符串，所以线程安全，推荐使用。  占用5-8字节\n- Java.util 下Date需要额外的Calendar来进行日期加减, 比较繁琐; 而Java.time 下LocalDate提供丰富的 API\n### 5. 时间戳转换区别\n- Date 和时间戳的转换是直接基于 getTime()（毫秒值）。\n- LocalDate 与时间戳没有直接关联，如果需要转时间戳，必须先转换为 LocalDateTime 并指定时区。\n### 6.数值型时间戳\n- 底层也是时间戳, 但是由于使用int或者bigint来存储时间戳, 不会出现时区问题, 占用空间更小(4字节), 缺点是不够直观\n## 什么是转换器\n\n- **SpringMVC**执行流程: **DispatherServlet** -> **HandlerMapping** -> **HandleAdapt** -> **Resolve**\n- 当请求被Tomcat容器捕获时,下一步将交由前置控制器去分发请求, 前置控制器核心方法将调用映射器,去匹配请求(uri匹配失败返回404, 请求方法匹配失败返回405), 成功之后进入适配器, 进行参数的反序列化, handle处理完成要离开适配器的时候也将由适配器去做序列化, 通常返回数据默认加上@ResponseBody(restful风格), 表明返回的是一个对象\n\n- 无论是请求**数据的反序列化**，还是**响应数据的序列化**，最终都需要将数据转换成**字节数组**（`byte[]`）以便进行网络传输,也就是 xxxToByteConverter, 任何转换器最终都需要经过这个进行二次转换\n\n- **`@RequestBody`**: 当你使用 `@RequestBody` 时，Spring 会利用 `HttpMessageConverter` 来处理请求体的转换。**如果你自定义了 `ObjectMapper`**（如 `JacksonObjectMapper`），它会生效并处理请求体的序列化和反序列化。因此，所有通过 `@RequestBody` 接收到的数据，都会通过你自定义的 `ObjectMapper` 来进行类型转换\n\n- @**`RequestParma`/`Pathvariable`**: 当你使用`RequestParma`/`Pathvariable` 时, 它们不会直接使用 `ObjectMapper` (`JacksonObjectMapper`)来转换, 而是使用 Spring 的类型转换器机制 (`ConversionService`),你可以通过实现 `Converter` 接口或 `@InitBinder`注解 来扩展转换逻辑\n\n## 参数绑定核心机制\n### `@RequestBody`\n- 作用对象：**请求体中的 JSON/XML 等格式的数据**\n- 使用工具：**`HttpMessageConverter`（消息转换器）**\n- 默认实现：**`MappingJackson2HttpMessageConverter`**\n- 影响方式：可通过自定义 `ObjectMapper模块`来定制序列化/反序列化逻辑（如时间格式、字段命名策略等）\n### `@RequestParam` & `@PathVariable`\n- 作用对象：**URL 查询参数、路径参数**\n- 使用工具：**`ConversionService`（类型转换服务）**\n- 自定义扩展方式：\n    - 实现Converter接口: `org.springframework.core.convert.converter.Converter<S, T>` \n    - 通过 `@InitBinder` 自定义 `WebDataBinder`\n### `HttpMessageConverter` 的组成\n- Spring Boot 默认引入的是 **Jackson** 相关的 HTTP 消息转换器（除非你引入了其他如 Gson、Fastjson 会自动替换）：\n- `MappingJackson2HttpMessageConverter`\n- 其中底层依赖的就是 Jackson 的 `ObjectMapper`，你自定义的 `JacksonObjectMapper` 正是通过这个机制生效。\n\n## 自定义转换器\n- **`针对@RequestParam`** \n\t- 单次生效: 采用注解\n\t\t- **`@RequestParam @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")`** \n\t- 全局生效: 自定义Converter转换器\n```java\n@GetMapping  \npublic String test(@RequestParam LocalDateTime date) {  \n    System.out.println(\"接收到的时间: \" + date);  \n    return \"ok\";  \n}\n```\n\n```java\n/**  \n * 自定义转换: @RequestParam  \n * @author cloud_3111  \n * @since 2025-04-16  \n */public class customConvert implements Converter<String, LocalDateTime> {  \n    @Override  \n    @SneakyThrows    \n    public LocalDateTime convert(String source) {  \n        source = source.trim();  \n        String dateString = DateUtil.format(date, \"yyyy-MM-dd HH:mm:ss\");\n        return dateString;\n    }  \n}\n```\n\n```java\n@Configuration  \npublic class WebMvcConfig implements WebMvcConfigurer {  \n    @Override  \n    public void addFormatters(FormatterRegistry registry) {  \n        registry.addConverter(new customConvert());  \n    }  \n}\n```\n## 自定义消息转换器\n- 定义消息转换器的两种方式: \n  - 1.继承ObjectMapper,添加进行模块进行功能增强\n  - 2.完全自定义消息转换器替换Jackson的converter\n- **`针对@RequestBody`**\n\t- 全局生效: 自定义继承ObjectMapper的消息转换器\n\t-  单次生效: 采用注解\n- 在对象中对属性date使用: **`@JsonFormat(pattern = \"yyyy-MM-dd\", timezone = \"GMT+8\")`** \n\n```java\n/**  \n * 拓展新的消息转换器模块  \n * @author cloud_3111  \n * @since 2025-04-16  \n */public class newModelMapper extends ObjectMapper {  \n    public static final String DEFAULT_DATE_FORMAT = \"yyyy-MM-dd\";  \n    public static final String DEFAULT_DATE_TIME_FORMAT = \"yyyy-MM-dd HH:mm:ss\";  \n  \n    public newModelMapper() {  \n        super();  \n        //收到未知属性时不报异常 unkonwProperties        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);  \n        //反序列化时，属性不存在的兼容处理  \n        this.getDeserializationConfig().withoutFeatures(FAIL_ON_UNKNOWN_PROPERTIES);  \n        // 序列化和反序列化都要添加  \n        SimpleModule simpleModule = new SimpleModule()  \n                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))  \n                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))  \n                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))  \n                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));  \n        //把功能加入\n        this.registerModule(simpleModule);  \n    }  \n}\n```\n\n```java\n@Configuration  \npublic class WebMvcConfig implements WebMvcConfigurer {  \n    @Override  \n    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {  \n        //创建一个消息转换器对象  \n        MappingJackson2HttpMessageConverter converterObject = new MappingJackson2HttpMessageConverter();  \n        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据  \n        converterObject.setObjectMapper(new newModelMapper());  \n        //将自己的消息转化器加入容器中  \n        converters.add(0, converterObject);  \n    }  \n}\n```\n## 总结\n- ⚠️**注意**: 使用了上面的转换器使得只能接收前端的 `yyyy-MM-dd HH:mm:ss` ,当格式`yyyy-MM-ddTHH:mm:ss`变成这个时还是使用上面的转换器的话就会报错!!!\n\n - **WebMVC框架的转换器**: 针对@**`RequestParma`/`Pathvariable`**\n- **JacksonObjectMapper依赖包的消息转换器**: 针对@**`RequestBody/ResponseBody`**\n\n- @JsonForm和@DateTimeForm相当于转换器的小部件\n\t- **@JsonForm 对 @RequestBody有效, 所以要定义在实体类的属性上**\n\t- **@DateTimeForm 对 @RequestParma有效**\n\n- **时区的偏移**: Date日期在数据库中默认是 日期+时间 的, 所以在某些特定条件下 保存到数据库的`Date`**只有日期**部分 **时区如果不设定会使时间出现偏移**(默认使用系统时区, 但是开启代理会改变时区)\n","source":"_posts/DateConverter.md","raw":"---\ntitle: \" 日期格式和消息转换器\"\ntags:\n  - Converter\n  - DateTimeFormatter\n  - Date\n  - LocalDateTime\ncategories: 编程\ndate: 2024-11-23 09:52:54\n---\n\n# 日期格式和消息转换器\n\n> 你会遇见很多星星, 而我只会心动💓一个月亮\n\n---\n## Date 和 LocalDate 的区别\n### 1. 基本概念\n- Date：是 Java 1引入的日期时间类，底层存储的是一个UTC时间戳（即自 1970-01-01 00:00:00 UTC 到今日**精确到毫秒的时间戳**）。\n- LocalDate：是 Java 8 引入的新日期时间 API，表示一个纯日期（年月日），不包含时间信息和时区信息，具有不可变性和线程安全性。\n### 2. 系统时钟影响\n - 不管是Date还是LocalDate, 在new 对象时都是根据本地系统时钟(时区)来设置时间的\n### 3. 数据库存储差异\n- Date 通常与数据库中的 **timestamp** 或 **datetime** 类型直接映射，数据库和应用服务器时区不一致时，可能出现时间偏移问题。\n- LocalDate一般映射为数据库的 **date** 类型，**仅存储日期字符串**，不涉及时间和时区，因此不会出现时间偏移问题。\n- **存储时，MySQL 会将当前会话时区下的时间值转换成 UTC（协调世界时）进行内部存储。当查询 `TIMESTAMP` 字段时，MySQL 又会将存储的 UTC 时间转换回当前会话所设置的时区来显示。**\n### 4. 区别\n- 不可变性与线程安全:\n\t- Date 是可变对象，线程不安全。 占用4-7字节\n\t- LocalDate 是不可变对象的字符串，所以线程安全，推荐使用。  占用5-8字节\n- Java.util 下Date需要额外的Calendar来进行日期加减, 比较繁琐; 而Java.time 下LocalDate提供丰富的 API\n### 5. 时间戳转换区别\n- Date 和时间戳的转换是直接基于 getTime()（毫秒值）。\n- LocalDate 与时间戳没有直接关联，如果需要转时间戳，必须先转换为 LocalDateTime 并指定时区。\n### 6.数值型时间戳\n- 底层也是时间戳, 但是由于使用int或者bigint来存储时间戳, 不会出现时区问题, 占用空间更小(4字节), 缺点是不够直观\n## 什么是转换器\n\n- **SpringMVC**执行流程: **DispatherServlet** -> **HandlerMapping** -> **HandleAdapt** -> **Resolve**\n- 当请求被Tomcat容器捕获时,下一步将交由前置控制器去分发请求, 前置控制器核心方法将调用映射器,去匹配请求(uri匹配失败返回404, 请求方法匹配失败返回405), 成功之后进入适配器, 进行参数的反序列化, handle处理完成要离开适配器的时候也将由适配器去做序列化, 通常返回数据默认加上@ResponseBody(restful风格), 表明返回的是一个对象\n\n- 无论是请求**数据的反序列化**，还是**响应数据的序列化**，最终都需要将数据转换成**字节数组**（`byte[]`）以便进行网络传输,也就是 xxxToByteConverter, 任何转换器最终都需要经过这个进行二次转换\n\n- **`@RequestBody`**: 当你使用 `@RequestBody` 时，Spring 会利用 `HttpMessageConverter` 来处理请求体的转换。**如果你自定义了 `ObjectMapper`**（如 `JacksonObjectMapper`），它会生效并处理请求体的序列化和反序列化。因此，所有通过 `@RequestBody` 接收到的数据，都会通过你自定义的 `ObjectMapper` 来进行类型转换\n\n- @**`RequestParma`/`Pathvariable`**: 当你使用`RequestParma`/`Pathvariable` 时, 它们不会直接使用 `ObjectMapper` (`JacksonObjectMapper`)来转换, 而是使用 Spring 的类型转换器机制 (`ConversionService`),你可以通过实现 `Converter` 接口或 `@InitBinder`注解 来扩展转换逻辑\n\n## 参数绑定核心机制\n### `@RequestBody`\n- 作用对象：**请求体中的 JSON/XML 等格式的数据**\n- 使用工具：**`HttpMessageConverter`（消息转换器）**\n- 默认实现：**`MappingJackson2HttpMessageConverter`**\n- 影响方式：可通过自定义 `ObjectMapper模块`来定制序列化/反序列化逻辑（如时间格式、字段命名策略等）\n### `@RequestParam` & `@PathVariable`\n- 作用对象：**URL 查询参数、路径参数**\n- 使用工具：**`ConversionService`（类型转换服务）**\n- 自定义扩展方式：\n    - 实现Converter接口: `org.springframework.core.convert.converter.Converter<S, T>` \n    - 通过 `@InitBinder` 自定义 `WebDataBinder`\n### `HttpMessageConverter` 的组成\n- Spring Boot 默认引入的是 **Jackson** 相关的 HTTP 消息转换器（除非你引入了其他如 Gson、Fastjson 会自动替换）：\n- `MappingJackson2HttpMessageConverter`\n- 其中底层依赖的就是 Jackson 的 `ObjectMapper`，你自定义的 `JacksonObjectMapper` 正是通过这个机制生效。\n\n## 自定义转换器\n- **`针对@RequestParam`** \n\t- 单次生效: 采用注解\n\t\t- **`@RequestParam @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")`** \n\t- 全局生效: 自定义Converter转换器\n```java\n@GetMapping  \npublic String test(@RequestParam LocalDateTime date) {  \n    System.out.println(\"接收到的时间: \" + date);  \n    return \"ok\";  \n}\n```\n\n```java\n/**  \n * 自定义转换: @RequestParam  \n * @author cloud_3111  \n * @since 2025-04-16  \n */public class customConvert implements Converter<String, LocalDateTime> {  \n    @Override  \n    @SneakyThrows    \n    public LocalDateTime convert(String source) {  \n        source = source.trim();  \n        String dateString = DateUtil.format(date, \"yyyy-MM-dd HH:mm:ss\");\n        return dateString;\n    }  \n}\n```\n\n```java\n@Configuration  \npublic class WebMvcConfig implements WebMvcConfigurer {  \n    @Override  \n    public void addFormatters(FormatterRegistry registry) {  \n        registry.addConverter(new customConvert());  \n    }  \n}\n```\n## 自定义消息转换器\n- 定义消息转换器的两种方式: \n  - 1.继承ObjectMapper,添加进行模块进行功能增强\n  - 2.完全自定义消息转换器替换Jackson的converter\n- **`针对@RequestBody`**\n\t- 全局生效: 自定义继承ObjectMapper的消息转换器\n\t-  单次生效: 采用注解\n- 在对象中对属性date使用: **`@JsonFormat(pattern = \"yyyy-MM-dd\", timezone = \"GMT+8\")`** \n\n```java\n/**  \n * 拓展新的消息转换器模块  \n * @author cloud_3111  \n * @since 2025-04-16  \n */public class newModelMapper extends ObjectMapper {  \n    public static final String DEFAULT_DATE_FORMAT = \"yyyy-MM-dd\";  \n    public static final String DEFAULT_DATE_TIME_FORMAT = \"yyyy-MM-dd HH:mm:ss\";  \n  \n    public newModelMapper() {  \n        super();  \n        //收到未知属性时不报异常 unkonwProperties        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);  \n        //反序列化时，属性不存在的兼容处理  \n        this.getDeserializationConfig().withoutFeatures(FAIL_ON_UNKNOWN_PROPERTIES);  \n        // 序列化和反序列化都要添加  \n        SimpleModule simpleModule = new SimpleModule()  \n                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))  \n                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))  \n                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))  \n                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));  \n        //把功能加入\n        this.registerModule(simpleModule);  \n    }  \n}\n```\n\n```java\n@Configuration  \npublic class WebMvcConfig implements WebMvcConfigurer {  \n    @Override  \n    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {  \n        //创建一个消息转换器对象  \n        MappingJackson2HttpMessageConverter converterObject = new MappingJackson2HttpMessageConverter();  \n        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据  \n        converterObject.setObjectMapper(new newModelMapper());  \n        //将自己的消息转化器加入容器中  \n        converters.add(0, converterObject);  \n    }  \n}\n```\n## 总结\n- ⚠️**注意**: 使用了上面的转换器使得只能接收前端的 `yyyy-MM-dd HH:mm:ss` ,当格式`yyyy-MM-ddTHH:mm:ss`变成这个时还是使用上面的转换器的话就会报错!!!\n\n - **WebMVC框架的转换器**: 针对@**`RequestParma`/`Pathvariable`**\n- **JacksonObjectMapper依赖包的消息转换器**: 针对@**`RequestBody/ResponseBody`**\n\n- @JsonForm和@DateTimeForm相当于转换器的小部件\n\t- **@JsonForm 对 @RequestBody有效, 所以要定义在实体类的属性上**\n\t- **@DateTimeForm 对 @RequestParma有效**\n\n- **时区的偏移**: Date日期在数据库中默认是 日期+时间 的, 所以在某些特定条件下 保存到数据库的`Date`**只有日期**部分 **时区如果不设定会使时间出现偏移**(默认使用系统时区, 但是开启代理会改变时区)\n","slug":"DateConverter","published":1,"updated":"2025-10-09T12:32:06.148Z","_id":"cmfw4z08q0003uomwc54g2cvi","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"日期格式和消息转换器\"><a href=\"#日期格式和消息转换器\" class=\"headerlink\" title=\"日期格式和消息转换器\"></a>日期格式和消息转换器</h1><blockquote>\n<p>你会遇见很多星星, 而我只会心动💓一个月亮</p>\n</blockquote>\n<hr>\n<h2 id=\"Date-和-LocalDate-的区别\"><a href=\"#Date-和-LocalDate-的区别\" class=\"headerlink\" title=\"Date 和 LocalDate 的区别\"></a>Date 和 LocalDate 的区别</h2><h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><ul>\n<li>Date：是 Java 1引入的日期时间类，底层存储的是一个UTC时间戳（即自 1970-01-01 00:00:00 UTC 到今日<strong>精确到毫秒的时间戳</strong>）。</li>\n<li>LocalDate：是 Java 8 引入的新日期时间 API，表示一个纯日期（年月日），不包含时间信息和时区信息，具有不可变性和线程安全性。<h3 id=\"2-系统时钟影响\"><a href=\"#2-系统时钟影响\" class=\"headerlink\" title=\"2. 系统时钟影响\"></a>2. 系统时钟影响</h3><ul>\n<li>不管是Date还是LocalDate, 在new 对象时都是根据本地系统时钟(时区)来设置时间的<h3 id=\"3-数据库存储差异\"><a href=\"#3-数据库存储差异\" class=\"headerlink\" title=\"3. 数据库存储差异\"></a>3. 数据库存储差异</h3></li>\n</ul>\n</li>\n<li>Date 通常与数据库中的 <strong>timestamp</strong> 或 <strong>datetime</strong> 类型直接映射，数据库和应用服务器时区不一致时，可能出现时间偏移问题。</li>\n<li>LocalDate一般映射为数据库的 <strong>date</strong> 类型，<strong>仅存储日期字符串</strong>，不涉及时间和时区，因此不会出现时间偏移问题。</li>\n<li><strong>存储时，MySQL 会将当前会话时区下的时间值转换成 UTC（协调世界时）进行内部存储。当查询 <code>TIMESTAMP</code> 字段时，MySQL 又会将存储的 UTC 时间转换回当前会话所设置的时区来显示。</strong><h3 id=\"4-区别\"><a href=\"#4-区别\" class=\"headerlink\" title=\"4. 区别\"></a>4. 区别</h3></li>\n<li>不可变性与线程安全:<ul>\n<li>Date 是可变对象，线程不安全。 占用4-7字节</li>\n<li>LocalDate 是不可变对象的字符串，所以线程安全，推荐使用。  占用5-8字节</li>\n</ul>\n</li>\n<li>Java.util 下Date需要额外的Calendar来进行日期加减, 比较繁琐; 而Java.time 下LocalDate提供丰富的 API<h3 id=\"5-时间戳转换区别\"><a href=\"#5-时间戳转换区别\" class=\"headerlink\" title=\"5. 时间戳转换区别\"></a>5. 时间戳转换区别</h3></li>\n<li>Date 和时间戳的转换是直接基于 getTime()（毫秒值）。</li>\n<li>LocalDate 与时间戳没有直接关联，如果需要转时间戳，必须先转换为 LocalDateTime 并指定时区。<h3 id=\"6-数值型时间戳\"><a href=\"#6-数值型时间戳\" class=\"headerlink\" title=\"6.数值型时间戳\"></a>6.数值型时间戳</h3></li>\n<li><p>底层也是时间戳, 但是由于使用int或者bigint来存储时间戳, 不会出现时区问题, 占用空间更小(4字节), 缺点是不够直观</p>\n<h2 id=\"什么是转换器\"><a href=\"#什么是转换器\" class=\"headerlink\" title=\"什么是转换器\"></a>什么是转换器</h2></li>\n<li><p><strong>SpringMVC</strong>执行流程: <strong>DispatherServlet</strong> -&gt; <strong>HandlerMapping</strong> -&gt; <strong>HandleAdapt</strong> -&gt; <strong>Resolve</strong></p>\n</li>\n<li><p>当请求被Tomcat容器捕获时,下一步将交由前置控制器去分发请求, 前置控制器核心方法将调用映射器,去匹配请求(uri匹配失败返回404, 请求方法匹配失败返回405), 成功之后进入适配器, 进行参数的反序列化, handle处理完成要离开适配器的时候也将由适配器去做序列化, 通常返回数据默认加上@ResponseBody(restful风格), 表明返回的是一个对象</p>\n</li>\n<li><p>无论是请求<strong>数据的反序列化</strong>，还是<strong>响应数据的序列化</strong>，最终都需要将数据转换成<strong>字节数组</strong>（<code>byte[]</code>）以便进行网络传输,也就是 xxxToByteConverter, 任何转换器最终都需要经过这个进行二次转换</p>\n</li>\n<li><p><strong><code>@RequestBody</code></strong>: 当你使用 <code>@RequestBody</code> 时，Spring 会利用 <code>HttpMessageConverter</code> 来处理请求体的转换。<strong>如果你自定义了 <code>ObjectMapper</code></strong>（如 <code>JacksonObjectMapper</code>），它会生效并处理请求体的序列化和反序列化。因此，所有通过 <code>@RequestBody</code> 接收到的数据，都会通过你自定义的 <code>ObjectMapper</code> 来进行类型转换</p>\n</li>\n<li><p>@<strong><code>RequestParma</code>/<code>Pathvariable</code></strong>: 当你使用<code>RequestParma</code>/<code>Pathvariable</code> 时, 它们不会直接使用 <code>ObjectMapper</code> (<code>JacksonObjectMapper</code>)来转换, 而是使用 Spring 的类型转换器机制 (<code>ConversionService</code>),你可以通过实现 <code>Converter</code> 接口或 <code>@InitBinder</code>注解 来扩展转换逻辑</p>\n</li>\n</ul>\n<h2 id=\"参数绑定核心机制\"><a href=\"#参数绑定核心机制\" class=\"headerlink\" title=\"参数绑定核心机制\"></a>参数绑定核心机制</h2><h3 id=\"RequestBody\"><a href=\"#RequestBody\" class=\"headerlink\" title=\"@RequestBody\"></a><code>@RequestBody</code></h3><ul>\n<li>作用对象：<strong>请求体中的 JSON/XML 等格式的数据</strong></li>\n<li>使用工具：<strong><code>HttpMessageConverter</code>（消息转换器）</strong></li>\n<li>默认实现：<strong><code>MappingJackson2HttpMessageConverter</code></strong></li>\n<li>影响方式：可通过自定义 <code>ObjectMapper模块</code>来定制序列化/反序列化逻辑（如时间格式、字段命名策略等）<h3 id=\"RequestParam-amp-PathVariable\"><a href=\"#RequestParam-amp-PathVariable\" class=\"headerlink\" title=\"@RequestParam &amp; @PathVariable\"></a><code>@RequestParam</code> &amp; <code>@PathVariable</code></h3></li>\n<li>作用对象：<strong>URL 查询参数、路径参数</strong></li>\n<li>使用工具：<strong><code>ConversionService</code>（类型转换服务）</strong></li>\n<li>自定义扩展方式：<ul>\n<li>实现Converter接口: <code>org.springframework.core.convert.converter.Converter&lt;S, T&gt;</code> </li>\n<li>通过 <code>@InitBinder</code> 自定义 <code>WebDataBinder</code><h3 id=\"HttpMessageConverter-的组成\"><a href=\"#HttpMessageConverter-的组成\" class=\"headerlink\" title=\"HttpMessageConverter 的组成\"></a><code>HttpMessageConverter</code> 的组成</h3></li>\n</ul>\n</li>\n<li>Spring Boot 默认引入的是 <strong>Jackson</strong> 相关的 HTTP 消息转换器（除非你引入了其他如 Gson、Fastjson 会自动替换）：</li>\n<li><code>MappingJackson2HttpMessageConverter</code></li>\n<li>其中底层依赖的就是 Jackson 的 <code>ObjectMapper</code>，你自定义的 <code>JacksonObjectMapper</code> 正是通过这个机制生效。</li>\n</ul>\n<h2 id=\"自定义转换器\"><a href=\"#自定义转换器\" class=\"headerlink\" title=\"自定义转换器\"></a>自定义转换器</h2><ul>\n<li><strong><code>针对@RequestParam</code></strong> <ul>\n<li>单次生效: 采用注解<ul>\n<li><strong><code>@RequestParam @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</code></strong> </li>\n</ul>\n</li>\n<li>全局生效: 自定义Converter转换器<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">(<span class=\"meta\">@RequestParam</span> LocalDateTime date)</span> &#123;  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;接收到的时间: &quot;</span> + date);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;ok&quot;</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义转换: <span class=\"doctag\">@RequestParam</span>  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> cloud_3111  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2025-04-16  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">customConvert</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Converter</span>&lt;String, LocalDateTime&gt; &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"meta\">@SneakyThrows</span>    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> LocalDateTime <span class=\"title function_\">convert</span><span class=\"params\">(String source)</span> &#123;  </span><br><span class=\"line\">        source = source.trim();  </span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">dateString</span> <span class=\"operator\">=</span> DateUtil.format(date, <span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dateString;</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebMvcConfig</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">WebMvcConfigurer</span> &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addFormatters</span><span class=\"params\">(FormatterRegistry registry)</span> &#123;  </span><br><span class=\"line\">        registry.addConverter(<span class=\"keyword\">new</span> <span class=\"title class_\">customConvert</span>());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"自定义消息转换器\"><a href=\"#自定义消息转换器\" class=\"headerlink\" title=\"自定义消息转换器\"></a>自定义消息转换器</h2><ul>\n<li>定义消息转换器的两种方式: <ul>\n<li>1.继承ObjectMapper,添加进行模块进行功能增强</li>\n<li>2.完全自定义消息转换器替换Jackson的converter</li>\n</ul>\n</li>\n<li><strong><code>针对@RequestBody</code></strong><ul>\n<li>全局生效: 自定义继承ObjectMapper的消息转换器</li>\n<li>单次生效: 采用注解</li>\n</ul>\n</li>\n<li>在对象中对属性date使用: <strong><code>@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, timezone = &quot;GMT+8&quot;)</code></strong> </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 拓展新的消息转换器模块  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> cloud_3111  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2025-04-16  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">newModelMapper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ObjectMapper</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DEFAULT_DATE_FORMAT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;yyyy-MM-dd&quot;</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DEFAULT_DATE_TIME_FORMAT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">newModelMapper</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">super</span>();  </span><br><span class=\"line\">        <span class=\"comment\">//收到未知属性时不报异常 unkonwProperties        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);  </span></span><br><span class=\"line\">        <span class=\"comment\">//反序列化时，属性不存在的兼容处理  </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.getDeserializationConfig().withoutFeatures(FAIL_ON_UNKNOWN_PROPERTIES);  </span><br><span class=\"line\">        <span class=\"comment\">// 序列化和反序列化都要添加  </span></span><br><span class=\"line\">        <span class=\"type\">SimpleModule</span> <span class=\"variable\">simpleModule</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleModule</span>()  </span><br><span class=\"line\">                .addDeserializer(LocalDateTime.class, <span class=\"keyword\">new</span> <span class=\"title class_\">LocalDateTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))  </span><br><span class=\"line\">                .addDeserializer(LocalDate.class, <span class=\"keyword\">new</span> <span class=\"title class_\">LocalDateDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))  </span><br><span class=\"line\">                .addSerializer(LocalDateTime.class, <span class=\"keyword\">new</span> <span class=\"title class_\">LocalDateTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))  </span><br><span class=\"line\">                .addSerializer(LocalDate.class, <span class=\"keyword\">new</span> <span class=\"title class_\">LocalDateSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));  </span><br><span class=\"line\">        <span class=\"comment\">//把功能加入</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.registerModule(simpleModule);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebMvcConfig</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">WebMvcConfigurer</span> &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">extendMessageConverters</span><span class=\"params\">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//创建一个消息转换器对象  </span></span><br><span class=\"line\">        <span class=\"type\">MappingJackson2HttpMessageConverter</span> <span class=\"variable\">converterObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MappingJackson2HttpMessageConverter</span>();  </span><br><span class=\"line\">        <span class=\"comment\">//需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据  </span></span><br><span class=\"line\">        converterObject.setObjectMapper(<span class=\"keyword\">new</span> <span class=\"title class_\">newModelMapper</span>());  </span><br><span class=\"line\">        <span class=\"comment\">//将自己的消息转化器加入容器中  </span></span><br><span class=\"line\">        converters.add(<span class=\"number\">0</span>, converterObject);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p>⚠️<strong>注意</strong>: 使用了上面的转换器使得只能接收前端的 <code>yyyy-MM-dd HH:mm:ss</code> ,当格式<code>yyyy-MM-ddTHH:mm:ss</code>变成这个时还是使用上面的转换器的话就会报错!!!</p>\n<ul>\n<li><strong>WebMVC框架的转换器</strong>: 针对@<strong><code>RequestParma</code>/<code>Pathvariable</code></strong></li>\n</ul>\n</li>\n<li><p><strong>JacksonObjectMapper依赖包的消息转换器</strong>: 针对@<strong><code>RequestBody/ResponseBody</code></strong></p>\n</li>\n<li><p>@JsonForm和@DateTimeForm相当于转换器的小部件</p>\n<ul>\n<li><strong>@JsonForm 对 @RequestBody有效, 所以要定义在实体类的属性上</strong></li>\n<li><strong>@DateTimeForm 对 @RequestParma有效</strong></li>\n</ul>\n</li>\n<li><p><strong>时区的偏移</strong>: Date日期在数据库中默认是 日期+时间 的, 所以在某些特定条件下 保存到数据库的<code>Date</code><strong>只有日期</strong>部分 <strong>时区如果不设定会使时间出现偏移</strong>(默认使用系统时区, 但是开启代理会改变时区)</p>\n</li>\n</ul>\n","cover":"/img/5.png","cover_type":"img","excerpt":"","more":"<h1 id=\"日期格式和消息转换器\"><a href=\"#日期格式和消息转换器\" class=\"headerlink\" title=\"日期格式和消息转换器\"></a>日期格式和消息转换器</h1><blockquote>\n<p>你会遇见很多星星, 而我只会心动💓一个月亮</p>\n</blockquote>\n<hr>\n<h2 id=\"Date-和-LocalDate-的区别\"><a href=\"#Date-和-LocalDate-的区别\" class=\"headerlink\" title=\"Date 和 LocalDate 的区别\"></a>Date 和 LocalDate 的区别</h2><h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><ul>\n<li>Date：是 Java 1引入的日期时间类，底层存储的是一个UTC时间戳（即自 1970-01-01 00:00:00 UTC 到今日<strong>精确到毫秒的时间戳</strong>）。</li>\n<li>LocalDate：是 Java 8 引入的新日期时间 API，表示一个纯日期（年月日），不包含时间信息和时区信息，具有不可变性和线程安全性。<h3 id=\"2-系统时钟影响\"><a href=\"#2-系统时钟影响\" class=\"headerlink\" title=\"2. 系统时钟影响\"></a>2. 系统时钟影响</h3><ul>\n<li>不管是Date还是LocalDate, 在new 对象时都是根据本地系统时钟(时区)来设置时间的<h3 id=\"3-数据库存储差异\"><a href=\"#3-数据库存储差异\" class=\"headerlink\" title=\"3. 数据库存储差异\"></a>3. 数据库存储差异</h3></li>\n</ul>\n</li>\n<li>Date 通常与数据库中的 <strong>timestamp</strong> 或 <strong>datetime</strong> 类型直接映射，数据库和应用服务器时区不一致时，可能出现时间偏移问题。</li>\n<li>LocalDate一般映射为数据库的 <strong>date</strong> 类型，<strong>仅存储日期字符串</strong>，不涉及时间和时区，因此不会出现时间偏移问题。</li>\n<li><strong>存储时，MySQL 会将当前会话时区下的时间值转换成 UTC（协调世界时）进行内部存储。当查询 <code>TIMESTAMP</code> 字段时，MySQL 又会将存储的 UTC 时间转换回当前会话所设置的时区来显示。</strong><h3 id=\"4-区别\"><a href=\"#4-区别\" class=\"headerlink\" title=\"4. 区别\"></a>4. 区别</h3></li>\n<li>不可变性与线程安全:<ul>\n<li>Date 是可变对象，线程不安全。 占用4-7字节</li>\n<li>LocalDate 是不可变对象的字符串，所以线程安全，推荐使用。  占用5-8字节</li>\n</ul>\n</li>\n<li>Java.util 下Date需要额外的Calendar来进行日期加减, 比较繁琐; 而Java.time 下LocalDate提供丰富的 API<h3 id=\"5-时间戳转换区别\"><a href=\"#5-时间戳转换区别\" class=\"headerlink\" title=\"5. 时间戳转换区别\"></a>5. 时间戳转换区别</h3></li>\n<li>Date 和时间戳的转换是直接基于 getTime()（毫秒值）。</li>\n<li>LocalDate 与时间戳没有直接关联，如果需要转时间戳，必须先转换为 LocalDateTime 并指定时区。<h3 id=\"6-数值型时间戳\"><a href=\"#6-数值型时间戳\" class=\"headerlink\" title=\"6.数值型时间戳\"></a>6.数值型时间戳</h3></li>\n<li><p>底层也是时间戳, 但是由于使用int或者bigint来存储时间戳, 不会出现时区问题, 占用空间更小(4字节), 缺点是不够直观</p>\n<h2 id=\"什么是转换器\"><a href=\"#什么是转换器\" class=\"headerlink\" title=\"什么是转换器\"></a>什么是转换器</h2></li>\n<li><p><strong>SpringMVC</strong>执行流程: <strong>DispatherServlet</strong> -&gt; <strong>HandlerMapping</strong> -&gt; <strong>HandleAdapt</strong> -&gt; <strong>Resolve</strong></p>\n</li>\n<li><p>当请求被Tomcat容器捕获时,下一步将交由前置控制器去分发请求, 前置控制器核心方法将调用映射器,去匹配请求(uri匹配失败返回404, 请求方法匹配失败返回405), 成功之后进入适配器, 进行参数的反序列化, handle处理完成要离开适配器的时候也将由适配器去做序列化, 通常返回数据默认加上@ResponseBody(restful风格), 表明返回的是一个对象</p>\n</li>\n<li><p>无论是请求<strong>数据的反序列化</strong>，还是<strong>响应数据的序列化</strong>，最终都需要将数据转换成<strong>字节数组</strong>（<code>byte[]</code>）以便进行网络传输,也就是 xxxToByteConverter, 任何转换器最终都需要经过这个进行二次转换</p>\n</li>\n<li><p><strong><code>@RequestBody</code></strong>: 当你使用 <code>@RequestBody</code> 时，Spring 会利用 <code>HttpMessageConverter</code> 来处理请求体的转换。<strong>如果你自定义了 <code>ObjectMapper</code></strong>（如 <code>JacksonObjectMapper</code>），它会生效并处理请求体的序列化和反序列化。因此，所有通过 <code>@RequestBody</code> 接收到的数据，都会通过你自定义的 <code>ObjectMapper</code> 来进行类型转换</p>\n</li>\n<li><p>@<strong><code>RequestParma</code>/<code>Pathvariable</code></strong>: 当你使用<code>RequestParma</code>/<code>Pathvariable</code> 时, 它们不会直接使用 <code>ObjectMapper</code> (<code>JacksonObjectMapper</code>)来转换, 而是使用 Spring 的类型转换器机制 (<code>ConversionService</code>),你可以通过实现 <code>Converter</code> 接口或 <code>@InitBinder</code>注解 来扩展转换逻辑</p>\n</li>\n</ul>\n<h2 id=\"参数绑定核心机制\"><a href=\"#参数绑定核心机制\" class=\"headerlink\" title=\"参数绑定核心机制\"></a>参数绑定核心机制</h2><h3 id=\"RequestBody\"><a href=\"#RequestBody\" class=\"headerlink\" title=\"@RequestBody\"></a><code>@RequestBody</code></h3><ul>\n<li>作用对象：<strong>请求体中的 JSON/XML 等格式的数据</strong></li>\n<li>使用工具：<strong><code>HttpMessageConverter</code>（消息转换器）</strong></li>\n<li>默认实现：<strong><code>MappingJackson2HttpMessageConverter</code></strong></li>\n<li>影响方式：可通过自定义 <code>ObjectMapper模块</code>来定制序列化/反序列化逻辑（如时间格式、字段命名策略等）<h3 id=\"RequestParam-amp-PathVariable\"><a href=\"#RequestParam-amp-PathVariable\" class=\"headerlink\" title=\"@RequestParam &amp; @PathVariable\"></a><code>@RequestParam</code> &amp; <code>@PathVariable</code></h3></li>\n<li>作用对象：<strong>URL 查询参数、路径参数</strong></li>\n<li>使用工具：<strong><code>ConversionService</code>（类型转换服务）</strong></li>\n<li>自定义扩展方式：<ul>\n<li>实现Converter接口: <code>org.springframework.core.convert.converter.Converter&lt;S, T&gt;</code> </li>\n<li>通过 <code>@InitBinder</code> 自定义 <code>WebDataBinder</code><h3 id=\"HttpMessageConverter-的组成\"><a href=\"#HttpMessageConverter-的组成\" class=\"headerlink\" title=\"HttpMessageConverter 的组成\"></a><code>HttpMessageConverter</code> 的组成</h3></li>\n</ul>\n</li>\n<li>Spring Boot 默认引入的是 <strong>Jackson</strong> 相关的 HTTP 消息转换器（除非你引入了其他如 Gson、Fastjson 会自动替换）：</li>\n<li><code>MappingJackson2HttpMessageConverter</code></li>\n<li>其中底层依赖的就是 Jackson 的 <code>ObjectMapper</code>，你自定义的 <code>JacksonObjectMapper</code> 正是通过这个机制生效。</li>\n</ul>\n<h2 id=\"自定义转换器\"><a href=\"#自定义转换器\" class=\"headerlink\" title=\"自定义转换器\"></a>自定义转换器</h2><ul>\n<li><strong><code>针对@RequestParam</code></strong> <ul>\n<li>单次生效: 采用注解<ul>\n<li><strong><code>@RequestParam @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</code></strong> </li>\n</ul>\n</li>\n<li>全局生效: 自定义Converter转换器<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">(<span class=\"meta\">@RequestParam</span> LocalDateTime date)</span> &#123;  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;接收到的时间: &quot;</span> + date);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;ok&quot;</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义转换: <span class=\"doctag\">@RequestParam</span>  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> cloud_3111  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2025-04-16  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">customConvert</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Converter</span>&lt;String, LocalDateTime&gt; &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"meta\">@SneakyThrows</span>    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> LocalDateTime <span class=\"title function_\">convert</span><span class=\"params\">(String source)</span> &#123;  </span><br><span class=\"line\">        source = source.trim();  </span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">dateString</span> <span class=\"operator\">=</span> DateUtil.format(date, <span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dateString;</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebMvcConfig</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">WebMvcConfigurer</span> &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addFormatters</span><span class=\"params\">(FormatterRegistry registry)</span> &#123;  </span><br><span class=\"line\">        registry.addConverter(<span class=\"keyword\">new</span> <span class=\"title class_\">customConvert</span>());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"自定义消息转换器\"><a href=\"#自定义消息转换器\" class=\"headerlink\" title=\"自定义消息转换器\"></a>自定义消息转换器</h2><ul>\n<li>定义消息转换器的两种方式: <ul>\n<li>1.继承ObjectMapper,添加进行模块进行功能增强</li>\n<li>2.完全自定义消息转换器替换Jackson的converter</li>\n</ul>\n</li>\n<li><strong><code>针对@RequestBody</code></strong><ul>\n<li>全局生效: 自定义继承ObjectMapper的消息转换器</li>\n<li>单次生效: 采用注解</li>\n</ul>\n</li>\n<li>在对象中对属性date使用: <strong><code>@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, timezone = &quot;GMT+8&quot;)</code></strong> </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 拓展新的消息转换器模块  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> cloud_3111  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2025-04-16  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">newModelMapper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ObjectMapper</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DEFAULT_DATE_FORMAT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;yyyy-MM-dd&quot;</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">DEFAULT_DATE_TIME_FORMAT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">newModelMapper</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">super</span>();  </span><br><span class=\"line\">        <span class=\"comment\">//收到未知属性时不报异常 unkonwProperties        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);  </span></span><br><span class=\"line\">        <span class=\"comment\">//反序列化时，属性不存在的兼容处理  </span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.getDeserializationConfig().withoutFeatures(FAIL_ON_UNKNOWN_PROPERTIES);  </span><br><span class=\"line\">        <span class=\"comment\">// 序列化和反序列化都要添加  </span></span><br><span class=\"line\">        <span class=\"type\">SimpleModule</span> <span class=\"variable\">simpleModule</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleModule</span>()  </span><br><span class=\"line\">                .addDeserializer(LocalDateTime.class, <span class=\"keyword\">new</span> <span class=\"title class_\">LocalDateTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))  </span><br><span class=\"line\">                .addDeserializer(LocalDate.class, <span class=\"keyword\">new</span> <span class=\"title class_\">LocalDateDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))  </span><br><span class=\"line\">                .addSerializer(LocalDateTime.class, <span class=\"keyword\">new</span> <span class=\"title class_\">LocalDateTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))  </span><br><span class=\"line\">                .addSerializer(LocalDate.class, <span class=\"keyword\">new</span> <span class=\"title class_\">LocalDateSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));  </span><br><span class=\"line\">        <span class=\"comment\">//把功能加入</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.registerModule(simpleModule);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebMvcConfig</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">WebMvcConfigurer</span> &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">extendMessageConverters</span><span class=\"params\">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//创建一个消息转换器对象  </span></span><br><span class=\"line\">        <span class=\"type\">MappingJackson2HttpMessageConverter</span> <span class=\"variable\">converterObject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MappingJackson2HttpMessageConverter</span>();  </span><br><span class=\"line\">        <span class=\"comment\">//需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据  </span></span><br><span class=\"line\">        converterObject.setObjectMapper(<span class=\"keyword\">new</span> <span class=\"title class_\">newModelMapper</span>());  </span><br><span class=\"line\">        <span class=\"comment\">//将自己的消息转化器加入容器中  </span></span><br><span class=\"line\">        converters.add(<span class=\"number\">0</span>, converterObject);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p>⚠️<strong>注意</strong>: 使用了上面的转换器使得只能接收前端的 <code>yyyy-MM-dd HH:mm:ss</code> ,当格式<code>yyyy-MM-ddTHH:mm:ss</code>变成这个时还是使用上面的转换器的话就会报错!!!</p>\n<ul>\n<li><strong>WebMVC框架的转换器</strong>: 针对@<strong><code>RequestParma</code>/<code>Pathvariable</code></strong></li>\n</ul>\n</li>\n<li><p><strong>JacksonObjectMapper依赖包的消息转换器</strong>: 针对@<strong><code>RequestBody/ResponseBody</code></strong></p>\n</li>\n<li><p>@JsonForm和@DateTimeForm相当于转换器的小部件</p>\n<ul>\n<li><strong>@JsonForm 对 @RequestBody有效, 所以要定义在实体类的属性上</strong></li>\n<li><strong>@DateTimeForm 对 @RequestParma有效</strong></li>\n</ul>\n</li>\n<li><p><strong>时区的偏移</strong>: Date日期在数据库中默认是 日期+时间 的, 所以在某些特定条件下 保存到数据库的<code>Date</code><strong>只有日期</strong>部分 <strong>时区如果不设定会使时间出现偏移</strong>(默认使用系统时区, 但是开启代理会改变时区)</p>\n</li>\n</ul>\n"},{"banner":"[[pixel-banner-image.png]]","title":"ElasticSearch分布式搜索引擎","date":"2025-02-24T10:46:00.000Z","_content":"\n# ElasticSearch分布式搜索引擎\n[参考文献](https://www.cnblogs.com/buchizicai/p/17093719.html)\n## 概念理解\n- 当你在搜索栏输入'显卡'的时候, 发送请求到后端, 请求携带'显卡'这个字符串到es的分词器进行分词, 发现不可拆分, 以'显卡'为词条然后查询es索引库得到在MySQL中ids(ES 根据倒排索引查出匹配的文档), 根据ids到MySQL中去查找数据getByIds, 这就是es充当的角色 -> 中间件\n- ElasticSearch是一个分布式搜索引擎中间件, 用来过滤查找符合条件的数据, 也可以结合Logstash做日志统计、分析、系统监控等功能\n![17584443366841758444336429.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17584443366841758444336429.png)\n- Kibana可以给我们提供一个elasticsearch的可视化界面: 9200 -> 5601\n## 倒排索引\n- 核心原理：通过单词一文档ID的映射实现高速搜索（如搜索“手机”返回所有含该词的文档）\n- 倒排索引的概念是基于MySQL这样的正向索引而言的, **倒排只能给词条创建索引**，而不是字段\n- **文档**（`Document`）：其中的每一条数据就是一个文档, 具有文档唯一id(自动生成)\n- **词条**（`Term`）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条\n![17403951668551740395166641.png|706x449](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17403951668551740395166641.png)\n![17403952738551740395273706.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17403952738551740395273706.png)\n## 分词器\n- 分词器的选用是es搜索的精髓\n- 创建倒排索引时对文档分词,根据自定义分词规则进行字符串分词\n- 默认分词器为 Standard分词器, 但是对中文分词不友好\n- 常用的分词器: IK分词器 有两种模式: 例如我爱你\n\t- `ik_smart`：最少切分 -> 我爱你\n\t- `ik_max_word`：最多切分 -> 我爱你 爱你\n- ”analyzer“模式: 选择分词器的开关\n- 停用词: 所以很多语言是不允许在网络上传递的, 在索引时就直接忽略当前的停用词汇表中的内容\n## 客户端\n- JavaRestClient操作ElasticSearch的流程基本类似\n- 索引库操作的基本步骤\n\t- 初始化RestHighLevelClient客户端 client\n\t- 创建XxxRequest\n\t- 准备DSL语句\n\t- 发送请求\n```Java\n/*索引表CRUD*/  \n@Test  \npublic void createIndex() throws IOException {  \n    // 第一步: 创建request对象 index为表名  \n    CreateIndexRequest request = new CreateIndexRequest(\"hotel\");  \n  \n    // 第二步: 封装请求参数: 创建表 PUT/hotel  -->  DSL语句  \n    request.source(esConstants.CREATE_DSL, XContentType.JSON);  \n  \n    // 第三步: 发起请求  \n    client.indices().create(request, RequestOptions.DEFAULT);  \n}\n```\n```Java\n/*文档CRUD*/  \n@Test  \npublic void matchAllDocument() throws IOException {  \n    // 第一步: 创建request对象  \n    SearchRequest request = new SearchRequest(\"user\");  \n  \n    // 第二步: DSL语句  \n    request.source().query(QueryBuilders.matchAllQuery());  \n  \n    // 第三步: 发起请求  \n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);  \n  \n    // 第四步: 拿到数据  \n    SearchHits searchHits = response.getHits();  \n    TotalHits totalHits = searchHits.getTotalHits();  \n    for (SearchHit hit : searchHits.getHits()) {  \n        System.out.println(hit.getSourceAsString());  \n    }  \n}\n```\n## 可视化界面条件检索\n- match_all: 查询所有\n- multi_match：多字段查询，任意一个字段符合条件就算符合查询条\n- term：根据词条精确值查询\n- range：根据值的范围查询\n- geo_distance: 根据地理位置查询(经纬度)\n\t- `took` – Elasticsearch运行查询所花费的时间（以毫秒为单位）\n\t- `timed_out` –搜索请求是否超时\n\t- `_shards` - 搜索了多少个碎片，以及成功，失败或跳过了多少个碎片的细目分类。\n\t- `max_score` – 找到的最相关文档的分数\n\t- `hits.total.value` - 找到了多少个匹配的文档\n\t- `hits.sort` - 文档的排序位置（不按相关性得分排序时）\n\t- `hits._score` - 文档的相关性得分（使用match_all时不适用）\n```bash\nGET /表名/_search(类型: 文档/搜索)\n{\n\t# 搜索规则\n    \"query\": {\n      \"查询条件\": \"条件值\"\n    },\n    # 排序规则\n    \"sort\": [\n    { \"account_number\": \"asc\" }\n   ],\n   # 分页查询\n    \"from\": 10,\n    \"to\": 10 \n}\n\nPUT /索引表名/_doc(类型: 文档/搜索)/文档id\n{\n# 存放内容\n  \"id\": \"1\",\n  \"name\" : \"唐伯虎点秋香\",\n  \"realName\": \"唐伯虎\"\n}\n```\n## 问题\n- 创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：\n\t- 字段名是什么? 字段数据类型是什么?  字段名、字段数据类型，可以参考数据表结构的名称和类型\n\t- 是否参与搜索?  是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索\n\t- 是否需要分词?  是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词 -> 现有的分词库\n\t- 如果分词，分词器是什么？ 分词器，我们可以统一使用ik_max_word类型\n- ES与Mysql数据同步?  同步更新 vs 异步更新(mq+定时任务)\n ![17584364152201758436414246.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17584364152201758436414246.png)\n- TF-IDF相关性算法?  score = TF * IDF\n\t- TF = 词条出现的次数/词条总数  \n\t- IDF = log(文档总数/出现词条的文档数)\n- es和mysql的like的不同\n\t- 比如搜索 显卡9060和9060显卡 es两种都能搜索到, 而like匹配只能匹配一种 \n\t- es还能进行范围geo搜索, 拼音搜索和相关性搜索\n## 总结\n- 索引的CRUD\n\t- **创建索引** (`PUT/user`): 用于创建索引。\n\t- **查看索引** (`GET/user`): 获取索引的配置和信息。\n\t- **删除索引** (`DELETE/user`): 删除指定的索引。\n- 文档的CRUD\n\t- **创建文档** (`PUT/user/_doc/1001`): 向索引中插入一个新的文档。\n\t- **查看文档** (`GET/user/_doc/1001`): 根据文档 ID 查看文档的内容。\n\t- **更新文档** (`POST/user/_update/1001`): 更新文档的某些字段，不会替换整个文档。\n\t- **删除文档** (`DELETE/user/_doc/1001`): 删除指定 ID 的文档。\n\t- **查询文档** (`GET/user/_search`): 根据查询条件检索符合条件的文档。\n- 什么是ELK\n\t- ELK = Elasticsearch + Logstash + Kibana\n\t- Logstash负责日志收集, 解析以及转发到es, es负责存储数据, Kibanna负责可视化工具，提供图表、仪表盘、搜索分析界面","source":"_posts/ElasticSearch.md","raw":"---\nbanner: \"[[pixel-banner-image.png]]\"\ntitle: ElasticSearch分布式搜索引擎\ntags:\n  - ElasticSearch\ncategories: 编程\ndate: 2025-02-24T18:46:00\n---\n\n# ElasticSearch分布式搜索引擎\n[参考文献](https://www.cnblogs.com/buchizicai/p/17093719.html)\n## 概念理解\n- 当你在搜索栏输入'显卡'的时候, 发送请求到后端, 请求携带'显卡'这个字符串到es的分词器进行分词, 发现不可拆分, 以'显卡'为词条然后查询es索引库得到在MySQL中ids(ES 根据倒排索引查出匹配的文档), 根据ids到MySQL中去查找数据getByIds, 这就是es充当的角色 -> 中间件\n- ElasticSearch是一个分布式搜索引擎中间件, 用来过滤查找符合条件的数据, 也可以结合Logstash做日志统计、分析、系统监控等功能\n![17584443366841758444336429.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17584443366841758444336429.png)\n- Kibana可以给我们提供一个elasticsearch的可视化界面: 9200 -> 5601\n## 倒排索引\n- 核心原理：通过单词一文档ID的映射实现高速搜索（如搜索“手机”返回所有含该词的文档）\n- 倒排索引的概念是基于MySQL这样的正向索引而言的, **倒排只能给词条创建索引**，而不是字段\n- **文档**（`Document`）：其中的每一条数据就是一个文档, 具有文档唯一id(自动生成)\n- **词条**（`Term`）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条\n![17403951668551740395166641.png|706x449](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17403951668551740395166641.png)\n![17403952738551740395273706.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17403952738551740395273706.png)\n## 分词器\n- 分词器的选用是es搜索的精髓\n- 创建倒排索引时对文档分词,根据自定义分词规则进行字符串分词\n- 默认分词器为 Standard分词器, 但是对中文分词不友好\n- 常用的分词器: IK分词器 有两种模式: 例如我爱你\n\t- `ik_smart`：最少切分 -> 我爱你\n\t- `ik_max_word`：最多切分 -> 我爱你 爱你\n- ”analyzer“模式: 选择分词器的开关\n- 停用词: 所以很多语言是不允许在网络上传递的, 在索引时就直接忽略当前的停用词汇表中的内容\n## 客户端\n- JavaRestClient操作ElasticSearch的流程基本类似\n- 索引库操作的基本步骤\n\t- 初始化RestHighLevelClient客户端 client\n\t- 创建XxxRequest\n\t- 准备DSL语句\n\t- 发送请求\n```Java\n/*索引表CRUD*/  \n@Test  \npublic void createIndex() throws IOException {  \n    // 第一步: 创建request对象 index为表名  \n    CreateIndexRequest request = new CreateIndexRequest(\"hotel\");  \n  \n    // 第二步: 封装请求参数: 创建表 PUT/hotel  -->  DSL语句  \n    request.source(esConstants.CREATE_DSL, XContentType.JSON);  \n  \n    // 第三步: 发起请求  \n    client.indices().create(request, RequestOptions.DEFAULT);  \n}\n```\n```Java\n/*文档CRUD*/  \n@Test  \npublic void matchAllDocument() throws IOException {  \n    // 第一步: 创建request对象  \n    SearchRequest request = new SearchRequest(\"user\");  \n  \n    // 第二步: DSL语句  \n    request.source().query(QueryBuilders.matchAllQuery());  \n  \n    // 第三步: 发起请求  \n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);  \n  \n    // 第四步: 拿到数据  \n    SearchHits searchHits = response.getHits();  \n    TotalHits totalHits = searchHits.getTotalHits();  \n    for (SearchHit hit : searchHits.getHits()) {  \n        System.out.println(hit.getSourceAsString());  \n    }  \n}\n```\n## 可视化界面条件检索\n- match_all: 查询所有\n- multi_match：多字段查询，任意一个字段符合条件就算符合查询条\n- term：根据词条精确值查询\n- range：根据值的范围查询\n- geo_distance: 根据地理位置查询(经纬度)\n\t- `took` – Elasticsearch运行查询所花费的时间（以毫秒为单位）\n\t- `timed_out` –搜索请求是否超时\n\t- `_shards` - 搜索了多少个碎片，以及成功，失败或跳过了多少个碎片的细目分类。\n\t- `max_score` – 找到的最相关文档的分数\n\t- `hits.total.value` - 找到了多少个匹配的文档\n\t- `hits.sort` - 文档的排序位置（不按相关性得分排序时）\n\t- `hits._score` - 文档的相关性得分（使用match_all时不适用）\n```bash\nGET /表名/_search(类型: 文档/搜索)\n{\n\t# 搜索规则\n    \"query\": {\n      \"查询条件\": \"条件值\"\n    },\n    # 排序规则\n    \"sort\": [\n    { \"account_number\": \"asc\" }\n   ],\n   # 分页查询\n    \"from\": 10,\n    \"to\": 10 \n}\n\nPUT /索引表名/_doc(类型: 文档/搜索)/文档id\n{\n# 存放内容\n  \"id\": \"1\",\n  \"name\" : \"唐伯虎点秋香\",\n  \"realName\": \"唐伯虎\"\n}\n```\n## 问题\n- 创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：\n\t- 字段名是什么? 字段数据类型是什么?  字段名、字段数据类型，可以参考数据表结构的名称和类型\n\t- 是否参与搜索?  是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索\n\t- 是否需要分词?  是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词 -> 现有的分词库\n\t- 如果分词，分词器是什么？ 分词器，我们可以统一使用ik_max_word类型\n- ES与Mysql数据同步?  同步更新 vs 异步更新(mq+定时任务)\n ![17584364152201758436414246.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17584364152201758436414246.png)\n- TF-IDF相关性算法?  score = TF * IDF\n\t- TF = 词条出现的次数/词条总数  \n\t- IDF = log(文档总数/出现词条的文档数)\n- es和mysql的like的不同\n\t- 比如搜索 显卡9060和9060显卡 es两种都能搜索到, 而like匹配只能匹配一种 \n\t- es还能进行范围geo搜索, 拼音搜索和相关性搜索\n## 总结\n- 索引的CRUD\n\t- **创建索引** (`PUT/user`): 用于创建索引。\n\t- **查看索引** (`GET/user`): 获取索引的配置和信息。\n\t- **删除索引** (`DELETE/user`): 删除指定的索引。\n- 文档的CRUD\n\t- **创建文档** (`PUT/user/_doc/1001`): 向索引中插入一个新的文档。\n\t- **查看文档** (`GET/user/_doc/1001`): 根据文档 ID 查看文档的内容。\n\t- **更新文档** (`POST/user/_update/1001`): 更新文档的某些字段，不会替换整个文档。\n\t- **删除文档** (`DELETE/user/_doc/1001`): 删除指定 ID 的文档。\n\t- **查询文档** (`GET/user/_search`): 根据查询条件检索符合条件的文档。\n- 什么是ELK\n\t- ELK = Elasticsearch + Logstash + Kibana\n\t- Logstash负责日志收集, 解析以及转发到es, es负责存储数据, Kibanna负责可视化工具，提供图表、仪表盘、搜索分析界面","slug":"ElasticSearch","published":1,"updated":"2025-09-22T09:40:46.500Z","comments":1,"layout":"post","photos":[],"_id":"cmfw4z08z0007uomwgl45d1kr","content":"<h1 id=\"ElasticSearch分布式搜索引擎\"><a href=\"#ElasticSearch分布式搜索引擎\" class=\"headerlink\" title=\"ElasticSearch分布式搜索引擎\"></a>ElasticSearch分布式搜索引擎</h1><p><a href=\"https://www.cnblogs.com/buchizicai/p/17093719.html\">参考文献</a></p>\n<h2 id=\"概念理解\"><a href=\"#概念理解\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h2><ul>\n<li>当你在搜索栏输入’显卡’的时候, 发送请求到后端, 请求携带’显卡’这个字符串到es的分词器进行分词, 发现不可拆分, 以’显卡’为词条然后查询es索引库得到在MySQL中ids(ES 根据倒排索引查出匹配的文档), 根据ids到MySQL中去查找数据getByIds, 这就是es充当的角色 -&gt; 中间件</li>\n<li>ElasticSearch是一个分布式搜索引擎中间件, 用来过滤查找符合条件的数据, 也可以结合Logstash做日志统计、分析、系统监控等功能<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17584443366841758444336429.png\" alt=\"17584443366841758444336429.png\"></li>\n<li>Kibana可以给我们提供一个elasticsearch的可视化界面: 9200 -&gt; 5601<h2 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h2></li>\n<li>核心原理：通过单词一文档ID的映射实现高速搜索（如搜索“手机”返回所有含该词的文档）</li>\n<li>倒排索引的概念是基于MySQL这样的正向索引而言的, <strong>倒排只能给词条创建索引</strong>，而不是字段</li>\n<li><strong>文档</strong>（<code>Document</code>）：其中的每一条数据就是一个文档, 具有文档唯一id(自动生成)</li>\n<li><strong>词条</strong>（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17403951668551740395166641.png\" alt=\"17403951668551740395166641.png|706x449\"><br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17403952738551740395273706.png\" alt=\"17403952738551740395273706.png\"><h2 id=\"分词器\"><a href=\"#分词器\" class=\"headerlink\" title=\"分词器\"></a>分词器</h2></li>\n<li>分词器的选用是es搜索的精髓</li>\n<li>创建倒排索引时对文档分词,根据自定义分词规则进行字符串分词</li>\n<li>默认分词器为 Standard分词器, 但是对中文分词不友好</li>\n<li>常用的分词器: IK分词器 有两种模式: 例如我爱你<ul>\n<li><code>ik_smart</code>：最少切分 -&gt; 我爱你</li>\n<li><code>ik_max_word</code>：最多切分 -&gt; 我爱你 爱你</li>\n</ul>\n</li>\n<li>”analyzer“模式: 选择分词器的开关</li>\n<li>停用词: 所以很多语言是不允许在网络上传递的, 在索引时就直接忽略当前的停用词汇表中的内容<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2></li>\n<li>JavaRestClient操作ElasticSearch的流程基本类似</li>\n<li>索引库操作的基本步骤<ul>\n<li>初始化RestHighLevelClient客户端 client</li>\n<li>创建XxxRequest</li>\n<li>准备DSL语句</li>\n<li>发送请求<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*索引表CRUD*/</span>  </span><br><span class=\"line\"><span class=\"meta\">@Test</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createIndex</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 第一步: 创建request对象 index为表名  </span></span><br><span class=\"line\">    <span class=\"type\">CreateIndexRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CreateIndexRequest</span>(<span class=\"string\">&quot;hotel&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 第二步: 封装请求参数: 创建表 PUT/hotel  --&gt;  DSL语句  </span></span><br><span class=\"line\">    request.source(esConstants.CREATE_DSL, XContentType.JSON);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 第三步: 发起请求  </span></span><br><span class=\"line\">    client.indices().create(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*文档CRUD*/</span>  </span><br><span class=\"line\"><span class=\"meta\">@Test</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">matchAllDocument</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 第一步: 创建request对象  </span></span><br><span class=\"line\">    <span class=\"type\">SearchRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SearchRequest</span>(<span class=\"string\">&quot;user&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 第二步: DSL语句  </span></span><br><span class=\"line\">    request.source().query(QueryBuilders.matchAllQuery());  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 第三步: 发起请求  </span></span><br><span class=\"line\">    <span class=\"type\">SearchResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> client.search(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 第四步: 拿到数据  </span></span><br><span class=\"line\">    <span class=\"type\">SearchHits</span> <span class=\"variable\">searchHits</span> <span class=\"operator\">=</span> response.getHits();  </span><br><span class=\"line\">    <span class=\"type\">TotalHits</span> <span class=\"variable\">totalHits</span> <span class=\"operator\">=</span> searchHits.getTotalHits();  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchHit hit : searchHits.getHits()) &#123;  </span><br><span class=\"line\">        System.out.println(hit.getSourceAsString());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"可视化界面条件检索\"><a href=\"#可视化界面条件检索\" class=\"headerlink\" title=\"可视化界面条件检索\"></a>可视化界面条件检索</h2></li>\n</ul>\n</li>\n<li>match_all: 查询所有</li>\n<li>multi_match：多字段查询，任意一个字段符合条件就算符合查询条</li>\n<li>term：根据词条精确值查询</li>\n<li>range：根据值的范围查询</li>\n<li>geo_distance: 根据地理位置查询(经纬度)<ul>\n<li><code>took</code> – Elasticsearch运行查询所花费的时间（以毫秒为单位）</li>\n<li><code>timed_out</code> –搜索请求是否超时</li>\n<li><code>_shards</code> - 搜索了多少个碎片，以及成功，失败或跳过了多少个碎片的细目分类。</li>\n<li><code>max_score</code> – 找到的最相关文档的分数</li>\n<li><code>hits.total.value</code> - 找到了多少个匹配的文档</li>\n<li><code>hits.sort</code> - 文档的排序位置（不按相关性得分排序时）</li>\n<li><code>hits._score</code> - 文档的相关性得分（使用match_all时不适用）<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /表名/_search(类型: 文档/搜索)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\"># 搜索规则</span></span><br><span class=\"line\">    <span class=\"string\">&quot;query&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;查询条件&quot;</span>: <span class=\"string\">&quot;条件值&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\"># 排序规则</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sort&quot;</span>: [</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;account_number&quot;</span>: <span class=\"string\">&quot;asc&quot;</span> &#125;</span><br><span class=\"line\">   ],</span><br><span class=\"line\">   <span class=\"comment\"># 分页查询</span></span><br><span class=\"line\">    <span class=\"string\">&quot;from&quot;</span>: 10,</span><br><span class=\"line\">    <span class=\"string\">&quot;to&quot;</span>: 10 </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PUT /索引表名/_doc(类型: 文档/搜索)/文档<span class=\"built_in\">id</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\"># 存放内容</span></span><br><span class=\"line\">  <span class=\"string\">&quot;id&quot;</span>: <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;唐伯虎点秋香&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;realName&quot;</span>: <span class=\"string\">&quot;唐伯虎&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2></li>\n</ul>\n</li>\n<li>创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：<ul>\n<li>字段名是什么? 字段数据类型是什么?  字段名、字段数据类型，可以参考数据表结构的名称和类型</li>\n<li>是否参与搜索?  是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li>\n<li>是否需要分词?  是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词 -&gt; 现有的分词库</li>\n<li>如果分词，分词器是什么？ 分词器，我们可以统一使用ik_max_word类型</li>\n</ul>\n</li>\n<li>ES与Mysql数据同步?  同步更新 vs 异步更新(mq+定时任务)<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17584364152201758436414246.png\" alt=\"17584364152201758436414246.png\"></li>\n<li>TF-IDF相关性算法?  score = TF * IDF<ul>\n<li>TF = 词条出现的次数/词条总数  </li>\n<li>IDF = log(文档总数/出现词条的文档数)</li>\n</ul>\n</li>\n<li>es和mysql的like的不同<ul>\n<li>比如搜索 显卡9060和9060显卡 es两种都能搜索到, 而like匹配只能匹配一种 </li>\n<li>es还能进行范围geo搜索, 拼音搜索和相关性搜索<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2></li>\n</ul>\n</li>\n<li>索引的CRUD<ul>\n<li><strong>创建索引</strong> (<code>PUT/user</code>): 用于创建索引。</li>\n<li><strong>查看索引</strong> (<code>GET/user</code>): 获取索引的配置和信息。</li>\n<li><strong>删除索引</strong> (<code>DELETE/user</code>): 删除指定的索引。</li>\n</ul>\n</li>\n<li>文档的CRUD<ul>\n<li><strong>创建文档</strong> (<code>PUT/user/_doc/1001</code>): 向索引中插入一个新的文档。</li>\n<li><strong>查看文档</strong> (<code>GET/user/_doc/1001</code>): 根据文档 ID 查看文档的内容。</li>\n<li><strong>更新文档</strong> (<code>POST/user/_update/1001</code>): 更新文档的某些字段，不会替换整个文档。</li>\n<li><strong>删除文档</strong> (<code>DELETE/user/_doc/1001</code>): 删除指定 ID 的文档。</li>\n<li><strong>查询文档</strong> (<code>GET/user/_search</code>): 根据查询条件检索符合条件的文档。</li>\n</ul>\n</li>\n<li>什么是ELK<ul>\n<li>ELK = Elasticsearch + Logstash + Kibana</li>\n<li>Logstash负责日志收集, 解析以及转发到es, es负责存储数据, Kibanna负责可视化工具，提供图表、仪表盘、搜索分析界面</li>\n</ul>\n</li>\n</ul>\n","cover":"/img/view9.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"ElasticSearch分布式搜索引擎\"><a href=\"#ElasticSearch分布式搜索引擎\" class=\"headerlink\" title=\"ElasticSearch分布式搜索引擎\"></a>ElasticSearch分布式搜索引擎</h1><p><a href=\"https://www.cnblogs.com/buchizicai/p/17093719.html\">参考文献</a></p>\n<h2 id=\"概念理解\"><a href=\"#概念理解\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h2><ul>\n<li>当你在搜索栏输入’显卡’的时候, 发送请求到后端, 请求携带’显卡’这个字符串到es的分词器进行分词, 发现不可拆分, 以’显卡’为词条然后查询es索引库得到在MySQL中ids(ES 根据倒排索引查出匹配的文档), 根据ids到MySQL中去查找数据getByIds, 这就是es充当的角色 -&gt; 中间件</li>\n<li>ElasticSearch是一个分布式搜索引擎中间件, 用来过滤查找符合条件的数据, 也可以结合Logstash做日志统计、分析、系统监控等功能<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17584443366841758444336429.png\" alt=\"17584443366841758444336429.png\"></li>\n<li>Kibana可以给我们提供一个elasticsearch的可视化界面: 9200 -&gt; 5601<h2 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h2></li>\n<li>核心原理：通过单词一文档ID的映射实现高速搜索（如搜索“手机”返回所有含该词的文档）</li>\n<li>倒排索引的概念是基于MySQL这样的正向索引而言的, <strong>倒排只能给词条创建索引</strong>，而不是字段</li>\n<li><strong>文档</strong>（<code>Document</code>）：其中的每一条数据就是一个文档, 具有文档唯一id(自动生成)</li>\n<li><strong>词条</strong>（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17403951668551740395166641.png\" alt=\"17403951668551740395166641.png|706x449\"><br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17403952738551740395273706.png\" alt=\"17403952738551740395273706.png\"><h2 id=\"分词器\"><a href=\"#分词器\" class=\"headerlink\" title=\"分词器\"></a>分词器</h2></li>\n<li>分词器的选用是es搜索的精髓</li>\n<li>创建倒排索引时对文档分词,根据自定义分词规则进行字符串分词</li>\n<li>默认分词器为 Standard分词器, 但是对中文分词不友好</li>\n<li>常用的分词器: IK分词器 有两种模式: 例如我爱你<ul>\n<li><code>ik_smart</code>：最少切分 -&gt; 我爱你</li>\n<li><code>ik_max_word</code>：最多切分 -&gt; 我爱你 爱你</li>\n</ul>\n</li>\n<li>”analyzer“模式: 选择分词器的开关</li>\n<li>停用词: 所以很多语言是不允许在网络上传递的, 在索引时就直接忽略当前的停用词汇表中的内容<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2></li>\n<li>JavaRestClient操作ElasticSearch的流程基本类似</li>\n<li>索引库操作的基本步骤<ul>\n<li>初始化RestHighLevelClient客户端 client</li>\n<li>创建XxxRequest</li>\n<li>准备DSL语句</li>\n<li>发送请求<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*索引表CRUD*/</span>  </span><br><span class=\"line\"><span class=\"meta\">@Test</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createIndex</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 第一步: 创建request对象 index为表名  </span></span><br><span class=\"line\">    <span class=\"type\">CreateIndexRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CreateIndexRequest</span>(<span class=\"string\">&quot;hotel&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 第二步: 封装请求参数: 创建表 PUT/hotel  --&gt;  DSL语句  </span></span><br><span class=\"line\">    request.source(esConstants.CREATE_DSL, XContentType.JSON);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 第三步: 发起请求  </span></span><br><span class=\"line\">    client.indices().create(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*文档CRUD*/</span>  </span><br><span class=\"line\"><span class=\"meta\">@Test</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">matchAllDocument</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 第一步: 创建request对象  </span></span><br><span class=\"line\">    <span class=\"type\">SearchRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SearchRequest</span>(<span class=\"string\">&quot;user&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 第二步: DSL语句  </span></span><br><span class=\"line\">    request.source().query(QueryBuilders.matchAllQuery());  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 第三步: 发起请求  </span></span><br><span class=\"line\">    <span class=\"type\">SearchResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> client.search(request, RequestOptions.DEFAULT);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 第四步: 拿到数据  </span></span><br><span class=\"line\">    <span class=\"type\">SearchHits</span> <span class=\"variable\">searchHits</span> <span class=\"operator\">=</span> response.getHits();  </span><br><span class=\"line\">    <span class=\"type\">TotalHits</span> <span class=\"variable\">totalHits</span> <span class=\"operator\">=</span> searchHits.getTotalHits();  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchHit hit : searchHits.getHits()) &#123;  </span><br><span class=\"line\">        System.out.println(hit.getSourceAsString());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"可视化界面条件检索\"><a href=\"#可视化界面条件检索\" class=\"headerlink\" title=\"可视化界面条件检索\"></a>可视化界面条件检索</h2></li>\n</ul>\n</li>\n<li>match_all: 查询所有</li>\n<li>multi_match：多字段查询，任意一个字段符合条件就算符合查询条</li>\n<li>term：根据词条精确值查询</li>\n<li>range：根据值的范围查询</li>\n<li>geo_distance: 根据地理位置查询(经纬度)<ul>\n<li><code>took</code> – Elasticsearch运行查询所花费的时间（以毫秒为单位）</li>\n<li><code>timed_out</code> –搜索请求是否超时</li>\n<li><code>_shards</code> - 搜索了多少个碎片，以及成功，失败或跳过了多少个碎片的细目分类。</li>\n<li><code>max_score</code> – 找到的最相关文档的分数</li>\n<li><code>hits.total.value</code> - 找到了多少个匹配的文档</li>\n<li><code>hits.sort</code> - 文档的排序位置（不按相关性得分排序时）</li>\n<li><code>hits._score</code> - 文档的相关性得分（使用match_all时不适用）<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /表名/_search(类型: 文档/搜索)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\"># 搜索规则</span></span><br><span class=\"line\">    <span class=\"string\">&quot;query&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;查询条件&quot;</span>: <span class=\"string\">&quot;条件值&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\"># 排序规则</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sort&quot;</span>: [</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;account_number&quot;</span>: <span class=\"string\">&quot;asc&quot;</span> &#125;</span><br><span class=\"line\">   ],</span><br><span class=\"line\">   <span class=\"comment\"># 分页查询</span></span><br><span class=\"line\">    <span class=\"string\">&quot;from&quot;</span>: 10,</span><br><span class=\"line\">    <span class=\"string\">&quot;to&quot;</span>: 10 </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PUT /索引表名/_doc(类型: 文档/搜索)/文档<span class=\"built_in\">id</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\"># 存放内容</span></span><br><span class=\"line\">  <span class=\"string\">&quot;id&quot;</span>: <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;name&quot;</span> : <span class=\"string\">&quot;唐伯虎点秋香&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;realName&quot;</span>: <span class=\"string\">&quot;唐伯虎&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2></li>\n</ul>\n</li>\n<li>创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：<ul>\n<li>字段名是什么? 字段数据类型是什么?  字段名、字段数据类型，可以参考数据表结构的名称和类型</li>\n<li>是否参与搜索?  是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li>\n<li>是否需要分词?  是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词 -&gt; 现有的分词库</li>\n<li>如果分词，分词器是什么？ 分词器，我们可以统一使用ik_max_word类型</li>\n</ul>\n</li>\n<li>ES与Mysql数据同步?  同步更新 vs 异步更新(mq+定时任务)<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17584364152201758436414246.png\" alt=\"17584364152201758436414246.png\"></li>\n<li>TF-IDF相关性算法?  score = TF * IDF<ul>\n<li>TF = 词条出现的次数/词条总数  </li>\n<li>IDF = log(文档总数/出现词条的文档数)</li>\n</ul>\n</li>\n<li>es和mysql的like的不同<ul>\n<li>比如搜索 显卡9060和9060显卡 es两种都能搜索到, 而like匹配只能匹配一种 </li>\n<li>es还能进行范围geo搜索, 拼音搜索和相关性搜索<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2></li>\n</ul>\n</li>\n<li>索引的CRUD<ul>\n<li><strong>创建索引</strong> (<code>PUT/user</code>): 用于创建索引。</li>\n<li><strong>查看索引</strong> (<code>GET/user</code>): 获取索引的配置和信息。</li>\n<li><strong>删除索引</strong> (<code>DELETE/user</code>): 删除指定的索引。</li>\n</ul>\n</li>\n<li>文档的CRUD<ul>\n<li><strong>创建文档</strong> (<code>PUT/user/_doc/1001</code>): 向索引中插入一个新的文档。</li>\n<li><strong>查看文档</strong> (<code>GET/user/_doc/1001</code>): 根据文档 ID 查看文档的内容。</li>\n<li><strong>更新文档</strong> (<code>POST/user/_update/1001</code>): 更新文档的某些字段，不会替换整个文档。</li>\n<li><strong>删除文档</strong> (<code>DELETE/user/_doc/1001</code>): 删除指定 ID 的文档。</li>\n<li><strong>查询文档</strong> (<code>GET/user/_search</code>): 根据查询条件检索符合条件的文档。</li>\n</ul>\n</li>\n<li>什么是ELK<ul>\n<li>ELK = Elasticsearch + Logstash + Kibana</li>\n<li>Logstash负责日志收集, 解析以及转发到es, es负责存储数据, Kibanna负责可视化工具，提供图表、仪表盘、搜索分析界面</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Nginx配置解析","date":"2024-10-23T03:29:59.000Z","_content":"\n# Nginx\n\n## `Nginx`配置页解析\n- **proxy_pass 是隐式的, 从前端看不到后端地址, 这是一个误区, nginx保护隐私隐藏代理后的ip和端口**\n- **Nginx可以通过添加请求头参数CORS解决跨域问题**\n```nginx\n#配置允许运行Nginx工作进程的用户和用户组\nuser www;\n\n#配置运行Nginx进程生成的worker进程数\nworker_processes 2;\n\n#配置Nginx服务器运行对错误日志存放的路径\nerror_log logs/error.log;\n\n#配置Nginx服务器允许时记录Nginx的master进程的PID文件路径和名称\npid logs/nginx.pid;\n\n#配置Nginx服务是否以守护进程方法启动\n#daemon on;\n\nupdtream cluster{\t\t\t# 选择性代理后端服务器的地址\n\t# nginx负载均衡策略: 默认轮询, 还有ip_hash(同一个ip每次都会定位到同一个后端)  \n    server 192.168.71.100:8080 weight = 1;\t\t\n    server 192.168.71.100:8081 weight = 2;\n    server 192.168.71.100:8082 weight = 1;\n}\n\nevents {\n    #设置Nginx网络连接序列化\n    accept_mutex on;\n\n    #设置Nginx的worker进程是否可以同时接收多个请求\n    multi_accept on;\n\n    #设置Nginx的worker进程最大的连接数\n    worker_connections 1024;\n\n    #设置Nginx使用的事件驱动模型\n    use epoll;\n}\n```\n\n```nginx\nhttp {\n    include\t\t\tmime.types;   \t# 根据文件后缀判断文件类型\n    \t\n\t# 每一个server块就是一个虚拟主机\n\t# 项目演示\n\tserver{\t\n\t\t# Nginx静态资源服务器\n\t\tlisten       1000;              \n\t\tserver_name  192.168.71.100;\n\n\t\tlocation / {\t\t\t\t\t# 代理本地 /根目录下的资源\n\t\t\troot   html;\t\t\t\t# 静态根目录\n\t\t\tindex   index.html;\t\t\t# 静态首页\n\t\t}\n\n\t   # 注意 nginx保护隐私隐藏代理后的ip和端口\n\t   # 将代理以/api开头的请求,然后重写清除/api前缀\n\t\tlocation /api/ {\n\t\t\trewrite ^/api/(.*)$ /$1 break;\n\t\t\tproxy_pass http://cluster;\n\t\t\tproxy_set_header Host $host;\n\t\t\tproxy_set_header X-Real-IP $remote_addr;\n\t\t\tadd_header Access-Control-Allow-Origin *;\n\t\t\tadd_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n\t\t\tadd_header Access-Control-Allow-Headers 'Origin, Content-Type, Accept';\n\t\t}\n\n\t\t# error_page:设置网站的错误页面 可以指定具体跳转的地址\n\t\terror_page 404 /404.html;\n\t\terror_page 500 502 503 504 /50x.html\n\n\t\t# 错误页面精确导向\n\t\tlocation = /404.html {\n\t\t\troot html;\n\t\t\tindex 404.html;\n\t\t}  \n\n\t\t# 指定重定向地址\n\t\tlocation =/50x.html {\n\t\t\troot html;\n\t\t\tindex 50x.html;\n\t\t}\n\t\t\t}\n\n\t# 利用nginx代理本地床图\n    server {\n        listen       3111;\n        server_name  www.iloveyou.*  www.other.com;\n\n        location / {\n            root html;\n            index index.html;\n        }\n\n        \n        location /img/ {\n        \talias html/img/;\n            autoindex on;  # 启用目录列表查看 \n            autoindex_exact_size on; # 是否在目录列表展示文件的详细大小\n            autoindex_format html; # 设置目录列表的格式\n            autoindex_localtime on;   # 是否在目录列表上显示时间\n    }\n\n    # 演示rewrite重定向 \n    server {\n        listen 3112;\n        server_name localhost;\n        rewrite ^/ http://www.baidu.com permanent;\n\n        location rewrite {\n            rewrite ^/rewrite/url\\w*$ https://www.baidu.com;\n            rewrite ^/rewrite/(test)\\w*$ /$1;\n            rewrite ^/rewrite/(demo)\\w*$ /$1;\n        }\n        location /test{\n            default_type text/plain;\n            return 200 test_success;\n        }\n    }\n}\n```\n\n![17312463677901731246367666.png|700x558](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17312463677901731246367666.png)\n## `Nginx`原理\n\n| **原理**：有一个 `index.html` 静态资源部署在 `192.168.71.100:80`。当用户通过浏览器访问 `192.168.71.100:80`（即 `www.iloveyou.com`）时，服务器将静态页面返回给用户。用户的浏览器在渲染页面时，如果发现需求，会发送 AJAX 或 Fetch 请求（由前端定义）到 **Nginx**，然后 **Nginx 反向代理**请求到后端的 Tomcat 服务器（`192.168.71.200:8080/get`） |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![17305165582881730516558235.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17305165582881730516558235.png)                                                                                                                  |\n\n## `Nginx`路径重写\n#### 1.路径重写的两种方式\n- **`rewrite` 指令**\n- `rewrite` 用于修改客户端请求的 URI（路径），在请求进入 Nginx 处理流程时生效。\n- **`proxy_pass` 指令**\n- `proxy_pass` 指令用于转发请求到后端服务器，并可根据路径配置进行自动拼接或替换。\n#### 2.rewrite详解\n- 语法\n  **`regex`**：**正则表达式**，用于匹配需要重写的路径。k;  \n  **`replacement`**：目标路径，替换 `regex` 匹配到的路径部分。\n  **`flag`**：\n  - `last`：重写完成后，停止当前 location 配置，重新进入新的处理流程。\n  - `break`：停止重写，但继续在当前 location 中处理请求。\n  - `redirect`：返回临时重定向（302）。\n  - `permanent`：返回永久重定向（301）。\n- 例子:   \n  - 重写为新路径: rewrite     ^/old-path/(.*)$      /new-path/$1 brea;  即请求 `/old-path/test` -> `/new-path/test`\n  - 重定向到完整 URL: rewrite    ^/google$      <https://www.google.com>     permanent;   即请求 `/google` -> 301 重定向到 `https://www.google.com`\n#### 3.proxy_pass详解\n**规则 1**：如果 `proxy_pass` 以 `/` 结尾：\n- Nginx 会将匹配的 `location` 中的 URI 前缀移除，并拼接到 `proxy_pass` 的 URL 后。\n**示例**：\n```nginx\nnginx复制代码location /api/ {\n    proxy_pass http://backend/service/;\n}\n```\n- 请求 `/api/test` 转发为 `http://backend/service/test`。\n**规则 2**：如果 `proxy_pass` 不以 `/` 结尾：\n- Nginx 会保留 `location` 中的 URI 前缀，并直接拼接到 `proxy_pass` 的 URL 后。\n**示例**：\n```nginx\nnginx复制代码location /api/ {\n    proxy_pass http://backend/service;\n}\n```\n- 请求 `/api/test` 转发为 `http://backend/service/api/test`。\n**规则3:移除路径前缀并转发**\n```nginx\nnginx复制代码location /api/ {\n    rewrite ^/api/(.*)$ /$1 break;\n    proxy_pass http://backend/;\n}\n```\n- 请求 `/api/login` -> 先重写为 `/login`，然后转发 `http://backend/login`。\n#### 4.方式区别\n![17318103314111731810330458.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17318103314111731810330458.png)\n## `Tips`\n#### 为什么要动静分离?\n- 前面我们介绍过**Nginx在处理静态资源的时候，效率是非常高的**，而且**Nginx的并发访问量也是名列前茅**，而Tomcat则相对比较弱一些，所以把静态资源交个Nginx后，可以减轻Tomcat服务器的访问压力并提高静态资源的访问速度。\n#### 如何实现动静分离?\n- 实现动静分离的方式很多，比如静态资源可以部署到CDN、Nginx等服务器上，动态资源可以部署到Tomcat,weblogic或者websphere上。\n```nginx\n#动态资源\nlocation /demo {\n    proxy_pass http://webservice;\n}\n#静态资源\nlocation ~/.*\\.(png|jpg|gif|js){\n    root html/web;\n    gzip on;\n}\n\n```\n#### 正向代理和反向代理的区别?\n- 正向代理是**客户端的代理**, 是由**客户端架设代理软件**之类的, 比如说**vpn**, **隐藏了客户端地址**\n- 反向代理是**服务端的代理**, 是由**服务端设置一个反向代理服务器**, 比如**nginx**, 可以**隐藏后端真实的ip地址**\n- 正向代理和反向代理的作用和目的不同。正向代理主要是用来**解决访问限制问题**；而反向代理则是提供**负载均衡**、安全防护等作用；但是二者**均能提高访问速度**\n#### 请求出现异常的可能情况\n- 跨域option预检失败 \n- 跨域请求\n- 未处理/api后缀  \n- 检查请求头参数 \n- 请求参数不正确\n","source":"_posts/Nginx.md","raw":"---\ntitle: Nginx配置解析\ndate: 2024-10-23 11:29:59\ntags:\n  - Nginx\n  - chuangTu\ncategories: 编程\n---\n\n# Nginx\n\n## `Nginx`配置页解析\n- **proxy_pass 是隐式的, 从前端看不到后端地址, 这是一个误区, nginx保护隐私隐藏代理后的ip和端口**\n- **Nginx可以通过添加请求头参数CORS解决跨域问题**\n```nginx\n#配置允许运行Nginx工作进程的用户和用户组\nuser www;\n\n#配置运行Nginx进程生成的worker进程数\nworker_processes 2;\n\n#配置Nginx服务器运行对错误日志存放的路径\nerror_log logs/error.log;\n\n#配置Nginx服务器允许时记录Nginx的master进程的PID文件路径和名称\npid logs/nginx.pid;\n\n#配置Nginx服务是否以守护进程方法启动\n#daemon on;\n\nupdtream cluster{\t\t\t# 选择性代理后端服务器的地址\n\t# nginx负载均衡策略: 默认轮询, 还有ip_hash(同一个ip每次都会定位到同一个后端)  \n    server 192.168.71.100:8080 weight = 1;\t\t\n    server 192.168.71.100:8081 weight = 2;\n    server 192.168.71.100:8082 weight = 1;\n}\n\nevents {\n    #设置Nginx网络连接序列化\n    accept_mutex on;\n\n    #设置Nginx的worker进程是否可以同时接收多个请求\n    multi_accept on;\n\n    #设置Nginx的worker进程最大的连接数\n    worker_connections 1024;\n\n    #设置Nginx使用的事件驱动模型\n    use epoll;\n}\n```\n\n```nginx\nhttp {\n    include\t\t\tmime.types;   \t# 根据文件后缀判断文件类型\n    \t\n\t# 每一个server块就是一个虚拟主机\n\t# 项目演示\n\tserver{\t\n\t\t# Nginx静态资源服务器\n\t\tlisten       1000;              \n\t\tserver_name  192.168.71.100;\n\n\t\tlocation / {\t\t\t\t\t# 代理本地 /根目录下的资源\n\t\t\troot   html;\t\t\t\t# 静态根目录\n\t\t\tindex   index.html;\t\t\t# 静态首页\n\t\t}\n\n\t   # 注意 nginx保护隐私隐藏代理后的ip和端口\n\t   # 将代理以/api开头的请求,然后重写清除/api前缀\n\t\tlocation /api/ {\n\t\t\trewrite ^/api/(.*)$ /$1 break;\n\t\t\tproxy_pass http://cluster;\n\t\t\tproxy_set_header Host $host;\n\t\t\tproxy_set_header X-Real-IP $remote_addr;\n\t\t\tadd_header Access-Control-Allow-Origin *;\n\t\t\tadd_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n\t\t\tadd_header Access-Control-Allow-Headers 'Origin, Content-Type, Accept';\n\t\t}\n\n\t\t# error_page:设置网站的错误页面 可以指定具体跳转的地址\n\t\terror_page 404 /404.html;\n\t\terror_page 500 502 503 504 /50x.html\n\n\t\t# 错误页面精确导向\n\t\tlocation = /404.html {\n\t\t\troot html;\n\t\t\tindex 404.html;\n\t\t}  \n\n\t\t# 指定重定向地址\n\t\tlocation =/50x.html {\n\t\t\troot html;\n\t\t\tindex 50x.html;\n\t\t}\n\t\t\t}\n\n\t# 利用nginx代理本地床图\n    server {\n        listen       3111;\n        server_name  www.iloveyou.*  www.other.com;\n\n        location / {\n            root html;\n            index index.html;\n        }\n\n        \n        location /img/ {\n        \talias html/img/;\n            autoindex on;  # 启用目录列表查看 \n            autoindex_exact_size on; # 是否在目录列表展示文件的详细大小\n            autoindex_format html; # 设置目录列表的格式\n            autoindex_localtime on;   # 是否在目录列表上显示时间\n    }\n\n    # 演示rewrite重定向 \n    server {\n        listen 3112;\n        server_name localhost;\n        rewrite ^/ http://www.baidu.com permanent;\n\n        location rewrite {\n            rewrite ^/rewrite/url\\w*$ https://www.baidu.com;\n            rewrite ^/rewrite/(test)\\w*$ /$1;\n            rewrite ^/rewrite/(demo)\\w*$ /$1;\n        }\n        location /test{\n            default_type text/plain;\n            return 200 test_success;\n        }\n    }\n}\n```\n\n![17312463677901731246367666.png|700x558](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17312463677901731246367666.png)\n## `Nginx`原理\n\n| **原理**：有一个 `index.html` 静态资源部署在 `192.168.71.100:80`。当用户通过浏览器访问 `192.168.71.100:80`（即 `www.iloveyou.com`）时，服务器将静态页面返回给用户。用户的浏览器在渲染页面时，如果发现需求，会发送 AJAX 或 Fetch 请求（由前端定义）到 **Nginx**，然后 **Nginx 反向代理**请求到后端的 Tomcat 服务器（`192.168.71.200:8080/get`） |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![17305165582881730516558235.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17305165582881730516558235.png)                                                                                                                  |\n\n## `Nginx`路径重写\n#### 1.路径重写的两种方式\n- **`rewrite` 指令**\n- `rewrite` 用于修改客户端请求的 URI（路径），在请求进入 Nginx 处理流程时生效。\n- **`proxy_pass` 指令**\n- `proxy_pass` 指令用于转发请求到后端服务器，并可根据路径配置进行自动拼接或替换。\n#### 2.rewrite详解\n- 语法\n  **`regex`**：**正则表达式**，用于匹配需要重写的路径。k;  \n  **`replacement`**：目标路径，替换 `regex` 匹配到的路径部分。\n  **`flag`**：\n  - `last`：重写完成后，停止当前 location 配置，重新进入新的处理流程。\n  - `break`：停止重写，但继续在当前 location 中处理请求。\n  - `redirect`：返回临时重定向（302）。\n  - `permanent`：返回永久重定向（301）。\n- 例子:   \n  - 重写为新路径: rewrite     ^/old-path/(.*)$      /new-path/$1 brea;  即请求 `/old-path/test` -> `/new-path/test`\n  - 重定向到完整 URL: rewrite    ^/google$      <https://www.google.com>     permanent;   即请求 `/google` -> 301 重定向到 `https://www.google.com`\n#### 3.proxy_pass详解\n**规则 1**：如果 `proxy_pass` 以 `/` 结尾：\n- Nginx 会将匹配的 `location` 中的 URI 前缀移除，并拼接到 `proxy_pass` 的 URL 后。\n**示例**：\n```nginx\nnginx复制代码location /api/ {\n    proxy_pass http://backend/service/;\n}\n```\n- 请求 `/api/test` 转发为 `http://backend/service/test`。\n**规则 2**：如果 `proxy_pass` 不以 `/` 结尾：\n- Nginx 会保留 `location` 中的 URI 前缀，并直接拼接到 `proxy_pass` 的 URL 后。\n**示例**：\n```nginx\nnginx复制代码location /api/ {\n    proxy_pass http://backend/service;\n}\n```\n- 请求 `/api/test` 转发为 `http://backend/service/api/test`。\n**规则3:移除路径前缀并转发**\n```nginx\nnginx复制代码location /api/ {\n    rewrite ^/api/(.*)$ /$1 break;\n    proxy_pass http://backend/;\n}\n```\n- 请求 `/api/login` -> 先重写为 `/login`，然后转发 `http://backend/login`。\n#### 4.方式区别\n![17318103314111731810330458.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17318103314111731810330458.png)\n## `Tips`\n#### 为什么要动静分离?\n- 前面我们介绍过**Nginx在处理静态资源的时候，效率是非常高的**，而且**Nginx的并发访问量也是名列前茅**，而Tomcat则相对比较弱一些，所以把静态资源交个Nginx后，可以减轻Tomcat服务器的访问压力并提高静态资源的访问速度。\n#### 如何实现动静分离?\n- 实现动静分离的方式很多，比如静态资源可以部署到CDN、Nginx等服务器上，动态资源可以部署到Tomcat,weblogic或者websphere上。\n```nginx\n#动态资源\nlocation /demo {\n    proxy_pass http://webservice;\n}\n#静态资源\nlocation ~/.*\\.(png|jpg|gif|js){\n    root html/web;\n    gzip on;\n}\n\n```\n#### 正向代理和反向代理的区别?\n- 正向代理是**客户端的代理**, 是由**客户端架设代理软件**之类的, 比如说**vpn**, **隐藏了客户端地址**\n- 反向代理是**服务端的代理**, 是由**服务端设置一个反向代理服务器**, 比如**nginx**, 可以**隐藏后端真实的ip地址**\n- 正向代理和反向代理的作用和目的不同。正向代理主要是用来**解决访问限制问题**；而反向代理则是提供**负载均衡**、安全防护等作用；但是二者**均能提高访问速度**\n#### 请求出现异常的可能情况\n- 跨域option预检失败 \n- 跨域请求\n- 未处理/api后缀  \n- 检查请求头参数 \n- 请求参数不正确\n","slug":"Nginx","published":1,"updated":"2025-10-14T11:27:31.927Z","_id":"cmfw4z0910009uomwh87zd3s7","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h1><h2 id=\"Nginx配置页解析\"><a href=\"#Nginx配置页解析\" class=\"headerlink\" title=\"Nginx配置页解析\"></a><code>Nginx</code>配置页解析</h2><ul>\n<li><strong>proxy_pass 是隐式的, 从前端看不到后端地址, 这是一个误区, nginx保护隐私隐藏代理后的ip和端口</strong></li>\n<li><strong>Nginx可以通过添加请求头参数CORS解决跨域问题</strong><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#配置允许运行Nginx工作进程的用户和用户组</span></span><br><span class=\"line\"><span class=\"attribute\">user</span> www;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#配置运行Nginx进程生成的worker进程数</span></span><br><span class=\"line\"><span class=\"attribute\">worker_processes</span> <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#配置Nginx服务器运行对错误日志存放的路径</span></span><br><span class=\"line\"><span class=\"attribute\">error_log</span> logs/<span class=\"literal\">error</span>.log;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#配置Nginx服务器允许时记录Nginx的master进程的PID文件路径和名称</span></span><br><span class=\"line\"><span class=\"attribute\">pid</span> logs/nginx.pid;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#配置Nginx服务是否以守护进程方法启动</span></span><br><span class=\"line\"><span class=\"comment\">#daemon on;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">updtream</span> cluster&#123;\t\t\t<span class=\"comment\"># 选择性代理后端服务器的地址</span></span><br><span class=\"line\">\t<span class=\"comment\"># nginx负载均衡策略: 默认轮询, 还有ip_hash(同一个ip每次都会定位到同一个后端)  </span></span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">192.168.71.100:8080</span> weight = <span class=\"number\">1</span>;\t\t</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">192.168.71.100:8081</span> weight = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">192.168.71.100:8082</span> weight = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">events</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">#设置Nginx网络连接序列化</span></span><br><span class=\"line\">    <span class=\"attribute\">accept_mutex</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#设置Nginx的worker进程是否可以同时接收多个请求</span></span><br><span class=\"line\">    <span class=\"attribute\">multi_accept</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#设置Nginx的worker进程最大的连接数</span></span><br><span class=\"line\">    <span class=\"attribute\">worker_connections</span> <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#设置Nginx使用的事件驱动模型</span></span><br><span class=\"line\">    <span class=\"attribute\">use</span> <span class=\"literal\">epoll</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">http</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">include</span>\t\t\tmime.types;   \t<span class=\"comment\"># 根据文件后缀判断文件类型</span></span><br><span class=\"line\">    \t</span><br><span class=\"line\">\t<span class=\"comment\"># 每一个server块就是一个虚拟主机</span></span><br><span class=\"line\">\t<span class=\"comment\"># 项目演示</span></span><br><span class=\"line\">\tserver&#123;\t</span><br><span class=\"line\">\t\t<span class=\"comment\"># Nginx静态资源服务器</span></span><br><span class=\"line\">\t\t<span class=\"attribute\">listen</span>       <span class=\"number\">1000</span>;              </span><br><span class=\"line\">\t\t<span class=\"attribute\">server_name</span>  <span class=\"number\">192.168.71.100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"section\">location</span> / &#123;\t\t\t\t\t<span class=\"comment\"># 代理本地 /根目录下的资源</span></span><br><span class=\"line\">\t\t\t<span class=\"attribute\">root</span>   html;\t\t\t\t<span class=\"comment\"># 静态根目录</span></span><br><span class=\"line\">\t\t\t<span class=\"attribute\">index</span>   index.html;\t\t\t<span class=\"comment\"># 静态首页</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t   <span class=\"comment\"># 注意 nginx保护隐私隐藏代理后的ip和端口</span></span><br><span class=\"line\">\t   <span class=\"comment\"># 将代理以/api开头的请求,然后重写清除/api前缀</span></span><br><span class=\"line\">\t\t<span class=\"section\">location</span> /api/ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/api/(.*)$</span> /<span class=\"variable\">$1</span> <span class=\"literal\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">proxy_pass</span> http://cluster;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Origin *;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Methods <span class=\"string\">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Headers <span class=\"string\">&#x27;Origin, Content-Type, Accept&#x27;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># error_page:设置网站的错误页面 可以指定具体跳转的地址</span></span><br><span class=\"line\">\t\t<span class=\"attribute\">error_page</span> <span class=\"number\">404</span> /<span class=\"number\">404</span>.html;</span><br><span class=\"line\">\t\t<span class=\"attribute\">error_page</span> <span class=\"number\">500</span> <span class=\"number\">502</span> <span class=\"number\">503</span> <span class=\"number\">504</span> /50x.html</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 错误页面精确导向</span></span><br><span class=\"line\">\t\tlocation = /<span class=\"number\">404</span>.html &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">root</span> html;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">index</span> <span class=\"number\">404</span>.html;</span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 指定重定向地址</span></span><br><span class=\"line\">\t\t<span class=\"section\">location</span> =/50x.html &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">root</span> html;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">index</span> 50x.html;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\"># 利用nginx代理本地床图</span></span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">listen</span>       <span class=\"number\">3111</span>;</span><br><span class=\"line\">        <span class=\"attribute\">server_name</span>  <span class=\"regexp\">www.iloveyou.*</span>  www.other.com;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">            <span class=\"attribute\">root</span> html;</span><br><span class=\"line\">            <span class=\"attribute\">index</span> index.html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"section\">location</span> /img/ &#123;</span><br><span class=\"line\">        \t<span class=\"attribute\">alias</span> html/img/;</span><br><span class=\"line\">            <span class=\"attribute\">autoindex</span> <span class=\"literal\">on</span>;  <span class=\"comment\"># 启用目录列表查看 </span></span><br><span class=\"line\">            <span class=\"attribute\">autoindex_exact_size</span> <span class=\"literal\">on</span>; <span class=\"comment\"># 是否在目录列表展示文件的详细大小</span></span><br><span class=\"line\">            <span class=\"attribute\">autoindex_format</span> html; <span class=\"comment\"># 设置目录列表的格式</span></span><br><span class=\"line\">            <span class=\"attribute\">autoindex_localtime</span> <span class=\"literal\">on</span>;   <span class=\"comment\"># 是否在目录列表上显示时间</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 演示rewrite重定向 </span></span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">listen</span> <span class=\"number\">3112</span>;</span><br><span class=\"line\">        <span class=\"attribute\">server_name</span> localhost;</span><br><span class=\"line\">        <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/</span> http://www.baidu.com <span class=\"literal\">permanent</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"section\">location</span> rewrite &#123;</span><br><span class=\"line\">            <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/rewrite/url\\w*$</span> https://www.baidu.com;</span><br><span class=\"line\">            <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/rewrite/(test)\\w*$</span> /<span class=\"variable\">$1</span>;</span><br><span class=\"line\">            <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/rewrite/(demo)\\w*$</span> /<span class=\"variable\">$1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"section\">location</span> /test&#123;</span><br><span class=\"line\">            <span class=\"attribute\">default_type</span> text/plain;</span><br><span class=\"line\">            <span class=\"attribute\">return</span> <span class=\"number\">200</span> test_success;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17312463677901731246367666.png\" alt=\"17312463677901731246367666.png|700x558\"></p>\n<h2 id=\"Nginx原理\"><a href=\"#Nginx原理\" class=\"headerlink\" title=\"Nginx原理\"></a><code>Nginx</code>原理</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>原理</strong>：有一个 <code>index.html</code> 静态资源部署在 <code>192.168.71.100:80</code>。当用户通过浏览器访问 <code>192.168.71.100:80</code>（即 <code>www.iloveyou.com</code>）时，服务器将静态页面返回给用户。用户的浏览器在渲染页面时，如果发现需求，会发送 AJAX 或 Fetch 请求（由前端定义）到 <strong>Nginx</strong>，然后 <strong>Nginx 反向代理</strong>请求到后端的 Tomcat 服务器（<code>192.168.71.200:8080/get</code>）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17305165582881730516558235.png\" alt=\"17305165582881730516558235.png\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"Nginx路径重写\"><a href=\"#Nginx路径重写\" class=\"headerlink\" title=\"Nginx路径重写\"></a><code>Nginx</code>路径重写</h2><h4 id=\"1-路径重写的两种方式\"><a href=\"#1-路径重写的两种方式\" class=\"headerlink\" title=\"1.路径重写的两种方式\"></a>1.路径重写的两种方式</h4><ul>\n<li><strong><code>rewrite</code> 指令</strong></li>\n<li><code>rewrite</code> 用于修改客户端请求的 URI（路径），在请求进入 Nginx 处理流程时生效。</li>\n<li><strong><code>proxy_pass</code> 指令</strong></li>\n<li><code>proxy_pass</code> 指令用于转发请求到后端服务器，并可根据路径配置进行自动拼接或替换。<h4 id=\"2-rewrite详解\"><a href=\"#2-rewrite详解\" class=\"headerlink\" title=\"2.rewrite详解\"></a>2.rewrite详解</h4></li>\n<li>语法<br><strong><code>regex</code></strong>：<strong>正则表达式</strong>，用于匹配需要重写的路径。k;<br><strong><code>replacement</code></strong>：目标路径，替换 <code>regex</code> 匹配到的路径部分。<br><strong><code>flag</code></strong>：<ul>\n<li><code>last</code>：重写完成后，停止当前 location 配置，重新进入新的处理流程。</li>\n<li><code>break</code>：停止重写，但继续在当前 location 中处理请求。</li>\n<li><code>redirect</code>：返回临时重定向（302）。</li>\n<li><code>permanent</code>：返回永久重定向（301）。</li>\n</ul>\n</li>\n<li>例子:   <ul>\n<li>重写为新路径: rewrite     ^/old-path/(.*)$      /new-path/$1 brea;  即请求 <code>/old-path/test</code> -&gt; <code>/new-path/test</code></li>\n<li>重定向到完整 URL: rewrite    ^/google$      <a href=\"https://www.google.com\">https://www.google.com</a>     permanent;   即请求 <code>/google</code> -&gt; 301 重定向到 <code>https://www.google.com</code><h4 id=\"3-proxy-pass详解\"><a href=\"#3-proxy-pass详解\" class=\"headerlink\" title=\"3.proxy_pass详解\"></a>3.proxy_pass详解</h4><strong>规则 1</strong>：如果 <code>proxy_pass</code> 以 <code>/</code> 结尾：</li>\n</ul>\n</li>\n<li>Nginx 会将匹配的 <code>location</code> 中的 URI 前缀移除，并拼接到 <code>proxy_pass</code> 的 URL 后。<br><strong>示例</strong>：<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx复制代码<span class=\"section\">location</span> /api/ &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://backend/service/;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>请求 <code>/api/test</code> 转发为 <code>http://backend/service/test</code>。<br><strong>规则 2</strong>：如果 <code>proxy_pass</code> 不以 <code>/</code> 结尾：</li>\n<li>Nginx 会保留 <code>location</code> 中的 URI 前缀，并直接拼接到 <code>proxy_pass</code> 的 URL 后。<br><strong>示例</strong>：<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx复制代码<span class=\"section\">location</span> /api/ &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://backend/service;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>请求 <code>/api/test</code> 转发为 <code>http://backend/service/api/test</code>。<br><strong>规则3:移除路径前缀并转发</strong><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx复制代码<span class=\"section\">location</span> /api/ &#123;</span><br><span class=\"line\">    <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/api/(.*)$</span> /<span class=\"variable\">$1</span> <span class=\"literal\">break</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://backend/;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>请求 <code>/api/login</code> -&gt; 先重写为 <code>/login</code>，然后转发 <code>http://backend/login</code>。<h4 id=\"4-方式区别\"><a href=\"#4-方式区别\" class=\"headerlink\" title=\"4.方式区别\"></a>4.方式区别</h4><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17318103314111731810330458.png\" alt=\"17318103314111731810330458.png\"><h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a><code>Tips</code></h2><h4 id=\"为什么要动静分离\"><a href=\"#为什么要动静分离\" class=\"headerlink\" title=\"为什么要动静分离?\"></a>为什么要动静分离?</h4></li>\n<li>前面我们介绍过<strong>Nginx在处理静态资源的时候，效率是非常高的</strong>，而且<strong>Nginx的并发访问量也是名列前茅</strong>，而Tomcat则相对比较弱一些，所以把静态资源交个Nginx后，可以减轻Tomcat服务器的访问压力并提高静态资源的访问速度。<h4 id=\"如何实现动静分离\"><a href=\"#如何实现动静分离\" class=\"headerlink\" title=\"如何实现动静分离?\"></a>如何实现动静分离?</h4></li>\n<li>实现动静分离的方式很多，比如静态资源可以部署到CDN、Nginx等服务器上，动态资源可以部署到Tomcat,weblogic或者websphere上。<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#动态资源</span></span><br><span class=\"line\"><span class=\"section\">location</span> /demo &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://webservice;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#静态资源</span></span><br><span class=\"line\"><span class=\"section\">location</span> ~/.*\\.(png|jpg|gif|js)&#123;</span><br><span class=\"line\">    <span class=\"attribute\">root</span> html/web;</span><br><span class=\"line\">    <span class=\"attribute\">gzip</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"正向代理和反向代理的区别\"><a href=\"#正向代理和反向代理的区别\" class=\"headerlink\" title=\"正向代理和反向代理的区别?\"></a>正向代理和反向代理的区别?</h4></li>\n<li>正向代理是<strong>客户端的代理</strong>, 是由<strong>客户端架设代理软件</strong>之类的, 比如说<strong>vpn</strong>, <strong>隐藏了客户端地址</strong></li>\n<li>反向代理是<strong>服务端的代理</strong>, 是由<strong>服务端设置一个反向代理服务器</strong>, 比如<strong>nginx</strong>, 可以<strong>隐藏后端真实的ip地址</strong></li>\n<li>正向代理和反向代理的作用和目的不同。正向代理主要是用来<strong>解决访问限制问题</strong>；而反向代理则是提供<strong>负载均衡</strong>、安全防护等作用；但是二者<strong>均能提高访问速度</strong><h4 id=\"请求出现异常的可能情况\"><a href=\"#请求出现异常的可能情况\" class=\"headerlink\" title=\"请求出现异常的可能情况\"></a>请求出现异常的可能情况</h4></li>\n<li>跨域option预检失败 </li>\n<li>跨域请求</li>\n<li>未处理/api后缀  </li>\n<li>检查请求头参数 </li>\n<li>请求参数不正确</li>\n</ul>\n","cover":"/img/5.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h1><h2 id=\"Nginx配置页解析\"><a href=\"#Nginx配置页解析\" class=\"headerlink\" title=\"Nginx配置页解析\"></a><code>Nginx</code>配置页解析</h2><ul>\n<li><strong>proxy_pass 是隐式的, 从前端看不到后端地址, 这是一个误区, nginx保护隐私隐藏代理后的ip和端口</strong></li>\n<li><strong>Nginx可以通过添加请求头参数CORS解决跨域问题</strong><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#配置允许运行Nginx工作进程的用户和用户组</span></span><br><span class=\"line\"><span class=\"attribute\">user</span> www;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#配置运行Nginx进程生成的worker进程数</span></span><br><span class=\"line\"><span class=\"attribute\">worker_processes</span> <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#配置Nginx服务器运行对错误日志存放的路径</span></span><br><span class=\"line\"><span class=\"attribute\">error_log</span> logs/<span class=\"literal\">error</span>.log;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#配置Nginx服务器允许时记录Nginx的master进程的PID文件路径和名称</span></span><br><span class=\"line\"><span class=\"attribute\">pid</span> logs/nginx.pid;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#配置Nginx服务是否以守护进程方法启动</span></span><br><span class=\"line\"><span class=\"comment\">#daemon on;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">updtream</span> cluster&#123;\t\t\t<span class=\"comment\"># 选择性代理后端服务器的地址</span></span><br><span class=\"line\">\t<span class=\"comment\"># nginx负载均衡策略: 默认轮询, 还有ip_hash(同一个ip每次都会定位到同一个后端)  </span></span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">192.168.71.100:8080</span> weight = <span class=\"number\">1</span>;\t\t</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">192.168.71.100:8081</span> weight = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attribute\">server</span> <span class=\"number\">192.168.71.100:8082</span> weight = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">events</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">#设置Nginx网络连接序列化</span></span><br><span class=\"line\">    <span class=\"attribute\">accept_mutex</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#设置Nginx的worker进程是否可以同时接收多个请求</span></span><br><span class=\"line\">    <span class=\"attribute\">multi_accept</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#设置Nginx的worker进程最大的连接数</span></span><br><span class=\"line\">    <span class=\"attribute\">worker_connections</span> <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#设置Nginx使用的事件驱动模型</span></span><br><span class=\"line\">    <span class=\"attribute\">use</span> <span class=\"literal\">epoll</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">http</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">include</span>\t\t\tmime.types;   \t<span class=\"comment\"># 根据文件后缀判断文件类型</span></span><br><span class=\"line\">    \t</span><br><span class=\"line\">\t<span class=\"comment\"># 每一个server块就是一个虚拟主机</span></span><br><span class=\"line\">\t<span class=\"comment\"># 项目演示</span></span><br><span class=\"line\">\tserver&#123;\t</span><br><span class=\"line\">\t\t<span class=\"comment\"># Nginx静态资源服务器</span></span><br><span class=\"line\">\t\t<span class=\"attribute\">listen</span>       <span class=\"number\">1000</span>;              </span><br><span class=\"line\">\t\t<span class=\"attribute\">server_name</span>  <span class=\"number\">192.168.71.100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"section\">location</span> / &#123;\t\t\t\t\t<span class=\"comment\"># 代理本地 /根目录下的资源</span></span><br><span class=\"line\">\t\t\t<span class=\"attribute\">root</span>   html;\t\t\t\t<span class=\"comment\"># 静态根目录</span></span><br><span class=\"line\">\t\t\t<span class=\"attribute\">index</span>   index.html;\t\t\t<span class=\"comment\"># 静态首页</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t   <span class=\"comment\"># 注意 nginx保护隐私隐藏代理后的ip和端口</span></span><br><span class=\"line\">\t   <span class=\"comment\"># 将代理以/api开头的请求,然后重写清除/api前缀</span></span><br><span class=\"line\">\t\t<span class=\"section\">location</span> /api/ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/api/(.*)$</span> /<span class=\"variable\">$1</span> <span class=\"literal\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">proxy_pass</span> http://cluster;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Origin *;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Methods <span class=\"string\">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">add_header</span> Access-Control-Allow-Headers <span class=\"string\">&#x27;Origin, Content-Type, Accept&#x27;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># error_page:设置网站的错误页面 可以指定具体跳转的地址</span></span><br><span class=\"line\">\t\t<span class=\"attribute\">error_page</span> <span class=\"number\">404</span> /<span class=\"number\">404</span>.html;</span><br><span class=\"line\">\t\t<span class=\"attribute\">error_page</span> <span class=\"number\">500</span> <span class=\"number\">502</span> <span class=\"number\">503</span> <span class=\"number\">504</span> /50x.html</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 错误页面精确导向</span></span><br><span class=\"line\">\t\tlocation = /<span class=\"number\">404</span>.html &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">root</span> html;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">index</span> <span class=\"number\">404</span>.html;</span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># 指定重定向地址</span></span><br><span class=\"line\">\t\t<span class=\"section\">location</span> =/50x.html &#123;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">root</span> html;</span><br><span class=\"line\">\t\t\t<span class=\"attribute\">index</span> 50x.html;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\"># 利用nginx代理本地床图</span></span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">listen</span>       <span class=\"number\">3111</span>;</span><br><span class=\"line\">        <span class=\"attribute\">server_name</span>  <span class=\"regexp\">www.iloveyou.*</span>  www.other.com;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">            <span class=\"attribute\">root</span> html;</span><br><span class=\"line\">            <span class=\"attribute\">index</span> index.html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"section\">location</span> /img/ &#123;</span><br><span class=\"line\">        \t<span class=\"attribute\">alias</span> html/img/;</span><br><span class=\"line\">            <span class=\"attribute\">autoindex</span> <span class=\"literal\">on</span>;  <span class=\"comment\"># 启用目录列表查看 </span></span><br><span class=\"line\">            <span class=\"attribute\">autoindex_exact_size</span> <span class=\"literal\">on</span>; <span class=\"comment\"># 是否在目录列表展示文件的详细大小</span></span><br><span class=\"line\">            <span class=\"attribute\">autoindex_format</span> html; <span class=\"comment\"># 设置目录列表的格式</span></span><br><span class=\"line\">            <span class=\"attribute\">autoindex_localtime</span> <span class=\"literal\">on</span>;   <span class=\"comment\"># 是否在目录列表上显示时间</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 演示rewrite重定向 </span></span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">listen</span> <span class=\"number\">3112</span>;</span><br><span class=\"line\">        <span class=\"attribute\">server_name</span> localhost;</span><br><span class=\"line\">        <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/</span> http://www.baidu.com <span class=\"literal\">permanent</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"section\">location</span> rewrite &#123;</span><br><span class=\"line\">            <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/rewrite/url\\w*$</span> https://www.baidu.com;</span><br><span class=\"line\">            <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/rewrite/(test)\\w*$</span> /<span class=\"variable\">$1</span>;</span><br><span class=\"line\">            <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/rewrite/(demo)\\w*$</span> /<span class=\"variable\">$1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"section\">location</span> /test&#123;</span><br><span class=\"line\">            <span class=\"attribute\">default_type</span> text/plain;</span><br><span class=\"line\">            <span class=\"attribute\">return</span> <span class=\"number\">200</span> test_success;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17312463677901731246367666.png\" alt=\"17312463677901731246367666.png|700x558\"></p>\n<h2 id=\"Nginx原理\"><a href=\"#Nginx原理\" class=\"headerlink\" title=\"Nginx原理\"></a><code>Nginx</code>原理</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>原理</strong>：有一个 <code>index.html</code> 静态资源部署在 <code>192.168.71.100:80</code>。当用户通过浏览器访问 <code>192.168.71.100:80</code>（即 <code>www.iloveyou.com</code>）时，服务器将静态页面返回给用户。用户的浏览器在渲染页面时，如果发现需求，会发送 AJAX 或 Fetch 请求（由前端定义）到 <strong>Nginx</strong>，然后 <strong>Nginx 反向代理</strong>请求到后端的 Tomcat 服务器（<code>192.168.71.200:8080/get</code>）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17305165582881730516558235.png\" alt=\"17305165582881730516558235.png\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"Nginx路径重写\"><a href=\"#Nginx路径重写\" class=\"headerlink\" title=\"Nginx路径重写\"></a><code>Nginx</code>路径重写</h2><h4 id=\"1-路径重写的两种方式\"><a href=\"#1-路径重写的两种方式\" class=\"headerlink\" title=\"1.路径重写的两种方式\"></a>1.路径重写的两种方式</h4><ul>\n<li><strong><code>rewrite</code> 指令</strong></li>\n<li><code>rewrite</code> 用于修改客户端请求的 URI（路径），在请求进入 Nginx 处理流程时生效。</li>\n<li><strong><code>proxy_pass</code> 指令</strong></li>\n<li><code>proxy_pass</code> 指令用于转发请求到后端服务器，并可根据路径配置进行自动拼接或替换。<h4 id=\"2-rewrite详解\"><a href=\"#2-rewrite详解\" class=\"headerlink\" title=\"2.rewrite详解\"></a>2.rewrite详解</h4></li>\n<li>语法<br><strong><code>regex</code></strong>：<strong>正则表达式</strong>，用于匹配需要重写的路径。k;<br><strong><code>replacement</code></strong>：目标路径，替换 <code>regex</code> 匹配到的路径部分。<br><strong><code>flag</code></strong>：<ul>\n<li><code>last</code>：重写完成后，停止当前 location 配置，重新进入新的处理流程。</li>\n<li><code>break</code>：停止重写，但继续在当前 location 中处理请求。</li>\n<li><code>redirect</code>：返回临时重定向（302）。</li>\n<li><code>permanent</code>：返回永久重定向（301）。</li>\n</ul>\n</li>\n<li>例子:   <ul>\n<li>重写为新路径: rewrite     ^/old-path/(.*)$      /new-path/$1 brea;  即请求 <code>/old-path/test</code> -&gt; <code>/new-path/test</code></li>\n<li>重定向到完整 URL: rewrite    ^/google$      <a href=\"https://www.google.com\">https://www.google.com</a>     permanent;   即请求 <code>/google</code> -&gt; 301 重定向到 <code>https://www.google.com</code><h4 id=\"3-proxy-pass详解\"><a href=\"#3-proxy-pass详解\" class=\"headerlink\" title=\"3.proxy_pass详解\"></a>3.proxy_pass详解</h4><strong>规则 1</strong>：如果 <code>proxy_pass</code> 以 <code>/</code> 结尾：</li>\n</ul>\n</li>\n<li>Nginx 会将匹配的 <code>location</code> 中的 URI 前缀移除，并拼接到 <code>proxy_pass</code> 的 URL 后。<br><strong>示例</strong>：<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx复制代码<span class=\"section\">location</span> /api/ &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://backend/service/;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>请求 <code>/api/test</code> 转发为 <code>http://backend/service/test</code>。<br><strong>规则 2</strong>：如果 <code>proxy_pass</code> 不以 <code>/</code> 结尾：</li>\n<li>Nginx 会保留 <code>location</code> 中的 URI 前缀，并直接拼接到 <code>proxy_pass</code> 的 URL 后。<br><strong>示例</strong>：<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx复制代码<span class=\"section\">location</span> /api/ &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://backend/service;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>请求 <code>/api/test</code> 转发为 <code>http://backend/service/api/test</code>。<br><strong>规则3:移除路径前缀并转发</strong><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx复制代码<span class=\"section\">location</span> /api/ &#123;</span><br><span class=\"line\">    <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/api/(.*)$</span> /<span class=\"variable\">$1</span> <span class=\"literal\">break</span>;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://backend/;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>请求 <code>/api/login</code> -&gt; 先重写为 <code>/login</code>，然后转发 <code>http://backend/login</code>。<h4 id=\"4-方式区别\"><a href=\"#4-方式区别\" class=\"headerlink\" title=\"4.方式区别\"></a>4.方式区别</h4><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17318103314111731810330458.png\" alt=\"17318103314111731810330458.png\"><h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a><code>Tips</code></h2><h4 id=\"为什么要动静分离\"><a href=\"#为什么要动静分离\" class=\"headerlink\" title=\"为什么要动静分离?\"></a>为什么要动静分离?</h4></li>\n<li>前面我们介绍过<strong>Nginx在处理静态资源的时候，效率是非常高的</strong>，而且<strong>Nginx的并发访问量也是名列前茅</strong>，而Tomcat则相对比较弱一些，所以把静态资源交个Nginx后，可以减轻Tomcat服务器的访问压力并提高静态资源的访问速度。<h4 id=\"如何实现动静分离\"><a href=\"#如何实现动静分离\" class=\"headerlink\" title=\"如何实现动静分离?\"></a>如何实现动静分离?</h4></li>\n<li>实现动静分离的方式很多，比如静态资源可以部署到CDN、Nginx等服务器上，动态资源可以部署到Tomcat,weblogic或者websphere上。<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#动态资源</span></span><br><span class=\"line\"><span class=\"section\">location</span> /demo &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://webservice;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#静态资源</span></span><br><span class=\"line\"><span class=\"section\">location</span> ~/.*\\.(png|jpg|gif|js)&#123;</span><br><span class=\"line\">    <span class=\"attribute\">root</span> html/web;</span><br><span class=\"line\">    <span class=\"attribute\">gzip</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"正向代理和反向代理的区别\"><a href=\"#正向代理和反向代理的区别\" class=\"headerlink\" title=\"正向代理和反向代理的区别?\"></a>正向代理和反向代理的区别?</h4></li>\n<li>正向代理是<strong>客户端的代理</strong>, 是由<strong>客户端架设代理软件</strong>之类的, 比如说<strong>vpn</strong>, <strong>隐藏了客户端地址</strong></li>\n<li>反向代理是<strong>服务端的代理</strong>, 是由<strong>服务端设置一个反向代理服务器</strong>, 比如<strong>nginx</strong>, 可以<strong>隐藏后端真实的ip地址</strong></li>\n<li>正向代理和反向代理的作用和目的不同。正向代理主要是用来<strong>解决访问限制问题</strong>；而反向代理则是提供<strong>负载均衡</strong>、安全防护等作用；但是二者<strong>均能提高访问速度</strong><h4 id=\"请求出现异常的可能情况\"><a href=\"#请求出现异常的可能情况\" class=\"headerlink\" title=\"请求出现异常的可能情况\"></a>请求出现异常的可能情况</h4></li>\n<li>跨域option预检失败 </li>\n<li>跨域请求</li>\n<li>未处理/api后缀  </li>\n<li>检查请求头参数 </li>\n<li>请求参数不正确</li>\n</ul>\n"},{"banner":"[[pixel-banner-image.png]]","title":"Linux总结","date":"2024-11-25T08:07:00.000Z","_content":"\n# Linux Shell 命令整理\n## Linux 目录结构\n1. /：根目录，所有文件和目录的起点。\n2. /bin：存放基础命令的可执行文件，如 ls、cp。\n3. /sbin：系统管理命令所在目录，普通用户通常没有权限。\n4. /etc：系统配置文件目录，如网络和服务配置。 (source /etc/profile: 刷新系统配置)\n5. /home：用户主目录，每个用户有自己的文件存储位置。\n6. /root：超级用户（root）的主目录。\n7. /var：存放日志、缓存、临时文件等可变数据。\n8. /usr：存放用户级应用程序和共享文件。\n9. /lib：系统基本库文件，支持 /bin 和 /sbin 命令。\n10. /opt：用于安装第三方或可选软件包。\n11. /dev：设备文件目录，所有硬件设备在此表示为文件。\n12. /proc：虚拟文件系统，存放内核和进程信息。\n13. /tmp：临时文件目录，系统重启后可能会清空。\n14. /boot：存放启动相关文件，如内核和引导加载程序。\n15. /mnt 和 /media：用于临时挂载外部设备。\n![17582598048201758259804688.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17582598048201758259804688.png)\n\n## 用户管理\n\n### 创建用户\n\n```bash\nuseradd -m -s /bin/bash -u 501 King\n```\n\n- `-m`：创建用户的家目录 `/home/King`\n- `-s /bin/bash`：指定默认 Shell 解释器为 Bash\n- `-u 501`：指定用户 ID（UID）为 501\n\n### 设置用户密码\n\n```bash\npasswd King\n```\n\n- 输入两次新密码即可完成用户密码设置。\n\n### 修改用户名\n\n```bash\nusermod -l Queen King\n```\n\n- `-l`：更改用户名，将 `King` 修改为 `Queen`\n\n### 查看用户信息(配置文件)\n\n```bash\ncat /etc/passwd\n```\n\n- 每个用户占一行，格式如下：\n\n  ```java\n  用户名:密码(加密后):用户ID:组ID:描述:家目录:默认Shell\n  ```\n\n### 查看用户所属组\n- 每个用户都有一个用户id和用户名; 用户组也有名和id\n- 一个用户可用属于一个或多个用户组\n```bash\ngroups Queen\n```\n\n- 显示 `Queen` 用户所属的组。\n\n### 创建用户组\n\n```bash\ngroupadd -g 501 QueenGroup\n```\n\n- `-g 501`：指定组 ID（GID）为 501。\n\n### 修改用户所属组\n\n```bash\ngroupmod -g QueenGroup Queen\n```\n\n- 修改 `Queen` 用户的主组为 `QueenGroup`。\n\n### 查看组信息\n\n```bash\ncat -n /etc/group\n```\n\n- `-n`：显示行号。\n- `/etc/group` 文件包含所有用户组的信息。\n\n### 过滤查询某个用户的组信息\n\n```bash\ngrep 'King' /etc/group\n```\n\n- 仅显示 `King` 用户的组信息。\n\n### 查看当前登录用户\n\n```bash\nwho -H\n```\n\n- 显示当前登录的用户列表。\n## 进程管理\n- PCB: process control blocker, 一个进程有一个PCB单元, 作用是进程描述, 进程调度(5种)… \n### 查看当前时间\n\n```bash\ndate \"+%Y-%m-%d %H:%M:%S\"\n```\n\n- 显示当前时间，格式为 `年-月-日 时:分:秒`。\n\n### 查询进程\n\n```bash\nps -l\nps -ef -u root | grep mysqld\n```\n\n- `ps -ef`：显示所有进程详细信息。\n- `-u root`：筛选 root 用户的进程。\n- `grep mysqld`：查找包含 `mysqld` 关键字的进程。\n\n### 强行终止进程\n\n```bash\nkill -9 3306\n```\n\n- `-9`：强制终止进程，`3306` 是进程 ID。\n### 执行进程\n\n```bash\n// 后台执行,将命令的信息重定向到指定的文件\nnohup command [参数] > output_file 2>&1 &\n// 例子:\nnohup java -jar -Dspring.profiles.active=dev ./javaProject.jar > ./log.log 2>&1 &\n```\n### 查看端口是否被占用\n\n```bash\nnetstat -anp | grep 3306\n```\n\n```bash\nnetstat -nltp\n```\n- `-a` → 列出所有的端口。\n- `-n` → 直接显示 IP 和端口，不做域名解析。\n- `-l` → 仅显示处于监听状态的套接字。\n- `-t` → 显示 TCP 连接。\n- `-p` → 显示进程 PID 和程序名。\n### 进程调度算法\n- 确定进程执行的先后以实现最大 CPU 利用率\n\t- **先到先服务调度算法**(FCFS，First Come, First Served) : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。\n\t- **短作业优先的调度算法**(SJF，Shortest Job First) : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。\n\t- **时间片轮转调度算法**（RR，Round-Robin） : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。\n\t- **多级反馈队列调度算法**（MFQ，Multi-level Feedback Queue）：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。\n\t- **优先级调度算法**（Priority）：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。\n### 僵尸进程和孤儿进程\n- 僵尸进程  子进程由于某些原因停止运行, 但是他的父进程仍然还在运行, 必须通过wait()或者wiatpid()来回收父进程\n- 孤儿进程  父进程意外终止, 子进程仍然运行, 没有调用wait()或者waitpid()回收进程, 但是操作系统会通过将子进程的父进程设置为init, 由init进程来回收子进程\n## 服务管理\n\n### 查看服务状态\n\n```bash\nsystemctl status firewalld.service\n```\n\n- 检查 `firewalld` 防火墙的运行状态。\n\n### 启用服务自启动\n\n```bash\nsystemctl enable firewalld.service\n```\n\n- 设置 `firewalld` 开机自启动。\n## 文件和目录操作\n\n### 复制文件(仅在源文件比目标文件新时执行)\n\n```bash\ncp -u 源文件 目标文件夹path\n```\n\n- `-u`：仅在目标文件较旧或不存在时才复制。\n\n### 移动文件（仅在目标文件较旧时执行）\n\n```bash\nmv -u 源文件 目标文件夹path\n```\n\n- `-u`：仅在目标文件较旧或不存在时才移动。\n\n### 修改文件权限\n\n```bash\nchmod -Rv 777 文件夹/文件\n```\n\n- `-R`：递归修改所有子目录。\n- `-v`：显示修改的过程。\n\n![17582812784061758281277599.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17582812784061758281277599.png)\n\n### 列出文件（不包括隐藏文件）\n\n```bash\nls -l 文件名\n```\n\n- `-l`:  列出当前目录可见文件详细信息\n- `-al`: 列出所有文件,包含隐藏文件\n\n### 实时查看文件末尾\n\n```bash\ntail -n 10 -f 文件名\n```\n\n- `-n 10`：显示最后 10 行。\n- `-f`：实时更新输出内容。\n\n### 向文件追加内容\n\n```bash\necho \"hello\" >> a.txt\n```\n\n- `>>` 表示追加内容到 `a.txt` 文件。\n\n### 查找特定类型文件\n\n```bash\nfind /package -name '*.sh'\n```\n\n- 在 `/package` 目录下查找所有 `.sh` 结尾的文件。\n\n### 对文件内容排序\n\n```bash\nsort -ur number.txt | head -n 5\n```\n\n- `-u`：去重。\n- `-r`：降序排序。\n- `head -n 5`：取前 5 行。\n\n### 压缩和解压缩文件\n\n压缩文件1和文件2 为一个文件:\n\n```bash\ntar -zcvf 压缩后文件名.tar.gz 源文件1 源文件2\n```\n\n- `-z`：使用 gzip 压缩。\n- `-c`：创建压缩包。\n- `-v`：显示详细信息。\n- `-f`：指定文件名。\n\n解压缩：\n\n```bash\ntar -zxvf 文件.tar.gz\n```\n\n- `-z`：使用 gzip 压缩。\n- `-x`：解压缩。\n- `-v`：显示详细信息。\n- `-f`：指定文件名。\n## 网络管理\n\n### 设置命令别名\n\n```bash\nalias ll='ls -l --color=auto'\n```\n\n- `alias` 用于给命令取别名。\n\n### 启动网络服务\n\n```bash\nservice network start\n```\n\n- 开启网络。\n\n### 启用/禁用网卡\n\n```bash\nifconfig ens33 up   # 启用网卡\nifconfig ens33 down # 禁用网卡\n```\n\n### 测试网络连通性\n\n```bash\nping -c 3 www.baidu.com\n```\n\n- `-c 3`：只执行 3 次 ping。\n\n### 查看端口占用情况\n\n```bash\nnetstat -anp | grep 3306\n```\n\n- `-a`：显示所有连接。\n- `-n`：显示数字格式的 IP 地址和端口。\n- `-p`：显示进程信息。\n## 系统管理\n\n### 查看磁盘使用情况\n\n```bash\ndf -h --total\n```\n\n- `-h`：以人类可读的格式显示。\n- `--total`：显示总计信息。\n\n### 查看块设备\n\n```bash\nlsblk\n```\n\n- 以树状结构显示所有块设备。\n\n### 查看内存、CPU、进程、I/O 等性能状态\n\n```bash\nvmstat 1 # 每隔1s显示系统情况\n```\n\n### 查看 系统内存的使用情况\n\n```bash\nfree -h  # -h人类可读\n```\n### 设置虚拟网卡\n```bash\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n```\n## 脚本Shell\n- 指定脚本解释器写,shell的习惯第一行指定解释器 例如  #!jdk17/bin/java.exe\n![17583670223771758367021565.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17583670223771758367021565.png)\n![17583670422641758367041783.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17583670422641758367041783.png)\n```bash\n#!/bin/sh   \necho $home  # 查询系统变量\nname = 'root'\nhello='Hello, I am $name!' \necho $hello  # 输出{变量}\n\nstr=\"iLoveChina\" \necho ${str} # 输出{变量}\n\narray=(! @ # $ %)  \nlength=${#array[@]}\necho ${array[1]}\n\na=1\nb=2\n# if条件判断 判断a是否大于b\nif [ ${a} -eq ${b} ]; then\n    echo \"a=b\"\nelif [ ${a} -gt ${b} ]; then\n    echo \"a>b\"\nelse\n    echo \"a<b\"\nfi\n\n# for循环\nfor loop in A B C D E F G \ndo\n    echo \"顺序输出字母为: $loop\"\ndone\n\n# 函数定义\nd() {\n    echo \"请录入第一个数\"\n    read number1\n    echo \"请录入第二个数\"\n    read number2\n    echo \"两个数字分别为 ${number1}, ${number2}\"\n    return $((number1 + number2))\n}\nd\necho $?\n```\n## Vim 编辑器\n\n### 普通模式命令\n\n#### 光标移动\n\n```java\nh：向左移动\nj：向下移动\nk：向上移动\nl：向右移动\n0：移动到行首\n$：移动到行尾\ngg：移动到文件开头\nG：移动到文件结尾\n```\n\n#### 文本操作\n\n```java\nx：删除光标下的字符\ndd：删除当前行\nyy：复制当前行\np：粘贴（在光标后插入）\nu：撤销\nCtrl + r：重做\n```\n\n#### 查找和替换\n\n```java\n/text：向下查找 text\n?text：向上查找 text\nn：跳转到下一个匹配\nN：跳转到上一个匹配\n```\n\n### 命令行模式命令\n\n#### 文件操作\n\n```java\n:w：保存文件\n:q：退出 vi\n:wq 或 ZZ：保存并退出\n:q!：强制退出而不保存\n:set nu：显示行号\n:set nonu：隐藏行号\n```\n\n#### 撤销与重做\n\n```java\nu：撤销上一步操作\nCtrl + r：重做上一步操作\n```\n\n#### 文件操作\n\n```java\n:e filename：打开新文件\n:r filename：将文件内容插入当前文件\n```\n\n#### 查找内容\n\n```java\n/关键字  # 向下查找关键字\n?关键字  # 向上查找关键字\n```\n\n\n## AB压力测试\n- Apache服务器的性能测试工具, 会创建并发线程访问同一个url(Web服务)\n- `ab -c 10 -n 100 http://www.myvick.cn/index.php`：同时处理100个请求并运行10次index.php\n\t- -c10表示并发用户数为10\n\t- -n100表示请求总数为100\n```bash\nServer Software:        nginx/1.13.6   #测试服务器的名字\nServer Hostname:        www.myvick.cn  #请求的URL主机名\nServer Port:            80             #web服务器监听的端口\n\nDocument Path:          /index.php　　  #请求的URL中的根绝对路径，通过该文件的后缀名，我们一般可以了解该请求的类型\nDocument Length:        799 bytes       #HTTP响应数据的正文长度\n\nConcurrency Level:      10　　　　　　　　# 并发用户数，这是我们设置的参数之一\nTime taken for tests:   0.668 seconds   #所有这些请求被处理完成所花费的总时间 单位秒\nComplete requests:      100 　　　　　　  # 总请求数量，这是我们设置的参数之一\nFailed requests:        0　　　　　　　　  # 表示失败的请求数量，这里的失败是指请求在连接服务器、发送数据等环节发生异常，以及无响应后超时的情况\nWrite errors:           0\nTotal transferred:      96200 bytes　　　 #所有请求的响应数据长度总和。包括每个HTTP响应数据的头信息和正文数据的长度\nHTML transferred:       79900 bytes　　　　# 所有请求的响应数据中正文数据的总和，也就是减去了Total transferred中HTTP响应数据中的头信息的长度\nRequests per second:    149.71 [#/sec] (mean) #吞吐率，计算公式：Complete requests/Time taken for tests  总请求数/处理完成这些请求数所花费的时间\nTime per request:       66.797 [ms] (mean)   # 用户平均请求等待时间，计算公式：Time token for tests/（Complete requests/Concurrency Level）。处理完成所有请求数所花费的时间/（总请求数/并发用户数）\nTime per request:       6.680 [ms] (mean, across all concurrent requests) #服务器平均请求等待时间，计算公式：Time taken for tests/Complete requests，正好是吞吐率的倒数。也可以这么统计：Time per request/Concurrency Level\nTransfer rate:          140.64 [Kbytes/sec] received  #表示这些请求在单位时间内从服务器获取的数据长度，计算公式：Total trnasferred/ Time taken for tests，这个统计很好的说明服务器的处理能力达到极限时，其出口宽带的需求量。\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        1    2   0.7      2       5\nProcessing:     2   26  81.3      3     615\nWaiting:        1   26  81.3      3     615\nTotal:          3   28  81.3      6     618\n\n```\n## 问答\n### 如何发起Http请求\n- 不同网络主机要通信一必须通过**Socket(套接字)**建立**传输层连接**（TCP/UDP）一→然后在上层跑具体的**应用层协议**(HTTP、MQTT、WebSocket等）实现数据格式约定和业务逻辑。\n```bash\ncurl https://baidu.com  # Get请求\ncurl -X POST https://baidu.com \"name=123&password=456\"\n\nwget https://baidu.com\n``` \n### 什么是线程的死锁\n- 互斥条件:  一个资源一个线程, 如果一个线程持有资源, 那么其他线程想要访问这个资源必须等待\n- 持有并等待条件:  一个资源被一个线程占有一段时间, 另一个线程必须死等\n- 不可剥夺条件:  已经分配资源给进程, 该资源不可被强制剥夺, 并主动释放\n- 循环等待条件:  a持有资源1 请求支援2;  b持有资源2 请求资源1;  想当与循环依赖\n### 怎么在Linux上安装Java环境\n1. 下载Linux版本的jdk安装包\n2. tar -zxvf 解压缩安装包\n3. 配置环境变量 export JAVA_HOME=/usr/local/java/jdk17\n4. 配置路径变量 export PATH=$JAVA-HOME/bin: $PATH\n5. 刷新配置 source /etc/profile\n6. 使用 java --version验证是否安装成功\n7. 使用`echo \"$PATH\"`查看是否加入到系统bin目录\n### `ps`和`netstat`的区别\n| 特性   | netstat              | ps                     |\n| ---- | -------------------- | ---------------------- |\n| 关注点  | 网络连接、端口、协议状态         | 进程运行状态、CPU/内存资源        |\n| 典型用途 | 看端口是否被占用，连接是否正常      | 看进程是否运行，消耗多少资源         |\n| 输出重点 | TCP/UDP 连接，监听端口，路由   | PID、父子进程关系、命令、用户       |\n| 结合场景 | 常和 `ps` 配合用来查哪个进程占端口 | 常和 `netstat` 配合找进程网络行为 |\n- netstat注重端口(网络连接);  ps注重进程情况\n### 如何统计 HTTPS 服务（通常运行在端口 443）每秒的请求数\n```bash\nwatch -n 1 \"netstat -an | grep ':443'\"\"\n```\n- `netstat -an`：显示所有连接和监听端口。\n- `grep ':443 '`：过滤出端口 443 的连接。\n- `grep ESTABLISHED`：过滤出已经建立的连接。\n- `wc -l`：统计连接数。\n- `watch -n 1`：每秒刷新一次命令的输出。\n### 什么是软链接和硬链接\n| 特性       | 软链接 (Symbolic)       | 硬链接 (Hard)         |\n| -------- | -------------------- | ------------------ |\n| inode    | 独立 inode，存储路径        | 和源文件 inode 相同      |\n| 指向对象     | 文件路径（间接指向数据）         | 文件本身（直接指向数据）       |\n| 是否可跨文件系统 | ✅ 可以                 | ❌ 不可以              |\n| 是否可链接目录  | ✅ 可以                 | ❌ 不可以              |\n| 删除源文件影响  | ❌ 软链失效（死链）           | ✅ 不影响（数据还在）        |\n| 文件大小     | 路径字符串长度              | 和源文件大小相同           |\n| 典型用途     | 快捷方式、版本切换            | 数据保护、防止误删          |\n| 命令       | ln -s target newFile | ln  target newFile |\n- 软链接保存的是指向文件的路径, 文件删除则软链接变死链;\n- 硬链接是“同一个文件的多个名字”, 删除源文件, 但是有副本","source":"_posts/Linux.md","raw":"---\nbanner: \"[[pixel-banner-image.png]]\"\ntitle: Linux总结\ntags:\n  - Linux\ncategories: 编程\ndate: 2024-11-25T16:07:00\n---\n\n# Linux Shell 命令整理\n## Linux 目录结构\n1. /：根目录，所有文件和目录的起点。\n2. /bin：存放基础命令的可执行文件，如 ls、cp。\n3. /sbin：系统管理命令所在目录，普通用户通常没有权限。\n4. /etc：系统配置文件目录，如网络和服务配置。 (source /etc/profile: 刷新系统配置)\n5. /home：用户主目录，每个用户有自己的文件存储位置。\n6. /root：超级用户（root）的主目录。\n7. /var：存放日志、缓存、临时文件等可变数据。\n8. /usr：存放用户级应用程序和共享文件。\n9. /lib：系统基本库文件，支持 /bin 和 /sbin 命令。\n10. /opt：用于安装第三方或可选软件包。\n11. /dev：设备文件目录，所有硬件设备在此表示为文件。\n12. /proc：虚拟文件系统，存放内核和进程信息。\n13. /tmp：临时文件目录，系统重启后可能会清空。\n14. /boot：存放启动相关文件，如内核和引导加载程序。\n15. /mnt 和 /media：用于临时挂载外部设备。\n![17582598048201758259804688.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17582598048201758259804688.png)\n\n## 用户管理\n\n### 创建用户\n\n```bash\nuseradd -m -s /bin/bash -u 501 King\n```\n\n- `-m`：创建用户的家目录 `/home/King`\n- `-s /bin/bash`：指定默认 Shell 解释器为 Bash\n- `-u 501`：指定用户 ID（UID）为 501\n\n### 设置用户密码\n\n```bash\npasswd King\n```\n\n- 输入两次新密码即可完成用户密码设置。\n\n### 修改用户名\n\n```bash\nusermod -l Queen King\n```\n\n- `-l`：更改用户名，将 `King` 修改为 `Queen`\n\n### 查看用户信息(配置文件)\n\n```bash\ncat /etc/passwd\n```\n\n- 每个用户占一行，格式如下：\n\n  ```java\n  用户名:密码(加密后):用户ID:组ID:描述:家目录:默认Shell\n  ```\n\n### 查看用户所属组\n- 每个用户都有一个用户id和用户名; 用户组也有名和id\n- 一个用户可用属于一个或多个用户组\n```bash\ngroups Queen\n```\n\n- 显示 `Queen` 用户所属的组。\n\n### 创建用户组\n\n```bash\ngroupadd -g 501 QueenGroup\n```\n\n- `-g 501`：指定组 ID（GID）为 501。\n\n### 修改用户所属组\n\n```bash\ngroupmod -g QueenGroup Queen\n```\n\n- 修改 `Queen` 用户的主组为 `QueenGroup`。\n\n### 查看组信息\n\n```bash\ncat -n /etc/group\n```\n\n- `-n`：显示行号。\n- `/etc/group` 文件包含所有用户组的信息。\n\n### 过滤查询某个用户的组信息\n\n```bash\ngrep 'King' /etc/group\n```\n\n- 仅显示 `King` 用户的组信息。\n\n### 查看当前登录用户\n\n```bash\nwho -H\n```\n\n- 显示当前登录的用户列表。\n## 进程管理\n- PCB: process control blocker, 一个进程有一个PCB单元, 作用是进程描述, 进程调度(5种)… \n### 查看当前时间\n\n```bash\ndate \"+%Y-%m-%d %H:%M:%S\"\n```\n\n- 显示当前时间，格式为 `年-月-日 时:分:秒`。\n\n### 查询进程\n\n```bash\nps -l\nps -ef -u root | grep mysqld\n```\n\n- `ps -ef`：显示所有进程详细信息。\n- `-u root`：筛选 root 用户的进程。\n- `grep mysqld`：查找包含 `mysqld` 关键字的进程。\n\n### 强行终止进程\n\n```bash\nkill -9 3306\n```\n\n- `-9`：强制终止进程，`3306` 是进程 ID。\n### 执行进程\n\n```bash\n// 后台执行,将命令的信息重定向到指定的文件\nnohup command [参数] > output_file 2>&1 &\n// 例子:\nnohup java -jar -Dspring.profiles.active=dev ./javaProject.jar > ./log.log 2>&1 &\n```\n### 查看端口是否被占用\n\n```bash\nnetstat -anp | grep 3306\n```\n\n```bash\nnetstat -nltp\n```\n- `-a` → 列出所有的端口。\n- `-n` → 直接显示 IP 和端口，不做域名解析。\n- `-l` → 仅显示处于监听状态的套接字。\n- `-t` → 显示 TCP 连接。\n- `-p` → 显示进程 PID 和程序名。\n### 进程调度算法\n- 确定进程执行的先后以实现最大 CPU 利用率\n\t- **先到先服务调度算法**(FCFS，First Come, First Served) : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。\n\t- **短作业优先的调度算法**(SJF，Shortest Job First) : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。\n\t- **时间片轮转调度算法**（RR，Round-Robin） : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。\n\t- **多级反馈队列调度算法**（MFQ，Multi-level Feedback Queue）：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。\n\t- **优先级调度算法**（Priority）：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。\n### 僵尸进程和孤儿进程\n- 僵尸进程  子进程由于某些原因停止运行, 但是他的父进程仍然还在运行, 必须通过wait()或者wiatpid()来回收父进程\n- 孤儿进程  父进程意外终止, 子进程仍然运行, 没有调用wait()或者waitpid()回收进程, 但是操作系统会通过将子进程的父进程设置为init, 由init进程来回收子进程\n## 服务管理\n\n### 查看服务状态\n\n```bash\nsystemctl status firewalld.service\n```\n\n- 检查 `firewalld` 防火墙的运行状态。\n\n### 启用服务自启动\n\n```bash\nsystemctl enable firewalld.service\n```\n\n- 设置 `firewalld` 开机自启动。\n## 文件和目录操作\n\n### 复制文件(仅在源文件比目标文件新时执行)\n\n```bash\ncp -u 源文件 目标文件夹path\n```\n\n- `-u`：仅在目标文件较旧或不存在时才复制。\n\n### 移动文件（仅在目标文件较旧时执行）\n\n```bash\nmv -u 源文件 目标文件夹path\n```\n\n- `-u`：仅在目标文件较旧或不存在时才移动。\n\n### 修改文件权限\n\n```bash\nchmod -Rv 777 文件夹/文件\n```\n\n- `-R`：递归修改所有子目录。\n- `-v`：显示修改的过程。\n\n![17582812784061758281277599.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17582812784061758281277599.png)\n\n### 列出文件（不包括隐藏文件）\n\n```bash\nls -l 文件名\n```\n\n- `-l`:  列出当前目录可见文件详细信息\n- `-al`: 列出所有文件,包含隐藏文件\n\n### 实时查看文件末尾\n\n```bash\ntail -n 10 -f 文件名\n```\n\n- `-n 10`：显示最后 10 行。\n- `-f`：实时更新输出内容。\n\n### 向文件追加内容\n\n```bash\necho \"hello\" >> a.txt\n```\n\n- `>>` 表示追加内容到 `a.txt` 文件。\n\n### 查找特定类型文件\n\n```bash\nfind /package -name '*.sh'\n```\n\n- 在 `/package` 目录下查找所有 `.sh` 结尾的文件。\n\n### 对文件内容排序\n\n```bash\nsort -ur number.txt | head -n 5\n```\n\n- `-u`：去重。\n- `-r`：降序排序。\n- `head -n 5`：取前 5 行。\n\n### 压缩和解压缩文件\n\n压缩文件1和文件2 为一个文件:\n\n```bash\ntar -zcvf 压缩后文件名.tar.gz 源文件1 源文件2\n```\n\n- `-z`：使用 gzip 压缩。\n- `-c`：创建压缩包。\n- `-v`：显示详细信息。\n- `-f`：指定文件名。\n\n解压缩：\n\n```bash\ntar -zxvf 文件.tar.gz\n```\n\n- `-z`：使用 gzip 压缩。\n- `-x`：解压缩。\n- `-v`：显示详细信息。\n- `-f`：指定文件名。\n## 网络管理\n\n### 设置命令别名\n\n```bash\nalias ll='ls -l --color=auto'\n```\n\n- `alias` 用于给命令取别名。\n\n### 启动网络服务\n\n```bash\nservice network start\n```\n\n- 开启网络。\n\n### 启用/禁用网卡\n\n```bash\nifconfig ens33 up   # 启用网卡\nifconfig ens33 down # 禁用网卡\n```\n\n### 测试网络连通性\n\n```bash\nping -c 3 www.baidu.com\n```\n\n- `-c 3`：只执行 3 次 ping。\n\n### 查看端口占用情况\n\n```bash\nnetstat -anp | grep 3306\n```\n\n- `-a`：显示所有连接。\n- `-n`：显示数字格式的 IP 地址和端口。\n- `-p`：显示进程信息。\n## 系统管理\n\n### 查看磁盘使用情况\n\n```bash\ndf -h --total\n```\n\n- `-h`：以人类可读的格式显示。\n- `--total`：显示总计信息。\n\n### 查看块设备\n\n```bash\nlsblk\n```\n\n- 以树状结构显示所有块设备。\n\n### 查看内存、CPU、进程、I/O 等性能状态\n\n```bash\nvmstat 1 # 每隔1s显示系统情况\n```\n\n### 查看 系统内存的使用情况\n\n```bash\nfree -h  # -h人类可读\n```\n### 设置虚拟网卡\n```bash\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n```\n## 脚本Shell\n- 指定脚本解释器写,shell的习惯第一行指定解释器 例如  #!jdk17/bin/java.exe\n![17583670223771758367021565.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17583670223771758367021565.png)\n![17583670422641758367041783.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17583670422641758367041783.png)\n```bash\n#!/bin/sh   \necho $home  # 查询系统变量\nname = 'root'\nhello='Hello, I am $name!' \necho $hello  # 输出{变量}\n\nstr=\"iLoveChina\" \necho ${str} # 输出{变量}\n\narray=(! @ # $ %)  \nlength=${#array[@]}\necho ${array[1]}\n\na=1\nb=2\n# if条件判断 判断a是否大于b\nif [ ${a} -eq ${b} ]; then\n    echo \"a=b\"\nelif [ ${a} -gt ${b} ]; then\n    echo \"a>b\"\nelse\n    echo \"a<b\"\nfi\n\n# for循环\nfor loop in A B C D E F G \ndo\n    echo \"顺序输出字母为: $loop\"\ndone\n\n# 函数定义\nd() {\n    echo \"请录入第一个数\"\n    read number1\n    echo \"请录入第二个数\"\n    read number2\n    echo \"两个数字分别为 ${number1}, ${number2}\"\n    return $((number1 + number2))\n}\nd\necho $?\n```\n## Vim 编辑器\n\n### 普通模式命令\n\n#### 光标移动\n\n```java\nh：向左移动\nj：向下移动\nk：向上移动\nl：向右移动\n0：移动到行首\n$：移动到行尾\ngg：移动到文件开头\nG：移动到文件结尾\n```\n\n#### 文本操作\n\n```java\nx：删除光标下的字符\ndd：删除当前行\nyy：复制当前行\np：粘贴（在光标后插入）\nu：撤销\nCtrl + r：重做\n```\n\n#### 查找和替换\n\n```java\n/text：向下查找 text\n?text：向上查找 text\nn：跳转到下一个匹配\nN：跳转到上一个匹配\n```\n\n### 命令行模式命令\n\n#### 文件操作\n\n```java\n:w：保存文件\n:q：退出 vi\n:wq 或 ZZ：保存并退出\n:q!：强制退出而不保存\n:set nu：显示行号\n:set nonu：隐藏行号\n```\n\n#### 撤销与重做\n\n```java\nu：撤销上一步操作\nCtrl + r：重做上一步操作\n```\n\n#### 文件操作\n\n```java\n:e filename：打开新文件\n:r filename：将文件内容插入当前文件\n```\n\n#### 查找内容\n\n```java\n/关键字  # 向下查找关键字\n?关键字  # 向上查找关键字\n```\n\n\n## AB压力测试\n- Apache服务器的性能测试工具, 会创建并发线程访问同一个url(Web服务)\n- `ab -c 10 -n 100 http://www.myvick.cn/index.php`：同时处理100个请求并运行10次index.php\n\t- -c10表示并发用户数为10\n\t- -n100表示请求总数为100\n```bash\nServer Software:        nginx/1.13.6   #测试服务器的名字\nServer Hostname:        www.myvick.cn  #请求的URL主机名\nServer Port:            80             #web服务器监听的端口\n\nDocument Path:          /index.php　　  #请求的URL中的根绝对路径，通过该文件的后缀名，我们一般可以了解该请求的类型\nDocument Length:        799 bytes       #HTTP响应数据的正文长度\n\nConcurrency Level:      10　　　　　　　　# 并发用户数，这是我们设置的参数之一\nTime taken for tests:   0.668 seconds   #所有这些请求被处理完成所花费的总时间 单位秒\nComplete requests:      100 　　　　　　  # 总请求数量，这是我们设置的参数之一\nFailed requests:        0　　　　　　　　  # 表示失败的请求数量，这里的失败是指请求在连接服务器、发送数据等环节发生异常，以及无响应后超时的情况\nWrite errors:           0\nTotal transferred:      96200 bytes　　　 #所有请求的响应数据长度总和。包括每个HTTP响应数据的头信息和正文数据的长度\nHTML transferred:       79900 bytes　　　　# 所有请求的响应数据中正文数据的总和，也就是减去了Total transferred中HTTP响应数据中的头信息的长度\nRequests per second:    149.71 [#/sec] (mean) #吞吐率，计算公式：Complete requests/Time taken for tests  总请求数/处理完成这些请求数所花费的时间\nTime per request:       66.797 [ms] (mean)   # 用户平均请求等待时间，计算公式：Time token for tests/（Complete requests/Concurrency Level）。处理完成所有请求数所花费的时间/（总请求数/并发用户数）\nTime per request:       6.680 [ms] (mean, across all concurrent requests) #服务器平均请求等待时间，计算公式：Time taken for tests/Complete requests，正好是吞吐率的倒数。也可以这么统计：Time per request/Concurrency Level\nTransfer rate:          140.64 [Kbytes/sec] received  #表示这些请求在单位时间内从服务器获取的数据长度，计算公式：Total trnasferred/ Time taken for tests，这个统计很好的说明服务器的处理能力达到极限时，其出口宽带的需求量。\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        1    2   0.7      2       5\nProcessing:     2   26  81.3      3     615\nWaiting:        1   26  81.3      3     615\nTotal:          3   28  81.3      6     618\n\n```\n## 问答\n### 如何发起Http请求\n- 不同网络主机要通信一必须通过**Socket(套接字)**建立**传输层连接**（TCP/UDP）一→然后在上层跑具体的**应用层协议**(HTTP、MQTT、WebSocket等）实现数据格式约定和业务逻辑。\n```bash\ncurl https://baidu.com  # Get请求\ncurl -X POST https://baidu.com \"name=123&password=456\"\n\nwget https://baidu.com\n``` \n### 什么是线程的死锁\n- 互斥条件:  一个资源一个线程, 如果一个线程持有资源, 那么其他线程想要访问这个资源必须等待\n- 持有并等待条件:  一个资源被一个线程占有一段时间, 另一个线程必须死等\n- 不可剥夺条件:  已经分配资源给进程, 该资源不可被强制剥夺, 并主动释放\n- 循环等待条件:  a持有资源1 请求支援2;  b持有资源2 请求资源1;  想当与循环依赖\n### 怎么在Linux上安装Java环境\n1. 下载Linux版本的jdk安装包\n2. tar -zxvf 解压缩安装包\n3. 配置环境变量 export JAVA_HOME=/usr/local/java/jdk17\n4. 配置路径变量 export PATH=$JAVA-HOME/bin: $PATH\n5. 刷新配置 source /etc/profile\n6. 使用 java --version验证是否安装成功\n7. 使用`echo \"$PATH\"`查看是否加入到系统bin目录\n### `ps`和`netstat`的区别\n| 特性   | netstat              | ps                     |\n| ---- | -------------------- | ---------------------- |\n| 关注点  | 网络连接、端口、协议状态         | 进程运行状态、CPU/内存资源        |\n| 典型用途 | 看端口是否被占用，连接是否正常      | 看进程是否运行，消耗多少资源         |\n| 输出重点 | TCP/UDP 连接，监听端口，路由   | PID、父子进程关系、命令、用户       |\n| 结合场景 | 常和 `ps` 配合用来查哪个进程占端口 | 常和 `netstat` 配合找进程网络行为 |\n- netstat注重端口(网络连接);  ps注重进程情况\n### 如何统计 HTTPS 服务（通常运行在端口 443）每秒的请求数\n```bash\nwatch -n 1 \"netstat -an | grep ':443'\"\"\n```\n- `netstat -an`：显示所有连接和监听端口。\n- `grep ':443 '`：过滤出端口 443 的连接。\n- `grep ESTABLISHED`：过滤出已经建立的连接。\n- `wc -l`：统计连接数。\n- `watch -n 1`：每秒刷新一次命令的输出。\n### 什么是软链接和硬链接\n| 特性       | 软链接 (Symbolic)       | 硬链接 (Hard)         |\n| -------- | -------------------- | ------------------ |\n| inode    | 独立 inode，存储路径        | 和源文件 inode 相同      |\n| 指向对象     | 文件路径（间接指向数据）         | 文件本身（直接指向数据）       |\n| 是否可跨文件系统 | ✅ 可以                 | ❌ 不可以              |\n| 是否可链接目录  | ✅ 可以                 | ❌ 不可以              |\n| 删除源文件影响  | ❌ 软链失效（死链）           | ✅ 不影响（数据还在）        |\n| 文件大小     | 路径字符串长度              | 和源文件大小相同           |\n| 典型用途     | 快捷方式、版本切换            | 数据保护、防止误删          |\n| 命令       | ln -s target newFile | ln  target newFile |\n- 软链接保存的是指向文件的路径, 文件删除则软链接变死链;\n- 硬链接是“同一个文件的多个名字”, 删除源文件, 但是有副本","slug":"Linux","published":1,"updated":"2025-09-21T06:05:40.257Z","comments":1,"layout":"post","photos":[],"_id":"cmfw4z094000buomw9cb0eq99","content":"<h1 id=\"Linux-Shell-命令整理\"><a href=\"#Linux-Shell-命令整理\" class=\"headerlink\" title=\"Linux Shell 命令整理\"></a>Linux Shell 命令整理</h1><h2 id=\"Linux-目录结构\"><a href=\"#Linux-目录结构\" class=\"headerlink\" title=\"Linux 目录结构\"></a>Linux 目录结构</h2><ol>\n<li>/：根目录，所有文件和目录的起点。</li>\n<li>/bin：存放基础命令的可执行文件，如 ls、cp。</li>\n<li>/sbin：系统管理命令所在目录，普通用户通常没有权限。</li>\n<li>/etc：系统配置文件目录，如网络和服务配置。 (source /etc/profile: 刷新系统配置)</li>\n<li>/home：用户主目录，每个用户有自己的文件存储位置。</li>\n<li>/root：超级用户（root）的主目录。</li>\n<li>/var：存放日志、缓存、临时文件等可变数据。</li>\n<li>/usr：存放用户级应用程序和共享文件。</li>\n<li>/lib：系统基本库文件，支持 /bin 和 /sbin 命令。</li>\n<li>/opt：用于安装第三方或可选软件包。</li>\n<li>/dev：设备文件目录，所有硬件设备在此表示为文件。</li>\n<li>/proc：虚拟文件系统，存放内核和进程信息。</li>\n<li>/tmp：临时文件目录，系统重启后可能会清空。</li>\n<li>/boot：存放启动相关文件，如内核和引导加载程序。</li>\n<li>/mnt 和 /media：用于临时挂载外部设备。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17582598048201758259804688.png\" alt=\"17582598048201758259804688.png\"></li>\n</ol>\n<h2 id=\"用户管理\"><a href=\"#用户管理\" class=\"headerlink\" title=\"用户管理\"></a>用户管理</h2><h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd -m -s /bin/bash -u 501 King</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-m</code>：创建用户的家目录 <code>/home/King</code></li>\n<li><code>-s /bin/bash</code>：指定默认 Shell 解释器为 Bash</li>\n<li><code>-u 501</code>：指定用户 ID（UID）为 501</li>\n</ul>\n<h3 id=\"设置用户密码\"><a href=\"#设置用户密码\" class=\"headerlink\" title=\"设置用户密码\"></a>设置用户密码</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passwd King</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输入两次新密码即可完成用户密码设置。</li>\n</ul>\n<h3 id=\"修改用户名\"><a href=\"#修改用户名\" class=\"headerlink\" title=\"修改用户名\"></a>修改用户名</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">usermod -l Queen King</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-l</code>：更改用户名，将 <code>King</code> 修改为 <code>Queen</code></li>\n</ul>\n<h3 id=\"查看用户信息-配置文件\"><a href=\"#查看用户信息-配置文件\" class=\"headerlink\" title=\"查看用户信息(配置文件)\"></a>查看用户信息(配置文件)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> /etc/passwd</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>每个用户占一行，格式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户名:密码(加密后):用户ID:组ID:描述:家目录:默认Shell</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"查看用户所属组\"><a href=\"#查看用户所属组\" class=\"headerlink\" title=\"查看用户所属组\"></a>查看用户所属组</h3><ul>\n<li>每个用户都有一个用户id和用户名; 用户组也有名和id</li>\n<li><p>一个用户可用属于一个或多个用户组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">groups</span> Queen</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>显示 <code>Queen</code> 用户所属的组。</p>\n</li>\n</ul>\n<h3 id=\"创建用户组\"><a href=\"#创建用户组\" class=\"headerlink\" title=\"创建用户组\"></a>创建用户组</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupadd -g 501 QueenGroup</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-g 501</code>：指定组 ID（GID）为 501。</li>\n</ul>\n<h3 id=\"修改用户所属组\"><a href=\"#修改用户所属组\" class=\"headerlink\" title=\"修改用户所属组\"></a>修改用户所属组</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupmod -g QueenGroup Queen</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改 <code>Queen</code> 用户的主组为 <code>QueenGroup</code>。</li>\n</ul>\n<h3 id=\"查看组信息\"><a href=\"#查看组信息\" class=\"headerlink\" title=\"查看组信息\"></a>查看组信息</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> -n /etc/group</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-n</code>：显示行号。</li>\n<li><code>/etc/group</code> 文件包含所有用户组的信息。</li>\n</ul>\n<h3 id=\"过滤查询某个用户的组信息\"><a href=\"#过滤查询某个用户的组信息\" class=\"headerlink\" title=\"过滤查询某个用户的组信息\"></a>过滤查询某个用户的组信息</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep <span class=\"string\">&#x27;King&#x27;</span> /etc/group</span><br></pre></td></tr></table></figure>\n<ul>\n<li>仅显示 <code>King</code> 用户的组信息。</li>\n</ul>\n<h3 id=\"查看当前登录用户\"><a href=\"#查看当前登录用户\" class=\"headerlink\" title=\"查看当前登录用户\"></a>查看当前登录用户</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">who</span> -H</span><br></pre></td></tr></table></figure>\n<ul>\n<li>显示当前登录的用户列表。<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2></li>\n<li>PCB: process control blocker, 一个进程有一个PCB单元, 作用是进程描述, 进程调度(5种)… <h3 id=\"查看当前时间\"><a href=\"#查看当前时间\" class=\"headerlink\" title=\"查看当前时间\"></a>查看当前时间</h3></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">date</span> <span class=\"string\">&quot;+%Y-%m-%d %H:%M:%S&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>显示当前时间，格式为 <code>年-月-日 时:分:秒</code>。</li>\n</ul>\n<h3 id=\"查询进程\"><a href=\"#查询进程\" class=\"headerlink\" title=\"查询进程\"></a>查询进程</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -l</span><br><span class=\"line\">ps -ef -u root | grep mysqld</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>ps -ef</code>：显示所有进程详细信息。</li>\n<li><code>-u root</code>：筛选 root 用户的进程。</li>\n<li><code>grep mysqld</code>：查找包含 <code>mysqld</code> 关键字的进程。</li>\n</ul>\n<h3 id=\"强行终止进程\"><a href=\"#强行终止进程\" class=\"headerlink\" title=\"强行终止进程\"></a>强行终止进程</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">kill</span> -9 3306</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-9</code>：强制终止进程，<code>3306</code> 是进程 ID。<h3 id=\"执行进程\"><a href=\"#执行进程\" class=\"headerlink\" title=\"执行进程\"></a>执行进程</h3></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 后台执行,将命令的信息重定向到指定的文件</span><br><span class=\"line\"><span class=\"built_in\">nohup</span> <span class=\"built_in\">command</span> [参数] &gt; output_file 2&gt;&amp;1 &amp;</span><br><span class=\"line\">// 例子:</span><br><span class=\"line\"><span class=\"built_in\">nohup</span> java -jar -Dspring.profiles.active=dev ./javaProject.jar &gt; ./log.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看端口是否被占用\"><a href=\"#查看端口是否被占用\" class=\"headerlink\" title=\"查看端口是否被占用\"></a>查看端口是否被占用</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -anp | grep 3306</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -nltp</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-a</code> → 列出所有的端口。</li>\n<li><code>-n</code> → 直接显示 IP 和端口，不做域名解析。</li>\n<li><code>-l</code> → 仅显示处于监听状态的套接字。</li>\n<li><code>-t</code> → 显示 TCP 连接。</li>\n<li><code>-p</code> → 显示进程 PID 和程序名。<h3 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h3></li>\n<li>确定进程执行的先后以实现最大 CPU 利用率<ul>\n<li><strong>先到先服务调度算法</strong>(FCFS，First Come, First Served) : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>\n<li><strong>短作业优先的调度算法</strong>(SJF，Shortest Job First) : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>\n<li><strong>时间片轮转调度算法</strong>（RR，Round-Robin） : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>\n<li><strong>多级反馈队列调度算法</strong>（MFQ，Multi-level Feedback Queue）：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</li>\n<li><strong>优先级调度算法</strong>（Priority）：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。<h3 id=\"僵尸进程和孤儿进程\"><a href=\"#僵尸进程和孤儿进程\" class=\"headerlink\" title=\"僵尸进程和孤儿进程\"></a>僵尸进程和孤儿进程</h3></li>\n</ul>\n</li>\n<li>僵尸进程  子进程由于某些原因停止运行, 但是他的父进程仍然还在运行, 必须通过wait()或者wiatpid()来回收父进程</li>\n<li>孤儿进程  父进程意外终止, 子进程仍然运行, 没有调用wait()或者waitpid()回收进程, 但是操作系统会通过将子进程的父进程设置为init, 由init进程来回收子进程<h2 id=\"服务管理\"><a href=\"#服务管理\" class=\"headerlink\" title=\"服务管理\"></a>服务管理</h2></li>\n</ul>\n<h3 id=\"查看服务状态\"><a href=\"#查看服务状态\" class=\"headerlink\" title=\"查看服务状态\"></a>查看服务状态</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status firewalld.service</span><br></pre></td></tr></table></figure>\n<ul>\n<li>检查 <code>firewalld</code> 防火墙的运行状态。</li>\n</ul>\n<h3 id=\"启用服务自启动\"><a href=\"#启用服务自启动\" class=\"headerlink\" title=\"启用服务自启动\"></a>启用服务自启动</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> firewalld.service</span><br></pre></td></tr></table></figure>\n<ul>\n<li>设置 <code>firewalld</code> 开机自启动。<h2 id=\"文件和目录操作\"><a href=\"#文件和目录操作\" class=\"headerlink\" title=\"文件和目录操作\"></a>文件和目录操作</h2></li>\n</ul>\n<h3 id=\"复制文件-仅在源文件比目标文件新时执行\"><a href=\"#复制文件-仅在源文件比目标文件新时执行\" class=\"headerlink\" title=\"复制文件(仅在源文件比目标文件新时执行)\"></a>复制文件(仅在源文件比目标文件新时执行)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cp</span> -u 源文件 目标文件夹path</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-u</code>：仅在目标文件较旧或不存在时才复制。</li>\n</ul>\n<h3 id=\"移动文件（仅在目标文件较旧时执行）\"><a href=\"#移动文件（仅在目标文件较旧时执行）\" class=\"headerlink\" title=\"移动文件（仅在目标文件较旧时执行）\"></a>移动文件（仅在目标文件较旧时执行）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mv</span> -u 源文件 目标文件夹path</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-u</code>：仅在目标文件较旧或不存在时才移动。</li>\n</ul>\n<h3 id=\"修改文件权限\"><a href=\"#修改文件权限\" class=\"headerlink\" title=\"修改文件权限\"></a>修改文件权限</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> -Rv 777 文件夹/文件</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-R</code>：递归修改所有子目录。</li>\n<li><code>-v</code>：显示修改的过程。</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17582812784061758281277599.png\" alt=\"17582812784061758281277599.png\"></p>\n<h3 id=\"列出文件（不包括隐藏文件）\"><a href=\"#列出文件（不包括隐藏文件）\" class=\"headerlink\" title=\"列出文件（不包括隐藏文件）\"></a>列出文件（不包括隐藏文件）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> -l 文件名</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-l</code>:  列出当前目录可见文件详细信息</li>\n<li><code>-al</code>: 列出所有文件,包含隐藏文件</li>\n</ul>\n<h3 id=\"实时查看文件末尾\"><a href=\"#实时查看文件末尾\" class=\"headerlink\" title=\"实时查看文件末尾\"></a>实时查看文件末尾</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">tail</span> -n 10 -f 文件名</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-n 10</code>：显示最后 10 行。</li>\n<li><code>-f</code>：实时更新输出内容。</li>\n</ul>\n<h3 id=\"向文件追加内容\"><a href=\"#向文件追加内容\" class=\"headerlink\" title=\"向文件追加内容\"></a>向文件追加内容</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;hello&quot;</span> &gt;&gt; a.txt</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>&gt;&gt;</code> 表示追加内容到 <code>a.txt</code> 文件。</li>\n</ul>\n<h3 id=\"查找特定类型文件\"><a href=\"#查找特定类型文件\" class=\"headerlink\" title=\"查找特定类型文件\"></a>查找特定类型文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /package -name <span class=\"string\">&#x27;*.sh&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>在 <code>/package</code> 目录下查找所有 <code>.sh</code> 结尾的文件。</li>\n</ul>\n<h3 id=\"对文件内容排序\"><a href=\"#对文件内容排序\" class=\"headerlink\" title=\"对文件内容排序\"></a>对文件内容排序</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span> -ur number.txt | <span class=\"built_in\">head</span> -n 5</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-u</code>：去重。</li>\n<li><code>-r</code>：降序排序。</li>\n<li><code>head -n 5</code>：取前 5 行。</li>\n</ul>\n<h3 id=\"压缩和解压缩文件\"><a href=\"#压缩和解压缩文件\" class=\"headerlink\" title=\"压缩和解压缩文件\"></a>压缩和解压缩文件</h3><p>压缩文件1和文件2 为一个文件:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zcvf 压缩后文件名.tar.gz 源文件1 源文件2</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-z</code>：使用 gzip 压缩。</li>\n<li><code>-c</code>：创建压缩包。</li>\n<li><code>-v</code>：显示详细信息。</li>\n<li><code>-f</code>：指定文件名。</li>\n</ul>\n<p>解压缩：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf 文件.tar.gz</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-z</code>：使用 gzip 压缩。</li>\n<li><code>-x</code>：解压缩。</li>\n<li><code>-v</code>：显示详细信息。</li>\n<li><code>-f</code>：指定文件名。<h2 id=\"网络管理\"><a href=\"#网络管理\" class=\"headerlink\" title=\"网络管理\"></a>网络管理</h2></li>\n</ul>\n<h3 id=\"设置命令别名\"><a href=\"#设置命令别名\" class=\"headerlink\" title=\"设置命令别名\"></a>设置命令别名</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> ll=<span class=\"string\">&#x27;ls -l --color=auto&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>alias</code> 用于给命令取别名。</li>\n</ul>\n<h3 id=\"启动网络服务\"><a href=\"#启动网络服务\" class=\"headerlink\" title=\"启动网络服务\"></a>启动网络服务</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service network start</span><br></pre></td></tr></table></figure>\n<ul>\n<li>开启网络。</li>\n</ul>\n<h3 id=\"启用-禁用网卡\"><a href=\"#启用-禁用网卡\" class=\"headerlink\" title=\"启用/禁用网卡\"></a>启用/禁用网卡</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifconfig ens33 up   <span class=\"comment\"># 启用网卡</span></span><br><span class=\"line\">ifconfig ens33 down <span class=\"comment\"># 禁用网卡</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"测试网络连通性\"><a href=\"#测试网络连通性\" class=\"headerlink\" title=\"测试网络连通性\"></a>测试网络连通性</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping -c 3 www.baidu.com</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-c 3</code>：只执行 3 次 ping。</li>\n</ul>\n<h3 id=\"查看端口占用情况\"><a href=\"#查看端口占用情况\" class=\"headerlink\" title=\"查看端口占用情况\"></a>查看端口占用情况</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -anp | grep 3306</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-a</code>：显示所有连接。</li>\n<li><code>-n</code>：显示数字格式的 IP 地址和端口。</li>\n<li><code>-p</code>：显示进程信息。<h2 id=\"系统管理\"><a href=\"#系统管理\" class=\"headerlink\" title=\"系统管理\"></a>系统管理</h2></li>\n</ul>\n<h3 id=\"查看磁盘使用情况\"><a href=\"#查看磁盘使用情况\" class=\"headerlink\" title=\"查看磁盘使用情况\"></a>查看磁盘使用情况</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">df</span> -h --total</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-h</code>：以人类可读的格式显示。</li>\n<li><code>--total</code>：显示总计信息。</li>\n</ul>\n<h3 id=\"查看块设备\"><a href=\"#查看块设备\" class=\"headerlink\" title=\"查看块设备\"></a>查看块设备</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsblk</span><br></pre></td></tr></table></figure>\n<ul>\n<li>以树状结构显示所有块设备。</li>\n</ul>\n<h3 id=\"查看内存、CPU、进程、I-O-等性能状态\"><a href=\"#查看内存、CPU、进程、I-O-等性能状态\" class=\"headerlink\" title=\"查看内存、CPU、进程、I/O 等性能状态\"></a>查看内存、CPU、进程、I/O 等性能状态</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vmstat 1 <span class=\"comment\"># 每隔1s显示系统情况</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-系统内存的使用情况\"><a href=\"#查看-系统内存的使用情况\" class=\"headerlink\" title=\"查看 系统内存的使用情况\"></a>查看 系统内存的使用情况</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -h  <span class=\"comment\"># -h人类可读</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"设置虚拟网卡\"><a href=\"#设置虚拟网卡\" class=\"headerlink\" title=\"设置虚拟网卡\"></a>设置虚拟网卡</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure>\n<h2 id=\"脚本Shell\"><a href=\"#脚本Shell\" class=\"headerlink\" title=\"脚本Shell\"></a>脚本Shell</h2><ul>\n<li>指定脚本解释器写,shell的习惯第一行指定解释器 例如  #!jdk17/bin/java.exe<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17583670223771758367021565.png\" alt=\"17583670223771758367021565.png\"><br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17583670422641758367041783.png\" alt=\"17583670422641758367041783.png\"><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh   </span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$home</span>  <span class=\"comment\"># 查询系统变量</span></span><br><span class=\"line\">name = <span class=\"string\">&#x27;root&#x27;</span></span><br><span class=\"line\">hello=<span class=\"string\">&#x27;Hello, I am $name!&#x27;</span> </span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$hello</span>  <span class=\"comment\"># 输出&#123;变量&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">str=<span class=\"string\">&quot;iLoveChina&quot;</span> </span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;str&#125;</span> <span class=\"comment\"># 输出&#123;变量&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">array=(! @ <span class=\"comment\"># $ %)  </span></span><br><span class=\"line\">length=<span class=\"variable\">$&#123;#array[@]&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;array[1]&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">a=1</span><br><span class=\"line\">b=2</span><br><span class=\"line\"><span class=\"comment\"># if条件判断 判断a是否大于b</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$&#123;a&#125;</span> -eq <span class=\"variable\">$&#123;b&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;a=b&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [ <span class=\"variable\">$&#123;a&#125;</span> -gt <span class=\"variable\">$&#123;b&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;a&gt;b&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;a&lt;b&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># for循环</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> loop <span class=\"keyword\">in</span> A B C D E F G </span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;顺序输出字母为: <span class=\"variable\">$loop</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">d</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;请录入第一个数&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">read</span> number1</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;请录入第二个数&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">read</span> number2</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;两个数字分别为 <span class=\"variable\">$&#123;number1&#125;</span>, <span class=\"variable\">$&#123;number2&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> $((number1 + number2))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">d</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $?</span><br></pre></td></tr></table></figure>\n<h2 id=\"Vim-编辑器\"><a href=\"#Vim-编辑器\" class=\"headerlink\" title=\"Vim 编辑器\"></a>Vim 编辑器</h2></li>\n</ul>\n<h3 id=\"普通模式命令\"><a href=\"#普通模式命令\" class=\"headerlink\" title=\"普通模式命令\"></a>普通模式命令</h3><h4 id=\"光标移动\"><a href=\"#光标移动\" class=\"headerlink\" title=\"光标移动\"></a>光标移动</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h：向左移动</span><br><span class=\"line\">j：向下移动</span><br><span class=\"line\">k：向上移动</span><br><span class=\"line\">l：向右移动</span><br><span class=\"line\"><span class=\"number\">0</span>：移动到行首</span><br><span class=\"line\">$：移动到行尾</span><br><span class=\"line\">gg：移动到文件开头</span><br><span class=\"line\">G：移动到文件结尾</span><br></pre></td></tr></table></figure>\n<h4 id=\"文本操作\"><a href=\"#文本操作\" class=\"headerlink\" title=\"文本操作\"></a>文本操作</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x：删除光标下的字符</span><br><span class=\"line\">dd：删除当前行</span><br><span class=\"line\">yy：复制当前行</span><br><span class=\"line\">p：粘贴（在光标后插入）</span><br><span class=\"line\">u：撤销</span><br><span class=\"line\">Ctrl + r：重做</span><br></pre></td></tr></table></figure>\n<h4 id=\"查找和替换\"><a href=\"#查找和替换\" class=\"headerlink\" title=\"查找和替换\"></a>查找和替换</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/text：向下查找 text</span><br><span class=\"line\">?text：向上查找 text</span><br><span class=\"line\">n：跳转到下一个匹配</span><br><span class=\"line\">N：跳转到上一个匹配</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令行模式命令\"><a href=\"#命令行模式命令\" class=\"headerlink\" title=\"命令行模式命令\"></a>命令行模式命令</h3><h4 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:w：保存文件</span><br><span class=\"line\">:q：退出 vi</span><br><span class=\"line\">:wq 或 ZZ：保存并退出</span><br><span class=\"line\">:q!：强制退出而不保存</span><br><span class=\"line\">:set nu：显示行号</span><br><span class=\"line\">:set nonu：隐藏行号</span><br></pre></td></tr></table></figure>\n<h4 id=\"撤销与重做\"><a href=\"#撤销与重做\" class=\"headerlink\" title=\"撤销与重做\"></a>撤销与重做</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u：撤销上一步操作</span><br><span class=\"line\">Ctrl + r：重做上一步操作</span><br></pre></td></tr></table></figure>\n<h4 id=\"文件操作-1\"><a href=\"#文件操作-1\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:e filename：打开新文件</span><br><span class=\"line\">:r filename：将文件内容插入当前文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"查找内容\"><a href=\"#查找内容\" class=\"headerlink\" title=\"查找内容\"></a>查找内容</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/关键字  # 向下查找关键字</span><br><span class=\"line\">?关键字  # 向上查找关键字</span><br></pre></td></tr></table></figure>\n<h2 id=\"AB压力测试\"><a href=\"#AB压力测试\" class=\"headerlink\" title=\"AB压力测试\"></a>AB压力测试</h2><ul>\n<li>Apache服务器的性能测试工具, 会创建并发线程访问同一个url(Web服务)</li>\n<li><code>ab -c 10 -n 100 http://www.myvick.cn/index.php</code>：同时处理100个请求并运行10次index.php<ul>\n<li>-c10表示并发用户数为10</li>\n<li>-n100表示请求总数为100<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Server Software:        nginx/1.13.6   <span class=\"comment\">#测试服务器的名字</span></span><br><span class=\"line\">Server Hostname:        www.myvick.cn  <span class=\"comment\">#请求的URL主机名</span></span><br><span class=\"line\">Server Port:            80             <span class=\"comment\">#web服务器监听的端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">Document Path:          /index.php　　  <span class=\"comment\">#请求的URL中的根绝对路径，通过该文件的后缀名，我们一般可以了解该请求的类型</span></span><br><span class=\"line\">Document Length:        799 bytes       <span class=\"comment\">#HTTP响应数据的正文长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">Concurrency Level:      10　　　　　　　　<span class=\"comment\"># 并发用户数，这是我们设置的参数之一</span></span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   0.668 seconds   <span class=\"comment\">#所有这些请求被处理完成所花费的总时间 单位秒</span></span><br><span class=\"line\">Complete requests:      100 　　　　　　  <span class=\"comment\"># 总请求数量，这是我们设置的参数之一</span></span><br><span class=\"line\">Failed requests:        0　　　　　　　　  <span class=\"comment\"># 表示失败的请求数量，这里的失败是指请求在连接服务器、发送数据等环节发生异常，以及无响应后超时的情况</span></span><br><span class=\"line\">Write errors:           0</span><br><span class=\"line\">Total transferred:      96200 bytes　　　 <span class=\"comment\">#所有请求的响应数据长度总和。包括每个HTTP响应数据的头信息和正文数据的长度</span></span><br><span class=\"line\">HTML transferred:       79900 bytes　　　　<span class=\"comment\"># 所有请求的响应数据中正文数据的总和，也就是减去了Total transferred中HTTP响应数据中的头信息的长度</span></span><br><span class=\"line\">Requests per second:    149.71 [#/sec] (mean) <span class=\"comment\">#吞吐率，计算公式：Complete requests/Time taken for tests  总请求数/处理完成这些请求数所花费的时间</span></span><br><span class=\"line\">Time per request:       66.797 [ms] (mean)   <span class=\"comment\"># 用户平均请求等待时间，计算公式：Time token for tests/（Complete requests/Concurrency Level）。处理完成所有请求数所花费的时间/（总请求数/并发用户数）</span></span><br><span class=\"line\">Time per request:       6.680 [ms] (mean, across all concurrent requests) <span class=\"comment\">#服务器平均请求等待时间，计算公式：Time taken for tests/Complete requests，正好是吞吐率的倒数。也可以这么统计：Time per request/Concurrency Level</span></span><br><span class=\"line\">Transfer rate:          140.64 [Kbytes/sec] received  <span class=\"comment\">#表示这些请求在单位时间内从服务器获取的数据长度，计算公式：Total trnasferred/ Time taken for tests，这个统计很好的说明服务器的处理能力达到极限时，其出口宽带的需求量。</span></span><br><span class=\"line\"></span><br><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">              min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:        1    2   0.7      2       5</span><br><span class=\"line\">Processing:     2   26  81.3      3     615</span><br><span class=\"line\">Waiting:        1   26  81.3      3     615</span><br><span class=\"line\">Total:          3   28  81.3      6     618</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"问答\"><a href=\"#问答\" class=\"headerlink\" title=\"问答\"></a>问答</h2><h3 id=\"如何发起Http请求\"><a href=\"#如何发起Http请求\" class=\"headerlink\" title=\"如何发起Http请求\"></a>如何发起Http请求</h3></li>\n</ul>\n</li>\n<li>不同网络主机要通信一必须通过<strong>Socket(套接字)</strong>建立<strong>传输层连接</strong>（TCP/UDP）一→然后在上层跑具体的<strong>应用层协议</strong>(HTTP、MQTT、WebSocket等）实现数据格式约定和业务逻辑。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://baidu.com  <span class=\"comment\"># Get请求</span></span><br><span class=\"line\">curl -X POST https://baidu.com <span class=\"string\">&quot;name=123&amp;password=456&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">wget https://baidu.com</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是线程的死锁\"><a href=\"#什么是线程的死锁\" class=\"headerlink\" title=\"什么是线程的死锁\"></a>什么是线程的死锁</h3></li>\n<li>互斥条件:  一个资源一个线程, 如果一个线程持有资源, 那么其他线程想要访问这个资源必须等待</li>\n<li>持有并等待条件:  一个资源被一个线程占有一段时间, 另一个线程必须死等</li>\n<li>不可剥夺条件:  已经分配资源给进程, 该资源不可被强制剥夺, 并主动释放</li>\n<li>循环等待条件:  a持有资源1 请求支援2;  b持有资源2 请求资源1;  想当与循环依赖<h3 id=\"怎么在Linux上安装Java环境\"><a href=\"#怎么在Linux上安装Java环境\" class=\"headerlink\" title=\"怎么在Linux上安装Java环境\"></a>怎么在Linux上安装Java环境</h3></li>\n</ul>\n<ol>\n<li>下载Linux版本的jdk安装包</li>\n<li>tar -zxvf 解压缩安装包</li>\n<li>配置环境变量 export JAVA_HOME=/usr/local/java/jdk17</li>\n<li>配置路径变量 export PATH=$JAVA-HOME/bin: $PATH</li>\n<li>刷新配置 source /etc/profile</li>\n<li>使用 java —version验证是否安装成功</li>\n<li>使用<code>echo &quot;$PATH&quot;</code>查看是否加入到系统bin目录<h3 id=\"ps和netstat的区别\"><a href=\"#ps和netstat的区别\" class=\"headerlink\" title=\"ps和netstat的区别\"></a><code>ps</code>和<code>netstat</code>的区别</h3>| 特性   | netstat              | ps                     |<br>| —— | —————————— | ——————————— |<br>| 关注点  | 网络连接、端口、协议状态         | 进程运行状态、CPU/内存资源        |<br>| 典型用途 | 看端口是否被占用，连接是否正常      | 看进程是否运行，消耗多少资源         |<br>| 输出重点 | TCP/UDP 连接，监听端口，路由   | PID、父子进程关系、命令、用户       |<br>| 结合场景 | 常和 <code>ps</code> 配合用来查哪个进程占端口 | 常和 <code>netstat</code> 配合找进程网络行为 |</li>\n</ol>\n<ul>\n<li>netstat注重端口(网络连接);  ps注重进程情况<h3 id=\"如何统计-HTTPS-服务（通常运行在端口-443）每秒的请求数\"><a href=\"#如何统计-HTTPS-服务（通常运行在端口-443）每秒的请求数\" class=\"headerlink\" title=\"如何统计 HTTPS 服务（通常运行在端口 443）每秒的请求数\"></a>如何统计 HTTPS 服务（通常运行在端口 443）每秒的请求数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch -n 1 <span class=\"string\">&quot;netstat -an | grep &#x27;:443&#x27;&quot;</span><span class=\"string\">&quot;</span></span><br></pre></td></tr></table></figure></li>\n<li><code>netstat -an</code>：显示所有连接和监听端口。</li>\n<li><code>grep &#39;:443 &#39;</code>：过滤出端口 443 的连接。</li>\n<li><code>grep ESTABLISHED</code>：过滤出已经建立的连接。</li>\n<li><code>wc -l</code>：统计连接数。</li>\n<li><code>watch -n 1</code>：每秒刷新一次命令的输出。<h3 id=\"什么是软链接和硬链接\"><a href=\"#什么是软链接和硬链接\" class=\"headerlink\" title=\"什么是软链接和硬链接\"></a>什么是软链接和硬链接</h3>| 特性       | 软链接 (Symbolic)       | 硬链接 (Hard)         |<br>| ———— | —————————— | ————————— |<br>| inode    | 独立 inode，存储路径        | 和源文件 inode 相同      |<br>| 指向对象     | 文件路径（间接指向数据）         | 文件本身（直接指向数据）       |<br>| 是否可跨文件系统 | ✅ 可以                 | ❌ 不可以              |<br>| 是否可链接目录  | ✅ 可以                 | ❌ 不可以              |<br>| 删除源文件影响  | ❌ 软链失效（死链）           | ✅ 不影响（数据还在）        |<br>| 文件大小     | 路径字符串长度              | 和源文件大小相同           |<br>| 典型用途     | 快捷方式、版本切换            | 数据保护、防止误删          |<br>| 命令       | ln -s target newFile | ln  target newFile |</li>\n<li>软链接保存的是指向文件的路径, 文件删除则软链接变死链;</li>\n<li>硬链接是“同一个文件的多个名字”, 删除源文件, 但是有副本</li>\n</ul>\n","cover":"/img/view9.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"Linux-Shell-命令整理\"><a href=\"#Linux-Shell-命令整理\" class=\"headerlink\" title=\"Linux Shell 命令整理\"></a>Linux Shell 命令整理</h1><h2 id=\"Linux-目录结构\"><a href=\"#Linux-目录结构\" class=\"headerlink\" title=\"Linux 目录结构\"></a>Linux 目录结构</h2><ol>\n<li>/：根目录，所有文件和目录的起点。</li>\n<li>/bin：存放基础命令的可执行文件，如 ls、cp。</li>\n<li>/sbin：系统管理命令所在目录，普通用户通常没有权限。</li>\n<li>/etc：系统配置文件目录，如网络和服务配置。 (source /etc/profile: 刷新系统配置)</li>\n<li>/home：用户主目录，每个用户有自己的文件存储位置。</li>\n<li>/root：超级用户（root）的主目录。</li>\n<li>/var：存放日志、缓存、临时文件等可变数据。</li>\n<li>/usr：存放用户级应用程序和共享文件。</li>\n<li>/lib：系统基本库文件，支持 /bin 和 /sbin 命令。</li>\n<li>/opt：用于安装第三方或可选软件包。</li>\n<li>/dev：设备文件目录，所有硬件设备在此表示为文件。</li>\n<li>/proc：虚拟文件系统，存放内核和进程信息。</li>\n<li>/tmp：临时文件目录，系统重启后可能会清空。</li>\n<li>/boot：存放启动相关文件，如内核和引导加载程序。</li>\n<li>/mnt 和 /media：用于临时挂载外部设备。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17582598048201758259804688.png\" alt=\"17582598048201758259804688.png\"></li>\n</ol>\n<h2 id=\"用户管理\"><a href=\"#用户管理\" class=\"headerlink\" title=\"用户管理\"></a>用户管理</h2><h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useradd -m -s /bin/bash -u 501 King</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-m</code>：创建用户的家目录 <code>/home/King</code></li>\n<li><code>-s /bin/bash</code>：指定默认 Shell 解释器为 Bash</li>\n<li><code>-u 501</code>：指定用户 ID（UID）为 501</li>\n</ul>\n<h3 id=\"设置用户密码\"><a href=\"#设置用户密码\" class=\"headerlink\" title=\"设置用户密码\"></a>设置用户密码</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passwd King</span><br></pre></td></tr></table></figure>\n<ul>\n<li>输入两次新密码即可完成用户密码设置。</li>\n</ul>\n<h3 id=\"修改用户名\"><a href=\"#修改用户名\" class=\"headerlink\" title=\"修改用户名\"></a>修改用户名</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">usermod -l Queen King</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-l</code>：更改用户名，将 <code>King</code> 修改为 <code>Queen</code></li>\n</ul>\n<h3 id=\"查看用户信息-配置文件\"><a href=\"#查看用户信息-配置文件\" class=\"headerlink\" title=\"查看用户信息(配置文件)\"></a>查看用户信息(配置文件)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> /etc/passwd</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>每个用户占一行，格式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户名:密码(加密后):用户ID:组ID:描述:家目录:默认Shell</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"查看用户所属组\"><a href=\"#查看用户所属组\" class=\"headerlink\" title=\"查看用户所属组\"></a>查看用户所属组</h3><ul>\n<li>每个用户都有一个用户id和用户名; 用户组也有名和id</li>\n<li><p>一个用户可用属于一个或多个用户组</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">groups</span> Queen</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>显示 <code>Queen</code> 用户所属的组。</p>\n</li>\n</ul>\n<h3 id=\"创建用户组\"><a href=\"#创建用户组\" class=\"headerlink\" title=\"创建用户组\"></a>创建用户组</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupadd -g 501 QueenGroup</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-g 501</code>：指定组 ID（GID）为 501。</li>\n</ul>\n<h3 id=\"修改用户所属组\"><a href=\"#修改用户所属组\" class=\"headerlink\" title=\"修改用户所属组\"></a>修改用户所属组</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groupmod -g QueenGroup Queen</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改 <code>Queen</code> 用户的主组为 <code>QueenGroup</code>。</li>\n</ul>\n<h3 id=\"查看组信息\"><a href=\"#查看组信息\" class=\"headerlink\" title=\"查看组信息\"></a>查看组信息</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> -n /etc/group</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-n</code>：显示行号。</li>\n<li><code>/etc/group</code> 文件包含所有用户组的信息。</li>\n</ul>\n<h3 id=\"过滤查询某个用户的组信息\"><a href=\"#过滤查询某个用户的组信息\" class=\"headerlink\" title=\"过滤查询某个用户的组信息\"></a>过滤查询某个用户的组信息</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep <span class=\"string\">&#x27;King&#x27;</span> /etc/group</span><br></pre></td></tr></table></figure>\n<ul>\n<li>仅显示 <code>King</code> 用户的组信息。</li>\n</ul>\n<h3 id=\"查看当前登录用户\"><a href=\"#查看当前登录用户\" class=\"headerlink\" title=\"查看当前登录用户\"></a>查看当前登录用户</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">who</span> -H</span><br></pre></td></tr></table></figure>\n<ul>\n<li>显示当前登录的用户列表。<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2></li>\n<li>PCB: process control blocker, 一个进程有一个PCB单元, 作用是进程描述, 进程调度(5种)… <h3 id=\"查看当前时间\"><a href=\"#查看当前时间\" class=\"headerlink\" title=\"查看当前时间\"></a>查看当前时间</h3></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">date</span> <span class=\"string\">&quot;+%Y-%m-%d %H:%M:%S&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>显示当前时间，格式为 <code>年-月-日 时:分:秒</code>。</li>\n</ul>\n<h3 id=\"查询进程\"><a href=\"#查询进程\" class=\"headerlink\" title=\"查询进程\"></a>查询进程</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -l</span><br><span class=\"line\">ps -ef -u root | grep mysqld</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>ps -ef</code>：显示所有进程详细信息。</li>\n<li><code>-u root</code>：筛选 root 用户的进程。</li>\n<li><code>grep mysqld</code>：查找包含 <code>mysqld</code> 关键字的进程。</li>\n</ul>\n<h3 id=\"强行终止进程\"><a href=\"#强行终止进程\" class=\"headerlink\" title=\"强行终止进程\"></a>强行终止进程</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">kill</span> -9 3306</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-9</code>：强制终止进程，<code>3306</code> 是进程 ID。<h3 id=\"执行进程\"><a href=\"#执行进程\" class=\"headerlink\" title=\"执行进程\"></a>执行进程</h3></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 后台执行,将命令的信息重定向到指定的文件</span><br><span class=\"line\"><span class=\"built_in\">nohup</span> <span class=\"built_in\">command</span> [参数] &gt; output_file 2&gt;&amp;1 &amp;</span><br><span class=\"line\">// 例子:</span><br><span class=\"line\"><span class=\"built_in\">nohup</span> java -jar -Dspring.profiles.active=dev ./javaProject.jar &gt; ./log.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看端口是否被占用\"><a href=\"#查看端口是否被占用\" class=\"headerlink\" title=\"查看端口是否被占用\"></a>查看端口是否被占用</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -anp | grep 3306</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -nltp</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-a</code> → 列出所有的端口。</li>\n<li><code>-n</code> → 直接显示 IP 和端口，不做域名解析。</li>\n<li><code>-l</code> → 仅显示处于监听状态的套接字。</li>\n<li><code>-t</code> → 显示 TCP 连接。</li>\n<li><code>-p</code> → 显示进程 PID 和程序名。<h3 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h3></li>\n<li>确定进程执行的先后以实现最大 CPU 利用率<ul>\n<li><strong>先到先服务调度算法</strong>(FCFS，First Come, First Served) : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>\n<li><strong>短作业优先的调度算法</strong>(SJF，Shortest Job First) : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>\n<li><strong>时间片轮转调度算法</strong>（RR，Round-Robin） : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>\n<li><strong>多级反馈队列调度算法</strong>（MFQ，Multi-level Feedback Queue）：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</li>\n<li><strong>优先级调度算法</strong>（Priority）：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。<h3 id=\"僵尸进程和孤儿进程\"><a href=\"#僵尸进程和孤儿进程\" class=\"headerlink\" title=\"僵尸进程和孤儿进程\"></a>僵尸进程和孤儿进程</h3></li>\n</ul>\n</li>\n<li>僵尸进程  子进程由于某些原因停止运行, 但是他的父进程仍然还在运行, 必须通过wait()或者wiatpid()来回收父进程</li>\n<li>孤儿进程  父进程意外终止, 子进程仍然运行, 没有调用wait()或者waitpid()回收进程, 但是操作系统会通过将子进程的父进程设置为init, 由init进程来回收子进程<h2 id=\"服务管理\"><a href=\"#服务管理\" class=\"headerlink\" title=\"服务管理\"></a>服务管理</h2></li>\n</ul>\n<h3 id=\"查看服务状态\"><a href=\"#查看服务状态\" class=\"headerlink\" title=\"查看服务状态\"></a>查看服务状态</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status firewalld.service</span><br></pre></td></tr></table></figure>\n<ul>\n<li>检查 <code>firewalld</code> 防火墙的运行状态。</li>\n</ul>\n<h3 id=\"启用服务自启动\"><a href=\"#启用服务自启动\" class=\"headerlink\" title=\"启用服务自启动\"></a>启用服务自启动</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> firewalld.service</span><br></pre></td></tr></table></figure>\n<ul>\n<li>设置 <code>firewalld</code> 开机自启动。<h2 id=\"文件和目录操作\"><a href=\"#文件和目录操作\" class=\"headerlink\" title=\"文件和目录操作\"></a>文件和目录操作</h2></li>\n</ul>\n<h3 id=\"复制文件-仅在源文件比目标文件新时执行\"><a href=\"#复制文件-仅在源文件比目标文件新时执行\" class=\"headerlink\" title=\"复制文件(仅在源文件比目标文件新时执行)\"></a>复制文件(仅在源文件比目标文件新时执行)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cp</span> -u 源文件 目标文件夹path</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-u</code>：仅在目标文件较旧或不存在时才复制。</li>\n</ul>\n<h3 id=\"移动文件（仅在目标文件较旧时执行）\"><a href=\"#移动文件（仅在目标文件较旧时执行）\" class=\"headerlink\" title=\"移动文件（仅在目标文件较旧时执行）\"></a>移动文件（仅在目标文件较旧时执行）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mv</span> -u 源文件 目标文件夹path</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-u</code>：仅在目标文件较旧或不存在时才移动。</li>\n</ul>\n<h3 id=\"修改文件权限\"><a href=\"#修改文件权限\" class=\"headerlink\" title=\"修改文件权限\"></a>修改文件权限</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> -Rv 777 文件夹/文件</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-R</code>：递归修改所有子目录。</li>\n<li><code>-v</code>：显示修改的过程。</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17582812784061758281277599.png\" alt=\"17582812784061758281277599.png\"></p>\n<h3 id=\"列出文件（不包括隐藏文件）\"><a href=\"#列出文件（不包括隐藏文件）\" class=\"headerlink\" title=\"列出文件（不包括隐藏文件）\"></a>列出文件（不包括隐藏文件）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> -l 文件名</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-l</code>:  列出当前目录可见文件详细信息</li>\n<li><code>-al</code>: 列出所有文件,包含隐藏文件</li>\n</ul>\n<h3 id=\"实时查看文件末尾\"><a href=\"#实时查看文件末尾\" class=\"headerlink\" title=\"实时查看文件末尾\"></a>实时查看文件末尾</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">tail</span> -n 10 -f 文件名</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-n 10</code>：显示最后 10 行。</li>\n<li><code>-f</code>：实时更新输出内容。</li>\n</ul>\n<h3 id=\"向文件追加内容\"><a href=\"#向文件追加内容\" class=\"headerlink\" title=\"向文件追加内容\"></a>向文件追加内容</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;hello&quot;</span> &gt;&gt; a.txt</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>&gt;&gt;</code> 表示追加内容到 <code>a.txt</code> 文件。</li>\n</ul>\n<h3 id=\"查找特定类型文件\"><a href=\"#查找特定类型文件\" class=\"headerlink\" title=\"查找特定类型文件\"></a>查找特定类型文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /package -name <span class=\"string\">&#x27;*.sh&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>在 <code>/package</code> 目录下查找所有 <code>.sh</code> 结尾的文件。</li>\n</ul>\n<h3 id=\"对文件内容排序\"><a href=\"#对文件内容排序\" class=\"headerlink\" title=\"对文件内容排序\"></a>对文件内容排序</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span> -ur number.txt | <span class=\"built_in\">head</span> -n 5</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-u</code>：去重。</li>\n<li><code>-r</code>：降序排序。</li>\n<li><code>head -n 5</code>：取前 5 行。</li>\n</ul>\n<h3 id=\"压缩和解压缩文件\"><a href=\"#压缩和解压缩文件\" class=\"headerlink\" title=\"压缩和解压缩文件\"></a>压缩和解压缩文件</h3><p>压缩文件1和文件2 为一个文件:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zcvf 压缩后文件名.tar.gz 源文件1 源文件2</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-z</code>：使用 gzip 压缩。</li>\n<li><code>-c</code>：创建压缩包。</li>\n<li><code>-v</code>：显示详细信息。</li>\n<li><code>-f</code>：指定文件名。</li>\n</ul>\n<p>解压缩：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf 文件.tar.gz</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-z</code>：使用 gzip 压缩。</li>\n<li><code>-x</code>：解压缩。</li>\n<li><code>-v</code>：显示详细信息。</li>\n<li><code>-f</code>：指定文件名。<h2 id=\"网络管理\"><a href=\"#网络管理\" class=\"headerlink\" title=\"网络管理\"></a>网络管理</h2></li>\n</ul>\n<h3 id=\"设置命令别名\"><a href=\"#设置命令别名\" class=\"headerlink\" title=\"设置命令别名\"></a>设置命令别名</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> ll=<span class=\"string\">&#x27;ls -l --color=auto&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>alias</code> 用于给命令取别名。</li>\n</ul>\n<h3 id=\"启动网络服务\"><a href=\"#启动网络服务\" class=\"headerlink\" title=\"启动网络服务\"></a>启动网络服务</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service network start</span><br></pre></td></tr></table></figure>\n<ul>\n<li>开启网络。</li>\n</ul>\n<h3 id=\"启用-禁用网卡\"><a href=\"#启用-禁用网卡\" class=\"headerlink\" title=\"启用/禁用网卡\"></a>启用/禁用网卡</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifconfig ens33 up   <span class=\"comment\"># 启用网卡</span></span><br><span class=\"line\">ifconfig ens33 down <span class=\"comment\"># 禁用网卡</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"测试网络连通性\"><a href=\"#测试网络连通性\" class=\"headerlink\" title=\"测试网络连通性\"></a>测试网络连通性</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping -c 3 www.baidu.com</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-c 3</code>：只执行 3 次 ping。</li>\n</ul>\n<h3 id=\"查看端口占用情况\"><a href=\"#查看端口占用情况\" class=\"headerlink\" title=\"查看端口占用情况\"></a>查看端口占用情况</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -anp | grep 3306</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-a</code>：显示所有连接。</li>\n<li><code>-n</code>：显示数字格式的 IP 地址和端口。</li>\n<li><code>-p</code>：显示进程信息。<h2 id=\"系统管理\"><a href=\"#系统管理\" class=\"headerlink\" title=\"系统管理\"></a>系统管理</h2></li>\n</ul>\n<h3 id=\"查看磁盘使用情况\"><a href=\"#查看磁盘使用情况\" class=\"headerlink\" title=\"查看磁盘使用情况\"></a>查看磁盘使用情况</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">df</span> -h --total</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>-h</code>：以人类可读的格式显示。</li>\n<li><code>--total</code>：显示总计信息。</li>\n</ul>\n<h3 id=\"查看块设备\"><a href=\"#查看块设备\" class=\"headerlink\" title=\"查看块设备\"></a>查看块设备</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsblk</span><br></pre></td></tr></table></figure>\n<ul>\n<li>以树状结构显示所有块设备。</li>\n</ul>\n<h3 id=\"查看内存、CPU、进程、I-O-等性能状态\"><a href=\"#查看内存、CPU、进程、I-O-等性能状态\" class=\"headerlink\" title=\"查看内存、CPU、进程、I/O 等性能状态\"></a>查看内存、CPU、进程、I/O 等性能状态</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vmstat 1 <span class=\"comment\"># 每隔1s显示系统情况</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看-系统内存的使用情况\"><a href=\"#查看-系统内存的使用情况\" class=\"headerlink\" title=\"查看 系统内存的使用情况\"></a>查看 系统内存的使用情况</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -h  <span class=\"comment\"># -h人类可读</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"设置虚拟网卡\"><a href=\"#设置虚拟网卡\" class=\"headerlink\" title=\"设置虚拟网卡\"></a>设置虚拟网卡</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure>\n<h2 id=\"脚本Shell\"><a href=\"#脚本Shell\" class=\"headerlink\" title=\"脚本Shell\"></a>脚本Shell</h2><ul>\n<li>指定脚本解释器写,shell的习惯第一行指定解释器 例如  #!jdk17/bin/java.exe<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17583670223771758367021565.png\" alt=\"17583670223771758367021565.png\"><br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17583670422641758367041783.png\" alt=\"17583670422641758367041783.png\"><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh   </span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$home</span>  <span class=\"comment\"># 查询系统变量</span></span><br><span class=\"line\">name = <span class=\"string\">&#x27;root&#x27;</span></span><br><span class=\"line\">hello=<span class=\"string\">&#x27;Hello, I am $name!&#x27;</span> </span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$hello</span>  <span class=\"comment\"># 输出&#123;变量&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">str=<span class=\"string\">&quot;iLoveChina&quot;</span> </span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;str&#125;</span> <span class=\"comment\"># 输出&#123;变量&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">array=(! @ <span class=\"comment\"># $ %)  </span></span><br><span class=\"line\">length=<span class=\"variable\">$&#123;#array[@]&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;array[1]&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">a=1</span><br><span class=\"line\">b=2</span><br><span class=\"line\"><span class=\"comment\"># if条件判断 判断a是否大于b</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$&#123;a&#125;</span> -eq <span class=\"variable\">$&#123;b&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;a=b&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [ <span class=\"variable\">$&#123;a&#125;</span> -gt <span class=\"variable\">$&#123;b&#125;</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;a&gt;b&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;a&lt;b&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># for循环</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> loop <span class=\"keyword\">in</span> A B C D E F G </span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;顺序输出字母为: <span class=\"variable\">$loop</span>&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">d</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;请录入第一个数&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">read</span> number1</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;请录入第二个数&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">read</span> number2</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;两个数字分别为 <span class=\"variable\">$&#123;number1&#125;</span>, <span class=\"variable\">$&#123;number2&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> $((number1 + number2))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">d</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $?</span><br></pre></td></tr></table></figure>\n<h2 id=\"Vim-编辑器\"><a href=\"#Vim-编辑器\" class=\"headerlink\" title=\"Vim 编辑器\"></a>Vim 编辑器</h2></li>\n</ul>\n<h3 id=\"普通模式命令\"><a href=\"#普通模式命令\" class=\"headerlink\" title=\"普通模式命令\"></a>普通模式命令</h3><h4 id=\"光标移动\"><a href=\"#光标移动\" class=\"headerlink\" title=\"光标移动\"></a>光标移动</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h：向左移动</span><br><span class=\"line\">j：向下移动</span><br><span class=\"line\">k：向上移动</span><br><span class=\"line\">l：向右移动</span><br><span class=\"line\"><span class=\"number\">0</span>：移动到行首</span><br><span class=\"line\">$：移动到行尾</span><br><span class=\"line\">gg：移动到文件开头</span><br><span class=\"line\">G：移动到文件结尾</span><br></pre></td></tr></table></figure>\n<h4 id=\"文本操作\"><a href=\"#文本操作\" class=\"headerlink\" title=\"文本操作\"></a>文本操作</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x：删除光标下的字符</span><br><span class=\"line\">dd：删除当前行</span><br><span class=\"line\">yy：复制当前行</span><br><span class=\"line\">p：粘贴（在光标后插入）</span><br><span class=\"line\">u：撤销</span><br><span class=\"line\">Ctrl + r：重做</span><br></pre></td></tr></table></figure>\n<h4 id=\"查找和替换\"><a href=\"#查找和替换\" class=\"headerlink\" title=\"查找和替换\"></a>查找和替换</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/text：向下查找 text</span><br><span class=\"line\">?text：向上查找 text</span><br><span class=\"line\">n：跳转到下一个匹配</span><br><span class=\"line\">N：跳转到上一个匹配</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令行模式命令\"><a href=\"#命令行模式命令\" class=\"headerlink\" title=\"命令行模式命令\"></a>命令行模式命令</h3><h4 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:w：保存文件</span><br><span class=\"line\">:q：退出 vi</span><br><span class=\"line\">:wq 或 ZZ：保存并退出</span><br><span class=\"line\">:q!：强制退出而不保存</span><br><span class=\"line\">:set nu：显示行号</span><br><span class=\"line\">:set nonu：隐藏行号</span><br></pre></td></tr></table></figure>\n<h4 id=\"撤销与重做\"><a href=\"#撤销与重做\" class=\"headerlink\" title=\"撤销与重做\"></a>撤销与重做</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u：撤销上一步操作</span><br><span class=\"line\">Ctrl + r：重做上一步操作</span><br></pre></td></tr></table></figure>\n<h4 id=\"文件操作-1\"><a href=\"#文件操作-1\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:e filename：打开新文件</span><br><span class=\"line\">:r filename：将文件内容插入当前文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"查找内容\"><a href=\"#查找内容\" class=\"headerlink\" title=\"查找内容\"></a>查找内容</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/关键字  # 向下查找关键字</span><br><span class=\"line\">?关键字  # 向上查找关键字</span><br></pre></td></tr></table></figure>\n<h2 id=\"AB压力测试\"><a href=\"#AB压力测试\" class=\"headerlink\" title=\"AB压力测试\"></a>AB压力测试</h2><ul>\n<li>Apache服务器的性能测试工具, 会创建并发线程访问同一个url(Web服务)</li>\n<li><code>ab -c 10 -n 100 http://www.myvick.cn/index.php</code>：同时处理100个请求并运行10次index.php<ul>\n<li>-c10表示并发用户数为10</li>\n<li>-n100表示请求总数为100<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Server Software:        nginx/1.13.6   <span class=\"comment\">#测试服务器的名字</span></span><br><span class=\"line\">Server Hostname:        www.myvick.cn  <span class=\"comment\">#请求的URL主机名</span></span><br><span class=\"line\">Server Port:            80             <span class=\"comment\">#web服务器监听的端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">Document Path:          /index.php　　  <span class=\"comment\">#请求的URL中的根绝对路径，通过该文件的后缀名，我们一般可以了解该请求的类型</span></span><br><span class=\"line\">Document Length:        799 bytes       <span class=\"comment\">#HTTP响应数据的正文长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">Concurrency Level:      10　　　　　　　　<span class=\"comment\"># 并发用户数，这是我们设置的参数之一</span></span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   0.668 seconds   <span class=\"comment\">#所有这些请求被处理完成所花费的总时间 单位秒</span></span><br><span class=\"line\">Complete requests:      100 　　　　　　  <span class=\"comment\"># 总请求数量，这是我们设置的参数之一</span></span><br><span class=\"line\">Failed requests:        0　　　　　　　　  <span class=\"comment\"># 表示失败的请求数量，这里的失败是指请求在连接服务器、发送数据等环节发生异常，以及无响应后超时的情况</span></span><br><span class=\"line\">Write errors:           0</span><br><span class=\"line\">Total transferred:      96200 bytes　　　 <span class=\"comment\">#所有请求的响应数据长度总和。包括每个HTTP响应数据的头信息和正文数据的长度</span></span><br><span class=\"line\">HTML transferred:       79900 bytes　　　　<span class=\"comment\"># 所有请求的响应数据中正文数据的总和，也就是减去了Total transferred中HTTP响应数据中的头信息的长度</span></span><br><span class=\"line\">Requests per second:    149.71 [#/sec] (mean) <span class=\"comment\">#吞吐率，计算公式：Complete requests/Time taken for tests  总请求数/处理完成这些请求数所花费的时间</span></span><br><span class=\"line\">Time per request:       66.797 [ms] (mean)   <span class=\"comment\"># 用户平均请求等待时间，计算公式：Time token for tests/（Complete requests/Concurrency Level）。处理完成所有请求数所花费的时间/（总请求数/并发用户数）</span></span><br><span class=\"line\">Time per request:       6.680 [ms] (mean, across all concurrent requests) <span class=\"comment\">#服务器平均请求等待时间，计算公式：Time taken for tests/Complete requests，正好是吞吐率的倒数。也可以这么统计：Time per request/Concurrency Level</span></span><br><span class=\"line\">Transfer rate:          140.64 [Kbytes/sec] received  <span class=\"comment\">#表示这些请求在单位时间内从服务器获取的数据长度，计算公式：Total trnasferred/ Time taken for tests，这个统计很好的说明服务器的处理能力达到极限时，其出口宽带的需求量。</span></span><br><span class=\"line\"></span><br><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">              min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:        1    2   0.7      2       5</span><br><span class=\"line\">Processing:     2   26  81.3      3     615</span><br><span class=\"line\">Waiting:        1   26  81.3      3     615</span><br><span class=\"line\">Total:          3   28  81.3      6     618</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"问答\"><a href=\"#问答\" class=\"headerlink\" title=\"问答\"></a>问答</h2><h3 id=\"如何发起Http请求\"><a href=\"#如何发起Http请求\" class=\"headerlink\" title=\"如何发起Http请求\"></a>如何发起Http请求</h3></li>\n</ul>\n</li>\n<li>不同网络主机要通信一必须通过<strong>Socket(套接字)</strong>建立<strong>传输层连接</strong>（TCP/UDP）一→然后在上层跑具体的<strong>应用层协议</strong>(HTTP、MQTT、WebSocket等）实现数据格式约定和业务逻辑。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://baidu.com  <span class=\"comment\"># Get请求</span></span><br><span class=\"line\">curl -X POST https://baidu.com <span class=\"string\">&quot;name=123&amp;password=456&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">wget https://baidu.com</span><br></pre></td></tr></table></figure>\n<h3 id=\"什么是线程的死锁\"><a href=\"#什么是线程的死锁\" class=\"headerlink\" title=\"什么是线程的死锁\"></a>什么是线程的死锁</h3></li>\n<li>互斥条件:  一个资源一个线程, 如果一个线程持有资源, 那么其他线程想要访问这个资源必须等待</li>\n<li>持有并等待条件:  一个资源被一个线程占有一段时间, 另一个线程必须死等</li>\n<li>不可剥夺条件:  已经分配资源给进程, 该资源不可被强制剥夺, 并主动释放</li>\n<li>循环等待条件:  a持有资源1 请求支援2;  b持有资源2 请求资源1;  想当与循环依赖<h3 id=\"怎么在Linux上安装Java环境\"><a href=\"#怎么在Linux上安装Java环境\" class=\"headerlink\" title=\"怎么在Linux上安装Java环境\"></a>怎么在Linux上安装Java环境</h3></li>\n</ul>\n<ol>\n<li>下载Linux版本的jdk安装包</li>\n<li>tar -zxvf 解压缩安装包</li>\n<li>配置环境变量 export JAVA_HOME=/usr/local/java/jdk17</li>\n<li>配置路径变量 export PATH=$JAVA-HOME/bin: $PATH</li>\n<li>刷新配置 source /etc/profile</li>\n<li>使用 java —version验证是否安装成功</li>\n<li>使用<code>echo &quot;$PATH&quot;</code>查看是否加入到系统bin目录<h3 id=\"ps和netstat的区别\"><a href=\"#ps和netstat的区别\" class=\"headerlink\" title=\"ps和netstat的区别\"></a><code>ps</code>和<code>netstat</code>的区别</h3>| 特性   | netstat              | ps                     |<br>| —— | —————————— | ——————————— |<br>| 关注点  | 网络连接、端口、协议状态         | 进程运行状态、CPU/内存资源        |<br>| 典型用途 | 看端口是否被占用，连接是否正常      | 看进程是否运行，消耗多少资源         |<br>| 输出重点 | TCP/UDP 连接，监听端口，路由   | PID、父子进程关系、命令、用户       |<br>| 结合场景 | 常和 <code>ps</code> 配合用来查哪个进程占端口 | 常和 <code>netstat</code> 配合找进程网络行为 |</li>\n</ol>\n<ul>\n<li>netstat注重端口(网络连接);  ps注重进程情况<h3 id=\"如何统计-HTTPS-服务（通常运行在端口-443）每秒的请求数\"><a href=\"#如何统计-HTTPS-服务（通常运行在端口-443）每秒的请求数\" class=\"headerlink\" title=\"如何统计 HTTPS 服务（通常运行在端口 443）每秒的请求数\"></a>如何统计 HTTPS 服务（通常运行在端口 443）每秒的请求数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch -n 1 <span class=\"string\">&quot;netstat -an | grep &#x27;:443&#x27;&quot;</span><span class=\"string\">&quot;</span></span><br></pre></td></tr></table></figure></li>\n<li><code>netstat -an</code>：显示所有连接和监听端口。</li>\n<li><code>grep &#39;:443 &#39;</code>：过滤出端口 443 的连接。</li>\n<li><code>grep ESTABLISHED</code>：过滤出已经建立的连接。</li>\n<li><code>wc -l</code>：统计连接数。</li>\n<li><code>watch -n 1</code>：每秒刷新一次命令的输出。<h3 id=\"什么是软链接和硬链接\"><a href=\"#什么是软链接和硬链接\" class=\"headerlink\" title=\"什么是软链接和硬链接\"></a>什么是软链接和硬链接</h3>| 特性       | 软链接 (Symbolic)       | 硬链接 (Hard)         |<br>| ———— | —————————— | ————————— |<br>| inode    | 独立 inode，存储路径        | 和源文件 inode 相同      |<br>| 指向对象     | 文件路径（间接指向数据）         | 文件本身（直接指向数据）       |<br>| 是否可跨文件系统 | ✅ 可以                 | ❌ 不可以              |<br>| 是否可链接目录  | ✅ 可以                 | ❌ 不可以              |<br>| 删除源文件影响  | ❌ 软链失效（死链）           | ✅ 不影响（数据还在）        |<br>| 文件大小     | 路径字符串长度              | 和源文件大小相同           |<br>| 典型用途     | 快捷方式、版本切换            | 数据保护、防止误删          |<br>| 命令       | ln -s target newFile | ln  target newFile |</li>\n<li>软链接保存的是指向文件的路径, 文件删除则软链接变死链;</li>\n<li>硬链接是“同一个文件的多个名字”, 删除源文件, 但是有副本</li>\n</ul>\n"},{"title":"网络请求预检","date":"2024-12-31T08:32:51.000Z","_content":"\n# 网络请求预检(OptionalCheck)\n\n## 简介\n\n- OPTIONS请求**即预检请求**，可用于检测服务器允许的http方法。当发起跨域请求时，由于安全原因，**触发一定条件时**浏览器会在正式请求之前**自动先发起OPTIONS请求**，即CORS预检请求，服务器若接受该跨域请求，返回一个通过响应, 浏览器才继续发起正式请求。\n- 未配置允许`OPTIONS`请求，那么浏览器将收到一个**403 Forbidden**响应，表示服务器拒绝了该`OPTIONS`请求，`POST`请求的状态显示**CORS error**\n- Access-Control-Max-Age: 跨域预检测的option请求有效期\n\n## 分类\n\n- 简单请求: 不需要预检验\n  - 请求方法为: GET 和 POST和HEAD\n  - 请求体类型 Content-Type 为: 除了application/json外所有\n- 复杂请求: 通常需要发情预检验请求\n  - 请求方式为: PUT 和 DELETE\n  - 请求体类型 Content-Type 为: application/json\n- 预检请求方式为特殊的: OPTION请求\n\n## 参数\n\n**简单请求**\n\n- **Access-Control-Allow-Origin**\n  - 必须, 表示源地址, 要么是一个`*`，表示接受任意域名的请求(如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: `*`，必须指定具体域名)\n- **Access-Control-Allow-Credentials**\n  - 非必须, 表示是否允许发送Cookie, Boolean类型\n- **Access-Control-Expose-Headers**\n  - 非必须, 请求头参数\n\n**复杂请求**\n\n- **Access-Control-Request-Method**\n  - 预检请求必须: 询问请求方式是否允许\n- **Access-Control-Request-Headers**\n  - 预检请求必须, 询问请求头信息是否允许\n- **Access-Control-Allow-Methods**\n  - 预检响应必须: 得到允许的请求方式\n- **Access-Control-Allow-Headers**\n  - 预检响应必须: 得到允许的请求头信息\n- **Access-Control-Allow-Credentials**\n  - 预检响应非必须: 得到允许请求时携带Cookie\n- **Access-Control-Max-Age**\n  - 预检响应非必须: 单次预检生效时间, 超过需重新预检\n\n## 跨域\n\n- 什么是跨域: 通俗来说就是端对端访问了不同的 **地址 端口 路径** 的其中一种\n\n- 解决方式: \n  - ​对于spring-Boot项目来说,只需要加一个注解 **@CrossOrigin**\n  - 或者全局加一个过滤器\n  - 如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: 通配符，必须指定具体域名\n  - ​如果部署在Nginx上,需要在location块下加入如下参数\n```nginx\n  add_header Access-Control-Allow-Origin *;  # CORS 设置 跨域问题\n  add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n  add_header Access-Control-Allow-Headers 'Origin, Content-Type, Accept';\n```\n\n## 例子\n\n- 复杂请求的演示: OPTION预检请求格式   OPTION预检响应格式\n```http\nOPTIONS /cors HTTP/1.1 \nOrigin: http://ImOrigin.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\nHost: http://ImTarget.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0…\n```\n\n```http\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)   // 服务器信息\nAccess-Control-Allow-Origin: http://ImOrigin.com   // 也可以为*,允许全部 \nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nContent-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n```\n- 后端例子: 要注意配置是否生效 , 网关就不能用普通的`implements GlobalFilter`过滤器, 要使用Spring WebFlux 内置的 CORS 过滤器, 执行顺序靠前\n\n```java\n/**  \n * spring层面的过滤器: addAllowedOriginPattern 框架特有的,不是请求头参数, 因为有了它才能使用setAllowCredentials  \n * 如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: *，必须指定具体域名 \n * 作为 Spring WebFlux 内置的 CORS 过滤器，CorsWebFilter 在请求进入 Gateway 之前 就已经处理了跨域请求（包括 OPTIONS 预检请求）。  \n * @author cloud_3111  \n * @since 2025-03-24  \n**/\n@Configuration  \n@Slf4j  \npublic class GlobalCorsConfig {  \n  \n    private static final String ALL = \"*\";  \n    private static final String MATCHING_PATH = \"/**\";  // 注意这里的斜杠  \n    private static final Long MAX_AGE = 3600L;  \n    public static final boolean TRUE = true;  \n  \n    @Bean  \n    public CorsWebFilter corsWebFilter() {  \n        log.info(\"*************跨域检测*************\");  \n        CorsConfiguration config = new CorsConfiguration();  \n        // 这里仅为了说明问题，配置为放行所有域名，生产环境请对此进行修改:  \n        config.addAllowedOriginPattern(\"*\");  \n        // 放行的请求头  \n        config.addAllowedHeader(ALL);  \n        // 放行的请求方式，主要有：GET, POST, PUT, DELETE, OPTIONS  \n        config.addAllowedMethod(ALL);  \n        // 暴露头部信息  \n        config.addExposedHeader(ALL);  \n        // 设置预检有效期: 3600秒(1小时)  \n        config.setMaxAge(Duration.ofSeconds(MAX_AGE));  \n        // 是否发送cookie  \n        config.setAllowCredentials(TRUE);  \n          \n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();  \n        source.registerCorsConfiguration(MATCHING_PATH, config);  \n        return new CorsWebFilter(source);  \n    }  \n}\n```\n- 单体项目例子\n```java\n/**  \n * 跨域处理  \n * 已被废弃: Spring 提供的 CorsWebFilter（你的 GlobalCorsConfig）更早执行，在 HandlerMapping 级别拦截预检请求（OPTIONS）  \n * 网关就不能用普通的`implements GlobalFilter`过滤器, 要使用Spring WebFlux 内置的 CORS 过滤器, 执行顺序靠前  \n * @author cloud_3111  \n * @since 2025-03-19  \n *///@Component  \n@Slf4j  \npublic class CorsFilter implements GlobalFilter, Ordered {  \n  \n    private static final String ALL = \"*\";  \n    private static final String MAX_AGE = \"3600L\";  \n    public static final String TRUE = \"true\";  \n  \n    @Override  \n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {  \n        log.info(\"跨域检测\");  \n  \n        ServerHttpRequest request = exchange.getRequest();  \n        ServerHttpResponse response = exchange.getResponse();  \n  \n        // 设置跨域响应头  \n        HttpHeaders headers = response.getHeaders();  \n        // 如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: *，必须指定具体域名  \n        headers.add(\"Access-Control-Allow-Origin\", \"http://localhost:9000\");  \n        headers.add(\"Access-Control-Allow-Methods\", ALL);  \n        headers.add(\"Access-Control-Allow-Headers\", ALL);  \n        headers.add(\"Access-Control-Allow-Credentials\", TRUE);  \n        headers.add(\"Access-Control-Max-Age\", MAX_AGE);  \n  \n        // 判断是否为预检验  \n        if (request.getMethod() == HttpMethod.OPTIONS) {  \n            // OPTIONS 预检请求 的目的是让浏览器询问服务器是否允许跨域,不需要手动加跨域头  \n            log.info(\"预检请求\");  \n            response.setStatusCode(HttpStatus.OK);  \n            return response.setComplete(); // 返回一个完整的 Mono<Void>        }  \n        return chain.filter(exchange);  \n    }  \n  \n    @Override  \n    public int getOrder() {  \n        // 最先被执行  \n        return 0;  \n    }  \n}\n```","source":"_posts/OptionalCheck.md","raw":"---\ntitle: 网络请求预检\ntags:\n  - Cors\ncategories: 编程\ndate: 2024-12-31 16:32:51\n---\n\n# 网络请求预检(OptionalCheck)\n\n## 简介\n\n- OPTIONS请求**即预检请求**，可用于检测服务器允许的http方法。当发起跨域请求时，由于安全原因，**触发一定条件时**浏览器会在正式请求之前**自动先发起OPTIONS请求**，即CORS预检请求，服务器若接受该跨域请求，返回一个通过响应, 浏览器才继续发起正式请求。\n- 未配置允许`OPTIONS`请求，那么浏览器将收到一个**403 Forbidden**响应，表示服务器拒绝了该`OPTIONS`请求，`POST`请求的状态显示**CORS error**\n- Access-Control-Max-Age: 跨域预检测的option请求有效期\n\n## 分类\n\n- 简单请求: 不需要预检验\n  - 请求方法为: GET 和 POST和HEAD\n  - 请求体类型 Content-Type 为: 除了application/json外所有\n- 复杂请求: 通常需要发情预检验请求\n  - 请求方式为: PUT 和 DELETE\n  - 请求体类型 Content-Type 为: application/json\n- 预检请求方式为特殊的: OPTION请求\n\n## 参数\n\n**简单请求**\n\n- **Access-Control-Allow-Origin**\n  - 必须, 表示源地址, 要么是一个`*`，表示接受任意域名的请求(如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: `*`，必须指定具体域名)\n- **Access-Control-Allow-Credentials**\n  - 非必须, 表示是否允许发送Cookie, Boolean类型\n- **Access-Control-Expose-Headers**\n  - 非必须, 请求头参数\n\n**复杂请求**\n\n- **Access-Control-Request-Method**\n  - 预检请求必须: 询问请求方式是否允许\n- **Access-Control-Request-Headers**\n  - 预检请求必须, 询问请求头信息是否允许\n- **Access-Control-Allow-Methods**\n  - 预检响应必须: 得到允许的请求方式\n- **Access-Control-Allow-Headers**\n  - 预检响应必须: 得到允许的请求头信息\n- **Access-Control-Allow-Credentials**\n  - 预检响应非必须: 得到允许请求时携带Cookie\n- **Access-Control-Max-Age**\n  - 预检响应非必须: 单次预检生效时间, 超过需重新预检\n\n## 跨域\n\n- 什么是跨域: 通俗来说就是端对端访问了不同的 **地址 端口 路径** 的其中一种\n\n- 解决方式: \n  - ​对于spring-Boot项目来说,只需要加一个注解 **@CrossOrigin**\n  - 或者全局加一个过滤器\n  - 如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: 通配符，必须指定具体域名\n  - ​如果部署在Nginx上,需要在location块下加入如下参数\n```nginx\n  add_header Access-Control-Allow-Origin *;  # CORS 设置 跨域问题\n  add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n  add_header Access-Control-Allow-Headers 'Origin, Content-Type, Accept';\n```\n\n## 例子\n\n- 复杂请求的演示: OPTION预检请求格式   OPTION预检响应格式\n```http\nOPTIONS /cors HTTP/1.1 \nOrigin: http://ImOrigin.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\nHost: http://ImTarget.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0…\n```\n\n```http\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)   // 服务器信息\nAccess-Control-Allow-Origin: http://ImOrigin.com   // 也可以为*,允许全部 \nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nContent-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n```\n- 后端例子: 要注意配置是否生效 , 网关就不能用普通的`implements GlobalFilter`过滤器, 要使用Spring WebFlux 内置的 CORS 过滤器, 执行顺序靠前\n\n```java\n/**  \n * spring层面的过滤器: addAllowedOriginPattern 框架特有的,不是请求头参数, 因为有了它才能使用setAllowCredentials  \n * 如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: *，必须指定具体域名 \n * 作为 Spring WebFlux 内置的 CORS 过滤器，CorsWebFilter 在请求进入 Gateway 之前 就已经处理了跨域请求（包括 OPTIONS 预检请求）。  \n * @author cloud_3111  \n * @since 2025-03-24  \n**/\n@Configuration  \n@Slf4j  \npublic class GlobalCorsConfig {  \n  \n    private static final String ALL = \"*\";  \n    private static final String MATCHING_PATH = \"/**\";  // 注意这里的斜杠  \n    private static final Long MAX_AGE = 3600L;  \n    public static final boolean TRUE = true;  \n  \n    @Bean  \n    public CorsWebFilter corsWebFilter() {  \n        log.info(\"*************跨域检测*************\");  \n        CorsConfiguration config = new CorsConfiguration();  \n        // 这里仅为了说明问题，配置为放行所有域名，生产环境请对此进行修改:  \n        config.addAllowedOriginPattern(\"*\");  \n        // 放行的请求头  \n        config.addAllowedHeader(ALL);  \n        // 放行的请求方式，主要有：GET, POST, PUT, DELETE, OPTIONS  \n        config.addAllowedMethod(ALL);  \n        // 暴露头部信息  \n        config.addExposedHeader(ALL);  \n        // 设置预检有效期: 3600秒(1小时)  \n        config.setMaxAge(Duration.ofSeconds(MAX_AGE));  \n        // 是否发送cookie  \n        config.setAllowCredentials(TRUE);  \n          \n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();  \n        source.registerCorsConfiguration(MATCHING_PATH, config);  \n        return new CorsWebFilter(source);  \n    }  \n}\n```\n- 单体项目例子\n```java\n/**  \n * 跨域处理  \n * 已被废弃: Spring 提供的 CorsWebFilter（你的 GlobalCorsConfig）更早执行，在 HandlerMapping 级别拦截预检请求（OPTIONS）  \n * 网关就不能用普通的`implements GlobalFilter`过滤器, 要使用Spring WebFlux 内置的 CORS 过滤器, 执行顺序靠前  \n * @author cloud_3111  \n * @since 2025-03-19  \n *///@Component  \n@Slf4j  \npublic class CorsFilter implements GlobalFilter, Ordered {  \n  \n    private static final String ALL = \"*\";  \n    private static final String MAX_AGE = \"3600L\";  \n    public static final String TRUE = \"true\";  \n  \n    @Override  \n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {  \n        log.info(\"跨域检测\");  \n  \n        ServerHttpRequest request = exchange.getRequest();  \n        ServerHttpResponse response = exchange.getResponse();  \n  \n        // 设置跨域响应头  \n        HttpHeaders headers = response.getHeaders();  \n        // 如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: *，必须指定具体域名  \n        headers.add(\"Access-Control-Allow-Origin\", \"http://localhost:9000\");  \n        headers.add(\"Access-Control-Allow-Methods\", ALL);  \n        headers.add(\"Access-Control-Allow-Headers\", ALL);  \n        headers.add(\"Access-Control-Allow-Credentials\", TRUE);  \n        headers.add(\"Access-Control-Max-Age\", MAX_AGE);  \n  \n        // 判断是否为预检验  \n        if (request.getMethod() == HttpMethod.OPTIONS) {  \n            // OPTIONS 预检请求 的目的是让浏览器询问服务器是否允许跨域,不需要手动加跨域头  \n            log.info(\"预检请求\");  \n            response.setStatusCode(HttpStatus.OK);  \n            return response.setComplete(); // 返回一个完整的 Mono<Void>        }  \n        return chain.filter(exchange);  \n    }  \n  \n    @Override  \n    public int getOrder() {  \n        // 最先被执行  \n        return 0;  \n    }  \n}\n```","slug":"OptionalCheck","published":1,"updated":"2025-09-21T13:19:39.404Z","comments":1,"layout":"post","photos":[],"_id":"cmfw4z09b000fuomw9d4bersn","content":"<h1 id=\"网络请求预检-OptionalCheck\"><a href=\"#网络请求预检-OptionalCheck\" class=\"headerlink\" title=\"网络请求预检(OptionalCheck)\"></a>网络请求预检(OptionalCheck)</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li>OPTIONS请求<strong>即预检请求</strong>，可用于检测服务器允许的http方法。当发起跨域请求时，由于安全原因，<strong>触发一定条件时</strong>浏览器会在正式请求之前<strong>自动先发起OPTIONS请求</strong>，即CORS预检请求，服务器若接受该跨域请求，返回一个通过响应, 浏览器才继续发起正式请求。</li>\n<li>未配置允许<code>OPTIONS</code>请求，那么浏览器将收到一个<strong>403 Forbidden</strong>响应，表示服务器拒绝了该<code>OPTIONS</code>请求，<code>POST</code>请求的状态显示<strong>CORS error</strong></li>\n<li>Access-Control-Max-Age: 跨域预检测的option请求有效期</li>\n</ul>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><ul>\n<li>简单请求: 不需要预检验<ul>\n<li>请求方法为: GET 和 POST和HEAD</li>\n<li>请求体类型 Content-Type 为: 除了application/json外所有</li>\n</ul>\n</li>\n<li>复杂请求: 通常需要发情预检验请求<ul>\n<li>请求方式为: PUT 和 DELETE</li>\n<li>请求体类型 Content-Type 为: application/json</li>\n</ul>\n</li>\n<li>预检请求方式为特殊的: OPTION请求</li>\n</ul>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p><strong>简单请求</strong></p>\n<ul>\n<li><strong>Access-Control-Allow-Origin</strong><ul>\n<li>必须, 表示源地址, 要么是一个<code>*</code>，表示接受任意域名的请求(如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: <code>*</code>，必须指定具体域名)</li>\n</ul>\n</li>\n<li><strong>Access-Control-Allow-Credentials</strong><ul>\n<li>非必须, 表示是否允许发送Cookie, Boolean类型</li>\n</ul>\n</li>\n<li><strong>Access-Control-Expose-Headers</strong><ul>\n<li>非必须, 请求头参数</li>\n</ul>\n</li>\n</ul>\n<p><strong>复杂请求</strong></p>\n<ul>\n<li><strong>Access-Control-Request-Method</strong><ul>\n<li>预检请求必须: 询问请求方式是否允许</li>\n</ul>\n</li>\n<li><strong>Access-Control-Request-Headers</strong><ul>\n<li>预检请求必须, 询问请求头信息是否允许</li>\n</ul>\n</li>\n<li><strong>Access-Control-Allow-Methods</strong><ul>\n<li>预检响应必须: 得到允许的请求方式</li>\n</ul>\n</li>\n<li><strong>Access-Control-Allow-Headers</strong><ul>\n<li>预检响应必须: 得到允许的请求头信息</li>\n</ul>\n</li>\n<li><strong>Access-Control-Allow-Credentials</strong><ul>\n<li>预检响应非必须: 得到允许请求时携带Cookie</li>\n</ul>\n</li>\n<li><strong>Access-Control-Max-Age</strong><ul>\n<li>预检响应非必须: 单次预检生效时间, 超过需重新预检</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><ul>\n<li><p>什么是跨域: 通俗来说就是端对端访问了不同的 <strong>地址 端口 路径</strong> 的其中一种</p>\n</li>\n<li><p>解决方式: </p>\n<ul>\n<li>​对于spring-Boot项目来说,只需要加一个注解 <strong>@CrossOrigin</strong></li>\n<li>或者全局加一个过滤器</li>\n<li>如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: 通配符，必须指定具体域名</li>\n<li>​如果部署在Nginx上,需要在location块下加入如下参数<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">add_header</span> Access-Control-Allow-Origin *;  <span class=\"comment\"># CORS 设置 跨域问题</span></span><br><span class=\"line\"><span class=\"attribute\">add_header</span> Access-Control-Allow-Methods <span class=\"string\">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class=\"line\"><span class=\"attribute\">add_header</span> Access-Control-Allow-Headers <span class=\"string\">&#x27;Origin, Content-Type, Accept&#x27;</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><ul>\n<li>复杂请求的演示: OPTION预检请求格式   OPTION预检响应格式<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OPTIONS /cors HTTP/1.1 </span><br><span class=\"line\"><span class=\"attribute\">Origin</span><span class=\"punctuation\">: </span>http://ImOrigin.com</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Request-Method</span><span class=\"punctuation\">: </span>PUT</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Request-Headers</span><span class=\"punctuation\">: </span>X-Custom-Header</span><br><span class=\"line\"><span class=\"attribute\">Host</span><span class=\"punctuation\">: </span>http://ImTarget.com</span><br><span class=\"line\"><span class=\"attribute\">Accept-Language</span><span class=\"punctuation\">: </span>en-US</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>keep-alive</span><br><span class=\"line\"><span class=\"attribute\">User-Agent</span><span class=\"punctuation\">: </span>Mozilla/5.0…</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">HTTP/1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span><span class=\"punctuation\">: </span>Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class=\"line\"><span class=\"attribute\">Server</span><span class=\"punctuation\">: </span>Apache/2.0.61 (Unix)   // 服务器信息</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Origin</span><span class=\"punctuation\">: </span>http://ImOrigin.com   // 也可以为*,允许全部 </span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Methods</span><span class=\"punctuation\">: </span>GET, POST, PUT</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Headers</span><span class=\"punctuation\">: </span>X-Custom-Header</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>text/html; charset=utf-8</span><br><span class=\"line\"><span class=\"attribute\">Content-Encoding</span><span class=\"punctuation\">: </span>gzip</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span><span class=\"punctuation\">: </span>0</span><br><span class=\"line\"><span class=\"attribute\">Keep-Alive</span><span class=\"punctuation\">: </span>timeout=2, max=100</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>Keep-Alive</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>text/plain</span><br></pre></td></tr></table></figure>\n<ul>\n<li>后端例子: 要注意配置是否生效 , 网关就不能用普通的<code>implements GlobalFilter</code>过滤器, 要使用Spring WebFlux 内置的 CORS 过滤器, 执行顺序靠前</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * spring层面的过滤器: addAllowedOriginPattern 框架特有的,不是请求头参数, 因为有了它才能使用setAllowCredentials  </span></span><br><span class=\"line\"><span class=\"comment\"> * 如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: *，必须指定具体域名 </span></span><br><span class=\"line\"><span class=\"comment\"> * 作为 Spring WebFlux 内置的 CORS 过滤器，CorsWebFilter 在请求进入 Gateway 之前 就已经处理了跨域请求（包括 OPTIONS 预检请求）。  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> cloud_3111  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2025-03-24  </span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span>  </span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GlobalCorsConfig</span> &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">ALL</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;*&quot;</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">MATCHING_PATH</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;/**&quot;</span>;  <span class=\"comment\">// 注意这里的斜杠  </span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Long</span> <span class=\"variable\">MAX_AGE</span> <span class=\"operator\">=</span> <span class=\"number\">3600L</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">TRUE</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> CorsWebFilter <span class=\"title function_\">corsWebFilter</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;*************跨域检测*************&quot;</span>);  </span><br><span class=\"line\">        <span class=\"type\">CorsConfiguration</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CorsConfiguration</span>();  </span><br><span class=\"line\">        <span class=\"comment\">// 这里仅为了说明问题，配置为放行所有域名，生产环境请对此进行修改:  </span></span><br><span class=\"line\">        config.addAllowedOriginPattern(<span class=\"string\">&quot;*&quot;</span>);  </span><br><span class=\"line\">        <span class=\"comment\">// 放行的请求头  </span></span><br><span class=\"line\">        config.addAllowedHeader(ALL);  </span><br><span class=\"line\">        <span class=\"comment\">// 放行的请求方式，主要有：GET, POST, PUT, DELETE, OPTIONS  </span></span><br><span class=\"line\">        config.addAllowedMethod(ALL);  </span><br><span class=\"line\">        <span class=\"comment\">// 暴露头部信息  </span></span><br><span class=\"line\">        config.addExposedHeader(ALL);  </span><br><span class=\"line\">        <span class=\"comment\">// 设置预检有效期: 3600秒(1小时)  </span></span><br><span class=\"line\">        config.setMaxAge(Duration.ofSeconds(MAX_AGE));  </span><br><span class=\"line\">        <span class=\"comment\">// 是否发送cookie  </span></span><br><span class=\"line\">        config.setAllowCredentials(TRUE);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"type\">UrlBasedCorsConfigurationSource</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UrlBasedCorsConfigurationSource</span>();  </span><br><span class=\"line\">        source.registerCorsConfiguration(MATCHING_PATH, config);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CorsWebFilter</span>(source);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>单体项目例子<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 跨域处理  </span></span><br><span class=\"line\"><span class=\"comment\"> * 已被废弃: Spring 提供的 CorsWebFilter（你的 GlobalCorsConfig）更早执行，在 HandlerMapping 级别拦截预检请求（OPTIONS）  </span></span><br><span class=\"line\"><span class=\"comment\"> * 网关就不能用普通的`implements GlobalFilter`过滤器, 要使用Spring WebFlux 内置的 CORS 过滤器, 执行顺序靠前  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> cloud_3111  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2025-03-19  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span><span class=\"comment\">//@Component  </span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CorsFilter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">GlobalFilter</span>, Ordered &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">ALL</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;*&quot;</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">MAX_AGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;3600L&quot;</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">TRUE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;true&quot;</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Mono&lt;Void&gt; <span class=\"title function_\">filter</span><span class=\"params\">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;  </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;跨域检测&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"type\">ServerHttpRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> exchange.getRequest();  </span><br><span class=\"line\">        <span class=\"type\">ServerHttpResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> exchange.getResponse();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 设置跨域响应头  </span></span><br><span class=\"line\">        <span class=\"type\">HttpHeaders</span> <span class=\"variable\">headers</span> <span class=\"operator\">=</span> response.getHeaders();  </span><br><span class=\"line\">        <span class=\"comment\">// 如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: *，必须指定具体域名  </span></span><br><span class=\"line\">        headers.add(<span class=\"string\">&quot;Access-Control-Allow-Origin&quot;</span>, <span class=\"string\">&quot;http://localhost:9000&quot;</span>);  </span><br><span class=\"line\">        headers.add(<span class=\"string\">&quot;Access-Control-Allow-Methods&quot;</span>, ALL);  </span><br><span class=\"line\">        headers.add(<span class=\"string\">&quot;Access-Control-Allow-Headers&quot;</span>, ALL);  </span><br><span class=\"line\">        headers.add(<span class=\"string\">&quot;Access-Control-Allow-Credentials&quot;</span>, TRUE);  </span><br><span class=\"line\">        headers.add(<span class=\"string\">&quot;Access-Control-Max-Age&quot;</span>, MAX_AGE);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为预检验  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request.getMethod() == HttpMethod.OPTIONS) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// OPTIONS 预检请求 的目的是让浏览器询问服务器是否允许跨域,不需要手动加跨域头  </span></span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;预检请求&quot;</span>);  </span><br><span class=\"line\">            response.setStatusCode(HttpStatus.OK);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> response.setComplete(); <span class=\"comment\">// 返回一个完整的 Mono&lt;Void&gt;        &#125;  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> chain.filter(exchange);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getOrder</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 最先被执行  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","cover":"/img/5.png","cover_type":"img","excerpt":"","more":"<h1 id=\"网络请求预检-OptionalCheck\"><a href=\"#网络请求预检-OptionalCheck\" class=\"headerlink\" title=\"网络请求预检(OptionalCheck)\"></a>网络请求预检(OptionalCheck)</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li>OPTIONS请求<strong>即预检请求</strong>，可用于检测服务器允许的http方法。当发起跨域请求时，由于安全原因，<strong>触发一定条件时</strong>浏览器会在正式请求之前<strong>自动先发起OPTIONS请求</strong>，即CORS预检请求，服务器若接受该跨域请求，返回一个通过响应, 浏览器才继续发起正式请求。</li>\n<li>未配置允许<code>OPTIONS</code>请求，那么浏览器将收到一个<strong>403 Forbidden</strong>响应，表示服务器拒绝了该<code>OPTIONS</code>请求，<code>POST</code>请求的状态显示<strong>CORS error</strong></li>\n<li>Access-Control-Max-Age: 跨域预检测的option请求有效期</li>\n</ul>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><ul>\n<li>简单请求: 不需要预检验<ul>\n<li>请求方法为: GET 和 POST和HEAD</li>\n<li>请求体类型 Content-Type 为: 除了application/json外所有</li>\n</ul>\n</li>\n<li>复杂请求: 通常需要发情预检验请求<ul>\n<li>请求方式为: PUT 和 DELETE</li>\n<li>请求体类型 Content-Type 为: application/json</li>\n</ul>\n</li>\n<li>预检请求方式为特殊的: OPTION请求</li>\n</ul>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p><strong>简单请求</strong></p>\n<ul>\n<li><strong>Access-Control-Allow-Origin</strong><ul>\n<li>必须, 表示源地址, 要么是一个<code>*</code>，表示接受任意域名的请求(如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: <code>*</code>，必须指定具体域名)</li>\n</ul>\n</li>\n<li><strong>Access-Control-Allow-Credentials</strong><ul>\n<li>非必须, 表示是否允许发送Cookie, Boolean类型</li>\n</ul>\n</li>\n<li><strong>Access-Control-Expose-Headers</strong><ul>\n<li>非必须, 请求头参数</li>\n</ul>\n</li>\n</ul>\n<p><strong>复杂请求</strong></p>\n<ul>\n<li><strong>Access-Control-Request-Method</strong><ul>\n<li>预检请求必须: 询问请求方式是否允许</li>\n</ul>\n</li>\n<li><strong>Access-Control-Request-Headers</strong><ul>\n<li>预检请求必须, 询问请求头信息是否允许</li>\n</ul>\n</li>\n<li><strong>Access-Control-Allow-Methods</strong><ul>\n<li>预检响应必须: 得到允许的请求方式</li>\n</ul>\n</li>\n<li><strong>Access-Control-Allow-Headers</strong><ul>\n<li>预检响应必须: 得到允许的请求头信息</li>\n</ul>\n</li>\n<li><strong>Access-Control-Allow-Credentials</strong><ul>\n<li>预检响应非必须: 得到允许请求时携带Cookie</li>\n</ul>\n</li>\n<li><strong>Access-Control-Max-Age</strong><ul>\n<li>预检响应非必须: 单次预检生效时间, 超过需重新预检</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><ul>\n<li><p>什么是跨域: 通俗来说就是端对端访问了不同的 <strong>地址 端口 路径</strong> 的其中一种</p>\n</li>\n<li><p>解决方式: </p>\n<ul>\n<li>​对于spring-Boot项目来说,只需要加一个注解 <strong>@CrossOrigin</strong></li>\n<li>或者全局加一个过滤器</li>\n<li>如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: 通配符，必须指定具体域名</li>\n<li>​如果部署在Nginx上,需要在location块下加入如下参数<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">add_header</span> Access-Control-Allow-Origin *;  <span class=\"comment\"># CORS 设置 跨域问题</span></span><br><span class=\"line\"><span class=\"attribute\">add_header</span> Access-Control-Allow-Methods <span class=\"string\">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class=\"line\"><span class=\"attribute\">add_header</span> Access-Control-Allow-Headers <span class=\"string\">&#x27;Origin, Content-Type, Accept&#x27;</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><ul>\n<li>复杂请求的演示: OPTION预检请求格式   OPTION预检响应格式<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OPTIONS /cors HTTP/1.1 </span><br><span class=\"line\"><span class=\"attribute\">Origin</span><span class=\"punctuation\">: </span>http://ImOrigin.com</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Request-Method</span><span class=\"punctuation\">: </span>PUT</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Request-Headers</span><span class=\"punctuation\">: </span>X-Custom-Header</span><br><span class=\"line\"><span class=\"attribute\">Host</span><span class=\"punctuation\">: </span>http://ImTarget.com</span><br><span class=\"line\"><span class=\"attribute\">Accept-Language</span><span class=\"punctuation\">: </span>en-US</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>keep-alive</span><br><span class=\"line\"><span class=\"attribute\">User-Agent</span><span class=\"punctuation\">: </span>Mozilla/5.0…</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">HTTP/1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span><span class=\"punctuation\">: </span>Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class=\"line\"><span class=\"attribute\">Server</span><span class=\"punctuation\">: </span>Apache/2.0.61 (Unix)   // 服务器信息</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Origin</span><span class=\"punctuation\">: </span>http://ImOrigin.com   // 也可以为*,允许全部 </span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Methods</span><span class=\"punctuation\">: </span>GET, POST, PUT</span><br><span class=\"line\"><span class=\"attribute\">Access-Control-Allow-Headers</span><span class=\"punctuation\">: </span>X-Custom-Header</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>text/html; charset=utf-8</span><br><span class=\"line\"><span class=\"attribute\">Content-Encoding</span><span class=\"punctuation\">: </span>gzip</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span><span class=\"punctuation\">: </span>0</span><br><span class=\"line\"><span class=\"attribute\">Keep-Alive</span><span class=\"punctuation\">: </span>timeout=2, max=100</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>Keep-Alive</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>text/plain</span><br></pre></td></tr></table></figure>\n<ul>\n<li>后端例子: 要注意配置是否生效 , 网关就不能用普通的<code>implements GlobalFilter</code>过滤器, 要使用Spring WebFlux 内置的 CORS 过滤器, 执行顺序靠前</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * spring层面的过滤器: addAllowedOriginPattern 框架特有的,不是请求头参数, 因为有了它才能使用setAllowCredentials  </span></span><br><span class=\"line\"><span class=\"comment\"> * 如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: *，必须指定具体域名 </span></span><br><span class=\"line\"><span class=\"comment\"> * 作为 Spring WebFlux 内置的 CORS 过滤器，CorsWebFilter 在请求进入 Gateway 之前 就已经处理了跨域请求（包括 OPTIONS 预检请求）。  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> cloud_3111  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2025-03-24  </span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span>  </span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GlobalCorsConfig</span> &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">ALL</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;*&quot;</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">MATCHING_PATH</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;/**&quot;</span>;  <span class=\"comment\">// 注意这里的斜杠  </span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Long</span> <span class=\"variable\">MAX_AGE</span> <span class=\"operator\">=</span> <span class=\"number\">3600L</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"variable\">TRUE</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> CorsWebFilter <span class=\"title function_\">corsWebFilter</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;*************跨域检测*************&quot;</span>);  </span><br><span class=\"line\">        <span class=\"type\">CorsConfiguration</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CorsConfiguration</span>();  </span><br><span class=\"line\">        <span class=\"comment\">// 这里仅为了说明问题，配置为放行所有域名，生产环境请对此进行修改:  </span></span><br><span class=\"line\">        config.addAllowedOriginPattern(<span class=\"string\">&quot;*&quot;</span>);  </span><br><span class=\"line\">        <span class=\"comment\">// 放行的请求头  </span></span><br><span class=\"line\">        config.addAllowedHeader(ALL);  </span><br><span class=\"line\">        <span class=\"comment\">// 放行的请求方式，主要有：GET, POST, PUT, DELETE, OPTIONS  </span></span><br><span class=\"line\">        config.addAllowedMethod(ALL);  </span><br><span class=\"line\">        <span class=\"comment\">// 暴露头部信息  </span></span><br><span class=\"line\">        config.addExposedHeader(ALL);  </span><br><span class=\"line\">        <span class=\"comment\">// 设置预检有效期: 3600秒(1小时)  </span></span><br><span class=\"line\">        config.setMaxAge(Duration.ofSeconds(MAX_AGE));  </span><br><span class=\"line\">        <span class=\"comment\">// 是否发送cookie  </span></span><br><span class=\"line\">        config.setAllowCredentials(TRUE);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"type\">UrlBasedCorsConfigurationSource</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UrlBasedCorsConfigurationSource</span>();  </span><br><span class=\"line\">        source.registerCorsConfiguration(MATCHING_PATH, config);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CorsWebFilter</span>(source);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>单体项目例子<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 跨域处理  </span></span><br><span class=\"line\"><span class=\"comment\"> * 已被废弃: Spring 提供的 CorsWebFilter（你的 GlobalCorsConfig）更早执行，在 HandlerMapping 级别拦截预检请求（OPTIONS）  </span></span><br><span class=\"line\"><span class=\"comment\"> * 网关就不能用普通的`implements GlobalFilter`过滤器, 要使用Spring WebFlux 内置的 CORS 过滤器, 执行顺序靠前  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> cloud_3111  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2025-03-19  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span><span class=\"comment\">//@Component  </span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CorsFilter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">GlobalFilter</span>, Ordered &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">ALL</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;*&quot;</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">MAX_AGE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;3600L&quot;</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">TRUE</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;true&quot;</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Mono&lt;Void&gt; <span class=\"title function_\">filter</span><span class=\"params\">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;  </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;跨域检测&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"type\">ServerHttpRequest</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> exchange.getRequest();  </span><br><span class=\"line\">        <span class=\"type\">ServerHttpResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> exchange.getResponse();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 设置跨域响应头  </span></span><br><span class=\"line\">        <span class=\"type\">HttpHeaders</span> <span class=\"variable\">headers</span> <span class=\"operator\">=</span> response.getHeaders();  </span><br><span class=\"line\">        <span class=\"comment\">// 如果 setAllowCredentials(true)，不能用 Access-Control-Allow-Origin: *，必须指定具体域名  </span></span><br><span class=\"line\">        headers.add(<span class=\"string\">&quot;Access-Control-Allow-Origin&quot;</span>, <span class=\"string\">&quot;http://localhost:9000&quot;</span>);  </span><br><span class=\"line\">        headers.add(<span class=\"string\">&quot;Access-Control-Allow-Methods&quot;</span>, ALL);  </span><br><span class=\"line\">        headers.add(<span class=\"string\">&quot;Access-Control-Allow-Headers&quot;</span>, ALL);  </span><br><span class=\"line\">        headers.add(<span class=\"string\">&quot;Access-Control-Allow-Credentials&quot;</span>, TRUE);  </span><br><span class=\"line\">        headers.add(<span class=\"string\">&quot;Access-Control-Max-Age&quot;</span>, MAX_AGE);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 判断是否为预检验  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request.getMethod() == HttpMethod.OPTIONS) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// OPTIONS 预检请求 的目的是让浏览器询问服务器是否允许跨域,不需要手动加跨域头  </span></span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;预检请求&quot;</span>);  </span><br><span class=\"line\">            response.setStatusCode(HttpStatus.OK);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> response.setComplete(); <span class=\"comment\">// 返回一个完整的 Mono&lt;Void&gt;        &#125;  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> chain.filter(exchange);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getOrder</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 最先被执行  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"banner":"[[pixel-banner-image.png]]","title":"MQ消息队列","date":"2025-02-17T02:02:00.000Z","_content":"\n# MQ消息队列\n## 简介\n- 消息队列(Message Queue)是在消息的传输过程中保存消息的容器。\n![17536471244591753647124102.png|700x808](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17536471244591753647124102.png)\n- **Broker**是mq的核心组件, 主要功能是负责 **接收生产者发送的消息**, **将消息投递给对应的消费者**\n- **connection 连接与 channel 信道**:\n    - AMQP的连接是长连接，它是一个使用 TCP作为可靠传输的应用层协议, 而信道channel是建立在真实的长TCP连接内的虚拟链接\n    - AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，都是通过信道完成的\n    - 类似于进程和线程, 一个服务对应一个connection, 服务中的每一个线程对应一个channel\n## 消息传输协议对比\n| 协议        | 传输层 | 模式       | 消息持久化  | 可靠性 | 特点                 | 常见实现                                        | 优点                                |\n| --------- | --- | -------- | ------ | --- | ------------------ | ------------------------------------------- | --------------------------------- |\n| MQTT      | TCP | 发布/订阅    | 支持 QoS | 高   | IoT 数据上报、移动端消息推送   | Mosquitto、EMQX、HiveMQ、阿里云物联网平台              | 轻量级的通讯协议, 即使在网络条件较差的情况下也能保持通信的稳定性 |\n| AMQP      | TCP | 发布/订阅/队列 | 支持     | 高   | 支持事务、确认机制、复杂路由     | RabbitMQ、Apache Qpid                        | 可靠性强、功能丰富、支持复杂业务逻辑                |\n| Kafka     | TCP | 发布/订阅/日志 | 内建持久化  | 高   | 自定义二进制协议、高吞吐量、顺序消费 | Apache Kafka                                | 高性能、高吞吐、顺序性好、可回溯消息                |\n| HTTP      | TCP | 请求-响应短链接 | 不支持    | 中   | 短时请求-响应通信          | 所有 Web 服务器/客户端（Nginx、Tomcat、浏览器等）           | 实现简单、生态完善、无客户端限制                  |\n| WebSocket | TCP | 双向长连接    | 不支持    | 中   | 实时通信、低延迟推送         | 浏览器/WebSocket Server、Netty、Spring WebSocket | 实时性强、双向通信、延迟低                     |\n## 作用\n- **解耦**: 快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间\n- **异步**: 用户下单后，系统可以先返回一个下单成功的消息，然后将订单信息放入消息队列中，后台系统再去处理订单信息, 而是相当于**异步线程**处理其他消费者信息\n- **削峰**: 将瞬时的高峰流量转化为持续的低流量，从而保护系统不会因为瞬时的高流量而崩溃, 使用mq对消息进行分段保存, **由消费者每次拉取一定数量的数据进行处理(prefetch)**\n![17406620441921740662044061.png|700x420](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17406620441921740662044061.png)\n## 特点\n- **可靠性**。支持持久化，传输确认，发布确认(ack序列码)等保证了MQ的可靠性。\n- **灵活的分发消息策略**。\n    - RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。\n    - RocketMQ使用 主题（Topic）+ 标签（Tag）+ 消费组（Consumer Group）来完成消息分类和消费。轮询发送(默认)\n- **支持集群**。多台MQ服务器可以组成一个集群，形成一个逻辑Broker(代理)。\n- **多种协议**。MQ支持多种消息队列协议，比如 STOMP、MQTT 等等。\n- **支持多种语言客户端**。RabbitMQ几乎支持所有常用编程语言，包括 Java(amqpTemplate客户端)、.NET、Ruby 等等。\n- **可视化管理界面**。\n    - RabbitMQ提供了一个易用的用户界面程序**Erlang**(端口是15672)\n    - RocketMQ的控制台是一个**SpringBoot项目**,需要手动打开; 或者使用打包好的jar包\n## 分析 RabbitMQ与RocketMQ\n### RabbitMQ(推模式)\n**RabbitMQ是采用 Erlang语言实现AMQP协议的消息中间件**\n- **虚拟主机**: 每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制\n- **交换机**: 一个重要组件,各自有自己的路由键, 负责接收生产者发送的消息，并根据一定的路由规则（如路由键、绑定等）将消息转发到一个或多个队列 ---> 控制消息的分发规则(交换机是消息的中转站)\n- **路由键**: 帮助交换机决定该消息应该被转发到哪个队列(规则), 是交换机的关键\n- **队列**: 队列是RabbitMQ中的一个存储结构，用于保存消息，直到消费者从队列中获取并处理这些消息。\n- **例子**: 假设有一个生产者将消息发送到一个`direct`类型的交换机，该交换机的路由键是`\"order.processed\"`。这个交换机会将消息转发到一个与该路由键绑定的队列，比如叫做`orderQueue`。消费者只需要监听 `orderQueue`，即可接收到 `\"order.processed\"` 类型的订单消息进行处理。\n![17536391946501753639194226.png|700x209](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17536391946501753639194226.png)\n### RocketMQ(拉模式)\n- **主题**: Topic\n- **路由键**: Tag + 可选 Key, RocketMQ 中的 Tag 是对消息的简单分类，Key 可以做业务标识。没有复杂的路由表达式\n- **消费组**: 消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。默认情况，如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。\n- **消费位置**: Offset, 为每个消费组在每个队列上维护一个消费位置, 用于为当前消费组保存上次消费到的位置\n- **队列**: MessageQueue, RocketMQ 的每个 Topic 会自动被分为多个消息队列，Producer 可指定发往哪个队列（可用于顺序消息）\n- **例子**: 创建一个 `Topic`主题：`OrderTopic`, 生产者发送消息到 `OrderTopic`，并设置 `Tag`(路由键) 为 `processed`, 消费者订阅 `OrderTopic`，并使用 `Tag` = \"`processed`\" 作为过滤条件, Broker 接收并分发消息到对应的 `MessageQueue`（队列片段), 消费者所在的`Consumer Group`拉取消息进行处理\n![17475484290661747548428888.png|700x400](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17475484290661747548428888.png)\n## RocketMQ集群\n- 一个 `Topic` 分布在多个 `Broker`上，一个 `Broker` 可以配置多个 `Topic` ，它们是多对多的关系\n### 步骤\n- 首先, 我们在Broker上做了主从+集群, 分`Master`和`Slaver`, Slaver会定时从Master备份数据(同步复制: 只有消息同步双写到主从节点上时才返回写入成功, 异步复制)，如果 `master` 宕机，则 `slave` 提供消费服务，但是不能写入消息\n- 其次, 我们对`NameServer`也做了集群, 但是不分主从节点, 每隔30s每一个`broker`会向所有的`NameServer`发送ping心跳检测(单个 Broker 和所有 NameServer 保持长连接), 心跳信息包括了Topic配置信息以及路由表信息\n- 在生产者需要向`Broker`发送消息的时候，需要先从`NameServer`获取关于 `Broker` 的路由表信息，然后通过轮询的方法去向每个队列中生产数据以达到 负载均衡 的效果。\n- 消费者通过NameServer获取路由表消息, 向broker拉取消息消费`Consumer` 可以以两种模式启动 广播和集群, 广播模式下，一条消息会发送给同一个消费组中的所有消费者 ，集群模式下消息只会发送给一个消费者。\n![17581623162691758162315810.png|698x506](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17581623162691758162315810.png)\n## Kafka集群\n### 单节点优化方案\n- 单节点Kafka的在高流量突增和存储压力增大时, 如果broker崩溃会联锁导致整个系统崩塌\n- 考虑使用主从节点部署\n\t- 主broker负责写\n\t- 从broker负责读\n\t- 从节点定期从主节点同步消息\n- 这样就算其中一个broker瘫痪也能使用另外一个broker\n### 集群优化方案\n- 部署多个broker服务, topic采用分布式方式存储, 一个topic数据被分散到不同broker服务中\n- 采用生产者集群和消费者集群, 提高生产消费能力;\n- broker集群定期向注册中心集群(ZooKeeper)发送心跳检测以及整个集群状态路由表(如: broker, topic); RocketMQ的注册中心则为NameServer;\n- 生产者集群和消费者集群监听注册中心, 确认每次生产和消费的消息是哪一个topic下的哪一个partation, 确保消费者拉取的同一性;\n![17580141768161758014176045.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580141768161758014176045.png)\n## 死信队列\n- 存储那些无法被正常消费的消息,通常由交换机和路由键指定到特殊的队列(即死信队列)\n- **消息过期**：如果消息设置了`expiration`属性，当消息在队列中存放超过指定时间后会被丢弃，并进入死信队列。\n- **队列溢出**：当队列已满且无法再接收新的消息时，新进入的消息将会被丢弃并进入死信队列。\n- **消息被拒绝**：当消费者拒绝处理某条消息时，可以选择将消息标记为“死信”。这种情况下，消息会进入死信队列。\n- **消费者未确认**：如果消息被消费者消费后未发送确认（ack），并且RabbitMQ设置了`requeue`为`false`，则消息会被丢弃并进入死信队列。\n要为队列或交换机添加死信参数（Dead Letter Exchange）配置，应该关注以下几个部分：\n1. **Dead letter exchange**：这里可以填写死信交换机的名称。当队列中的消息因某种原因（如超时、被拒绝等）不能被消费时，它们将被转发到这个死信交换机。你需要在此输入目标死信交换机的名称。\n2. **Dead letter routing key**：这是可选的参数，用于指定死信队列的路由键。消息会被转发到死信交换机，并根据路由键路由到相应的队列。你可以填写路由键，或者留空使用默认设置。\n    \n在配置过程中，如果你为队列设置了 **Dead letter exchange**，确保死信交换机已经存在，并且设置正确。你还可以根据需求配置其他参数，如 **Message TTL**（消息的过期时间）和 **Auto expire**（队列的过期时间）。\n### 死信参数添加步骤：\n\n1. 在 RabbitMQ 管理界面创建或编辑队列或交换机。\n2. 在 `Arguments` 部分找到并配置：\n    - **Dead letter exchange**：填写死信交换机的名称。\n    - **Dead letter routing key**：可选，填写死信路由键的名称。\n3. 完成设置后，保存队列或交换机配置。\n### 其他相关参数：\n- **Auto expire**：队列自动过期的时间。\n- **Message TTL**：设置消息的过期时间，消息在 TTL 到期后会被丢弃或进入死信队列。\n- **Overflow behaviour**：设置当队列达到最大长度时的行为。\n- **Single active consumer**：如果设置为 `true`，该队列只允许一个消费者进行消费。\n- **Max length / Max length bytes**：设置队列的最大长度或最大字节数，超出后会触发 `Overflow behaviour`。\n## 分发消息策略\n### 1. 简单队列模式 (Direct Mode)\n- 特点：生产者生产消息, 由多个消费者去竞争消费, 每个消息只消费一次\n- 使用场景：**适用于简单的点对点通信，生产者与消费者直接交互**。\n- 实现方式：生产者将消息发送到某个特定的队列，消费者从该队列中接收消息。\n- 特点：没有复杂的路由逻辑，简单高效，但不适合多消费者的场景。\n### 2. 工作队列模式 (Work Queue)\n- 特点：**生产者将消息发送到一个共享的队列(一对多)，多个消费者从该队列中获取消息进行并行处理。**\n- 使用场景：适用于**负载均衡**，多个消费者共同处理任务，避免某个消费者负担过重。\n- 实现方式：所有消费者都监听同一个队列，RabbitMQ会以公平的方式将消息分发给消费者（即一个消费者处理一条消息，直到处理完才会继续接收新的消息）。\n- 特点：消费者可以并行处理任务，确保负载均衡和异步处理，适用于后台任务处理、分布式任务调度等。\n### 3. 发布订阅模式 (Publish/Subscribe)\n- 特点：**生产者将消息发布到一个交换机(主题)，然后多个消费者订阅该交换机(主题)，消费者将接收来自交换机(主题)的所有消息, 也就是一个消息可以多次消费。**\n- 使用场景：**适用于广播消息场景，例如日志收集、事件通知等**。\n- 实现方式：生产者将消息发布到一个广播类型的交换机（如`fanout`交换机），交换机会将消息广播给所有绑定在其上的队列，所有消费者都会收到该消息。\n- 特点：通过交换机将消息发送到多个队列，实现多消费者接收消息，适用于需要广播的场景。\n### 4. 路由模式 (Routing)\n- 特点：生产者将消息发送到交换机，并通过指定的路由键来决定消息的去向。消费者根据路由键来决定是否接收消息。\n- 使用场景：适用于根据消息的某些属性进行路由，灵活性较高，能够支持更多的消息传递场景。\n- 实现方式：使用`direct`交换机，生产者将消息发送到交换机，并指定路由键，交换机会根据路由键将消息转发给与该路由键匹配的队列。消费者通过监听特定的队列来接收消息。\n- 特点：灵活的消息路由机制，生产者与消费者通过路由键关联，可以将消息发送到特定的队列\n## 全局唯一Id生成策略\n### Snowflake(64bit位的long类型)\n- 解决的问题: 分布式场景下主键ID重复性问题\n![17603292854441760329284549.png|700x214](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17603292854441760329284549.png)\n![17536471744521753647173892.png|700x396](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17536471744521753647173892.png)\n\n```java\n// 反解析 雪花id 右移22位机器位 加上元年时间戳得到当前时间\npublic class SnowflakeIdParser {\n\n    // Hutool 默认起始时间戳\n    private static final long EPOCH = 1577808000000L;\n\n    public static void main(String[] args) {\n        long id = 1950232867263090688L;\n\n        // 反解析时间戳（去掉序列号和机器ID部分，即右移22位）\n        long timePart = (id >> 22);\n\n        // 计算实际生成时间\n        long generateTime = timePart + EPOCH;\n\n        Date date = new Date(generateTime);\n        System.out.println(\"生成时间: \" + date);\n\n        // 反解析机器ID和序列号（根据Hutool Snowflake结构）\n        // Hutool Snowflake结构：\n        // 41位时间戳 | 10位工作机器ID | 12位序列号\n\n        long sequence = id & ((1 << 12) - 1); // 最后12位\n        long workerId = (id >> 12) & ((1 << 10) - 1); // 中间10位\n\n        System.out.println(\"工作机器ID: \" + workerId);\n        System.out.println(\"序列号: \" + sequence);\n    }\n}\n```\n### 百度的UidGenerate\n- 本质上也是基于雪花算法的64bit的id, 不同的是修改了64bit的分配比例\n- 时间戳可使用年数从原本的约69年下降至6年, 但是可分配的机器bit和序列毫秒bit增多, **解决了在高并发、大规模机器部署场景下，传统雪花算法机器位不够用的问题**\n![17603299984431760329997773.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17603299984431760329997773.png)\n### 时钟回拨问题\n- 出现原因\n\t1. 修改了系统时间\n\t2. 有时候不同的机器上需要同步时间，可能不同机器之间存在误差，那么可能会出现时间回拨问题\n- 解决方案\n\t1. 回拨时间小的时候，不生成 ID，**阻塞等待**到时间点到达。\n\t2. 上面的方案只适合时钟回拨较小的，如果间隔过大，阻塞等待，肯定是不可取的，因此要么**超过一定大小的回拨直接报错，拒绝服务**\n\t3. 使用中间服务器来定时同步所有服务器的时钟\n## 总结\n### MQ的存储容量上限\n- RabbitMQ如果消息数量超过 `x-max-length`，RabbitMQ 会**移除最旧的消息**，以便插入新消息。\n\t- map.put(\"x-max-length\", 1000);          // 最多 1000 条消息\n- RabbitMQ如果总大小超过 `x-max-length-bytes`，RabbitMQ 也会**删除旧消息**直到满足条件。\n\t- map.put(\"x-max-length-bytes\", 1000000); // 总字节数不超过1MB(约 1,000,000 字节)\n- RabbitMQ所以只能存储 1,000,000 bytes ÷ 16,000 bytes ≈ 62.5 条\n- RocketMQ如果消息大小超过4K, 会将消息压缩发送\n### 如何保证消息可靠性?\n| 阶段           | 机制           | 保证手段           |\n| ------------ | ------------ | -------------- |\n| 生产端的可靠投递     | 同步发送、发送确认、重试 | 保证消息能到达 Broker |\n| Broker服务端    | 磁盘持久化、主从复制   | 保证消息不丢失、可恢复    |\n| 消费端的确认消费 ACK | 消费确认、消息重试机制  | 保证消息不会漏处理或重复处理 |\n\n### 如何保证消息的幂等性(消息被重复消费)?\n- 消息必须携带唯一标识来保证幂等性\n- 通过使用雪花算法生成唯一消息id\n- 在消费时通过Redis判断是否存在以消息id为key的键值对, 存在就证明被消费过, 不再消费\n- 使用 **数据库插入法** ，基于数据库的唯一键来保证重复数据不会被插入多条。\n- 这些实现幂等的方法，也同样适用于，**在其他场景中来解决重复请求或者重复调用的问题** 。比如将 HTTP 服务设计成幂等的，**解决前端或者 APP 重复提交表单数据的问题** ，也可以将一个微服务设计成幂等的，解决 `RPC` 框架自动重试导致的 **重复调用问题** 。\n### RocketMQ如何实现延迟消息:\n- 将消息发送到临时Topic中的队列, 定时任务轮询, 然后把这些队列投递到对应的正确Topic中队列进行消费\n### 如何处理消息积压?\n- 溯源\n\t- 我们可以先检查 **是否是消费者出现了大量的消费错误** ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题\n- Broker端(队列端)\n\t- 部署Broker集群, 增加存储水平\n\t- 新建一些临时Broker用来存放消息\n- 消费端\n\t- 扩容消费者, 增加消费能力, 通过也应该扩容同一主题下的队列数量, 因为自始至终一个队列只能被一个消费者消费, 消费者多了, 而队列没多, 也会导致消费者被搁置\n\t- 优化消费逻辑: 消息积攒一批，一次性查询或写入数据库, 减少数据库IO\n- 逻辑端\n\t- 修改**prefetch count**, RabbitMQ官方给出的建议是prefetch count一般设置在100~300之间\n\t\t- prefetch count过大导致内存溢出问题\n\t\t- prefetch count过小导致吞吐量过低\n\t- 使用 延时队列TTL + 死信队列\n### 如何实现延迟消息?\n- Broker受到消息后先发送到特定的延时队列中, 开启一个定时任务轮询检测是否到时间, 若是, 再将消息投递到对应的供消费者消费的队列中\n### 发送方确认机制\n- 配置\n```yaml\nspring:  \n  rabbitmq:  \n    template:  \n      retry:  \n        enabled: true             # 开启发送失败时的重试机制  \n        initial-interval: 10s     # 初始重试间隔为10秒  \n        multiplier: 1             # 每次重试间隔不增长（固定间隔）  \n        max-attempts: 3           # 最多重试3次  \n    publisher-confirm-type: correlated     # 开启发送确认  \n    publisher-returns: true      # 开启Return 回调\n```\n- 发送消息时带上 CorrelationData: 可用于回调中追踪消息\n```java\n@Autowired  \nprivate RabbitTemplate rabbitTemplate;  \n​  \npublic void sendMessage() {  \n    String message = \"Hello RabbitMQ\";  \n    CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());  \n​  \n    rabbitTemplate.convertAndSend(  \n        \"orderExchange\",        // 交换机名  \n        \"order.processed\",      // 路由键  \n        message,  \n        correlationData         // 可用于回调中追踪消息   \n    );  \n}\n```\n- 配置回调\n```java\n@Configuration  \npublic class RabbitConfig {  \n​  \n    @Bean  \n    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {  \n        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);  \n​  \n        // 当生产者将消息发送到交换机后，会触发这个回调  \n        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {  \n            if (ack) {  \n                System.out.println(\"发送成功！CorrelationData: \" + correlationData);  \n            } else {  \n                System.err.println(\"发送失败！Cause: \" + cause);  \n            }  \n        });  \n​  \n        // 确认队列是否收到  \n        rabbitTemplate.setReturnsCallback(returned -> {  \n            System.err.println(\"消息未路由到队列: \" + returned.getMessage());  \n        });  \n​  \n        return rabbitTemplate;  \n    }  \n}\n```\n### 消费者消息确认和重试机制\n- 配置\n```yaml\nspring:  \n  rabbitmq:  \n    listener:  \n      simple:  \n        acknowledge-mode: manual   # 消息手动确认（业务处理成功后显式 ack）  \n        prefetch: 1                # 控制每次消费的条数  \n        retry:  \n          enabled: true           # 启用消费失败后的重试机制  \n          max-attempts: 3     # 最大重试次数  \n          initial-interval: 1000ms  \n          multiplier: 2       # 间隔时间增长倍数  \n          max-interval: 10000ms  \n    connection-timeout: 10s       # 连接超时设置\n```\n\n| 方法                            | 含义          | 用法                             |\n| ----------------------------- | ----------- | ------------------------------ |\n| `basicAck(tag, false)`        | 手动确认        | 正常消费成功后调用                      |\n| `basicNack(tag, false, true)` | 拒绝 + 是否重回队列 | 消息失败处理时使用                      |\n| `basicReject(tag, false)`     | 拒绝，不支持批量    | 等价于 `basicNack(requeue=false)` |\n\n- 消费者确认\n```java\n@Component  \npublic class OrderConsumer {  \n​  \n    @RabbitListener(queues = \"orderQueue\")  \n    public void receiveMessage(MsgBody msgBody, Message message, Channel channel) {  \n        try {  \n            System.out.println(\"✅ 收到消息：\" + msgBody);  \n​  \n            // 处理业务逻辑…  \n​  \n            // 手动确认消息（消息处理成功）: deliveryTag:RabbitMQ自动分配,用于标识消费者Channel中的消息  \n            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);  \n​  \n        } catch (Exception e) {  \n            System.err.println(\"消息处理失败：\" + e.getMessage());  \n​  \n            // 拒绝消息，并决定是否重回队列  \n            try {  \n                // 是否拒绝多个消息 是否重新入队  \n                channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false);   \n            } catch (IOException ioException) {  \n                ioException.printStackTrace();  \n            }  \n        }  \n    }  \n}\n```\n### 为什么MQ不直接使用Http协议呢？\n- 因为Http请求和响应报文是比较复杂的，包含了cookie、数据的加密解密、状态码、晌应码等附加的功能，但是对于个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就够，要追求的是高性能。尽量简洁，快速。\n- 大部分情况下Http大部分都是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，所以必须保持长链接, 目的是为了保证消息和数据的高可靠和稳健的运行\n### 小芝士\n- 一般来说要控制 主题中的队列数量与消费者一致\n- 一个队列在同一时刻只能被消费者组内的一个消费者消费\n- 每一个消费者组都要维护自己的消费位置(offSet指针), 如果不单独维护，每个消费组就没办法知道自己消费到哪里了，会互相干扰\n- RabbitMQ和ActiveMQ不像Kafka和RocketMQ一样支持主从以及分布式集群, 而是只支持主从\n- 如果业务场景对并发量(吞吐量)要求不是太高, 又因为RabbitMQ延迟在微秒级别, 时效性最高，RabbitMQ 一定是你的首选\n- Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据\n- 如果为了避免consumer崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull模式下，consumer就可以根据自己的消费能力去决定这些策略。\n","source":"_posts/RabbitMQ.md","raw":"---\nbanner: \"[[pixel-banner-image.png]]\"\ntitle: MQ消息队列\ntags:\n  - RabbitMQ\n  - SnowflakeId\n  - RocketMQ\ncategories: 编程\ndate: 2025-02-17T10:02:00\n---\n\n# MQ消息队列\n## 简介\n- 消息队列(Message Queue)是在消息的传输过程中保存消息的容器。\n![17536471244591753647124102.png|700x808](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17536471244591753647124102.png)\n- **Broker**是mq的核心组件, 主要功能是负责 **接收生产者发送的消息**, **将消息投递给对应的消费者**\n- **connection 连接与 channel 信道**:\n    - AMQP的连接是长连接，它是一个使用 TCP作为可靠传输的应用层协议, 而信道channel是建立在真实的长TCP连接内的虚拟链接\n    - AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，都是通过信道完成的\n    - 类似于进程和线程, 一个服务对应一个connection, 服务中的每一个线程对应一个channel\n## 消息传输协议对比\n| 协议        | 传输层 | 模式       | 消息持久化  | 可靠性 | 特点                 | 常见实现                                        | 优点                                |\n| --------- | --- | -------- | ------ | --- | ------------------ | ------------------------------------------- | --------------------------------- |\n| MQTT      | TCP | 发布/订阅    | 支持 QoS | 高   | IoT 数据上报、移动端消息推送   | Mosquitto、EMQX、HiveMQ、阿里云物联网平台              | 轻量级的通讯协议, 即使在网络条件较差的情况下也能保持通信的稳定性 |\n| AMQP      | TCP | 发布/订阅/队列 | 支持     | 高   | 支持事务、确认机制、复杂路由     | RabbitMQ、Apache Qpid                        | 可靠性强、功能丰富、支持复杂业务逻辑                |\n| Kafka     | TCP | 发布/订阅/日志 | 内建持久化  | 高   | 自定义二进制协议、高吞吐量、顺序消费 | Apache Kafka                                | 高性能、高吞吐、顺序性好、可回溯消息                |\n| HTTP      | TCP | 请求-响应短链接 | 不支持    | 中   | 短时请求-响应通信          | 所有 Web 服务器/客户端（Nginx、Tomcat、浏览器等）           | 实现简单、生态完善、无客户端限制                  |\n| WebSocket | TCP | 双向长连接    | 不支持    | 中   | 实时通信、低延迟推送         | 浏览器/WebSocket Server、Netty、Spring WebSocket | 实时性强、双向通信、延迟低                     |\n## 作用\n- **解耦**: 快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间\n- **异步**: 用户下单后，系统可以先返回一个下单成功的消息，然后将订单信息放入消息队列中，后台系统再去处理订单信息, 而是相当于**异步线程**处理其他消费者信息\n- **削峰**: 将瞬时的高峰流量转化为持续的低流量，从而保护系统不会因为瞬时的高流量而崩溃, 使用mq对消息进行分段保存, **由消费者每次拉取一定数量的数据进行处理(prefetch)**\n![17406620441921740662044061.png|700x420](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17406620441921740662044061.png)\n## 特点\n- **可靠性**。支持持久化，传输确认，发布确认(ack序列码)等保证了MQ的可靠性。\n- **灵活的分发消息策略**。\n    - RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。\n    - RocketMQ使用 主题（Topic）+ 标签（Tag）+ 消费组（Consumer Group）来完成消息分类和消费。轮询发送(默认)\n- **支持集群**。多台MQ服务器可以组成一个集群，形成一个逻辑Broker(代理)。\n- **多种协议**。MQ支持多种消息队列协议，比如 STOMP、MQTT 等等。\n- **支持多种语言客户端**。RabbitMQ几乎支持所有常用编程语言，包括 Java(amqpTemplate客户端)、.NET、Ruby 等等。\n- **可视化管理界面**。\n    - RabbitMQ提供了一个易用的用户界面程序**Erlang**(端口是15672)\n    - RocketMQ的控制台是一个**SpringBoot项目**,需要手动打开; 或者使用打包好的jar包\n## 分析 RabbitMQ与RocketMQ\n### RabbitMQ(推模式)\n**RabbitMQ是采用 Erlang语言实现AMQP协议的消息中间件**\n- **虚拟主机**: 每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制\n- **交换机**: 一个重要组件,各自有自己的路由键, 负责接收生产者发送的消息，并根据一定的路由规则（如路由键、绑定等）将消息转发到一个或多个队列 ---> 控制消息的分发规则(交换机是消息的中转站)\n- **路由键**: 帮助交换机决定该消息应该被转发到哪个队列(规则), 是交换机的关键\n- **队列**: 队列是RabbitMQ中的一个存储结构，用于保存消息，直到消费者从队列中获取并处理这些消息。\n- **例子**: 假设有一个生产者将消息发送到一个`direct`类型的交换机，该交换机的路由键是`\"order.processed\"`。这个交换机会将消息转发到一个与该路由键绑定的队列，比如叫做`orderQueue`。消费者只需要监听 `orderQueue`，即可接收到 `\"order.processed\"` 类型的订单消息进行处理。\n![17536391946501753639194226.png|700x209](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17536391946501753639194226.png)\n### RocketMQ(拉模式)\n- **主题**: Topic\n- **路由键**: Tag + 可选 Key, RocketMQ 中的 Tag 是对消息的简单分类，Key 可以做业务标识。没有复杂的路由表达式\n- **消费组**: 消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。默认情况，如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。\n- **消费位置**: Offset, 为每个消费组在每个队列上维护一个消费位置, 用于为当前消费组保存上次消费到的位置\n- **队列**: MessageQueue, RocketMQ 的每个 Topic 会自动被分为多个消息队列，Producer 可指定发往哪个队列（可用于顺序消息）\n- **例子**: 创建一个 `Topic`主题：`OrderTopic`, 生产者发送消息到 `OrderTopic`，并设置 `Tag`(路由键) 为 `processed`, 消费者订阅 `OrderTopic`，并使用 `Tag` = \"`processed`\" 作为过滤条件, Broker 接收并分发消息到对应的 `MessageQueue`（队列片段), 消费者所在的`Consumer Group`拉取消息进行处理\n![17475484290661747548428888.png|700x400](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17475484290661747548428888.png)\n## RocketMQ集群\n- 一个 `Topic` 分布在多个 `Broker`上，一个 `Broker` 可以配置多个 `Topic` ，它们是多对多的关系\n### 步骤\n- 首先, 我们在Broker上做了主从+集群, 分`Master`和`Slaver`, Slaver会定时从Master备份数据(同步复制: 只有消息同步双写到主从节点上时才返回写入成功, 异步复制)，如果 `master` 宕机，则 `slave` 提供消费服务，但是不能写入消息\n- 其次, 我们对`NameServer`也做了集群, 但是不分主从节点, 每隔30s每一个`broker`会向所有的`NameServer`发送ping心跳检测(单个 Broker 和所有 NameServer 保持长连接), 心跳信息包括了Topic配置信息以及路由表信息\n- 在生产者需要向`Broker`发送消息的时候，需要先从`NameServer`获取关于 `Broker` 的路由表信息，然后通过轮询的方法去向每个队列中生产数据以达到 负载均衡 的效果。\n- 消费者通过NameServer获取路由表消息, 向broker拉取消息消费`Consumer` 可以以两种模式启动 广播和集群, 广播模式下，一条消息会发送给同一个消费组中的所有消费者 ，集群模式下消息只会发送给一个消费者。\n![17581623162691758162315810.png|698x506](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17581623162691758162315810.png)\n## Kafka集群\n### 单节点优化方案\n- 单节点Kafka的在高流量突增和存储压力增大时, 如果broker崩溃会联锁导致整个系统崩塌\n- 考虑使用主从节点部署\n\t- 主broker负责写\n\t- 从broker负责读\n\t- 从节点定期从主节点同步消息\n- 这样就算其中一个broker瘫痪也能使用另外一个broker\n### 集群优化方案\n- 部署多个broker服务, topic采用分布式方式存储, 一个topic数据被分散到不同broker服务中\n- 采用生产者集群和消费者集群, 提高生产消费能力;\n- broker集群定期向注册中心集群(ZooKeeper)发送心跳检测以及整个集群状态路由表(如: broker, topic); RocketMQ的注册中心则为NameServer;\n- 生产者集群和消费者集群监听注册中心, 确认每次生产和消费的消息是哪一个topic下的哪一个partation, 确保消费者拉取的同一性;\n![17580141768161758014176045.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580141768161758014176045.png)\n## 死信队列\n- 存储那些无法被正常消费的消息,通常由交换机和路由键指定到特殊的队列(即死信队列)\n- **消息过期**：如果消息设置了`expiration`属性，当消息在队列中存放超过指定时间后会被丢弃，并进入死信队列。\n- **队列溢出**：当队列已满且无法再接收新的消息时，新进入的消息将会被丢弃并进入死信队列。\n- **消息被拒绝**：当消费者拒绝处理某条消息时，可以选择将消息标记为“死信”。这种情况下，消息会进入死信队列。\n- **消费者未确认**：如果消息被消费者消费后未发送确认（ack），并且RabbitMQ设置了`requeue`为`false`，则消息会被丢弃并进入死信队列。\n要为队列或交换机添加死信参数（Dead Letter Exchange）配置，应该关注以下几个部分：\n1. **Dead letter exchange**：这里可以填写死信交换机的名称。当队列中的消息因某种原因（如超时、被拒绝等）不能被消费时，它们将被转发到这个死信交换机。你需要在此输入目标死信交换机的名称。\n2. **Dead letter routing key**：这是可选的参数，用于指定死信队列的路由键。消息会被转发到死信交换机，并根据路由键路由到相应的队列。你可以填写路由键，或者留空使用默认设置。\n    \n在配置过程中，如果你为队列设置了 **Dead letter exchange**，确保死信交换机已经存在，并且设置正确。你还可以根据需求配置其他参数，如 **Message TTL**（消息的过期时间）和 **Auto expire**（队列的过期时间）。\n### 死信参数添加步骤：\n\n1. 在 RabbitMQ 管理界面创建或编辑队列或交换机。\n2. 在 `Arguments` 部分找到并配置：\n    - **Dead letter exchange**：填写死信交换机的名称。\n    - **Dead letter routing key**：可选，填写死信路由键的名称。\n3. 完成设置后，保存队列或交换机配置。\n### 其他相关参数：\n- **Auto expire**：队列自动过期的时间。\n- **Message TTL**：设置消息的过期时间，消息在 TTL 到期后会被丢弃或进入死信队列。\n- **Overflow behaviour**：设置当队列达到最大长度时的行为。\n- **Single active consumer**：如果设置为 `true`，该队列只允许一个消费者进行消费。\n- **Max length / Max length bytes**：设置队列的最大长度或最大字节数，超出后会触发 `Overflow behaviour`。\n## 分发消息策略\n### 1. 简单队列模式 (Direct Mode)\n- 特点：生产者生产消息, 由多个消费者去竞争消费, 每个消息只消费一次\n- 使用场景：**适用于简单的点对点通信，生产者与消费者直接交互**。\n- 实现方式：生产者将消息发送到某个特定的队列，消费者从该队列中接收消息。\n- 特点：没有复杂的路由逻辑，简单高效，但不适合多消费者的场景。\n### 2. 工作队列模式 (Work Queue)\n- 特点：**生产者将消息发送到一个共享的队列(一对多)，多个消费者从该队列中获取消息进行并行处理。**\n- 使用场景：适用于**负载均衡**，多个消费者共同处理任务，避免某个消费者负担过重。\n- 实现方式：所有消费者都监听同一个队列，RabbitMQ会以公平的方式将消息分发给消费者（即一个消费者处理一条消息，直到处理完才会继续接收新的消息）。\n- 特点：消费者可以并行处理任务，确保负载均衡和异步处理，适用于后台任务处理、分布式任务调度等。\n### 3. 发布订阅模式 (Publish/Subscribe)\n- 特点：**生产者将消息发布到一个交换机(主题)，然后多个消费者订阅该交换机(主题)，消费者将接收来自交换机(主题)的所有消息, 也就是一个消息可以多次消费。**\n- 使用场景：**适用于广播消息场景，例如日志收集、事件通知等**。\n- 实现方式：生产者将消息发布到一个广播类型的交换机（如`fanout`交换机），交换机会将消息广播给所有绑定在其上的队列，所有消费者都会收到该消息。\n- 特点：通过交换机将消息发送到多个队列，实现多消费者接收消息，适用于需要广播的场景。\n### 4. 路由模式 (Routing)\n- 特点：生产者将消息发送到交换机，并通过指定的路由键来决定消息的去向。消费者根据路由键来决定是否接收消息。\n- 使用场景：适用于根据消息的某些属性进行路由，灵活性较高，能够支持更多的消息传递场景。\n- 实现方式：使用`direct`交换机，生产者将消息发送到交换机，并指定路由键，交换机会根据路由键将消息转发给与该路由键匹配的队列。消费者通过监听特定的队列来接收消息。\n- 特点：灵活的消息路由机制，生产者与消费者通过路由键关联，可以将消息发送到特定的队列\n## 全局唯一Id生成策略\n### Snowflake(64bit位的long类型)\n- 解决的问题: 分布式场景下主键ID重复性问题\n![17603292854441760329284549.png|700x214](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17603292854441760329284549.png)\n![17536471744521753647173892.png|700x396](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17536471744521753647173892.png)\n\n```java\n// 反解析 雪花id 右移22位机器位 加上元年时间戳得到当前时间\npublic class SnowflakeIdParser {\n\n    // Hutool 默认起始时间戳\n    private static final long EPOCH = 1577808000000L;\n\n    public static void main(String[] args) {\n        long id = 1950232867263090688L;\n\n        // 反解析时间戳（去掉序列号和机器ID部分，即右移22位）\n        long timePart = (id >> 22);\n\n        // 计算实际生成时间\n        long generateTime = timePart + EPOCH;\n\n        Date date = new Date(generateTime);\n        System.out.println(\"生成时间: \" + date);\n\n        // 反解析机器ID和序列号（根据Hutool Snowflake结构）\n        // Hutool Snowflake结构：\n        // 41位时间戳 | 10位工作机器ID | 12位序列号\n\n        long sequence = id & ((1 << 12) - 1); // 最后12位\n        long workerId = (id >> 12) & ((1 << 10) - 1); // 中间10位\n\n        System.out.println(\"工作机器ID: \" + workerId);\n        System.out.println(\"序列号: \" + sequence);\n    }\n}\n```\n### 百度的UidGenerate\n- 本质上也是基于雪花算法的64bit的id, 不同的是修改了64bit的分配比例\n- 时间戳可使用年数从原本的约69年下降至6年, 但是可分配的机器bit和序列毫秒bit增多, **解决了在高并发、大规模机器部署场景下，传统雪花算法机器位不够用的问题**\n![17603299984431760329997773.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17603299984431760329997773.png)\n### 时钟回拨问题\n- 出现原因\n\t1. 修改了系统时间\n\t2. 有时候不同的机器上需要同步时间，可能不同机器之间存在误差，那么可能会出现时间回拨问题\n- 解决方案\n\t1. 回拨时间小的时候，不生成 ID，**阻塞等待**到时间点到达。\n\t2. 上面的方案只适合时钟回拨较小的，如果间隔过大，阻塞等待，肯定是不可取的，因此要么**超过一定大小的回拨直接报错，拒绝服务**\n\t3. 使用中间服务器来定时同步所有服务器的时钟\n## 总结\n### MQ的存储容量上限\n- RabbitMQ如果消息数量超过 `x-max-length`，RabbitMQ 会**移除最旧的消息**，以便插入新消息。\n\t- map.put(\"x-max-length\", 1000);          // 最多 1000 条消息\n- RabbitMQ如果总大小超过 `x-max-length-bytes`，RabbitMQ 也会**删除旧消息**直到满足条件。\n\t- map.put(\"x-max-length-bytes\", 1000000); // 总字节数不超过1MB(约 1,000,000 字节)\n- RabbitMQ所以只能存储 1,000,000 bytes ÷ 16,000 bytes ≈ 62.5 条\n- RocketMQ如果消息大小超过4K, 会将消息压缩发送\n### 如何保证消息可靠性?\n| 阶段           | 机制           | 保证手段           |\n| ------------ | ------------ | -------------- |\n| 生产端的可靠投递     | 同步发送、发送确认、重试 | 保证消息能到达 Broker |\n| Broker服务端    | 磁盘持久化、主从复制   | 保证消息不丢失、可恢复    |\n| 消费端的确认消费 ACK | 消费确认、消息重试机制  | 保证消息不会漏处理或重复处理 |\n\n### 如何保证消息的幂等性(消息被重复消费)?\n- 消息必须携带唯一标识来保证幂等性\n- 通过使用雪花算法生成唯一消息id\n- 在消费时通过Redis判断是否存在以消息id为key的键值对, 存在就证明被消费过, 不再消费\n- 使用 **数据库插入法** ，基于数据库的唯一键来保证重复数据不会被插入多条。\n- 这些实现幂等的方法，也同样适用于，**在其他场景中来解决重复请求或者重复调用的问题** 。比如将 HTTP 服务设计成幂等的，**解决前端或者 APP 重复提交表单数据的问题** ，也可以将一个微服务设计成幂等的，解决 `RPC` 框架自动重试导致的 **重复调用问题** 。\n### RocketMQ如何实现延迟消息:\n- 将消息发送到临时Topic中的队列, 定时任务轮询, 然后把这些队列投递到对应的正确Topic中队列进行消费\n### 如何处理消息积压?\n- 溯源\n\t- 我们可以先检查 **是否是消费者出现了大量的消费错误** ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题\n- Broker端(队列端)\n\t- 部署Broker集群, 增加存储水平\n\t- 新建一些临时Broker用来存放消息\n- 消费端\n\t- 扩容消费者, 增加消费能力, 通过也应该扩容同一主题下的队列数量, 因为自始至终一个队列只能被一个消费者消费, 消费者多了, 而队列没多, 也会导致消费者被搁置\n\t- 优化消费逻辑: 消息积攒一批，一次性查询或写入数据库, 减少数据库IO\n- 逻辑端\n\t- 修改**prefetch count**, RabbitMQ官方给出的建议是prefetch count一般设置在100~300之间\n\t\t- prefetch count过大导致内存溢出问题\n\t\t- prefetch count过小导致吞吐量过低\n\t- 使用 延时队列TTL + 死信队列\n### 如何实现延迟消息?\n- Broker受到消息后先发送到特定的延时队列中, 开启一个定时任务轮询检测是否到时间, 若是, 再将消息投递到对应的供消费者消费的队列中\n### 发送方确认机制\n- 配置\n```yaml\nspring:  \n  rabbitmq:  \n    template:  \n      retry:  \n        enabled: true             # 开启发送失败时的重试机制  \n        initial-interval: 10s     # 初始重试间隔为10秒  \n        multiplier: 1             # 每次重试间隔不增长（固定间隔）  \n        max-attempts: 3           # 最多重试3次  \n    publisher-confirm-type: correlated     # 开启发送确认  \n    publisher-returns: true      # 开启Return 回调\n```\n- 发送消息时带上 CorrelationData: 可用于回调中追踪消息\n```java\n@Autowired  \nprivate RabbitTemplate rabbitTemplate;  \n​  \npublic void sendMessage() {  \n    String message = \"Hello RabbitMQ\";  \n    CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());  \n​  \n    rabbitTemplate.convertAndSend(  \n        \"orderExchange\",        // 交换机名  \n        \"order.processed\",      // 路由键  \n        message,  \n        correlationData         // 可用于回调中追踪消息   \n    );  \n}\n```\n- 配置回调\n```java\n@Configuration  \npublic class RabbitConfig {  \n​  \n    @Bean  \n    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {  \n        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);  \n​  \n        // 当生产者将消息发送到交换机后，会触发这个回调  \n        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {  \n            if (ack) {  \n                System.out.println(\"发送成功！CorrelationData: \" + correlationData);  \n            } else {  \n                System.err.println(\"发送失败！Cause: \" + cause);  \n            }  \n        });  \n​  \n        // 确认队列是否收到  \n        rabbitTemplate.setReturnsCallback(returned -> {  \n            System.err.println(\"消息未路由到队列: \" + returned.getMessage());  \n        });  \n​  \n        return rabbitTemplate;  \n    }  \n}\n```\n### 消费者消息确认和重试机制\n- 配置\n```yaml\nspring:  \n  rabbitmq:  \n    listener:  \n      simple:  \n        acknowledge-mode: manual   # 消息手动确认（业务处理成功后显式 ack）  \n        prefetch: 1                # 控制每次消费的条数  \n        retry:  \n          enabled: true           # 启用消费失败后的重试机制  \n          max-attempts: 3     # 最大重试次数  \n          initial-interval: 1000ms  \n          multiplier: 2       # 间隔时间增长倍数  \n          max-interval: 10000ms  \n    connection-timeout: 10s       # 连接超时设置\n```\n\n| 方法                            | 含义          | 用法                             |\n| ----------------------------- | ----------- | ------------------------------ |\n| `basicAck(tag, false)`        | 手动确认        | 正常消费成功后调用                      |\n| `basicNack(tag, false, true)` | 拒绝 + 是否重回队列 | 消息失败处理时使用                      |\n| `basicReject(tag, false)`     | 拒绝，不支持批量    | 等价于 `basicNack(requeue=false)` |\n\n- 消费者确认\n```java\n@Component  \npublic class OrderConsumer {  \n​  \n    @RabbitListener(queues = \"orderQueue\")  \n    public void receiveMessage(MsgBody msgBody, Message message, Channel channel) {  \n        try {  \n            System.out.println(\"✅ 收到消息：\" + msgBody);  \n​  \n            // 处理业务逻辑…  \n​  \n            // 手动确认消息（消息处理成功）: deliveryTag:RabbitMQ自动分配,用于标识消费者Channel中的消息  \n            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);  \n​  \n        } catch (Exception e) {  \n            System.err.println(\"消息处理失败：\" + e.getMessage());  \n​  \n            // 拒绝消息，并决定是否重回队列  \n            try {  \n                // 是否拒绝多个消息 是否重新入队  \n                channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false);   \n            } catch (IOException ioException) {  \n                ioException.printStackTrace();  \n            }  \n        }  \n    }  \n}\n```\n### 为什么MQ不直接使用Http协议呢？\n- 因为Http请求和响应报文是比较复杂的，包含了cookie、数据的加密解密、状态码、晌应码等附加的功能，但是对于个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就够，要追求的是高性能。尽量简洁，快速。\n- 大部分情况下Http大部分都是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，所以必须保持长链接, 目的是为了保证消息和数据的高可靠和稳健的运行\n### 小芝士\n- 一般来说要控制 主题中的队列数量与消费者一致\n- 一个队列在同一时刻只能被消费者组内的一个消费者消费\n- 每一个消费者组都要维护自己的消费位置(offSet指针), 如果不单独维护，每个消费组就没办法知道自己消费到哪里了，会互相干扰\n- RabbitMQ和ActiveMQ不像Kafka和RocketMQ一样支持主从以及分布式集群, 而是只支持主从\n- 如果业务场景对并发量(吞吐量)要求不是太高, 又因为RabbitMQ延迟在微秒级别, 时效性最高，RabbitMQ 一定是你的首选\n- Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据\n- 如果为了避免consumer崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull模式下，consumer就可以根据自己的消费能力去决定这些策略。\n","slug":"RabbitMQ","published":1,"updated":"2025-10-13T09:01:07.985Z","_id":"cmfw4z09f000huomwdojx46tb","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"MQ消息队列\"><a href=\"#MQ消息队列\" class=\"headerlink\" title=\"MQ消息队列\"></a>MQ消息队列</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li>消息队列(Message Queue)是在消息的传输过程中保存消息的容器。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17536471244591753647124102.png\" alt=\"17536471244591753647124102.png|700x808\"></li>\n<li><strong>Broker</strong>是mq的核心组件, 主要功能是负责 <strong>接收生产者发送的消息</strong>, <strong>将消息投递给对应的消费者</strong></li>\n<li><strong>connection 连接与 channel 信道</strong>:<ul>\n<li>AMQP的连接是长连接，它是一个使用 TCP作为可靠传输的应用层协议, 而信道channel是建立在真实的长TCP连接内的虚拟链接</li>\n<li>AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，都是通过信道完成的</li>\n<li>类似于进程和线程, 一个服务对应一个connection, 服务中的每一个线程对应一个channel<h2 id=\"消息传输协议对比\"><a href=\"#消息传输协议对比\" class=\"headerlink\" title=\"消息传输协议对比\"></a>消息传输协议对比</h2>| 协议        | 传输层 | 模式       | 消息持久化  | 可靠性 | 特点                 | 常见实现                                        | 优点                                |<br>| ————- | —- | ———— | ——— | —- | ————————— | —————————————————————- | ————————————————- |<br>| MQTT      | TCP | 发布/订阅    | 支持 QoS | 高   | IoT 数据上报、移动端消息推送   | Mosquitto、EMQX、HiveMQ、阿里云物联网平台              | 轻量级的通讯协议, 即使在网络条件较差的情况下也能保持通信的稳定性 |<br>| AMQP      | TCP | 发布/订阅/队列 | 支持     | 高   | 支持事务、确认机制、复杂路由     | RabbitMQ、Apache Qpid                        | 可靠性强、功能丰富、支持复杂业务逻辑                |<br>| Kafka     | TCP | 发布/订阅/日志 | 内建持久化  | 高   | 自定义二进制协议、高吞吐量、顺序消费 | Apache Kafka                                | 高性能、高吞吐、顺序性好、可回溯消息                |<br>| HTTP      | TCP | 请求-响应短链接 | 不支持    | 中   | 短时请求-响应通信          | 所有 Web 服务器/客户端（Nginx、Tomcat、浏览器等）           | 实现简单、生态完善、无客户端限制                  |<br>| WebSocket | TCP | 双向长连接    | 不支持    | 中   | 实时通信、低延迟推送         | 浏览器/WebSocket Server、Netty、Spring WebSocket | 实时性强、双向通信、延迟低                     |<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2></li>\n</ul>\n</li>\n<li><strong>解耦</strong>: 快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间</li>\n<li><strong>异步</strong>: 用户下单后，系统可以先返回一个下单成功的消息，然后将订单信息放入消息队列中，后台系统再去处理订单信息, 而是相当于<strong>异步线程</strong>处理其他消费者信息</li>\n<li><strong>削峰</strong>: 将瞬时的高峰流量转化为持续的低流量，从而保护系统不会因为瞬时的高流量而崩溃, 使用mq对消息进行分段保存, <strong>由消费者每次拉取一定数量的数据进行处理(prefetch)</strong><br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17406620441921740662044061.png\" alt=\"17406620441921740662044061.png|700x420\"><h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2></li>\n<li><strong>可靠性</strong>。支持持久化，传输确认，发布确认(ack序列码)等保证了MQ的可靠性。</li>\n<li><strong>灵活的分发消息策略</strong>。<ul>\n<li>RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li>\n<li>RocketMQ使用 主题（Topic）+ 标签（Tag）+ 消费组（Consumer Group）来完成消息分类和消费。轮询发送(默认)</li>\n</ul>\n</li>\n<li><strong>支持集群</strong>。多台MQ服务器可以组成一个集群，形成一个逻辑Broker(代理)。</li>\n<li><strong>多种协议</strong>。MQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>\n<li><strong>支持多种语言客户端</strong>。RabbitMQ几乎支持所有常用编程语言，包括 Java(amqpTemplate客户端)、.NET、Ruby 等等。</li>\n<li><strong>可视化管理界面</strong>。<ul>\n<li>RabbitMQ提供了一个易用的用户界面程序<strong>Erlang</strong>(端口是15672)</li>\n<li>RocketMQ的控制台是一个<strong>SpringBoot项目</strong>,需要手动打开; 或者使用打包好的jar包<h2 id=\"分析-RabbitMQ与RocketMQ\"><a href=\"#分析-RabbitMQ与RocketMQ\" class=\"headerlink\" title=\"分析 RabbitMQ与RocketMQ\"></a>分析 RabbitMQ与RocketMQ</h2><h3 id=\"RabbitMQ-推模式\"><a href=\"#RabbitMQ-推模式\" class=\"headerlink\" title=\"RabbitMQ(推模式)\"></a>RabbitMQ(推模式)</h3><strong>RabbitMQ是采用 Erlang语言实现AMQP协议的消息中间件</strong></li>\n</ul>\n</li>\n<li><strong>虚拟主机</strong>: 每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制</li>\n<li><strong>交换机</strong>: 一个重要组件,各自有自己的路由键, 负责接收生产者发送的消息，并根据一定的路由规则（如路由键、绑定等）将消息转发到一个或多个队列 —-&gt; 控制消息的分发规则(交换机是消息的中转站)</li>\n<li><strong>路由键</strong>: 帮助交换机决定该消息应该被转发到哪个队列(规则), 是交换机的关键</li>\n<li><strong>队列</strong>: 队列是RabbitMQ中的一个存储结构，用于保存消息，直到消费者从队列中获取并处理这些消息。</li>\n<li><strong>例子</strong>: 假设有一个生产者将消息发送到一个<code>direct</code>类型的交换机，该交换机的路由键是<code>&quot;order.processed&quot;</code>。这个交换机会将消息转发到一个与该路由键绑定的队列，比如叫做<code>orderQueue</code>。消费者只需要监听 <code>orderQueue</code>，即可接收到 <code>&quot;order.processed&quot;</code> 类型的订单消息进行处理。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17536391946501753639194226.png\" alt=\"17536391946501753639194226.png|700x209\"><h3 id=\"RocketMQ-拉模式\"><a href=\"#RocketMQ-拉模式\" class=\"headerlink\" title=\"RocketMQ(拉模式)\"></a>RocketMQ(拉模式)</h3></li>\n<li><strong>主题</strong>: Topic</li>\n<li><strong>路由键</strong>: Tag + 可选 Key, RocketMQ 中的 Tag 是对消息的简单分类，Key 可以做业务标识。没有复杂的路由表达式</li>\n<li><strong>消费组</strong>: 消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。默认情况，如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。</li>\n<li><strong>消费位置</strong>: Offset, 为每个消费组在每个队列上维护一个消费位置, 用于为当前消费组保存上次消费到的位置</li>\n<li><strong>队列</strong>: MessageQueue, RocketMQ 的每个 Topic 会自动被分为多个消息队列，Producer 可指定发往哪个队列（可用于顺序消息）</li>\n<li><strong>例子</strong>: 创建一个 <code>Topic</code>主题：<code>OrderTopic</code>, 生产者发送消息到 <code>OrderTopic</code>，并设置 <code>Tag</code>(路由键) 为 <code>processed</code>, 消费者订阅 <code>OrderTopic</code>，并使用 <code>Tag</code> = “<code>processed</code>“ 作为过滤条件, Broker 接收并分发消息到对应的 <code>MessageQueue</code>（队列片段), 消费者所在的<code>Consumer Group</code>拉取消息进行处理<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17475484290661747548428888.png\" alt=\"17475484290661747548428888.png|700x400\"><h2 id=\"RocketMQ集群\"><a href=\"#RocketMQ集群\" class=\"headerlink\" title=\"RocketMQ集群\"></a>RocketMQ集群</h2></li>\n<li>一个 <code>Topic</code> 分布在多个 <code>Broker</code>上，一个 <code>Broker</code> 可以配置多个 <code>Topic</code> ，它们是多对多的关系<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3></li>\n<li>首先, 我们在Broker上做了主从+集群, 分<code>Master</code>和<code>Slaver</code>, Slaver会定时从Master备份数据(同步复制: 只有消息同步双写到主从节点上时才返回写入成功, 异步复制)，如果 <code>master</code> 宕机，则 <code>slave</code> 提供消费服务，但是不能写入消息</li>\n<li>其次, 我们对<code>NameServer</code>也做了集群, 但是不分主从节点, 每隔30s每一个<code>broker</code>会向所有的<code>NameServer</code>发送ping心跳检测(单个 Broker 和所有 NameServer 保持长连接), 心跳信息包括了Topic配置信息以及路由表信息</li>\n<li>在生产者需要向<code>Broker</code>发送消息的时候，需要先从<code>NameServer</code>获取关于 <code>Broker</code> 的路由表信息，然后通过轮询的方法去向每个队列中生产数据以达到 负载均衡 的效果。</li>\n<li>消费者通过NameServer获取路由表消息, 向broker拉取消息消费<code>Consumer</code> 可以以两种模式启动 广播和集群, 广播模式下，一条消息会发送给同一个消费组中的所有消费者 ，集群模式下消息只会发送给一个消费者。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17581623162691758162315810.png\" alt=\"17581623162691758162315810.png|698x506\"><h2 id=\"Kafka集群\"><a href=\"#Kafka集群\" class=\"headerlink\" title=\"Kafka集群\"></a>Kafka集群</h2><h3 id=\"单节点优化方案\"><a href=\"#单节点优化方案\" class=\"headerlink\" title=\"单节点优化方案\"></a>单节点优化方案</h3></li>\n<li>单节点Kafka的在高流量突增和存储压力增大时, 如果broker崩溃会联锁导致整个系统崩塌</li>\n<li>考虑使用主从节点部署<ul>\n<li>主broker负责写</li>\n<li>从broker负责读</li>\n<li>从节点定期从主节点同步消息</li>\n</ul>\n</li>\n<li>这样就算其中一个broker瘫痪也能使用另外一个broker<h3 id=\"集群优化方案\"><a href=\"#集群优化方案\" class=\"headerlink\" title=\"集群优化方案\"></a>集群优化方案</h3></li>\n<li>部署多个broker服务, topic采用分布式方式存储, 一个topic数据被分散到不同broker服务中</li>\n<li>采用生产者集群和消费者集群, 提高生产消费能力;</li>\n<li>broker集群定期向注册中心集群(ZooKeeper)发送心跳检测以及整个集群状态路由表(如: broker, topic); RocketMQ的注册中心则为NameServer;</li>\n<li>生产者集群和消费者集群监听注册中心, 确认每次生产和消费的消息是哪一个topic下的哪一个partation, 确保消费者拉取的同一性;<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580141768161758014176045.png\" alt=\"17580141768161758014176045.png\"><h2 id=\"死信队列\"><a href=\"#死信队列\" class=\"headerlink\" title=\"死信队列\"></a>死信队列</h2></li>\n<li>存储那些无法被正常消费的消息,通常由交换机和路由键指定到特殊的队列(即死信队列)</li>\n<li><strong>消息过期</strong>：如果消息设置了<code>expiration</code>属性，当消息在队列中存放超过指定时间后会被丢弃，并进入死信队列。</li>\n<li><strong>队列溢出</strong>：当队列已满且无法再接收新的消息时，新进入的消息将会被丢弃并进入死信队列。</li>\n<li><strong>消息被拒绝</strong>：当消费者拒绝处理某条消息时，可以选择将消息标记为“死信”。这种情况下，消息会进入死信队列。</li>\n<li><strong>消费者未确认</strong>：如果消息被消费者消费后未发送确认（ack），并且RabbitMQ设置了<code>requeue</code>为<code>false</code>，则消息会被丢弃并进入死信队列。<br>要为队列或交换机添加死信参数（Dead Letter Exchange）配置，应该关注以下几个部分：</li>\n</ul>\n<ol>\n<li><strong>Dead letter exchange</strong>：这里可以填写死信交换机的名称。当队列中的消息因某种原因（如超时、被拒绝等）不能被消费时，它们将被转发到这个死信交换机。你需要在此输入目标死信交换机的名称。</li>\n<li><strong>Dead letter routing key</strong>：这是可选的参数，用于指定死信队列的路由键。消息会被转发到死信交换机，并根据路由键路由到相应的队列。你可以填写路由键，或者留空使用默认设置。</li>\n</ol>\n<p>在配置过程中，如果你为队列设置了 <strong>Dead letter exchange</strong>，确保死信交换机已经存在，并且设置正确。你还可以根据需求配置其他参数，如 <strong>Message TTL</strong>（消息的过期时间）和 <strong>Auto expire</strong>（队列的过期时间）。</p>\n<h3 id=\"死信参数添加步骤：\"><a href=\"#死信参数添加步骤：\" class=\"headerlink\" title=\"死信参数添加步骤：\"></a>死信参数添加步骤：</h3><ol>\n<li>在 RabbitMQ 管理界面创建或编辑队列或交换机。</li>\n<li>在 <code>Arguments</code> 部分找到并配置：<ul>\n<li><strong>Dead letter exchange</strong>：填写死信交换机的名称。</li>\n<li><strong>Dead letter routing key</strong>：可选，填写死信路由键的名称。</li>\n</ul>\n</li>\n<li>完成设置后，保存队列或交换机配置。<h3 id=\"其他相关参数：\"><a href=\"#其他相关参数：\" class=\"headerlink\" title=\"其他相关参数：\"></a>其他相关参数：</h3></li>\n</ol>\n<ul>\n<li><strong>Auto expire</strong>：队列自动过期的时间。</li>\n<li><strong>Message TTL</strong>：设置消息的过期时间，消息在 TTL 到期后会被丢弃或进入死信队列。</li>\n<li><strong>Overflow behaviour</strong>：设置当队列达到最大长度时的行为。</li>\n<li><strong>Single active consumer</strong>：如果设置为 <code>true</code>，该队列只允许一个消费者进行消费。</li>\n<li><strong>Max length / Max length bytes</strong>：设置队列的最大长度或最大字节数，超出后会触发 <code>Overflow behaviour</code>。<h2 id=\"分发消息策略\"><a href=\"#分发消息策略\" class=\"headerlink\" title=\"分发消息策略\"></a>分发消息策略</h2><h3 id=\"1-简单队列模式-Direct-Mode\"><a href=\"#1-简单队列模式-Direct-Mode\" class=\"headerlink\" title=\"1. 简单队列模式 (Direct Mode)\"></a>1. 简单队列模式 (Direct Mode)</h3></li>\n<li>特点：生产者生产消息, 由多个消费者去竞争消费, 每个消息只消费一次</li>\n<li>使用场景：<strong>适用于简单的点对点通信，生产者与消费者直接交互</strong>。</li>\n<li>实现方式：生产者将消息发送到某个特定的队列，消费者从该队列中接收消息。</li>\n<li>特点：没有复杂的路由逻辑，简单高效，但不适合多消费者的场景。<h3 id=\"2-工作队列模式-Work-Queue\"><a href=\"#2-工作队列模式-Work-Queue\" class=\"headerlink\" title=\"2. 工作队列模式 (Work Queue)\"></a>2. 工作队列模式 (Work Queue)</h3></li>\n<li>特点：<strong>生产者将消息发送到一个共享的队列(一对多)，多个消费者从该队列中获取消息进行并行处理。</strong></li>\n<li>使用场景：适用于<strong>负载均衡</strong>，多个消费者共同处理任务，避免某个消费者负担过重。</li>\n<li>实现方式：所有消费者都监听同一个队列，RabbitMQ会以公平的方式将消息分发给消费者（即一个消费者处理一条消息，直到处理完才会继续接收新的消息）。</li>\n<li>特点：消费者可以并行处理任务，确保负载均衡和异步处理，适用于后台任务处理、分布式任务调度等。<h3 id=\"3-发布订阅模式-Publish-Subscribe\"><a href=\"#3-发布订阅模式-Publish-Subscribe\" class=\"headerlink\" title=\"3. 发布订阅模式 (Publish/Subscribe)\"></a>3. 发布订阅模式 (Publish/Subscribe)</h3></li>\n<li>特点：<strong>生产者将消息发布到一个交换机(主题)，然后多个消费者订阅该交换机(主题)，消费者将接收来自交换机(主题)的所有消息, 也就是一个消息可以多次消费。</strong></li>\n<li>使用场景：<strong>适用于广播消息场景，例如日志收集、事件通知等</strong>。</li>\n<li>实现方式：生产者将消息发布到一个广播类型的交换机（如<code>fanout</code>交换机），交换机会将消息广播给所有绑定在其上的队列，所有消费者都会收到该消息。</li>\n<li>特点：通过交换机将消息发送到多个队列，实现多消费者接收消息，适用于需要广播的场景。<h3 id=\"4-路由模式-Routing\"><a href=\"#4-路由模式-Routing\" class=\"headerlink\" title=\"4. 路由模式 (Routing)\"></a>4. 路由模式 (Routing)</h3></li>\n<li>特点：生产者将消息发送到交换机，并通过指定的路由键来决定消息的去向。消费者根据路由键来决定是否接收消息。</li>\n<li>使用场景：适用于根据消息的某些属性进行路由，灵活性较高，能够支持更多的消息传递场景。</li>\n<li>实现方式：使用<code>direct</code>交换机，生产者将消息发送到交换机，并指定路由键，交换机会根据路由键将消息转发给与该路由键匹配的队列。消费者通过监听特定的队列来接收消息。</li>\n<li>特点：灵活的消息路由机制，生产者与消费者通过路由键关联，可以将消息发送到特定的队列<h2 id=\"全局唯一Id生成策略\"><a href=\"#全局唯一Id生成策略\" class=\"headerlink\" title=\"全局唯一Id生成策略\"></a>全局唯一Id生成策略</h2><h3 id=\"Snowflake-64bit位的long类型\"><a href=\"#Snowflake-64bit位的long类型\" class=\"headerlink\" title=\"Snowflake(64bit位的long类型)\"></a>Snowflake(64bit位的long类型)</h3></li>\n<li>解决的问题: 分布式场景下主键ID重复性问题<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17603292854441760329284549.png\" alt=\"17603292854441760329284549.png|700x214\"><br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17536471744521753647173892.png\" alt=\"17536471744521753647173892.png|700x396\"></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反解析 雪花id 右移22位机器位 加上元年时间戳得到当前时间</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SnowflakeIdParser</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Hutool 默认起始时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">EPOCH</span> <span class=\"operator\">=</span> <span class=\"number\">1577808000000L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"number\">1950232867263090688L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 反解析时间戳（去掉序列号和机器ID部分，即右移22位）</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">timePart</span> <span class=\"operator\">=</span> (id &gt;&gt; <span class=\"number\">22</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算实际生成时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">generateTime</span> <span class=\"operator\">=</span> timePart + EPOCH;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(generateTime);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;生成时间: &quot;</span> + date);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 反解析机器ID和序列号（根据Hutool Snowflake结构）</span></span><br><span class=\"line\">        <span class=\"comment\">// Hutool Snowflake结构：</span></span><br><span class=\"line\">        <span class=\"comment\">// 41位时间戳 | 10位工作机器ID | 12位序列号</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">sequence</span> <span class=\"operator\">=</span> id &amp; ((<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">12</span>) - <span class=\"number\">1</span>); <span class=\"comment\">// 最后12位</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">workerId</span> <span class=\"operator\">=</span> (id &gt;&gt; <span class=\"number\">12</span>) &amp; ((<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">10</span>) - <span class=\"number\">1</span>); <span class=\"comment\">// 中间10位</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;工作机器ID: &quot;</span> + workerId);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;序列号: &quot;</span> + sequence);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"百度的UidGenerate\"><a href=\"#百度的UidGenerate\" class=\"headerlink\" title=\"百度的UidGenerate\"></a>百度的UidGenerate</h3><ul>\n<li>本质上也是基于雪花算法的64bit的id, 不同的是修改了64bit的分配比例</li>\n<li>时间戳可使用年数从原本的约69年下降至6年, 但是可分配的机器bit和序列毫秒bit增多, <strong>解决了在高并发、大规模机器部署场景下，传统雪花算法机器位不够用的问题</strong><br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17603299984431760329997773.png\" alt=\"17603299984431760329997773.png\"><h3 id=\"时钟回拨问题\"><a href=\"#时钟回拨问题\" class=\"headerlink\" title=\"时钟回拨问题\"></a>时钟回拨问题</h3></li>\n<li>出现原因<ol>\n<li>修改了系统时间</li>\n<li>有时候不同的机器上需要同步时间，可能不同机器之间存在误差，那么可能会出现时间回拨问题</li>\n</ol>\n</li>\n<li>解决方案<ol>\n<li>回拨时间小的时候，不生成 ID，<strong>阻塞等待</strong>到时间点到达。</li>\n<li>上面的方案只适合时钟回拨较小的，如果间隔过大，阻塞等待，肯定是不可取的，因此要么<strong>超过一定大小的回拨直接报错，拒绝服务</strong></li>\n<li>使用中间服务器来定时同步所有服务器的时钟<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"MQ的存储容量上限\"><a href=\"#MQ的存储容量上限\" class=\"headerlink\" title=\"MQ的存储容量上限\"></a>MQ的存储容量上限</h3></li>\n</ol>\n</li>\n<li>RabbitMQ如果消息数量超过 <code>x-max-length</code>，RabbitMQ 会<strong>移除最旧的消息</strong>，以便插入新消息。<ul>\n<li>map.put(“x-max-length”, 1000);          // 最多 1000 条消息</li>\n</ul>\n</li>\n<li>RabbitMQ如果总大小超过 <code>x-max-length-bytes</code>，RabbitMQ 也会<strong>删除旧消息</strong>直到满足条件。<ul>\n<li>map.put(“x-max-length-bytes”, 1000000); // 总字节数不超过1MB(约 1,000,000 字节)</li>\n</ul>\n</li>\n<li>RabbitMQ所以只能存储 1,000,000 bytes ÷ 16,000 bytes ≈ 62.5 条</li>\n<li>RocketMQ如果消息大小超过4K, 会将消息压缩发送<h3 id=\"如何保证消息可靠性\"><a href=\"#如何保证消息可靠性\" class=\"headerlink\" title=\"如何保证消息可靠性?\"></a>如何保证消息可靠性?</h3>| 阶段           | 机制           | 保证手段           |<br>| —————— | —————— | ——————— |<br>| 生产端的可靠投递     | 同步发送、发送确认、重试 | 保证消息能到达 Broker |<br>| Broker服务端    | 磁盘持久化、主从复制   | 保证消息不丢失、可恢复    |<br>| 消费端的确认消费 ACK | 消费确认、消息重试机制  | 保证消息不会漏处理或重复处理 |</li>\n</ul>\n<h3 id=\"如何保证消息的幂等性-消息被重复消费\"><a href=\"#如何保证消息的幂等性-消息被重复消费\" class=\"headerlink\" title=\"如何保证消息的幂等性(消息被重复消费)?\"></a>如何保证消息的幂等性(消息被重复消费)?</h3><ul>\n<li>消息必须携带唯一标识来保证幂等性</li>\n<li>通过使用雪花算法生成唯一消息id</li>\n<li>在消费时通过Redis判断是否存在以消息id为key的键值对, 存在就证明被消费过, 不再消费</li>\n<li>使用 <strong>数据库插入法</strong> ，基于数据库的唯一键来保证重复数据不会被插入多条。</li>\n<li>这些实现幂等的方法，也同样适用于，<strong>在其他场景中来解决重复请求或者重复调用的问题</strong> 。比如将 HTTP 服务设计成幂等的，<strong>解决前端或者 APP 重复提交表单数据的问题</strong> ，也可以将一个微服务设计成幂等的，解决 <code>RPC</code> 框架自动重试导致的 <strong>重复调用问题</strong> 。<h3 id=\"RocketMQ如何实现延迟消息\"><a href=\"#RocketMQ如何实现延迟消息\" class=\"headerlink\" title=\"RocketMQ如何实现延迟消息:\"></a>RocketMQ如何实现延迟消息:</h3></li>\n<li>将消息发送到临时Topic中的队列, 定时任务轮询, 然后把这些队列投递到对应的正确Topic中队列进行消费<h3 id=\"如何处理消息积压\"><a href=\"#如何处理消息积压\" class=\"headerlink\" title=\"如何处理消息积压?\"></a>如何处理消息积压?</h3></li>\n<li>溯源<ul>\n<li>我们可以先检查 <strong>是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题</li>\n</ul>\n</li>\n<li>Broker端(队列端)<ul>\n<li>部署Broker集群, 增加存储水平</li>\n<li>新建一些临时Broker用来存放消息</li>\n</ul>\n</li>\n<li>消费端<ul>\n<li>扩容消费者, 增加消费能力, 通过也应该扩容同一主题下的队列数量, 因为自始至终一个队列只能被一个消费者消费, 消费者多了, 而队列没多, 也会导致消费者被搁置</li>\n<li>优化消费逻辑: 消息积攒一批，一次性查询或写入数据库, 减少数据库IO</li>\n</ul>\n</li>\n<li>逻辑端<ul>\n<li>修改<strong>prefetch count</strong>, RabbitMQ官方给出的建议是prefetch count一般设置在100~300之间<ul>\n<li>prefetch count过大导致内存溢出问题</li>\n<li>prefetch count过小导致吞吐量过低</li>\n</ul>\n</li>\n<li>使用 延时队列TTL + 死信队列<h3 id=\"如何实现延迟消息\"><a href=\"#如何实现延迟消息\" class=\"headerlink\" title=\"如何实现延迟消息?\"></a>如何实现延迟消息?</h3></li>\n</ul>\n</li>\n<li>Broker受到消息后先发送到特定的延时队列中, 开启一个定时任务轮询检测是否到时间, 若是, 再将消息投递到对应的供消费者消费的队列中<h3 id=\"发送方确认机制\"><a href=\"#发送方确认机制\" class=\"headerlink\" title=\"发送方确认机制\"></a>发送方确认机制</h3></li>\n<li>配置<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span>  </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span>  </span><br><span class=\"line\">    <span class=\"attr\">template:</span>  </span><br><span class=\"line\">      <span class=\"attr\">retry:</span>  </span><br><span class=\"line\">        <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span>             <span class=\"comment\"># 开启发送失败时的重试机制  </span></span><br><span class=\"line\">        <span class=\"attr\">initial-interval:</span> <span class=\"string\">10s</span>     <span class=\"comment\"># 初始重试间隔为10秒  </span></span><br><span class=\"line\">        <span class=\"attr\">multiplier:</span> <span class=\"number\">1</span>             <span class=\"comment\"># 每次重试间隔不增长（固定间隔）  </span></span><br><span class=\"line\">        <span class=\"attr\">max-attempts:</span> <span class=\"number\">3</span>           <span class=\"comment\"># 最多重试3次  </span></span><br><span class=\"line\">    <span class=\"attr\">publisher-confirm-type:</span> <span class=\"string\">correlated</span>     <span class=\"comment\"># 开启发送确认  </span></span><br><span class=\"line\">    <span class=\"attr\">publisher-returns:</span> <span class=\"literal\">true</span>      <span class=\"comment\"># 开启Return 回调</span></span><br></pre></td></tr></table></figure></li>\n<li>发送消息时带上 CorrelationData: 可用于回调中追踪消息<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\"><span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;  </span><br><span class=\"line\">​  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello RabbitMQ&quot;</span>;  </span><br><span class=\"line\">    <span class=\"type\">CorrelationData</span> <span class=\"variable\">correlationData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CorrelationData</span>(UUID.randomUUID().toString());  </span><br><span class=\"line\">​  </span><br><span class=\"line\">    rabbitTemplate.convertAndSend(  </span><br><span class=\"line\">        <span class=\"string\">&quot;orderExchange&quot;</span>,        <span class=\"comment\">// 交换机名  </span></span><br><span class=\"line\">        <span class=\"string\">&quot;order.processed&quot;</span>,      <span class=\"comment\">// 路由键  </span></span><br><span class=\"line\">        message,  </span><br><span class=\"line\">        correlationData         <span class=\"comment\">// 可用于回调中追踪消息   </span></span><br><span class=\"line\">    );  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>配置回调<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfig</span> &#123;  </span><br><span class=\"line\">​  </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> RabbitTemplate <span class=\"title function_\">rabbitTemplate</span><span class=\"params\">(ConnectionFactory connectionFactory)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">RabbitTemplate</span> <span class=\"variable\">rabbitTemplate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>(connectionFactory);  </span><br><span class=\"line\">​  </span><br><span class=\"line\">        <span class=\"comment\">// 当生产者将消息发送到交换机后，会触发这个回调  </span></span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ack) &#123;  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;发送成功！CorrelationData: &quot;</span> + correlationData);  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                System.err.println(<span class=\"string\">&quot;发送失败！Cause: &quot;</span> + cause);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;);  </span><br><span class=\"line\">​  </span><br><span class=\"line\">        <span class=\"comment\">// 确认队列是否收到  </span></span><br><span class=\"line\">        rabbitTemplate.setReturnsCallback(returned -&gt; &#123;  </span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;消息未路由到队列: &quot;</span> + returned.getMessage());  </span><br><span class=\"line\">        &#125;);  </span><br><span class=\"line\">​  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> rabbitTemplate;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"消费者消息确认和重试机制\"><a href=\"#消费者消息确认和重试机制\" class=\"headerlink\" title=\"消费者消息确认和重试机制\"></a>消费者消息确认和重试机制</h3></li>\n<li>配置<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span>  </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span>  </span><br><span class=\"line\">    <span class=\"attr\">listener:</span>  </span><br><span class=\"line\">      <span class=\"attr\">simple:</span>  </span><br><span class=\"line\">        <span class=\"attr\">acknowledge-mode:</span> <span class=\"string\">manual</span>   <span class=\"comment\"># 消息手动确认（业务处理成功后显式 ack）  </span></span><br><span class=\"line\">        <span class=\"attr\">prefetch:</span> <span class=\"number\">1</span>                <span class=\"comment\"># 控制每次消费的条数  </span></span><br><span class=\"line\">        <span class=\"attr\">retry:</span>  </span><br><span class=\"line\">          <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span>           <span class=\"comment\"># 启用消费失败后的重试机制  </span></span><br><span class=\"line\">          <span class=\"attr\">max-attempts:</span> <span class=\"number\">3</span>     <span class=\"comment\"># 最大重试次数  </span></span><br><span class=\"line\">          <span class=\"attr\">initial-interval:</span> <span class=\"string\">1000ms</span>  </span><br><span class=\"line\">          <span class=\"attr\">multiplier:</span> <span class=\"number\">2</span>       <span class=\"comment\"># 间隔时间增长倍数  </span></span><br><span class=\"line\">          <span class=\"attr\">max-interval:</span> <span class=\"string\">10000ms</span>  </span><br><span class=\"line\">    <span class=\"attr\">connection-timeout:</span> <span class=\"string\">10s</span>       <span class=\"comment\"># 连接超时设置</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>含义</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>basicAck(tag, false)</code></td>\n<td>手动确认</td>\n<td>正常消费成功后调用</td>\n</tr>\n<tr>\n<td><code>basicNack(tag, false, true)</code></td>\n<td>拒绝 + 是否重回队列</td>\n<td>消息失败处理时使用</td>\n</tr>\n<tr>\n<td><code>basicReject(tag, false)</code></td>\n<td>拒绝，不支持批量</td>\n<td>等价于 <code>basicNack(requeue=false)</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>消费者确认<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderConsumer</span> &#123;  </span><br><span class=\"line\">​  </span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;orderQueue&quot;)</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">receiveMessage</span><span class=\"params\">(MsgBody msgBody, Message message, Channel channel)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;✅ 收到消息：&quot;</span> + msgBody);  </span><br><span class=\"line\">​  </span><br><span class=\"line\">            <span class=\"comment\">// 处理业务逻辑…  </span></span><br><span class=\"line\">​  </span><br><span class=\"line\">            <span class=\"comment\">// 手动确认消息（消息处理成功）: deliveryTag:RabbitMQ自动分配,用于标识消费者Channel中的消息  </span></span><br><span class=\"line\">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);  </span><br><span class=\"line\">​  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;消息处理失败：&quot;</span> + e.getMessage());  </span><br><span class=\"line\">​  </span><br><span class=\"line\">            <span class=\"comment\">// 拒绝消息，并决定是否重回队列  </span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">                <span class=\"comment\">// 是否拒绝多个消息 是否重新入队  </span></span><br><span class=\"line\">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>, <span class=\"literal\">false</span>);   </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ioException) &#123;  </span><br><span class=\"line\">                ioException.printStackTrace();  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么MQ不直接使用Http协议呢？\"><a href=\"#为什么MQ不直接使用Http协议呢？\" class=\"headerlink\" title=\"为什么MQ不直接使用Http协议呢？\"></a>为什么MQ不直接使用Http协议呢？</h3></li>\n<li>因为Http请求和响应报文是比较复杂的，包含了cookie、数据的加密解密、状态码、晌应码等附加的功能，但是对于个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就够，要追求的是高性能。尽量简洁，快速。</li>\n<li>大部分情况下Http大部分都是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，所以必须保持长链接, 目的是为了保证消息和数据的高可靠和稳健的运行<h3 id=\"小芝士\"><a href=\"#小芝士\" class=\"headerlink\" title=\"小芝士\"></a>小芝士</h3></li>\n<li>一般来说要控制 主题中的队列数量与消费者一致</li>\n<li>一个队列在同一时刻只能被消费者组内的一个消费者消费</li>\n<li>每一个消费者组都要维护自己的消费位置(offSet指针), 如果不单独维护，每个消费组就没办法知道自己消费到哪里了，会互相干扰</li>\n<li>RabbitMQ和ActiveMQ不像Kafka和RocketMQ一样支持主从以及分布式集群, 而是只支持主从</li>\n<li>如果业务场景对并发量(吞吐量)要求不是太高, 又因为RabbitMQ延迟在微秒级别, 时效性最高，RabbitMQ 一定是你的首选</li>\n<li>Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据</li>\n<li>如果为了避免consumer崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull模式下，consumer就可以根据自己的消费能力去决定这些策略。</li>\n</ul>\n","cover":"/img/view9.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"MQ消息队列\"><a href=\"#MQ消息队列\" class=\"headerlink\" title=\"MQ消息队列\"></a>MQ消息队列</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li>消息队列(Message Queue)是在消息的传输过程中保存消息的容器。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17536471244591753647124102.png\" alt=\"17536471244591753647124102.png|700x808\"></li>\n<li><strong>Broker</strong>是mq的核心组件, 主要功能是负责 <strong>接收生产者发送的消息</strong>, <strong>将消息投递给对应的消费者</strong></li>\n<li><strong>connection 连接与 channel 信道</strong>:<ul>\n<li>AMQP的连接是长连接，它是一个使用 TCP作为可靠传输的应用层协议, 而信道channel是建立在真实的长TCP连接内的虚拟链接</li>\n<li>AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，都是通过信道完成的</li>\n<li>类似于进程和线程, 一个服务对应一个connection, 服务中的每一个线程对应一个channel<h2 id=\"消息传输协议对比\"><a href=\"#消息传输协议对比\" class=\"headerlink\" title=\"消息传输协议对比\"></a>消息传输协议对比</h2>| 协议        | 传输层 | 模式       | 消息持久化  | 可靠性 | 特点                 | 常见实现                                        | 优点                                |<br>| ————- | —- | ———— | ——— | —- | ————————— | —————————————————————- | ————————————————- |<br>| MQTT      | TCP | 发布/订阅    | 支持 QoS | 高   | IoT 数据上报、移动端消息推送   | Mosquitto、EMQX、HiveMQ、阿里云物联网平台              | 轻量级的通讯协议, 即使在网络条件较差的情况下也能保持通信的稳定性 |<br>| AMQP      | TCP | 发布/订阅/队列 | 支持     | 高   | 支持事务、确认机制、复杂路由     | RabbitMQ、Apache Qpid                        | 可靠性强、功能丰富、支持复杂业务逻辑                |<br>| Kafka     | TCP | 发布/订阅/日志 | 内建持久化  | 高   | 自定义二进制协议、高吞吐量、顺序消费 | Apache Kafka                                | 高性能、高吞吐、顺序性好、可回溯消息                |<br>| HTTP      | TCP | 请求-响应短链接 | 不支持    | 中   | 短时请求-响应通信          | 所有 Web 服务器/客户端（Nginx、Tomcat、浏览器等）           | 实现简单、生态完善、无客户端限制                  |<br>| WebSocket | TCP | 双向长连接    | 不支持    | 中   | 实时通信、低延迟推送         | 浏览器/WebSocket Server、Netty、Spring WebSocket | 实时性强、双向通信、延迟低                     |<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2></li>\n</ul>\n</li>\n<li><strong>解耦</strong>: 快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间</li>\n<li><strong>异步</strong>: 用户下单后，系统可以先返回一个下单成功的消息，然后将订单信息放入消息队列中，后台系统再去处理订单信息, 而是相当于<strong>异步线程</strong>处理其他消费者信息</li>\n<li><strong>削峰</strong>: 将瞬时的高峰流量转化为持续的低流量，从而保护系统不会因为瞬时的高流量而崩溃, 使用mq对消息进行分段保存, <strong>由消费者每次拉取一定数量的数据进行处理(prefetch)</strong><br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17406620441921740662044061.png\" alt=\"17406620441921740662044061.png|700x420\"><h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2></li>\n<li><strong>可靠性</strong>。支持持久化，传输确认，发布确认(ack序列码)等保证了MQ的可靠性。</li>\n<li><strong>灵活的分发消息策略</strong>。<ul>\n<li>RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li>\n<li>RocketMQ使用 主题（Topic）+ 标签（Tag）+ 消费组（Consumer Group）来完成消息分类和消费。轮询发送(默认)</li>\n</ul>\n</li>\n<li><strong>支持集群</strong>。多台MQ服务器可以组成一个集群，形成一个逻辑Broker(代理)。</li>\n<li><strong>多种协议</strong>。MQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>\n<li><strong>支持多种语言客户端</strong>。RabbitMQ几乎支持所有常用编程语言，包括 Java(amqpTemplate客户端)、.NET、Ruby 等等。</li>\n<li><strong>可视化管理界面</strong>。<ul>\n<li>RabbitMQ提供了一个易用的用户界面程序<strong>Erlang</strong>(端口是15672)</li>\n<li>RocketMQ的控制台是一个<strong>SpringBoot项目</strong>,需要手动打开; 或者使用打包好的jar包<h2 id=\"分析-RabbitMQ与RocketMQ\"><a href=\"#分析-RabbitMQ与RocketMQ\" class=\"headerlink\" title=\"分析 RabbitMQ与RocketMQ\"></a>分析 RabbitMQ与RocketMQ</h2><h3 id=\"RabbitMQ-推模式\"><a href=\"#RabbitMQ-推模式\" class=\"headerlink\" title=\"RabbitMQ(推模式)\"></a>RabbitMQ(推模式)</h3><strong>RabbitMQ是采用 Erlang语言实现AMQP协议的消息中间件</strong></li>\n</ul>\n</li>\n<li><strong>虚拟主机</strong>: 每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制</li>\n<li><strong>交换机</strong>: 一个重要组件,各自有自己的路由键, 负责接收生产者发送的消息，并根据一定的路由规则（如路由键、绑定等）将消息转发到一个或多个队列 —-&gt; 控制消息的分发规则(交换机是消息的中转站)</li>\n<li><strong>路由键</strong>: 帮助交换机决定该消息应该被转发到哪个队列(规则), 是交换机的关键</li>\n<li><strong>队列</strong>: 队列是RabbitMQ中的一个存储结构，用于保存消息，直到消费者从队列中获取并处理这些消息。</li>\n<li><strong>例子</strong>: 假设有一个生产者将消息发送到一个<code>direct</code>类型的交换机，该交换机的路由键是<code>&quot;order.processed&quot;</code>。这个交换机会将消息转发到一个与该路由键绑定的队列，比如叫做<code>orderQueue</code>。消费者只需要监听 <code>orderQueue</code>，即可接收到 <code>&quot;order.processed&quot;</code> 类型的订单消息进行处理。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17536391946501753639194226.png\" alt=\"17536391946501753639194226.png|700x209\"><h3 id=\"RocketMQ-拉模式\"><a href=\"#RocketMQ-拉模式\" class=\"headerlink\" title=\"RocketMQ(拉模式)\"></a>RocketMQ(拉模式)</h3></li>\n<li><strong>主题</strong>: Topic</li>\n<li><strong>路由键</strong>: Tag + 可选 Key, RocketMQ 中的 Tag 是对消息的简单分类，Key 可以做业务标识。没有复杂的路由表达式</li>\n<li><strong>消费组</strong>: 消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。默认情况，如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。</li>\n<li><strong>消费位置</strong>: Offset, 为每个消费组在每个队列上维护一个消费位置, 用于为当前消费组保存上次消费到的位置</li>\n<li><strong>队列</strong>: MessageQueue, RocketMQ 的每个 Topic 会自动被分为多个消息队列，Producer 可指定发往哪个队列（可用于顺序消息）</li>\n<li><strong>例子</strong>: 创建一个 <code>Topic</code>主题：<code>OrderTopic</code>, 生产者发送消息到 <code>OrderTopic</code>，并设置 <code>Tag</code>(路由键) 为 <code>processed</code>, 消费者订阅 <code>OrderTopic</code>，并使用 <code>Tag</code> = “<code>processed</code>“ 作为过滤条件, Broker 接收并分发消息到对应的 <code>MessageQueue</code>（队列片段), 消费者所在的<code>Consumer Group</code>拉取消息进行处理<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17475484290661747548428888.png\" alt=\"17475484290661747548428888.png|700x400\"><h2 id=\"RocketMQ集群\"><a href=\"#RocketMQ集群\" class=\"headerlink\" title=\"RocketMQ集群\"></a>RocketMQ集群</h2></li>\n<li>一个 <code>Topic</code> 分布在多个 <code>Broker</code>上，一个 <code>Broker</code> 可以配置多个 <code>Topic</code> ，它们是多对多的关系<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3></li>\n<li>首先, 我们在Broker上做了主从+集群, 分<code>Master</code>和<code>Slaver</code>, Slaver会定时从Master备份数据(同步复制: 只有消息同步双写到主从节点上时才返回写入成功, 异步复制)，如果 <code>master</code> 宕机，则 <code>slave</code> 提供消费服务，但是不能写入消息</li>\n<li>其次, 我们对<code>NameServer</code>也做了集群, 但是不分主从节点, 每隔30s每一个<code>broker</code>会向所有的<code>NameServer</code>发送ping心跳检测(单个 Broker 和所有 NameServer 保持长连接), 心跳信息包括了Topic配置信息以及路由表信息</li>\n<li>在生产者需要向<code>Broker</code>发送消息的时候，需要先从<code>NameServer</code>获取关于 <code>Broker</code> 的路由表信息，然后通过轮询的方法去向每个队列中生产数据以达到 负载均衡 的效果。</li>\n<li>消费者通过NameServer获取路由表消息, 向broker拉取消息消费<code>Consumer</code> 可以以两种模式启动 广播和集群, 广播模式下，一条消息会发送给同一个消费组中的所有消费者 ，集群模式下消息只会发送给一个消费者。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17581623162691758162315810.png\" alt=\"17581623162691758162315810.png|698x506\"><h2 id=\"Kafka集群\"><a href=\"#Kafka集群\" class=\"headerlink\" title=\"Kafka集群\"></a>Kafka集群</h2><h3 id=\"单节点优化方案\"><a href=\"#单节点优化方案\" class=\"headerlink\" title=\"单节点优化方案\"></a>单节点优化方案</h3></li>\n<li>单节点Kafka的在高流量突增和存储压力增大时, 如果broker崩溃会联锁导致整个系统崩塌</li>\n<li>考虑使用主从节点部署<ul>\n<li>主broker负责写</li>\n<li>从broker负责读</li>\n<li>从节点定期从主节点同步消息</li>\n</ul>\n</li>\n<li>这样就算其中一个broker瘫痪也能使用另外一个broker<h3 id=\"集群优化方案\"><a href=\"#集群优化方案\" class=\"headerlink\" title=\"集群优化方案\"></a>集群优化方案</h3></li>\n<li>部署多个broker服务, topic采用分布式方式存储, 一个topic数据被分散到不同broker服务中</li>\n<li>采用生产者集群和消费者集群, 提高生产消费能力;</li>\n<li>broker集群定期向注册中心集群(ZooKeeper)发送心跳检测以及整个集群状态路由表(如: broker, topic); RocketMQ的注册中心则为NameServer;</li>\n<li>生产者集群和消费者集群监听注册中心, 确认每次生产和消费的消息是哪一个topic下的哪一个partation, 确保消费者拉取的同一性;<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17580141768161758014176045.png\" alt=\"17580141768161758014176045.png\"><h2 id=\"死信队列\"><a href=\"#死信队列\" class=\"headerlink\" title=\"死信队列\"></a>死信队列</h2></li>\n<li>存储那些无法被正常消费的消息,通常由交换机和路由键指定到特殊的队列(即死信队列)</li>\n<li><strong>消息过期</strong>：如果消息设置了<code>expiration</code>属性，当消息在队列中存放超过指定时间后会被丢弃，并进入死信队列。</li>\n<li><strong>队列溢出</strong>：当队列已满且无法再接收新的消息时，新进入的消息将会被丢弃并进入死信队列。</li>\n<li><strong>消息被拒绝</strong>：当消费者拒绝处理某条消息时，可以选择将消息标记为“死信”。这种情况下，消息会进入死信队列。</li>\n<li><strong>消费者未确认</strong>：如果消息被消费者消费后未发送确认（ack），并且RabbitMQ设置了<code>requeue</code>为<code>false</code>，则消息会被丢弃并进入死信队列。<br>要为队列或交换机添加死信参数（Dead Letter Exchange）配置，应该关注以下几个部分：</li>\n</ul>\n<ol>\n<li><strong>Dead letter exchange</strong>：这里可以填写死信交换机的名称。当队列中的消息因某种原因（如超时、被拒绝等）不能被消费时，它们将被转发到这个死信交换机。你需要在此输入目标死信交换机的名称。</li>\n<li><strong>Dead letter routing key</strong>：这是可选的参数，用于指定死信队列的路由键。消息会被转发到死信交换机，并根据路由键路由到相应的队列。你可以填写路由键，或者留空使用默认设置。</li>\n</ol>\n<p>在配置过程中，如果你为队列设置了 <strong>Dead letter exchange</strong>，确保死信交换机已经存在，并且设置正确。你还可以根据需求配置其他参数，如 <strong>Message TTL</strong>（消息的过期时间）和 <strong>Auto expire</strong>（队列的过期时间）。</p>\n<h3 id=\"死信参数添加步骤：\"><a href=\"#死信参数添加步骤：\" class=\"headerlink\" title=\"死信参数添加步骤：\"></a>死信参数添加步骤：</h3><ol>\n<li>在 RabbitMQ 管理界面创建或编辑队列或交换机。</li>\n<li>在 <code>Arguments</code> 部分找到并配置：<ul>\n<li><strong>Dead letter exchange</strong>：填写死信交换机的名称。</li>\n<li><strong>Dead letter routing key</strong>：可选，填写死信路由键的名称。</li>\n</ul>\n</li>\n<li>完成设置后，保存队列或交换机配置。<h3 id=\"其他相关参数：\"><a href=\"#其他相关参数：\" class=\"headerlink\" title=\"其他相关参数：\"></a>其他相关参数：</h3></li>\n</ol>\n<ul>\n<li><strong>Auto expire</strong>：队列自动过期的时间。</li>\n<li><strong>Message TTL</strong>：设置消息的过期时间，消息在 TTL 到期后会被丢弃或进入死信队列。</li>\n<li><strong>Overflow behaviour</strong>：设置当队列达到最大长度时的行为。</li>\n<li><strong>Single active consumer</strong>：如果设置为 <code>true</code>，该队列只允许一个消费者进行消费。</li>\n<li><strong>Max length / Max length bytes</strong>：设置队列的最大长度或最大字节数，超出后会触发 <code>Overflow behaviour</code>。<h2 id=\"分发消息策略\"><a href=\"#分发消息策略\" class=\"headerlink\" title=\"分发消息策略\"></a>分发消息策略</h2><h3 id=\"1-简单队列模式-Direct-Mode\"><a href=\"#1-简单队列模式-Direct-Mode\" class=\"headerlink\" title=\"1. 简单队列模式 (Direct Mode)\"></a>1. 简单队列模式 (Direct Mode)</h3></li>\n<li>特点：生产者生产消息, 由多个消费者去竞争消费, 每个消息只消费一次</li>\n<li>使用场景：<strong>适用于简单的点对点通信，生产者与消费者直接交互</strong>。</li>\n<li>实现方式：生产者将消息发送到某个特定的队列，消费者从该队列中接收消息。</li>\n<li>特点：没有复杂的路由逻辑，简单高效，但不适合多消费者的场景。<h3 id=\"2-工作队列模式-Work-Queue\"><a href=\"#2-工作队列模式-Work-Queue\" class=\"headerlink\" title=\"2. 工作队列模式 (Work Queue)\"></a>2. 工作队列模式 (Work Queue)</h3></li>\n<li>特点：<strong>生产者将消息发送到一个共享的队列(一对多)，多个消费者从该队列中获取消息进行并行处理。</strong></li>\n<li>使用场景：适用于<strong>负载均衡</strong>，多个消费者共同处理任务，避免某个消费者负担过重。</li>\n<li>实现方式：所有消费者都监听同一个队列，RabbitMQ会以公平的方式将消息分发给消费者（即一个消费者处理一条消息，直到处理完才会继续接收新的消息）。</li>\n<li>特点：消费者可以并行处理任务，确保负载均衡和异步处理，适用于后台任务处理、分布式任务调度等。<h3 id=\"3-发布订阅模式-Publish-Subscribe\"><a href=\"#3-发布订阅模式-Publish-Subscribe\" class=\"headerlink\" title=\"3. 发布订阅模式 (Publish/Subscribe)\"></a>3. 发布订阅模式 (Publish/Subscribe)</h3></li>\n<li>特点：<strong>生产者将消息发布到一个交换机(主题)，然后多个消费者订阅该交换机(主题)，消费者将接收来自交换机(主题)的所有消息, 也就是一个消息可以多次消费。</strong></li>\n<li>使用场景：<strong>适用于广播消息场景，例如日志收集、事件通知等</strong>。</li>\n<li>实现方式：生产者将消息发布到一个广播类型的交换机（如<code>fanout</code>交换机），交换机会将消息广播给所有绑定在其上的队列，所有消费者都会收到该消息。</li>\n<li>特点：通过交换机将消息发送到多个队列，实现多消费者接收消息，适用于需要广播的场景。<h3 id=\"4-路由模式-Routing\"><a href=\"#4-路由模式-Routing\" class=\"headerlink\" title=\"4. 路由模式 (Routing)\"></a>4. 路由模式 (Routing)</h3></li>\n<li>特点：生产者将消息发送到交换机，并通过指定的路由键来决定消息的去向。消费者根据路由键来决定是否接收消息。</li>\n<li>使用场景：适用于根据消息的某些属性进行路由，灵活性较高，能够支持更多的消息传递场景。</li>\n<li>实现方式：使用<code>direct</code>交换机，生产者将消息发送到交换机，并指定路由键，交换机会根据路由键将消息转发给与该路由键匹配的队列。消费者通过监听特定的队列来接收消息。</li>\n<li>特点：灵活的消息路由机制，生产者与消费者通过路由键关联，可以将消息发送到特定的队列<h2 id=\"全局唯一Id生成策略\"><a href=\"#全局唯一Id生成策略\" class=\"headerlink\" title=\"全局唯一Id生成策略\"></a>全局唯一Id生成策略</h2><h3 id=\"Snowflake-64bit位的long类型\"><a href=\"#Snowflake-64bit位的long类型\" class=\"headerlink\" title=\"Snowflake(64bit位的long类型)\"></a>Snowflake(64bit位的long类型)</h3></li>\n<li>解决的问题: 分布式场景下主键ID重复性问题<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17603292854441760329284549.png\" alt=\"17603292854441760329284549.png|700x214\"><br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17536471744521753647173892.png\" alt=\"17536471744521753647173892.png|700x396\"></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反解析 雪花id 右移22位机器位 加上元年时间戳得到当前时间</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SnowflakeIdParser</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Hutool 默认起始时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">EPOCH</span> <span class=\"operator\">=</span> <span class=\"number\">1577808000000L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"number\">1950232867263090688L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 反解析时间戳（去掉序列号和机器ID部分，即右移22位）</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">timePart</span> <span class=\"operator\">=</span> (id &gt;&gt; <span class=\"number\">22</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算实际生成时间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">generateTime</span> <span class=\"operator\">=</span> timePart + EPOCH;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(generateTime);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;生成时间: &quot;</span> + date);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 反解析机器ID和序列号（根据Hutool Snowflake结构）</span></span><br><span class=\"line\">        <span class=\"comment\">// Hutool Snowflake结构：</span></span><br><span class=\"line\">        <span class=\"comment\">// 41位时间戳 | 10位工作机器ID | 12位序列号</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">sequence</span> <span class=\"operator\">=</span> id &amp; ((<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">12</span>) - <span class=\"number\">1</span>); <span class=\"comment\">// 最后12位</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">workerId</span> <span class=\"operator\">=</span> (id &gt;&gt; <span class=\"number\">12</span>) &amp; ((<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">10</span>) - <span class=\"number\">1</span>); <span class=\"comment\">// 中间10位</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;工作机器ID: &quot;</span> + workerId);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;序列号: &quot;</span> + sequence);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"百度的UidGenerate\"><a href=\"#百度的UidGenerate\" class=\"headerlink\" title=\"百度的UidGenerate\"></a>百度的UidGenerate</h3><ul>\n<li>本质上也是基于雪花算法的64bit的id, 不同的是修改了64bit的分配比例</li>\n<li>时间戳可使用年数从原本的约69年下降至6年, 但是可分配的机器bit和序列毫秒bit增多, <strong>解决了在高并发、大规模机器部署场景下，传统雪花算法机器位不够用的问题</strong><br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17603299984431760329997773.png\" alt=\"17603299984431760329997773.png\"><h3 id=\"时钟回拨问题\"><a href=\"#时钟回拨问题\" class=\"headerlink\" title=\"时钟回拨问题\"></a>时钟回拨问题</h3></li>\n<li>出现原因<ol>\n<li>修改了系统时间</li>\n<li>有时候不同的机器上需要同步时间，可能不同机器之间存在误差，那么可能会出现时间回拨问题</li>\n</ol>\n</li>\n<li>解决方案<ol>\n<li>回拨时间小的时候，不生成 ID，<strong>阻塞等待</strong>到时间点到达。</li>\n<li>上面的方案只适合时钟回拨较小的，如果间隔过大，阻塞等待，肯定是不可取的，因此要么<strong>超过一定大小的回拨直接报错，拒绝服务</strong></li>\n<li>使用中间服务器来定时同步所有服务器的时钟<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"MQ的存储容量上限\"><a href=\"#MQ的存储容量上限\" class=\"headerlink\" title=\"MQ的存储容量上限\"></a>MQ的存储容量上限</h3></li>\n</ol>\n</li>\n<li>RabbitMQ如果消息数量超过 <code>x-max-length</code>，RabbitMQ 会<strong>移除最旧的消息</strong>，以便插入新消息。<ul>\n<li>map.put(“x-max-length”, 1000);          // 最多 1000 条消息</li>\n</ul>\n</li>\n<li>RabbitMQ如果总大小超过 <code>x-max-length-bytes</code>，RabbitMQ 也会<strong>删除旧消息</strong>直到满足条件。<ul>\n<li>map.put(“x-max-length-bytes”, 1000000); // 总字节数不超过1MB(约 1,000,000 字节)</li>\n</ul>\n</li>\n<li>RabbitMQ所以只能存储 1,000,000 bytes ÷ 16,000 bytes ≈ 62.5 条</li>\n<li>RocketMQ如果消息大小超过4K, 会将消息压缩发送<h3 id=\"如何保证消息可靠性\"><a href=\"#如何保证消息可靠性\" class=\"headerlink\" title=\"如何保证消息可靠性?\"></a>如何保证消息可靠性?</h3>| 阶段           | 机制           | 保证手段           |<br>| —————— | —————— | ——————— |<br>| 生产端的可靠投递     | 同步发送、发送确认、重试 | 保证消息能到达 Broker |<br>| Broker服务端    | 磁盘持久化、主从复制   | 保证消息不丢失、可恢复    |<br>| 消费端的确认消费 ACK | 消费确认、消息重试机制  | 保证消息不会漏处理或重复处理 |</li>\n</ul>\n<h3 id=\"如何保证消息的幂等性-消息被重复消费\"><a href=\"#如何保证消息的幂等性-消息被重复消费\" class=\"headerlink\" title=\"如何保证消息的幂等性(消息被重复消费)?\"></a>如何保证消息的幂等性(消息被重复消费)?</h3><ul>\n<li>消息必须携带唯一标识来保证幂等性</li>\n<li>通过使用雪花算法生成唯一消息id</li>\n<li>在消费时通过Redis判断是否存在以消息id为key的键值对, 存在就证明被消费过, 不再消费</li>\n<li>使用 <strong>数据库插入法</strong> ，基于数据库的唯一键来保证重复数据不会被插入多条。</li>\n<li>这些实现幂等的方法，也同样适用于，<strong>在其他场景中来解决重复请求或者重复调用的问题</strong> 。比如将 HTTP 服务设计成幂等的，<strong>解决前端或者 APP 重复提交表单数据的问题</strong> ，也可以将一个微服务设计成幂等的，解决 <code>RPC</code> 框架自动重试导致的 <strong>重复调用问题</strong> 。<h3 id=\"RocketMQ如何实现延迟消息\"><a href=\"#RocketMQ如何实现延迟消息\" class=\"headerlink\" title=\"RocketMQ如何实现延迟消息:\"></a>RocketMQ如何实现延迟消息:</h3></li>\n<li>将消息发送到临时Topic中的队列, 定时任务轮询, 然后把这些队列投递到对应的正确Topic中队列进行消费<h3 id=\"如何处理消息积压\"><a href=\"#如何处理消息积压\" class=\"headerlink\" title=\"如何处理消息积压?\"></a>如何处理消息积压?</h3></li>\n<li>溯源<ul>\n<li>我们可以先检查 <strong>是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题</li>\n</ul>\n</li>\n<li>Broker端(队列端)<ul>\n<li>部署Broker集群, 增加存储水平</li>\n<li>新建一些临时Broker用来存放消息</li>\n</ul>\n</li>\n<li>消费端<ul>\n<li>扩容消费者, 增加消费能力, 通过也应该扩容同一主题下的队列数量, 因为自始至终一个队列只能被一个消费者消费, 消费者多了, 而队列没多, 也会导致消费者被搁置</li>\n<li>优化消费逻辑: 消息积攒一批，一次性查询或写入数据库, 减少数据库IO</li>\n</ul>\n</li>\n<li>逻辑端<ul>\n<li>修改<strong>prefetch count</strong>, RabbitMQ官方给出的建议是prefetch count一般设置在100~300之间<ul>\n<li>prefetch count过大导致内存溢出问题</li>\n<li>prefetch count过小导致吞吐量过低</li>\n</ul>\n</li>\n<li>使用 延时队列TTL + 死信队列<h3 id=\"如何实现延迟消息\"><a href=\"#如何实现延迟消息\" class=\"headerlink\" title=\"如何实现延迟消息?\"></a>如何实现延迟消息?</h3></li>\n</ul>\n</li>\n<li>Broker受到消息后先发送到特定的延时队列中, 开启一个定时任务轮询检测是否到时间, 若是, 再将消息投递到对应的供消费者消费的队列中<h3 id=\"发送方确认机制\"><a href=\"#发送方确认机制\" class=\"headerlink\" title=\"发送方确认机制\"></a>发送方确认机制</h3></li>\n<li>配置<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span>  </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span>  </span><br><span class=\"line\">    <span class=\"attr\">template:</span>  </span><br><span class=\"line\">      <span class=\"attr\">retry:</span>  </span><br><span class=\"line\">        <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span>             <span class=\"comment\"># 开启发送失败时的重试机制  </span></span><br><span class=\"line\">        <span class=\"attr\">initial-interval:</span> <span class=\"string\">10s</span>     <span class=\"comment\"># 初始重试间隔为10秒  </span></span><br><span class=\"line\">        <span class=\"attr\">multiplier:</span> <span class=\"number\">1</span>             <span class=\"comment\"># 每次重试间隔不增长（固定间隔）  </span></span><br><span class=\"line\">        <span class=\"attr\">max-attempts:</span> <span class=\"number\">3</span>           <span class=\"comment\"># 最多重试3次  </span></span><br><span class=\"line\">    <span class=\"attr\">publisher-confirm-type:</span> <span class=\"string\">correlated</span>     <span class=\"comment\"># 开启发送确认  </span></span><br><span class=\"line\">    <span class=\"attr\">publisher-returns:</span> <span class=\"literal\">true</span>      <span class=\"comment\"># 开启Return 回调</span></span><br></pre></td></tr></table></figure></li>\n<li>发送消息时带上 CorrelationData: 可用于回调中追踪消息<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\"><span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;  </span><br><span class=\"line\">​  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendMessage</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello RabbitMQ&quot;</span>;  </span><br><span class=\"line\">    <span class=\"type\">CorrelationData</span> <span class=\"variable\">correlationData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CorrelationData</span>(UUID.randomUUID().toString());  </span><br><span class=\"line\">​  </span><br><span class=\"line\">    rabbitTemplate.convertAndSend(  </span><br><span class=\"line\">        <span class=\"string\">&quot;orderExchange&quot;</span>,        <span class=\"comment\">// 交换机名  </span></span><br><span class=\"line\">        <span class=\"string\">&quot;order.processed&quot;</span>,      <span class=\"comment\">// 路由键  </span></span><br><span class=\"line\">        message,  </span><br><span class=\"line\">        correlationData         <span class=\"comment\">// 可用于回调中追踪消息   </span></span><br><span class=\"line\">    );  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>配置回调<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfig</span> &#123;  </span><br><span class=\"line\">​  </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> RabbitTemplate <span class=\"title function_\">rabbitTemplate</span><span class=\"params\">(ConnectionFactory connectionFactory)</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">RabbitTemplate</span> <span class=\"variable\">rabbitTemplate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>(connectionFactory);  </span><br><span class=\"line\">​  </span><br><span class=\"line\">        <span class=\"comment\">// 当生产者将消息发送到交换机后，会触发这个回调  </span></span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ack) &#123;  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;发送成功！CorrelationData: &quot;</span> + correlationData);  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                System.err.println(<span class=\"string\">&quot;发送失败！Cause: &quot;</span> + cause);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;);  </span><br><span class=\"line\">​  </span><br><span class=\"line\">        <span class=\"comment\">// 确认队列是否收到  </span></span><br><span class=\"line\">        rabbitTemplate.setReturnsCallback(returned -&gt; &#123;  </span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;消息未路由到队列: &quot;</span> + returned.getMessage());  </span><br><span class=\"line\">        &#125;);  </span><br><span class=\"line\">​  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> rabbitTemplate;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"消费者消息确认和重试机制\"><a href=\"#消费者消息确认和重试机制\" class=\"headerlink\" title=\"消费者消息确认和重试机制\"></a>消费者消息确认和重试机制</h3></li>\n<li>配置<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span>  </span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span>  </span><br><span class=\"line\">    <span class=\"attr\">listener:</span>  </span><br><span class=\"line\">      <span class=\"attr\">simple:</span>  </span><br><span class=\"line\">        <span class=\"attr\">acknowledge-mode:</span> <span class=\"string\">manual</span>   <span class=\"comment\"># 消息手动确认（业务处理成功后显式 ack）  </span></span><br><span class=\"line\">        <span class=\"attr\">prefetch:</span> <span class=\"number\">1</span>                <span class=\"comment\"># 控制每次消费的条数  </span></span><br><span class=\"line\">        <span class=\"attr\">retry:</span>  </span><br><span class=\"line\">          <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span>           <span class=\"comment\"># 启用消费失败后的重试机制  </span></span><br><span class=\"line\">          <span class=\"attr\">max-attempts:</span> <span class=\"number\">3</span>     <span class=\"comment\"># 最大重试次数  </span></span><br><span class=\"line\">          <span class=\"attr\">initial-interval:</span> <span class=\"string\">1000ms</span>  </span><br><span class=\"line\">          <span class=\"attr\">multiplier:</span> <span class=\"number\">2</span>       <span class=\"comment\"># 间隔时间增长倍数  </span></span><br><span class=\"line\">          <span class=\"attr\">max-interval:</span> <span class=\"string\">10000ms</span>  </span><br><span class=\"line\">    <span class=\"attr\">connection-timeout:</span> <span class=\"string\">10s</span>       <span class=\"comment\"># 连接超时设置</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>含义</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>basicAck(tag, false)</code></td>\n<td>手动确认</td>\n<td>正常消费成功后调用</td>\n</tr>\n<tr>\n<td><code>basicNack(tag, false, true)</code></td>\n<td>拒绝 + 是否重回队列</td>\n<td>消息失败处理时使用</td>\n</tr>\n<tr>\n<td><code>basicReject(tag, false)</code></td>\n<td>拒绝，不支持批量</td>\n<td>等价于 <code>basicNack(requeue=false)</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>消费者确认<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderConsumer</span> &#123;  </span><br><span class=\"line\">​  </span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;orderQueue&quot;)</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">receiveMessage</span><span class=\"params\">(MsgBody msgBody, Message message, Channel channel)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;✅ 收到消息：&quot;</span> + msgBody);  </span><br><span class=\"line\">​  </span><br><span class=\"line\">            <span class=\"comment\">// 处理业务逻辑…  </span></span><br><span class=\"line\">​  </span><br><span class=\"line\">            <span class=\"comment\">// 手动确认消息（消息处理成功）: deliveryTag:RabbitMQ自动分配,用于标识消费者Channel中的消息  </span></span><br><span class=\"line\">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);  </span><br><span class=\"line\">​  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;消息处理失败：&quot;</span> + e.getMessage());  </span><br><span class=\"line\">​  </span><br><span class=\"line\">            <span class=\"comment\">// 拒绝消息，并决定是否重回队列  </span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">                <span class=\"comment\">// 是否拒绝多个消息 是否重新入队  </span></span><br><span class=\"line\">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>, <span class=\"literal\">false</span>);   </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ioException) &#123;  </span><br><span class=\"line\">                ioException.printStackTrace();  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么MQ不直接使用Http协议呢？\"><a href=\"#为什么MQ不直接使用Http协议呢？\" class=\"headerlink\" title=\"为什么MQ不直接使用Http协议呢？\"></a>为什么MQ不直接使用Http协议呢？</h3></li>\n<li>因为Http请求和响应报文是比较复杂的，包含了cookie、数据的加密解密、状态码、晌应码等附加的功能，但是对于个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就够，要追求的是高性能。尽量简洁，快速。</li>\n<li>大部分情况下Http大部分都是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，所以必须保持长链接, 目的是为了保证消息和数据的高可靠和稳健的运行<h3 id=\"小芝士\"><a href=\"#小芝士\" class=\"headerlink\" title=\"小芝士\"></a>小芝士</h3></li>\n<li>一般来说要控制 主题中的队列数量与消费者一致</li>\n<li>一个队列在同一时刻只能被消费者组内的一个消费者消费</li>\n<li>每一个消费者组都要维护自己的消费位置(offSet指针), 如果不单独维护，每个消费组就没办法知道自己消费到哪里了，会互相干扰</li>\n<li>RabbitMQ和ActiveMQ不像Kafka和RocketMQ一样支持主从以及分布式集群, 而是只支持主从</li>\n<li>如果业务场景对并发量(吞吐量)要求不是太高, 又因为RabbitMQ延迟在微秒级别, 时效性最高，RabbitMQ 一定是你的首选</li>\n<li>Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据</li>\n<li>如果为了避免consumer崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull模式下，consumer就可以根据自己的消费能力去决定这些策略。</li>\n</ul>\n"},{"title":"逻辑与物理序列化","date":"2024-11-19T06:52:38.000Z","_content":"\n------\n# 逻辑与物理序列化\n\n🤔💬`如果一个人不知道要驶向哪一个码头, 那么任何风都不会是顺风\n\n------\n## 序列化和反序列化的区别\n**逻辑序列化:\t对象\t-> \tJSON**\n**物理序列化\t JSON\t->\t字节**\n- **序列化是将 对象 转化成 字节 存储在磁盘(Redis通过RDB或AOF的持久化数据就是放在磁盘上)** \n- **反序列化是读取磁盘 将字节 转化成 对象**\n- 当然不只是磁盘, 因为是字节, 所以当成字节流可以在网络中运输\n- 不同进程/程序间进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等，而这些数据都会以二进制序列(字节流)的形式在网络上传送。\n- `transient` 关键字修饰的成员变量，将不参与序列化  \n## 序列化接口和序列化ID\n-  只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列\n-  序列化类的属性没有实现 Serializable接口 那么在序列化就会报错: NotSerializableException\n- Java的序列化机制是通过判断运行时类的serialVersionUID来验证版本一致性的，在进行反序列化时，JVM会把传进来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。\n- 步骤:\n  - 若User类仅仅实现了Serializable接口定义了自己的序列化id, 则可以按照以下方式进行序列化和反序列化。\n  - ObjectOutputStream采用默认的序列化方式，对User对象的非transient的实例变量进行序列化。\n  - ObjcetInputStream采用默认的反序列化方式，对对User对象的非transient的实例变量进行反序列化。\n## 序列化器\n- **网络直接传输数据，但是无法直接传输Json对象或者XML对象，必须在传输前序列化，传输完成后反序列化成对象。**\n- **网络底层只能识别和传输二进制数据。无论是 JSON、XML，还是 Java 对象，这些高层次的数据结构都需要转化为字节序列才能传输。**\n- 所以所有可在网络上传输的对象都必须是可序列化的。\n- springboot中是通过Jackson的**objectMapper序列化器**来实现序列化和反序列化的, 并不依赖java原生序列化接口\n  - Jackson 通过**反射读取类的字段**。\n  - 利用 `ObjectMapper` 序列化为 JSON 或反序列化为 Java 对象。\n  - 与传统的 Java 序列化不同，Jackson 不依赖 `Serializable` 接口。\n## 自定义序列化器\n\n- @JsonFormat\n  - Jackson 在处理对象转 JSON 时，会使用字段的默认序列化器\n  - Jackson 在序列化和反序列化时会扫描字段上的注解\n  - 如果字段上有 `@JsonFormat` 注解，Jackson 会为该字段生成一个自定义的序列化器。\n  - 这个序列化器会按照 `@JsonFormat` 指定的格式（例如 `pattern` 和 `timezone`）格式化数据。\n- @JsonSerialize(using = ToStringSerializer.class)\n\t- 返回前端是进行 将其他类型转换成String的操作\n\t- 避免诸如Long类型过长导致的JS精度丢失\n## 几种Json与字符串换转工具\n- **概念理解: 序列化是比较宽泛的词, 将普通字符串转换为JSON格式字符串也可以叫序列化**\n  - Gson 是 Google 开源的 JSON 库\n  - FastJSON 是阿里巴巴开源的高性能 JSON 处理库\n  - Jackson 是 Spring 框架默认集成的 JSON 序列化工具(SpringMVC 转换默认使用 Jackson)\n```java\n//      3种将实体类对象转化成json格式的字符串方法\n        Object heike = new HeiKe();\n\n        //第一种：谷歌旗下的gson\n        Gson gson = new Gson();\n        String json1 = gson.toJson(heike);\n\n        //第二种：阿里巴巴的fastJson\n        String json2 = JSONObject.toJSONString(heike);\n\n        //第三种：spring框架的jackJson   \n        ObjectMapper mapper = new ObjectMapper();\n        String json3 = mapper.writeValueAsString(heike);\n\n        System.out.println(json1);\n        System.out.println(json2);\n        System.out.println(json3);\n\n//         3种将JSON字符串转换为对象\n\n        //第一种：谷歌旗下的gson\n        gson.fromJson(json1, HeiKe.class);\n\n        //第二种：fastJson\n        JSON.parseObject(json2, HeiKe.class);\n\n        //第三种：jackJson\n        mapper.readValue(json3, HeiKe.class);\n\n    }\n```\n\n![17320061339471732006133927.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17320061339471732006133927.png)\n## Redis序列化器\n- spring-data-redis是整合了Lettuce和Jedis的java客户端, 提供了RedisTemplate这样的api来操作Redis\n- 通过 **`RedisConnectionFactory`** 来建立 Redis 连接。\n- **对不同的数据类型存放容器采取不同序列化器**\n- 使用 `Jackson2JsonRedisSerializer` 将 Java 对象序列化为 JSON 格式的字符串，并存入 Redis\n- **序列化成JSON字符串, 反序列化成Java对象:** \n\t- **Key的序列化**\n\t  - 如果 key 是字符串类型：使用 `StringRedisSerializer` 将 key 序列化为 UTF-8 编码的字节流。\n\t  - 如果 key 是对象类型: 一把来说用不到，需要用 `Jackson2JsonRedisSerializer` 或 `JdkSerializationRedisSerializer` 等将对象序列化为 Redis 存储格式（最终是字节流）。\n\t- **Value的序列化**\n\t  - 对象类型的 value 通常需要两步：\n\t    - **JSON 转换**（逻辑序列化）：例如用 `Jackson` 或 `Gson` **将对象序列化为 JSON 字符串**\n\t    - **字节流转换**（物理序列化）：例如用 `UTF-8` 编码**将 JSON 字符串转换为字节流**。\n\t    - JSON序列化器会将**类的class类型**写入Json结果中(**很重要**)\n- 注意: **Redis 的原生序列化器**是 **JDK 序列化机制**，即通过 Java 的 `Serializable` 接口进行序列化和反序列化。JDK 将对象转换为字节 存到Redis, 并没有进行JSON的转化\n```java\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        // 实例化自己的RedisTemplate\n        RedisTemplate<String, Object> template = new RedisTemplate<String, Object>();\n        \n        // 设置使用连接工厂连接\n        template.setConnectionFactory(factory);\n\n\t\t// key的序列化器\n\t\tStringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n\n\t\t// value的序列化器\n        Jackson2JsonRedisSerializer jacksonToJsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jacksonToJsonRedisSerializer.setObjectMapper(om);\n        \n        // key采用redis原生的String序列化器\n        template.setKeySerializer(stringRedisSerializer);\n        \n        // hash的key也采用redis原生的String序列化器\n        template.setHashKeySerializer(stringRedisSerializer);\n        \n        // value序列化方式采用jackson ObjectMapper的序列化器\n        template.setValueSerializer(jacksonToJsonRedisSerializer);\n        \n        // hash的value序列化方式采用jackson\n        template.setHashValueSerializer(jacksonToJsonRedisSerializer);\n        \n        template.afterPropertiesSet();\n        return template;\n    }\n```\n\n```java\n// 开启默认类型（兼容多态反序列化）就是处理嵌套类时保留类型信息,让反序列化顺利,解决出现复杂嵌套反序列化失败问题  \n//{  \n//  \"@class\": \"com.example.对象\",  \n//  \"id\": \"1\"  \n//}  \nobjectMapper.activateDefaultTyping(  \n        objectMapper.getPolymorphicTypeValidator(),  \n        ObjectMapper.DefaultTyping.NON_FINAL,  \n        JsonTypeInfo.As.PROPERTY  \n);\n```\n## Json格式的转化\n注:本文使用ObjectMapper工具类\n- Json转实体类\n```java\nString json = \"{\\\"name\\\": \\\"黎淳美\\\", \\\"age\\\": 21}\";\nObjectMapper objectMapper = new ObjectMapper();\nperson person = objectMapper.readValue(json, person.class);\n\nclass person{\n    String name;\n    Integer age;\n    ...\n}\n```\n- Json转Map\n```java\nString json = \"{\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": 123}\";\n        ObjectMapper objectMapper = new ObjectMapper();\n\n\t// 方法一: 未显式声明泛型的 Map 默认会将值类型解析为 Object\n        Map map = objectMapper.readValue(json, Map.class);\n        System.out.println(map.get(\"key1\"));\n\n\t// 方法二: TypeReference是抽象类\n        Map<String, Object> objectMap = objectMapper.readValue(json, new TypeReference<Map<String, Object>>() {});\n```\n- Json转数组\n```java\nString jsonArray = \"[{\\\"name\\\":\\\"Tom\\\",\\\"age\\\":25},{\\\"name\\\":\\\"Jerry\\\",\\\"age\\\":22}]\";\n\nList<Person> personList = objectMapper.readValue(jsonArray, new TypeReference<List<Person>>() {});\nList<Person> personList = objectMapper.readValue(jsonArray, List<person>.class);\n\n```\n## IO 流的体系：分块 缓冲 压缩 多线程\n- Java IO 流广泛采用装饰者模式，通过各种装饰器类来增强功能,，比如缓冲流，打印流\n- 根据数据流向分: 输入流(反序列化) 和 输出流(序列化)\n- 根据数据类型分: 字节流 和 字符流  (Byte 和 Char)  \n- 根据源文件类型分:  音频视频图片等二进制文件 和 文本文件(方便我们平时对字符进行流操作)  \n\n| 分类/对象 | 字节输入流                    | 字节输出流                     | 字符输入流           | 字符输出流           |     |     |\n| ----- | ------------------------ | ------------------------- | --------------- | --------------- | --- | --- |\n| 基类    | InputStream              | OutputStream              | Reader          | Writer          |     |     |\n| 文件流   | FileInputStream          | FileOutputStream          | FileReader      | FileWriter      |     |     |\n| 缓冲流   | BufferedInputStream      | BufferedOutputStream      | BufferedReader  | BufferedWriter  |     |     |\n| 转化流   | InputStreamReader(字节→字符) | OutputStreamWriter(字符→字节) | -               | -               |     |     |\n| 对象流   | ObjectInputStream        | ObjectOutputStream        | -               | -               |     |     |\n| 打印流   | -                        | PrintStream               | -               | PrintWriter     |     |     |\n| 数组流   | ByteArrayInputStream     | ByteArrayOutputStream     | CharArrayReader | CharArrayWriter |     |     |\n| 管道流   | PipeInputStream          | PipedOutputStream         | PipedReader     | PipedWriter     |     |     |\n|       |                          |                           |                 |                 |     |     |\n \n- 字节型缓冲流高效的原因：  \n\t- `BufferedInputStream`：在该类型中准备了一个缓存数组，存储字节信息，当外界调用 `read` 方法想获取一个字节的时候，该对象从文件中一次性读取了8192 个字节到数组中，只返回了第一个字节给调用者。将来调用者再次调用 `read` 方法时，当前对象就不需要再次访问磁盘，只需要从数组中取出字节返回给调用者即可，由于读取的是数组，所以速度非常快。当 8192 个字节全都读取完成之后，再需要读取一个字节，就得让该对象到文件中读取下一个 8192 个字节\n\t- `BufferedOutputStream`：在该类型中准备了一个数组，存储字节信息，当外界调用 `write`  \n\t  方法想写出一个字节的时候，该对象直接将这个字节存储到了自己的数组中，而不刷新到文件中。一直到该数组所有 8192  个位置全都占满，该对象才把这个数组中的所有数据一次性写出到目标文件中。如果最后一次循环没有将数组写满，最终在关闭流对象的时候，也会将该数组中的数据刷新到文件中\n- 字符型缓冲流高效的原因：\n\t- `BufferedReader` ：每次调用 `read` 方法，只有第一次从磁盘中读取了 8192个字符，存储到该类型对象的缓冲区数组中，将其中一个返回给调用者，再次调用\n\t  `read` 方法时，就不需要访问磁盘，直接从缓冲区中拿出一个数据即可，提升了效率  \n\t- `BufferedWriter`：每次调用 `write` 方法，不会直接将字符刷新到文件中，而是存储到字符数组中，等字符数组写满了，才一次性刷新到文件中，减少了IO次数，提升了效率 \n## Tips\n- 将数据存储到数据库要不要经过序列化和反序列化?\n\t- 数据库操作直接通过 ORM 框架 或 SQL 将数据与数据库表中的记录映射(mapper)，不涉及 Java 的序列化机制, 如果需要将对象存储为 JSON 格式，可以通过序列化工具（如 Jackson、Gson）将对象转换为 JSON 字符串存储到数据库的对应字段(一般是String )\n- Java 缓冲区溢出主要是由于向缓冲区写入的数据超过其能够存储的数据量?\n\t- 合理设置缓冲区大小\n\t- 控制写入数据量","source":"_posts/Serializable.md","raw":"---\ntitle: 逻辑与物理序列化\ntags:\n  - Serializable\n  - IO\n  - InputStream\n  - OutputStream\ncategories: 编程\ndate: 2024-11-19 14:52:38\n---\n\n------\n# 逻辑与物理序列化\n\n🤔💬`如果一个人不知道要驶向哪一个码头, 那么任何风都不会是顺风\n\n------\n## 序列化和反序列化的区别\n**逻辑序列化:\t对象\t-> \tJSON**\n**物理序列化\t JSON\t->\t字节**\n- **序列化是将 对象 转化成 字节 存储在磁盘(Redis通过RDB或AOF的持久化数据就是放在磁盘上)** \n- **反序列化是读取磁盘 将字节 转化成 对象**\n- 当然不只是磁盘, 因为是字节, 所以当成字节流可以在网络中运输\n- 不同进程/程序间进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等，而这些数据都会以二进制序列(字节流)的形式在网络上传送。\n- `transient` 关键字修饰的成员变量，将不参与序列化  \n## 序列化接口和序列化ID\n-  只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列\n-  序列化类的属性没有实现 Serializable接口 那么在序列化就会报错: NotSerializableException\n- Java的序列化机制是通过判断运行时类的serialVersionUID来验证版本一致性的，在进行反序列化时，JVM会把传进来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。\n- 步骤:\n  - 若User类仅仅实现了Serializable接口定义了自己的序列化id, 则可以按照以下方式进行序列化和反序列化。\n  - ObjectOutputStream采用默认的序列化方式，对User对象的非transient的实例变量进行序列化。\n  - ObjcetInputStream采用默认的反序列化方式，对对User对象的非transient的实例变量进行反序列化。\n## 序列化器\n- **网络直接传输数据，但是无法直接传输Json对象或者XML对象，必须在传输前序列化，传输完成后反序列化成对象。**\n- **网络底层只能识别和传输二进制数据。无论是 JSON、XML，还是 Java 对象，这些高层次的数据结构都需要转化为字节序列才能传输。**\n- 所以所有可在网络上传输的对象都必须是可序列化的。\n- springboot中是通过Jackson的**objectMapper序列化器**来实现序列化和反序列化的, 并不依赖java原生序列化接口\n  - Jackson 通过**反射读取类的字段**。\n  - 利用 `ObjectMapper` 序列化为 JSON 或反序列化为 Java 对象。\n  - 与传统的 Java 序列化不同，Jackson 不依赖 `Serializable` 接口。\n## 自定义序列化器\n\n- @JsonFormat\n  - Jackson 在处理对象转 JSON 时，会使用字段的默认序列化器\n  - Jackson 在序列化和反序列化时会扫描字段上的注解\n  - 如果字段上有 `@JsonFormat` 注解，Jackson 会为该字段生成一个自定义的序列化器。\n  - 这个序列化器会按照 `@JsonFormat` 指定的格式（例如 `pattern` 和 `timezone`）格式化数据。\n- @JsonSerialize(using = ToStringSerializer.class)\n\t- 返回前端是进行 将其他类型转换成String的操作\n\t- 避免诸如Long类型过长导致的JS精度丢失\n## 几种Json与字符串换转工具\n- **概念理解: 序列化是比较宽泛的词, 将普通字符串转换为JSON格式字符串也可以叫序列化**\n  - Gson 是 Google 开源的 JSON 库\n  - FastJSON 是阿里巴巴开源的高性能 JSON 处理库\n  - Jackson 是 Spring 框架默认集成的 JSON 序列化工具(SpringMVC 转换默认使用 Jackson)\n```java\n//      3种将实体类对象转化成json格式的字符串方法\n        Object heike = new HeiKe();\n\n        //第一种：谷歌旗下的gson\n        Gson gson = new Gson();\n        String json1 = gson.toJson(heike);\n\n        //第二种：阿里巴巴的fastJson\n        String json2 = JSONObject.toJSONString(heike);\n\n        //第三种：spring框架的jackJson   \n        ObjectMapper mapper = new ObjectMapper();\n        String json3 = mapper.writeValueAsString(heike);\n\n        System.out.println(json1);\n        System.out.println(json2);\n        System.out.println(json3);\n\n//         3种将JSON字符串转换为对象\n\n        //第一种：谷歌旗下的gson\n        gson.fromJson(json1, HeiKe.class);\n\n        //第二种：fastJson\n        JSON.parseObject(json2, HeiKe.class);\n\n        //第三种：jackJson\n        mapper.readValue(json3, HeiKe.class);\n\n    }\n```\n\n![17320061339471732006133927.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17320061339471732006133927.png)\n## Redis序列化器\n- spring-data-redis是整合了Lettuce和Jedis的java客户端, 提供了RedisTemplate这样的api来操作Redis\n- 通过 **`RedisConnectionFactory`** 来建立 Redis 连接。\n- **对不同的数据类型存放容器采取不同序列化器**\n- 使用 `Jackson2JsonRedisSerializer` 将 Java 对象序列化为 JSON 格式的字符串，并存入 Redis\n- **序列化成JSON字符串, 反序列化成Java对象:** \n\t- **Key的序列化**\n\t  - 如果 key 是字符串类型：使用 `StringRedisSerializer` 将 key 序列化为 UTF-8 编码的字节流。\n\t  - 如果 key 是对象类型: 一把来说用不到，需要用 `Jackson2JsonRedisSerializer` 或 `JdkSerializationRedisSerializer` 等将对象序列化为 Redis 存储格式（最终是字节流）。\n\t- **Value的序列化**\n\t  - 对象类型的 value 通常需要两步：\n\t    - **JSON 转换**（逻辑序列化）：例如用 `Jackson` 或 `Gson` **将对象序列化为 JSON 字符串**\n\t    - **字节流转换**（物理序列化）：例如用 `UTF-8` 编码**将 JSON 字符串转换为字节流**。\n\t    - JSON序列化器会将**类的class类型**写入Json结果中(**很重要**)\n- 注意: **Redis 的原生序列化器**是 **JDK 序列化机制**，即通过 Java 的 `Serializable` 接口进行序列化和反序列化。JDK 将对象转换为字节 存到Redis, 并没有进行JSON的转化\n```java\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        // 实例化自己的RedisTemplate\n        RedisTemplate<String, Object> template = new RedisTemplate<String, Object>();\n        \n        // 设置使用连接工厂连接\n        template.setConnectionFactory(factory);\n\n\t\t// key的序列化器\n\t\tStringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n\n\t\t// value的序列化器\n        Jackson2JsonRedisSerializer jacksonToJsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jacksonToJsonRedisSerializer.setObjectMapper(om);\n        \n        // key采用redis原生的String序列化器\n        template.setKeySerializer(stringRedisSerializer);\n        \n        // hash的key也采用redis原生的String序列化器\n        template.setHashKeySerializer(stringRedisSerializer);\n        \n        // value序列化方式采用jackson ObjectMapper的序列化器\n        template.setValueSerializer(jacksonToJsonRedisSerializer);\n        \n        // hash的value序列化方式采用jackson\n        template.setHashValueSerializer(jacksonToJsonRedisSerializer);\n        \n        template.afterPropertiesSet();\n        return template;\n    }\n```\n\n```java\n// 开启默认类型（兼容多态反序列化）就是处理嵌套类时保留类型信息,让反序列化顺利,解决出现复杂嵌套反序列化失败问题  \n//{  \n//  \"@class\": \"com.example.对象\",  \n//  \"id\": \"1\"  \n//}  \nobjectMapper.activateDefaultTyping(  \n        objectMapper.getPolymorphicTypeValidator(),  \n        ObjectMapper.DefaultTyping.NON_FINAL,  \n        JsonTypeInfo.As.PROPERTY  \n);\n```\n## Json格式的转化\n注:本文使用ObjectMapper工具类\n- Json转实体类\n```java\nString json = \"{\\\"name\\\": \\\"黎淳美\\\", \\\"age\\\": 21}\";\nObjectMapper objectMapper = new ObjectMapper();\nperson person = objectMapper.readValue(json, person.class);\n\nclass person{\n    String name;\n    Integer age;\n    ...\n}\n```\n- Json转Map\n```java\nString json = \"{\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": 123}\";\n        ObjectMapper objectMapper = new ObjectMapper();\n\n\t// 方法一: 未显式声明泛型的 Map 默认会将值类型解析为 Object\n        Map map = objectMapper.readValue(json, Map.class);\n        System.out.println(map.get(\"key1\"));\n\n\t// 方法二: TypeReference是抽象类\n        Map<String, Object> objectMap = objectMapper.readValue(json, new TypeReference<Map<String, Object>>() {});\n```\n- Json转数组\n```java\nString jsonArray = \"[{\\\"name\\\":\\\"Tom\\\",\\\"age\\\":25},{\\\"name\\\":\\\"Jerry\\\",\\\"age\\\":22}]\";\n\nList<Person> personList = objectMapper.readValue(jsonArray, new TypeReference<List<Person>>() {});\nList<Person> personList = objectMapper.readValue(jsonArray, List<person>.class);\n\n```\n## IO 流的体系：分块 缓冲 压缩 多线程\n- Java IO 流广泛采用装饰者模式，通过各种装饰器类来增强功能,，比如缓冲流，打印流\n- 根据数据流向分: 输入流(反序列化) 和 输出流(序列化)\n- 根据数据类型分: 字节流 和 字符流  (Byte 和 Char)  \n- 根据源文件类型分:  音频视频图片等二进制文件 和 文本文件(方便我们平时对字符进行流操作)  \n\n| 分类/对象 | 字节输入流                    | 字节输出流                     | 字符输入流           | 字符输出流           |     |     |\n| ----- | ------------------------ | ------------------------- | --------------- | --------------- | --- | --- |\n| 基类    | InputStream              | OutputStream              | Reader          | Writer          |     |     |\n| 文件流   | FileInputStream          | FileOutputStream          | FileReader      | FileWriter      |     |     |\n| 缓冲流   | BufferedInputStream      | BufferedOutputStream      | BufferedReader  | BufferedWriter  |     |     |\n| 转化流   | InputStreamReader(字节→字符) | OutputStreamWriter(字符→字节) | -               | -               |     |     |\n| 对象流   | ObjectInputStream        | ObjectOutputStream        | -               | -               |     |     |\n| 打印流   | -                        | PrintStream               | -               | PrintWriter     |     |     |\n| 数组流   | ByteArrayInputStream     | ByteArrayOutputStream     | CharArrayReader | CharArrayWriter |     |     |\n| 管道流   | PipeInputStream          | PipedOutputStream         | PipedReader     | PipedWriter     |     |     |\n|       |                          |                           |                 |                 |     |     |\n \n- 字节型缓冲流高效的原因：  \n\t- `BufferedInputStream`：在该类型中准备了一个缓存数组，存储字节信息，当外界调用 `read` 方法想获取一个字节的时候，该对象从文件中一次性读取了8192 个字节到数组中，只返回了第一个字节给调用者。将来调用者再次调用 `read` 方法时，当前对象就不需要再次访问磁盘，只需要从数组中取出字节返回给调用者即可，由于读取的是数组，所以速度非常快。当 8192 个字节全都读取完成之后，再需要读取一个字节，就得让该对象到文件中读取下一个 8192 个字节\n\t- `BufferedOutputStream`：在该类型中准备了一个数组，存储字节信息，当外界调用 `write`  \n\t  方法想写出一个字节的时候，该对象直接将这个字节存储到了自己的数组中，而不刷新到文件中。一直到该数组所有 8192  个位置全都占满，该对象才把这个数组中的所有数据一次性写出到目标文件中。如果最后一次循环没有将数组写满，最终在关闭流对象的时候，也会将该数组中的数据刷新到文件中\n- 字符型缓冲流高效的原因：\n\t- `BufferedReader` ：每次调用 `read` 方法，只有第一次从磁盘中读取了 8192个字符，存储到该类型对象的缓冲区数组中，将其中一个返回给调用者，再次调用\n\t  `read` 方法时，就不需要访问磁盘，直接从缓冲区中拿出一个数据即可，提升了效率  \n\t- `BufferedWriter`：每次调用 `write` 方法，不会直接将字符刷新到文件中，而是存储到字符数组中，等字符数组写满了，才一次性刷新到文件中，减少了IO次数，提升了效率 \n## Tips\n- 将数据存储到数据库要不要经过序列化和反序列化?\n\t- 数据库操作直接通过 ORM 框架 或 SQL 将数据与数据库表中的记录映射(mapper)，不涉及 Java 的序列化机制, 如果需要将对象存储为 JSON 格式，可以通过序列化工具（如 Jackson、Gson）将对象转换为 JSON 字符串存储到数据库的对应字段(一般是String )\n- Java 缓冲区溢出主要是由于向缓冲区写入的数据超过其能够存储的数据量?\n\t- 合理设置缓冲区大小\n\t- 控制写入数据量","slug":"Serializable","published":1,"updated":"2025-10-14T10:55:54.683Z","_id":"cmfw4z09j000muomw365d60dr","comments":1,"layout":"post","photos":[],"content":"<hr>\n<h1 id=\"逻辑与物理序列化\"><a href=\"#逻辑与物理序列化\" class=\"headerlink\" title=\"逻辑与物理序列化\"></a>逻辑与物理序列化</h1><p>🤔💬`如果一个人不知道要驶向哪一个码头, 那么任何风都不会是顺风</p>\n<hr>\n<h2 id=\"序列化和反序列化的区别\"><a href=\"#序列化和反序列化的区别\" class=\"headerlink\" title=\"序列化和反序列化的区别\"></a>序列化和反序列化的区别</h2><p><strong>逻辑序列化:    对象    -&gt;     JSON</strong><br><strong>物理序列化     JSON    -&gt;    字节</strong></p>\n<ul>\n<li><strong>序列化是将 对象 转化成 字节 存储在磁盘(Redis通过RDB或AOF的持久化数据就是放在磁盘上)</strong> </li>\n<li><strong>反序列化是读取磁盘 将字节 转化成 对象</strong></li>\n<li>当然不只是磁盘, 因为是字节, 所以当成字节流可以在网络中运输</li>\n<li>不同进程/程序间进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等，而这些数据都会以二进制序列(字节流)的形式在网络上传送。</li>\n<li><code>transient</code> 关键字修饰的成员变量，将不参与序列化  <h2 id=\"序列化接口和序列化ID\"><a href=\"#序列化接口和序列化ID\" class=\"headerlink\" title=\"序列化接口和序列化ID\"></a>序列化接口和序列化ID</h2></li>\n<li>只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列</li>\n<li>序列化类的属性没有实现 Serializable接口 那么在序列化就会报错: NotSerializableException</li>\n<li>Java的序列化机制是通过判断运行时类的serialVersionUID来验证版本一致性的，在进行反序列化时，JVM会把传进来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。</li>\n<li>步骤:<ul>\n<li>若User类仅仅实现了Serializable接口定义了自己的序列化id, 则可以按照以下方式进行序列化和反序列化。</li>\n<li>ObjectOutputStream采用默认的序列化方式，对User对象的非transient的实例变量进行序列化。</li>\n<li>ObjcetInputStream采用默认的反序列化方式，对对User对象的非transient的实例变量进行反序列化。<h2 id=\"序列化器\"><a href=\"#序列化器\" class=\"headerlink\" title=\"序列化器\"></a>序列化器</h2></li>\n</ul>\n</li>\n<li><strong>网络直接传输数据，但是无法直接传输Json对象或者XML对象，必须在传输前序列化，传输完成后反序列化成对象。</strong></li>\n<li><strong>网络底层只能识别和传输二进制数据。无论是 JSON、XML，还是 Java 对象，这些高层次的数据结构都需要转化为字节序列才能传输。</strong></li>\n<li>所以所有可在网络上传输的对象都必须是可序列化的。</li>\n<li><p>springboot中是通过Jackson的<strong>objectMapper序列化器</strong>来实现序列化和反序列化的, 并不依赖java原生序列化接口</p>\n<ul>\n<li>Jackson 通过<strong>反射读取类的字段</strong>。</li>\n<li>利用 <code>ObjectMapper</code> 序列化为 JSON 或反序列化为 Java 对象。</li>\n<li>与传统的 Java 序列化不同，Jackson 不依赖 <code>Serializable</code> 接口。<h2 id=\"自定义序列化器\"><a href=\"#自定义序列化器\" class=\"headerlink\" title=\"自定义序列化器\"></a>自定义序列化器</h2></li>\n</ul>\n</li>\n<li><p>@JsonFormat</p>\n<ul>\n<li>Jackson 在处理对象转 JSON 时，会使用字段的默认序列化器</li>\n<li>Jackson 在序列化和反序列化时会扫描字段上的注解</li>\n<li>如果字段上有 <code>@JsonFormat</code> 注解，Jackson 会为该字段生成一个自定义的序列化器。</li>\n<li>这个序列化器会按照 <code>@JsonFormat</code> 指定的格式（例如 <code>pattern</code> 和 <code>timezone</code>）格式化数据。</li>\n</ul>\n</li>\n<li>@JsonSerialize(using = ToStringSerializer.class)<ul>\n<li>返回前端是进行 将其他类型转换成String的操作</li>\n<li>避免诸如Long类型过长导致的JS精度丢失<h2 id=\"几种Json与字符串换转工具\"><a href=\"#几种Json与字符串换转工具\" class=\"headerlink\" title=\"几种Json与字符串换转工具\"></a>几种Json与字符串换转工具</h2></li>\n</ul>\n</li>\n<li><strong>概念理解: 序列化是比较宽泛的词, 将普通字符串转换为JSON格式字符串也可以叫序列化</strong><ul>\n<li>Gson 是 Google 开源的 JSON 库</li>\n<li>FastJSON 是阿里巴巴开源的高性能 JSON 处理库</li>\n<li>Jackson 是 Spring 框架默认集成的 JSON 序列化工具(SpringMVC 转换默认使用 Jackson)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//      3种将实体类对象转化成json格式的字符串方法</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">heike</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HeiKe</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第一种：谷歌旗下的gson</span></span><br><span class=\"line\">        <span class=\"type\">Gson</span> <span class=\"variable\">gson</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">json1</span> <span class=\"operator\">=</span> gson.toJson(heike);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第二种：阿里巴巴的fastJson</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">json2</span> <span class=\"operator\">=</span> JSONObject.toJSONString(heike);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第三种：spring框架的jackJson   </span></span><br><span class=\"line\">        <span class=\"type\">ObjectMapper</span> <span class=\"variable\">mapper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">json3</span> <span class=\"operator\">=</span> mapper.writeValueAsString(heike);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(json1);</span><br><span class=\"line\">        System.out.println(json2);</span><br><span class=\"line\">        System.out.println(json3);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//         3种将JSON字符串转换为对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第一种：谷歌旗下的gson</span></span><br><span class=\"line\">        gson.fromJson(json1, HeiKe.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第二种：fastJson</span></span><br><span class=\"line\">        JSON.parseObject(json2, HeiKe.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第三种：jackJson</span></span><br><span class=\"line\">        mapper.readValue(json3, HeiKe.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17320061339471732006133927.png\" alt=\"17320061339471732006133927.png\"></p>\n<h2 id=\"Redis序列化器\"><a href=\"#Redis序列化器\" class=\"headerlink\" title=\"Redis序列化器\"></a>Redis序列化器</h2><ul>\n<li>spring-data-redis是整合了Lettuce和Jedis的java客户端, 提供了RedisTemplate这样的api来操作Redis</li>\n<li>通过 <strong><code>RedisConnectionFactory</code></strong> 来建立 Redis 连接。</li>\n<li><strong>对不同的数据类型存放容器采取不同序列化器</strong></li>\n<li>使用 <code>Jackson2JsonRedisSerializer</code> 将 Java 对象序列化为 JSON 格式的字符串，并存入 Redis</li>\n<li><strong>序列化成JSON字符串, 反序列化成Java对象:</strong> <ul>\n<li><strong>Key的序列化</strong><ul>\n<li>如果 key 是字符串类型：使用 <code>StringRedisSerializer</code> 将 key 序列化为 UTF-8 编码的字节流。</li>\n<li>如果 key 是对象类型: 一把来说用不到，需要用 <code>Jackson2JsonRedisSerializer</code> 或 <code>JdkSerializationRedisSerializer</code> 等将对象序列化为 Redis 存储格式（最终是字节流）。</li>\n</ul>\n</li>\n<li><strong>Value的序列化</strong><ul>\n<li>对象类型的 value 通常需要两步：<ul>\n<li><strong>JSON 转换</strong>（逻辑序列化）：例如用 <code>Jackson</code> 或 <code>Gson</code> <strong>将对象序列化为 JSON 字符串</strong></li>\n<li><strong>字节流转换</strong>（物理序列化）：例如用 <code>UTF-8</code> 编码<strong>将 JSON 字符串转换为字节流</strong>。</li>\n<li>JSON序列化器会将<strong>类的class类型</strong>写入Json结果中(<strong>很重要</strong>)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>注意: <strong>Redis 的原生序列化器</strong>是 <strong>JDK 序列化机制</strong>，即通过 Java 的 <code>Serializable</code> 接口进行序列化和反序列化。JDK 将对象转换为字节 存到Redis, 并没有进行JSON的转化<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> RedisTemplate&lt;String, Object&gt; <span class=\"title function_\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory factory)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 实例化自己的RedisTemplate</span></span><br><span class=\"line\">      RedisTemplate&lt;String, Object&gt; template = <span class=\"keyword\">new</span> <span class=\"title class_\">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 设置使用连接工厂连接</span></span><br><span class=\"line\">      template.setConnectionFactory(factory);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// key的序列化器</span></span><br><span class=\"line\"><span class=\"type\">StringRedisSerializer</span> <span class=\"variable\">stringRedisSerializer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// value的序列化器</span></span><br><span class=\"line\">      <span class=\"type\">Jackson2JsonRedisSerializer</span> <span class=\"variable\">jacksonToJsonRedisSerializer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class=\"line\">      <span class=\"type\">ObjectMapper</span> <span class=\"variable\">om</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();</span><br><span class=\"line\">      om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class=\"line\">      om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class=\"line\">      jacksonToJsonRedisSerializer.setObjectMapper(om);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// key采用redis原生的String序列化器</span></span><br><span class=\"line\">      template.setKeySerializer(stringRedisSerializer);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// hash的key也采用redis原生的String序列化器</span></span><br><span class=\"line\">      template.setHashKeySerializer(stringRedisSerializer);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// value序列化方式采用jackson ObjectMapper的序列化器</span></span><br><span class=\"line\">      template.setValueSerializer(jacksonToJsonRedisSerializer);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// hash的value序列化方式采用jackson</span></span><br><span class=\"line\">      template.setHashValueSerializer(jacksonToJsonRedisSerializer);</span><br><span class=\"line\">      </span><br><span class=\"line\">      template.afterPropertiesSet();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开启默认类型（兼容多态反序列化）就是处理嵌套类时保留类型信息,让反序列化顺利,解决出现复杂嵌套反序列化失败问题  </span></span><br><span class=\"line\"><span class=\"comment\">//&#123;  </span></span><br><span class=\"line\"><span class=\"comment\">//  &quot;@class&quot;: &quot;com.example.对象&quot;,  </span></span><br><span class=\"line\"><span class=\"comment\">//  &quot;id&quot;: &quot;1&quot;  </span></span><br><span class=\"line\"><span class=\"comment\">//&#125;  </span></span><br><span class=\"line\">objectMapper.activateDefaultTyping(  </span><br><span class=\"line\">        objectMapper.getPolymorphicTypeValidator(),  </span><br><span class=\"line\">        ObjectMapper.DefaultTyping.NON_FINAL,  </span><br><span class=\"line\">        JsonTypeInfo.As.PROPERTY  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Json格式的转化\"><a href=\"#Json格式的转化\" class=\"headerlink\" title=\"Json格式的转化\"></a>Json格式的转化</h2><p>注:本文使用ObjectMapper工具类</p>\n<ul>\n<li>Json转实体类<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">json</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&#123;\\&quot;name\\&quot;: \\&quot;黎淳美\\&quot;, \\&quot;age\\&quot;: 21&#125;&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">ObjectMapper</span> <span class=\"variable\">objectMapper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();</span><br><span class=\"line\"><span class=\"type\">person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> objectMapper.readValue(json, person.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">person</span>&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    Integer age;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>Json转Map<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">json</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&#123;\\&quot;key1\\&quot;: \\&quot;value1\\&quot;, \\&quot;key2\\&quot;: 123&#125;&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">ObjectMapper</span> <span class=\"variable\">objectMapper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 方法一: 未显式声明泛型的 Map 默认会将值类型解析为 Object</span></span><br><span class=\"line\">        <span class=\"type\">Map</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> objectMapper.readValue(json, Map.class);</span><br><span class=\"line\">        System.out.println(map.get(<span class=\"string\">&quot;key1&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 方法二: TypeReference是抽象类</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; objectMap = objectMapper.readValue(json, <span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>Json转数组<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">jsonArray</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;[&#123;\\&quot;name\\&quot;:\\&quot;Tom\\&quot;,\\&quot;age\\&quot;:25&#125;,&#123;\\&quot;name\\&quot;:\\&quot;Jerry\\&quot;,\\&quot;age\\&quot;:22&#125;]&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Person&gt; personList = objectMapper.readValue(jsonArray, <span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;Person&gt;&gt;() &#123;&#125;);</span><br><span class=\"line\">List&lt;Person&gt; personList = objectMapper.readValue(jsonArray, List&lt;person&gt;.class);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"IO-流的体系：分块-缓冲-压缩-多线程\"><a href=\"#IO-流的体系：分块-缓冲-压缩-多线程\" class=\"headerlink\" title=\"IO 流的体系：分块 缓冲 压缩 多线程\"></a>IO 流的体系：分块 缓冲 压缩 多线程</h2></li>\n<li>Java IO 流广泛采用装饰者模式，通过各种装饰器类来增强功能,，比如缓冲流，打印流</li>\n<li>根据数据流向分: 输入流(反序列化) 和 输出流(序列化)</li>\n<li>根据数据类型分: 字节流 和 字符流  (Byte 和 Char)  </li>\n<li>根据源文件类型分:  音频视频图片等二进制文件 和 文本文件(方便我们平时对字符进行流操作)  </li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>分类/对象</th>\n<th>字节输入流</th>\n<th>字节输出流</th>\n<th>字符输入流</th>\n<th>字符输出流</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基类</td>\n<td>InputStream</td>\n<td>OutputStream</td>\n<td>Reader</td>\n<td>Writer</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>文件流</td>\n<td>FileInputStream</td>\n<td>FileOutputStream</td>\n<td>FileReader</td>\n<td>FileWriter</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>缓冲流</td>\n<td>BufferedInputStream</td>\n<td>BufferedOutputStream</td>\n<td>BufferedReader</td>\n<td>BufferedWriter</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>转化流</td>\n<td>InputStreamReader(字节→字符)</td>\n<td>OutputStreamWriter(字符→字节)</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>对象流</td>\n<td>ObjectInputStream</td>\n<td>ObjectOutputStream</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>打印流</td>\n<td>-</td>\n<td>PrintStream</td>\n<td>-</td>\n<td>PrintWriter</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>数组流</td>\n<td>ByteArrayInputStream</td>\n<td>ByteArrayOutputStream</td>\n<td>CharArrayReader</td>\n<td>CharArrayWriter</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>管道流</td>\n<td>PipeInputStream</td>\n<td>PipedOutputStream</td>\n<td>PipedReader</td>\n<td>PipedWriter</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>字节型缓冲流高效的原因：  <ul>\n<li><code>BufferedInputStream</code>：在该类型中准备了一个缓存数组，存储字节信息，当外界调用 <code>read</code> 方法想获取一个字节的时候，该对象从文件中一次性读取了8192 个字节到数组中，只返回了第一个字节给调用者。将来调用者再次调用 <code>read</code> 方法时，当前对象就不需要再次访问磁盘，只需要从数组中取出字节返回给调用者即可，由于读取的是数组，所以速度非常快。当 8192 个字节全都读取完成之后，再需要读取一个字节，就得让该对象到文件中读取下一个 8192 个字节</li>\n<li><code>BufferedOutputStream</code>：在该类型中准备了一个数组，存储字节信息，当外界调用 <code>write</code><br>方法想写出一个字节的时候，该对象直接将这个字节存储到了自己的数组中，而不刷新到文件中。一直到该数组所有 8192  个位置全都占满，该对象才把这个数组中的所有数据一次性写出到目标文件中。如果最后一次循环没有将数组写满，最终在关闭流对象的时候，也会将该数组中的数据刷新到文件中</li>\n</ul>\n</li>\n<li>字符型缓冲流高效的原因：<ul>\n<li><code>BufferedReader</code> ：每次调用 <code>read</code> 方法，只有第一次从磁盘中读取了 8192个字符，存储到该类型对象的缓冲区数组中，将其中一个返回给调用者，再次调用<br><code>read</code> 方法时，就不需要访问磁盘，直接从缓冲区中拿出一个数据即可，提升了效率  </li>\n<li><code>BufferedWriter</code>：每次调用 <code>write</code> 方法，不会直接将字符刷新到文件中，而是存储到字符数组中，等字符数组写满了，才一次性刷新到文件中，减少了IO次数，提升了效率 <h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2></li>\n</ul>\n</li>\n<li>将数据存储到数据库要不要经过序列化和反序列化?<ul>\n<li>数据库操作直接通过 ORM 框架 或 SQL 将数据与数据库表中的记录映射(mapper)，不涉及 Java 的序列化机制, 如果需要将对象存储为 JSON 格式，可以通过序列化工具（如 Jackson、Gson）将对象转换为 JSON 字符串存储到数据库的对应字段(一般是String )</li>\n</ul>\n</li>\n<li>Java 缓冲区溢出主要是由于向缓冲区写入的数据超过其能够存储的数据量?<ul>\n<li>合理设置缓冲区大小</li>\n<li>控制写入数据量</li>\n</ul>\n</li>\n</ul>\n","cover":"/img/3.png","cover_type":"img","excerpt":"","more":"<hr>\n<h1 id=\"逻辑与物理序列化\"><a href=\"#逻辑与物理序列化\" class=\"headerlink\" title=\"逻辑与物理序列化\"></a>逻辑与物理序列化</h1><p>🤔💬`如果一个人不知道要驶向哪一个码头, 那么任何风都不会是顺风</p>\n<hr>\n<h2 id=\"序列化和反序列化的区别\"><a href=\"#序列化和反序列化的区别\" class=\"headerlink\" title=\"序列化和反序列化的区别\"></a>序列化和反序列化的区别</h2><p><strong>逻辑序列化:    对象    -&gt;     JSON</strong><br><strong>物理序列化     JSON    -&gt;    字节</strong></p>\n<ul>\n<li><strong>序列化是将 对象 转化成 字节 存储在磁盘(Redis通过RDB或AOF的持久化数据就是放在磁盘上)</strong> </li>\n<li><strong>反序列化是读取磁盘 将字节 转化成 对象</strong></li>\n<li>当然不只是磁盘, 因为是字节, 所以当成字节流可以在网络中运输</li>\n<li>不同进程/程序间进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等，而这些数据都会以二进制序列(字节流)的形式在网络上传送。</li>\n<li><code>transient</code> 关键字修饰的成员变量，将不参与序列化  <h2 id=\"序列化接口和序列化ID\"><a href=\"#序列化接口和序列化ID\" class=\"headerlink\" title=\"序列化接口和序列化ID\"></a>序列化接口和序列化ID</h2></li>\n<li>只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列</li>\n<li>序列化类的属性没有实现 Serializable接口 那么在序列化就会报错: NotSerializableException</li>\n<li>Java的序列化机制是通过判断运行时类的serialVersionUID来验证版本一致性的，在进行反序列化时，JVM会把传进来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。</li>\n<li>步骤:<ul>\n<li>若User类仅仅实现了Serializable接口定义了自己的序列化id, 则可以按照以下方式进行序列化和反序列化。</li>\n<li>ObjectOutputStream采用默认的序列化方式，对User对象的非transient的实例变量进行序列化。</li>\n<li>ObjcetInputStream采用默认的反序列化方式，对对User对象的非transient的实例变量进行反序列化。<h2 id=\"序列化器\"><a href=\"#序列化器\" class=\"headerlink\" title=\"序列化器\"></a>序列化器</h2></li>\n</ul>\n</li>\n<li><strong>网络直接传输数据，但是无法直接传输Json对象或者XML对象，必须在传输前序列化，传输完成后反序列化成对象。</strong></li>\n<li><strong>网络底层只能识别和传输二进制数据。无论是 JSON、XML，还是 Java 对象，这些高层次的数据结构都需要转化为字节序列才能传输。</strong></li>\n<li>所以所有可在网络上传输的对象都必须是可序列化的。</li>\n<li><p>springboot中是通过Jackson的<strong>objectMapper序列化器</strong>来实现序列化和反序列化的, 并不依赖java原生序列化接口</p>\n<ul>\n<li>Jackson 通过<strong>反射读取类的字段</strong>。</li>\n<li>利用 <code>ObjectMapper</code> 序列化为 JSON 或反序列化为 Java 对象。</li>\n<li>与传统的 Java 序列化不同，Jackson 不依赖 <code>Serializable</code> 接口。<h2 id=\"自定义序列化器\"><a href=\"#自定义序列化器\" class=\"headerlink\" title=\"自定义序列化器\"></a>自定义序列化器</h2></li>\n</ul>\n</li>\n<li><p>@JsonFormat</p>\n<ul>\n<li>Jackson 在处理对象转 JSON 时，会使用字段的默认序列化器</li>\n<li>Jackson 在序列化和反序列化时会扫描字段上的注解</li>\n<li>如果字段上有 <code>@JsonFormat</code> 注解，Jackson 会为该字段生成一个自定义的序列化器。</li>\n<li>这个序列化器会按照 <code>@JsonFormat</code> 指定的格式（例如 <code>pattern</code> 和 <code>timezone</code>）格式化数据。</li>\n</ul>\n</li>\n<li>@JsonSerialize(using = ToStringSerializer.class)<ul>\n<li>返回前端是进行 将其他类型转换成String的操作</li>\n<li>避免诸如Long类型过长导致的JS精度丢失<h2 id=\"几种Json与字符串换转工具\"><a href=\"#几种Json与字符串换转工具\" class=\"headerlink\" title=\"几种Json与字符串换转工具\"></a>几种Json与字符串换转工具</h2></li>\n</ul>\n</li>\n<li><strong>概念理解: 序列化是比较宽泛的词, 将普通字符串转换为JSON格式字符串也可以叫序列化</strong><ul>\n<li>Gson 是 Google 开源的 JSON 库</li>\n<li>FastJSON 是阿里巴巴开源的高性能 JSON 处理库</li>\n<li>Jackson 是 Spring 框架默认集成的 JSON 序列化工具(SpringMVC 转换默认使用 Jackson)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//      3种将实体类对象转化成json格式的字符串方法</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">heike</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HeiKe</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第一种：谷歌旗下的gson</span></span><br><span class=\"line\">        <span class=\"type\">Gson</span> <span class=\"variable\">gson</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">json1</span> <span class=\"operator\">=</span> gson.toJson(heike);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第二种：阿里巴巴的fastJson</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">json2</span> <span class=\"operator\">=</span> JSONObject.toJSONString(heike);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第三种：spring框架的jackJson   </span></span><br><span class=\"line\">        <span class=\"type\">ObjectMapper</span> <span class=\"variable\">mapper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">json3</span> <span class=\"operator\">=</span> mapper.writeValueAsString(heike);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(json1);</span><br><span class=\"line\">        System.out.println(json2);</span><br><span class=\"line\">        System.out.println(json3);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//         3种将JSON字符串转换为对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第一种：谷歌旗下的gson</span></span><br><span class=\"line\">        gson.fromJson(json1, HeiKe.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第二种：fastJson</span></span><br><span class=\"line\">        JSON.parseObject(json2, HeiKe.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//第三种：jackJson</span></span><br><span class=\"line\">        mapper.readValue(json3, HeiKe.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17320061339471732006133927.png\" alt=\"17320061339471732006133927.png\"></p>\n<h2 id=\"Redis序列化器\"><a href=\"#Redis序列化器\" class=\"headerlink\" title=\"Redis序列化器\"></a>Redis序列化器</h2><ul>\n<li>spring-data-redis是整合了Lettuce和Jedis的java客户端, 提供了RedisTemplate这样的api来操作Redis</li>\n<li>通过 <strong><code>RedisConnectionFactory</code></strong> 来建立 Redis 连接。</li>\n<li><strong>对不同的数据类型存放容器采取不同序列化器</strong></li>\n<li>使用 <code>Jackson2JsonRedisSerializer</code> 将 Java 对象序列化为 JSON 格式的字符串，并存入 Redis</li>\n<li><strong>序列化成JSON字符串, 反序列化成Java对象:</strong> <ul>\n<li><strong>Key的序列化</strong><ul>\n<li>如果 key 是字符串类型：使用 <code>StringRedisSerializer</code> 将 key 序列化为 UTF-8 编码的字节流。</li>\n<li>如果 key 是对象类型: 一把来说用不到，需要用 <code>Jackson2JsonRedisSerializer</code> 或 <code>JdkSerializationRedisSerializer</code> 等将对象序列化为 Redis 存储格式（最终是字节流）。</li>\n</ul>\n</li>\n<li><strong>Value的序列化</strong><ul>\n<li>对象类型的 value 通常需要两步：<ul>\n<li><strong>JSON 转换</strong>（逻辑序列化）：例如用 <code>Jackson</code> 或 <code>Gson</code> <strong>将对象序列化为 JSON 字符串</strong></li>\n<li><strong>字节流转换</strong>（物理序列化）：例如用 <code>UTF-8</code> 编码<strong>将 JSON 字符串转换为字节流</strong>。</li>\n<li>JSON序列化器会将<strong>类的class类型</strong>写入Json结果中(<strong>很重要</strong>)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>注意: <strong>Redis 的原生序列化器</strong>是 <strong>JDK 序列化机制</strong>，即通过 Java 的 <code>Serializable</code> 接口进行序列化和反序列化。JDK 将对象转换为字节 存到Redis, 并没有进行JSON的转化<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> RedisTemplate&lt;String, Object&gt; <span class=\"title function_\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory factory)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 实例化自己的RedisTemplate</span></span><br><span class=\"line\">      RedisTemplate&lt;String, Object&gt; template = <span class=\"keyword\">new</span> <span class=\"title class_\">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 设置使用连接工厂连接</span></span><br><span class=\"line\">      template.setConnectionFactory(factory);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// key的序列化器</span></span><br><span class=\"line\"><span class=\"type\">StringRedisSerializer</span> <span class=\"variable\">stringRedisSerializer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// value的序列化器</span></span><br><span class=\"line\">      <span class=\"type\">Jackson2JsonRedisSerializer</span> <span class=\"variable\">jacksonToJsonRedisSerializer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class=\"line\">      <span class=\"type\">ObjectMapper</span> <span class=\"variable\">om</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();</span><br><span class=\"line\">      om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class=\"line\">      om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class=\"line\">      jacksonToJsonRedisSerializer.setObjectMapper(om);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// key采用redis原生的String序列化器</span></span><br><span class=\"line\">      template.setKeySerializer(stringRedisSerializer);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// hash的key也采用redis原生的String序列化器</span></span><br><span class=\"line\">      template.setHashKeySerializer(stringRedisSerializer);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// value序列化方式采用jackson ObjectMapper的序列化器</span></span><br><span class=\"line\">      template.setValueSerializer(jacksonToJsonRedisSerializer);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// hash的value序列化方式采用jackson</span></span><br><span class=\"line\">      template.setHashValueSerializer(jacksonToJsonRedisSerializer);</span><br><span class=\"line\">      </span><br><span class=\"line\">      template.afterPropertiesSet();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开启默认类型（兼容多态反序列化）就是处理嵌套类时保留类型信息,让反序列化顺利,解决出现复杂嵌套反序列化失败问题  </span></span><br><span class=\"line\"><span class=\"comment\">//&#123;  </span></span><br><span class=\"line\"><span class=\"comment\">//  &quot;@class&quot;: &quot;com.example.对象&quot;,  </span></span><br><span class=\"line\"><span class=\"comment\">//  &quot;id&quot;: &quot;1&quot;  </span></span><br><span class=\"line\"><span class=\"comment\">//&#125;  </span></span><br><span class=\"line\">objectMapper.activateDefaultTyping(  </span><br><span class=\"line\">        objectMapper.getPolymorphicTypeValidator(),  </span><br><span class=\"line\">        ObjectMapper.DefaultTyping.NON_FINAL,  </span><br><span class=\"line\">        JsonTypeInfo.As.PROPERTY  </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Json格式的转化\"><a href=\"#Json格式的转化\" class=\"headerlink\" title=\"Json格式的转化\"></a>Json格式的转化</h2><p>注:本文使用ObjectMapper工具类</p>\n<ul>\n<li>Json转实体类<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">json</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&#123;\\&quot;name\\&quot;: \\&quot;黎淳美\\&quot;, \\&quot;age\\&quot;: 21&#125;&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">ObjectMapper</span> <span class=\"variable\">objectMapper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();</span><br><span class=\"line\"><span class=\"type\">person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> objectMapper.readValue(json, person.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">person</span>&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    Integer age;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>Json转Map<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">json</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&#123;\\&quot;key1\\&quot;: \\&quot;value1\\&quot;, \\&quot;key2\\&quot;: 123&#125;&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">ObjectMapper</span> <span class=\"variable\">objectMapper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 方法一: 未显式声明泛型的 Map 默认会将值类型解析为 Object</span></span><br><span class=\"line\">        <span class=\"type\">Map</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> objectMapper.readValue(json, Map.class);</span><br><span class=\"line\">        System.out.println(map.get(<span class=\"string\">&quot;key1&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 方法二: TypeReference是抽象类</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; objectMap = objectMapper.readValue(json, <span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>Json转数组<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">jsonArray</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;[&#123;\\&quot;name\\&quot;:\\&quot;Tom\\&quot;,\\&quot;age\\&quot;:25&#125;,&#123;\\&quot;name\\&quot;:\\&quot;Jerry\\&quot;,\\&quot;age\\&quot;:22&#125;]&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Person&gt; personList = objectMapper.readValue(jsonArray, <span class=\"keyword\">new</span> <span class=\"title class_\">TypeReference</span>&lt;List&lt;Person&gt;&gt;() &#123;&#125;);</span><br><span class=\"line\">List&lt;Person&gt; personList = objectMapper.readValue(jsonArray, List&lt;person&gt;.class);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"IO-流的体系：分块-缓冲-压缩-多线程\"><a href=\"#IO-流的体系：分块-缓冲-压缩-多线程\" class=\"headerlink\" title=\"IO 流的体系：分块 缓冲 压缩 多线程\"></a>IO 流的体系：分块 缓冲 压缩 多线程</h2></li>\n<li>Java IO 流广泛采用装饰者模式，通过各种装饰器类来增强功能,，比如缓冲流，打印流</li>\n<li>根据数据流向分: 输入流(反序列化) 和 输出流(序列化)</li>\n<li>根据数据类型分: 字节流 和 字符流  (Byte 和 Char)  </li>\n<li>根据源文件类型分:  音频视频图片等二进制文件 和 文本文件(方便我们平时对字符进行流操作)  </li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>分类/对象</th>\n<th>字节输入流</th>\n<th>字节输出流</th>\n<th>字符输入流</th>\n<th>字符输出流</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基类</td>\n<td>InputStream</td>\n<td>OutputStream</td>\n<td>Reader</td>\n<td>Writer</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>文件流</td>\n<td>FileInputStream</td>\n<td>FileOutputStream</td>\n<td>FileReader</td>\n<td>FileWriter</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>缓冲流</td>\n<td>BufferedInputStream</td>\n<td>BufferedOutputStream</td>\n<td>BufferedReader</td>\n<td>BufferedWriter</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>转化流</td>\n<td>InputStreamReader(字节→字符)</td>\n<td>OutputStreamWriter(字符→字节)</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>对象流</td>\n<td>ObjectInputStream</td>\n<td>ObjectOutputStream</td>\n<td>-</td>\n<td>-</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>打印流</td>\n<td>-</td>\n<td>PrintStream</td>\n<td>-</td>\n<td>PrintWriter</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>数组流</td>\n<td>ByteArrayInputStream</td>\n<td>ByteArrayOutputStream</td>\n<td>CharArrayReader</td>\n<td>CharArrayWriter</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>管道流</td>\n<td>PipeInputStream</td>\n<td>PipedOutputStream</td>\n<td>PipedReader</td>\n<td>PipedWriter</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>字节型缓冲流高效的原因：  <ul>\n<li><code>BufferedInputStream</code>：在该类型中准备了一个缓存数组，存储字节信息，当外界调用 <code>read</code> 方法想获取一个字节的时候，该对象从文件中一次性读取了8192 个字节到数组中，只返回了第一个字节给调用者。将来调用者再次调用 <code>read</code> 方法时，当前对象就不需要再次访问磁盘，只需要从数组中取出字节返回给调用者即可，由于读取的是数组，所以速度非常快。当 8192 个字节全都读取完成之后，再需要读取一个字节，就得让该对象到文件中读取下一个 8192 个字节</li>\n<li><code>BufferedOutputStream</code>：在该类型中准备了一个数组，存储字节信息，当外界调用 <code>write</code><br>方法想写出一个字节的时候，该对象直接将这个字节存储到了自己的数组中，而不刷新到文件中。一直到该数组所有 8192  个位置全都占满，该对象才把这个数组中的所有数据一次性写出到目标文件中。如果最后一次循环没有将数组写满，最终在关闭流对象的时候，也会将该数组中的数据刷新到文件中</li>\n</ul>\n</li>\n<li>字符型缓冲流高效的原因：<ul>\n<li><code>BufferedReader</code> ：每次调用 <code>read</code> 方法，只有第一次从磁盘中读取了 8192个字符，存储到该类型对象的缓冲区数组中，将其中一个返回给调用者，再次调用<br><code>read</code> 方法时，就不需要访问磁盘，直接从缓冲区中拿出一个数据即可，提升了效率  </li>\n<li><code>BufferedWriter</code>：每次调用 <code>write</code> 方法，不会直接将字符刷新到文件中，而是存储到字符数组中，等字符数组写满了，才一次性刷新到文件中，减少了IO次数，提升了效率 <h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2></li>\n</ul>\n</li>\n<li>将数据存储到数据库要不要经过序列化和反序列化?<ul>\n<li>数据库操作直接通过 ORM 框架 或 SQL 将数据与数据库表中的记录映射(mapper)，不涉及 Java 的序列化机制, 如果需要将对象存储为 JSON 格式，可以通过序列化工具（如 Jackson、Gson）将对象转换为 JSON 字符串存储到数据库的对应字段(一般是String )</li>\n</ul>\n</li>\n<li>Java 缓冲区溢出主要是由于向缓冲区写入的数据超过其能够存储的数据量?<ul>\n<li>合理设置缓冲区大小</li>\n<li>控制写入数据量</li>\n</ul>\n</li>\n</ul>\n"},{"banner":"[[pixel-banner-image.png]]","title":"SpringCloud微服务","date":"2025-03-06T05:55:00.000Z","_content":"\n# SpringCloud微服务\n## 微服务概述\n- **核心是Spring框架**，**利用Spring Boot的自动配置**，力图实现最简化的**分布式**应用程序开发\n- Spring Cloud 是基于 Spring Boot 实现的，它不能独立创建工程或模块，更不能脱离 Spring Boot 独立运行。\n- Spring Cloud 本身并不是一个拿来即可用的框架，它是一套**微服务规范**，**共有两代实现**\n\t- **Spring Cloud Netflix** 是 Spring Cloud 的第一代实现，主要由 **Eureka**、**Ribbon**、**Feign**、**Hystrix** 等组件组成。\n\t- **Spring Cloud Alibaba** 是 Spring Cloud 的第二代实现，主要由 **Nacos**、**Sentinel**、**Seata** 等组件组成。\n- [依赖版本适配说明文档](https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E)\n## `RPC`远程调用\n#### 序章\n- RPC（Remote Procedure Call，远程过程调用）\n\t- 是一种分布式系统中的通信方式，允许不同的服务之间像调用本地方法一样调用远程服务\n- HttpClient, OKHttp, RestTemplate 都是gRPC的典型HTTP请求客户端\n#### RPC和HTTP的区别\n- HTTP 是应用层协议，用于传输超文本数据，基于请求-响应模型，常用于 Web 开发、API 调用等场景。\n- RPC 是远程过程调用协议，用于实现分布式系统中不同节点之间的通信，基于方法调用模型，常用于构建面向服务的微服务架构。\n- 在微服务架构中，Feign 和 Dubbo 都是用于实现远程调用的框架，Feign 基于 HTTP 协议，Dubbo 基于 RPC 协议。\n#### 为什么 WebFlux 使用 Netty 而不是 Tomcat？\n\n\t✅ **非阻塞 I/O**，支持高并发请求  \n\t✅ **事件驱动（Reactor 模式）**，更适合 WebSockets、流式处理  \n\t✅ **适用于 API 网关、微服务架构**（如 Spring Cloud Gateway）\n#### 阻塞和非阻塞IO的区别\n\n| 调用方式        | 描述                                                                  | 场景                 | 优缺点             |\n| ----------- | ------------------------------------------------------------------- | ------------------ | --------------- |\n| 同步调用(阻塞IO)  | 客户端发送请求必须等待服务器返回结果, 如: Tomcat -> SpringMVC -> Servlet               | 需要实时响应的业务，如支付、订单查询 | 阻塞影响性能,但是满足业务需求 |\n| 异步调用(非阻塞IO) | 客户端发送请求后，不会阻塞等待，而是立即返回，后续通过回调函数、轮询或者事件通知的方式获取结果。如: WebFlux -> Netty | 高并发、任务队列，如日志收集     | 不等待需要管理回调或轮询    |\n| 单向调用        | 客户端只发送请求，不关心返回值                                                     | 日志上报、监控数据          | 高效,但是无法确认是否调用成功 |\n| 广播调用        | 请求同时发送给多个服务器                                                        | 配置更新、消息通知          | 需要策略控制（超时、重试等）  |\n\n## `Nacos`\n### 序章\n- 为什么要有服务注册和发现Nacos\n\t- 因为如果是单体项目, 模块之间可以用依赖注入的方式互相调用; 但是对于两个已经启动的进程, 必须通过远程调用(Http, gRPC), 但是ip地址是写死的在配置的, 无法集中化管理 \n- Nacos 本身就是一个中心化的服务平台, 客户端依赖通过**封装好的接口与 Nacos 服务端交互**，从而实现服务注册、配置拉取等操作\n- 全称含义: **Dynamic Naming and Configuration Service** 动态命名与配置服务中心\n- 层级结构梳理如下：\n\t- **命名空间（Namespace） \n\t      └─ 分组（Group） \n\t            └─ 服务/配置（Data ID）**\n![17579852910921757985290713.png|700x396](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17579852910921757985290713.png)\n### Eureka和Nacos的区别\n- Eureka相比于Nacos没有配置中心, 但是都有服务注册和发现的功能\n- Eureka和Nacos的ping健康检测机制不一样\n\t- Eureka\n\t\t- 心跳检测：服务实例每 **30s** 发送一次心跳。\n\t\t- 服务清理：服务端每 **60s** 扫描一次，剔除超过 90s 未续约的服务实例\n\t- Nacos\n\t\t- 心跳检测：客户端每 **5s** 上报一次心跳。\n\t\t- 服务清理：服务端每 **30s** 检查，超过 15s 无心跳标记为不健康，30s 内无心跳剔除。\n### 注意\n- 配置`spring.cloud.nacos.discovery`, 就会注册服务到已经启动的 Nacos 注册中心\n- `bootstrap.*` 里的配置会先于 `application.*`  **优先加载**（适用于 Nacos 这种外部配置中心), 如果有同名配置则会被覆盖\n- 尤其要注意的是所有注册到nacos的服务会自动吃到当前空间下的所有配置, 并且可以**动态刷新**, 但是要在类上加注解`@RefreshScope`\n- nacos有**缓存通讯录和ping心跳检测**, 所以即使挂了也不会影响已经运行的服务\n- nacos可以做**负载均衡**, 但是要引入依赖, 默认是轮询\n\n![17412603872831741260386317.png|700x464](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412603872831741260386317.png)\n### 例子\n```yaml\nspring:\n  profiles:\n    active: dev\n  cloud:\n    nacos:\n      # nacos discovery center\n      discovery:\n        server-addr: ${nacos.address}\n        namespace: ${nacos.namespace}\n\n      # nacos config center\n      config:\n        server-addr: ${nacos.address}\n        namespace: ${nacos.namespace}\n\n        # nacos config extension type\n        file-extension: ${nacos.fileExtension}\n\n\t\t# properties inject list\n        extension-configs:\n          - data-id: ${nacos.dataIds[0].one}\n            refresh: true\n          - data-id: ${nacos.dataIds[1].two}\n            refresh: true\n          - data-id: ${nacos.dataIds[2].three}\n            refresh: true\n```\n## `GateWay`\n#### 序章\n- Spring Cloud Gateway是基于**Netty**的异步服务器，允许我们编写一系列过滤器来实现**黑名单**、**权限检查**、**限流**等功能。\n- 通过 Predicate **断言来实现 Route 路由的匹配规则**。简单点说，Predicate 是路由转发的判断条件，请求只有满足了 Predicate 的条件，才会被转发到指定的服务上进行处理。\n#### 核心概念\n\n| 核心概念          | 描述                                                                                     |\n| ------------- | -------------------------------------------------------------------------------------- |\n| Route(路由)     | 网关最基本的模块。它**由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成**。                         |\n| Predicate(断言) | 路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。 |\n| Filter(过滤器)   | 过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对上文的响应进行再处理。                                               |\n![17412623069201741262305954.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412623069201741262305954.png)\n#### 断言匹配规则\n- Route 路由与 Predicate 断言的对应关系为“**一对多**”，**一个路由可以包含多个不同断言**。\n- 一个请求想要转发到指定的路由上，就必须同时匹配路由上的所有断言。\n- **当一个请求同时满足多个路由的断言条件时，请求只会被首个成功匹配的路由转发****。\n- 共有7种匹配断言规则\n![17412433659841741243365893.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412433659841741243365893.png)\n\n| 断言          | 示例                                                                                                  | 说明                                                                                                                    |\n| ----------- | --------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |\n| **Path**    | - Path=/dept/list/**                                                                                | 当请求路径与 /dept/list/** 匹配时，该请求才能被转发到 <http://localhost:8001> 上。                                                         |\n| **Before**  | - Before=2021-10-20T11:47:34.255+08:00[Asia/Shanghai]                                               | 在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之前的请求，才会被转发到 <http://localhost:8001> 上。                                          |\n| **After**   | - After=2021-10-20T11:47:34.255+08:00[Asia/Shanghai]                                                | 在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之后的请求，才会被转发到 <http://localhost:8001> 上。                                          |\n| **Between** | - Between=2021-10-20T15:18:33.226+08:00[Asia/Shanghai],2021-10-20T15:23:33.226+08:00[Asia/Shanghai] | 在 2021 年 10 月 20 日 15 时 18 分 33.226 秒 到 2021 年 10 月 20 日 15 时 23 分 33.226 秒之间的请求，才会被转发到 <http://localhost:8001> 服务器上。 |\n| **Cookie**  | - Cookie=name, c.biancheng.net                                                                      | 携带 Cookie 且 Cookie 的内容为 name=c.biancheng.net 的请求，才会被转发到 <http://localhost:8001> 上。                                    |\n| **Header**  | - Header=X-Request-Id,\\d+                                                                           | 请求头上携带属性 X-Request-Id 且属性值为整数的请求，才会被转发到 <http://localhost:8001> 上。                                                    |\n| **Method**  | - Method=GET                                                                                        | 只有 GET 请求才会被转发到 <http://localhost:8001> 上。                                                                            |\n| Host        | -Host=`**.nihao.org,**.host.com`                                                                    | 请求必须是某些域名                                                                                                             |\n#### 工作流程\n![17579866481091757986646541.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17579866481091757986646541.png)\n- **Gateway Web Handler（网关处理器）**：网关处理器是 Spring Cloud Gateway 的核心组件，负责将请求转发到匹配的路由上。它根据路由配置和断言条件进行路由匹配，选择合适的路由进行请求转发。网关处理器还会依次应用配置的过滤器链，对请求进行处理和转换。\n- **Gateway Filter Chain（网关过滤器链）**：网关过滤器链由一系列过滤器组成，按照配置的顺序依次执行。每个过滤器可以在请求前、请求后或请求发生错误时进行处理。过滤器链的执行过程可以修改请求、响应以及执行其他自定义逻辑。\n## `OpenForeign`\n#### 序言\n- Spring Cloud OpenFeign把**REST请求封装为Java接口方法**，**实现了一种声明式的RPC服务调用与负载均衡组件**\n- 有RequestInterceptor拦截器\n\n| 注解                  | 说明                                                                                                                                            |\n| ------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |\n| @FeignClient        | 该注解用于通知 OpenFeign 组件对 @RequestMapping 注解下的接口进行解析，并通过动态代理的方式产生实现类，实现负载均衡和服务调用                                                                  |\n| @EnableFeignClients | 该注解用于开启 OpenFeign 功能，OpenFeign 会扫描标有 @FeignClient 注解的接口，生成代理并注册到 Spring 容器中,启动类和配置类中有1个就行 **@EnableFeignClients(\"com.train.business.feign\")** |\n#### 解释\n1. 声明式 API：Feign 允许开发者使用简单的注解来定义和描述对远程服务的访问。通过使用注解，开发者可以轻松地指定 URL、HTTP 方法、请求参数、请求头等信息，使得远程调用变得非常直观和易于理解。\n```java\n@FeignClient(name = \"example\", url = \"https://api.example.com\")\n public interface ExampleService {\n     @GetMapping(\"/endpoint\")\n     String getEndpointData();\n }\n```\n2. 集成负载均衡：Feign 集成了 Ribbon 负载均衡器，可以自动实现客户端的负载均衡。它可以根据服务名和可用实例进行动态路由，并分发请求到不同的服务实例上，提高系统的可用性和可伸缩性。\n3. 容错机制：Feign 支持集成 Hystrix 容错框架，可以在调用远程服务时提供容错和断路器功能。当远程服务不可用或响应时间过长时，Feign 可以快速失败并返回预设的响应结果，避免对整个系统造成级联故障\n#### OpenFeign 和 RestTemplate 的区别\n| 特性   | RestTemplate        | OpenFeign           |\n| ---- | ------------------- | ------------------- |\n| 调用请求 | 手动拼URL，模板调用         | 声明式接口调用Rest风格，像本地方法 |\n| 负载均衡 | 需额外配置 @LoadBalanced | 内置支持                |\n| 扩展能力 | 功能单一，需手动封装          | 日志、拦截器、熔断、重试        |\n| 开发效率 | 低，代码冗余              | 高，简洁优雅              |\n#### OpenFeign 和 Dubbo 的区别\n- 定义上\n\t- feign是一个声明式的用于Web 服务, 简化Http Api调用的框架, 适用于构建 RESTful 风格\n\t- Dubbo 是一个分布式服务框架，用于构建面向服务的微服务架构。\n- 通信方式\n\t- feign基于 HTTP 协议，使用 RESTful 风格的接口进行定义和调用。\n\t- Dubbo 默认基于 Netty 作为通信层\n- 生态\n\t- feign天然集成Spring Cloud 生态\n#### 例子\n```java\n/**  \n * 请求是实际服务地址,为了提高效率 \n * 使用feign拦截器要带上请求头token 否则实际服务的拦截器会报错  \n * 注意: 使用PUT请求时,如果max_header_size过小会报400错误  \n * @author cloud_3111  \n * @since 2025-04-15  \n */\n@FeignClient(name = \"memberService\")  // memberService = ip+端口(通过nacos通讯录拿到的)\npublic interface memberFeign {  \n    @PostMapping(\"/member/ticket/save\")  // 完整uri\n    Result save(@RequestBody TicketDTO ticketDTO);  \n  \n}\n```\n#### 负载均衡算法\n1. **轮询算法（Round Robin）**：轮询算法是最简单的负载均衡算法之一。它按照顺序将请求依次分配给每个后端服务器，循环往复。\n2. **加权轮询算法（Weighted Round Robin）**：加权轮询算法在轮询算法的基础上增加了权重的概念。每个后端服务器都被赋予一个权重值，权重值越高，被选中的概率就越大。\n3. **随机算法（Random）**：随机算法将请求随机分配给后端服务器。每个后端服务器有相等的被选中概率，没有考虑服务器的实际负载情况。这种算法简单快速，适用于后端服务器性能相近且无需考虑请求处理能力的场景。\n4. **加权随机算法（Weighted Random）**：加权随机算法在随机算法的基础上引入了权重的概念。每个后端服务器被赋予一个权重值，权重值越高，被选中的概率就越大。这样可以根据服务器的处理能力和性能调整请求的分配比例。\n5. **最少连接算法（Least Connection）**：最少连接算法会根据后端服务器**当前的连接数**来决定请求的分配。负载均衡器会选择当前连接数最少的服务器进行请求分配，以保证后端服务器的负载均衡。这种算法适用于后端服务器的处理能力不同或者请求的处理时间不同的场景。\n6. **哈希算法（Hash）**：哈希算法会根据请求的某个特定属性（如客户端 IP 地址、请求 URL 等）计算哈希值，然后根据哈希值选择相应的后端服务器。\n#### 什么是服务雪崩\n- 一个或者多个服务出现故障，如果这时候，依赖的服务还在不断发起请求，或者重试，那么这些请求的压力会不断在下游堆积，导致下游服务的负载急剧增加。不断累计之下，可能会导致故障的进一步加剧，可能会导致级联式的失败，甚至导致整个系统崩溃，这就叫服务雪崩。\n- 措施：\n\t1. Cluster集群部署多个\n\t2. 限流和熔断：对服务之间的请求进行限流和熔断，以防止过多的请求涌入导致后端服务不可用。\n\t3. 缓存和降级：合理使用缓存来减轻后端服务的负载压力，并在必要时进行服务降级，保证核心功能的可用性\n## `Seata`\n### 序言\n- 微服务下的 **分布式事务** 处理框架\n- Seata的3个核心组件: \n\t- `TC`: **事务协调者 Coordinator**, 维护全局和分支事务的状态, 驱动全局事务提交或回滚 \n\t- `TM`: **事务管理器 Manager**, 定义全局事务的范围, 开启全局事务, 提交或回滚全局事务\n\t- `RM`: **资源管理器 Manager**, 管理分支事务的资源, 与TC交谈以及注册分支事务和报告分支事务的状态, 启动分支事务的提交与回滚\n- `TC` 以 **Seata Server**形式独立部署(8091)，`TM` 和 `RM` 则是以 **Seata Client** 的形式集成在微服务中运行\n- **Seata 在开启全局事务时，会在业务逻辑执行过程中捕获异常来判断是否需要回滚**\n### 分布式事务的4种模式\n#### XA 模式（两阶段提交协议）\n- **标准：** 来自于 X/Open 组织的分布式事务标准。\n- **流程：**\n    1. 第一阶段：**所有资源准备就绪（prepare），但不提交**；\n    2. 第二阶段：**协调器发送提交命令，所有资源正式提交**；\n- **特点：** 强一致性，自动化程度高；\n- **问题：**\n    - 阻塞资源，性能较低；\n    - 数据库需要支持 XA协议\n#### AT 模式（自动事务，Seata默认）\n- **核心：** 利用业务操作前后的快照，自动生成**反向 SQL**来实现回滚；\n- **流程:** \n\t- 每一次全局事务会在seat数据库表**global_table**生成事务记录, 执行完成就删除\n\t- 每一次全局事务会在seat数据库表**branch_table**生成各自操作持久层的**反向SQL**, 执行完成就删除\n\t- **全局事务会生成一个全局事务ID也叫XID, 上游服务通过设置拦截器设置Header把XID传递给下游服务, 以确保全局事务的唯一性**\n\t- **还要保证抛出的异常正确被seata接收到, 不能被自定义的全局异常处理器处理**\n\t- seata的全局锁和分支事务锁都是通过mysql来做的(key,value,expire)\n- **工作机制：**\n    1. 前置操作：在数据库执行 SQL 之前记录快照（undo_log）**；\n    2. 失败回滚： **自动生成并执行反向 SQL；**\n- **特点：**\n    - 无需业务侵入；\n    - 高性能；\n    - 最终一致性；\n- **缺点**\n\t- Seata的反向SQL不支持复杂的嵌套SQL\n\t- Seata的反向SQL不支持批量更新\n- **适用：** 一般业务场景，性能优先。\n- **控制台日志记录**\n\t1. Begin new global transaction + XID  \n\t日志表示开始一个新的全局事务（Global Transaction），并且系统生成了一个唯一的事务ID（XID）来标识这个全局事务。  \n\t2. 发生异常, 被Seata捕获, RM生成分支事务  \n\t在全局事务的执行过程中发生了异常，Seata框架捕获到该异常并进行处理。  \n\t为了处理事务中的错误，RM（Resource Manager，资源管理器）生成了一个分支事务（Branch Transaction），用于处理失败后的恢复操作。  \n\t3. RM handle branch rollback process: xid=XID, branchId=分支事务ID  \n\tRM开始处理分支事务的回滚过程。通过XID和branchId来标识需要回滚的分支事务。  \n\t4. RM处理分支事务, 开始执行回滚操作，并且删除存储分支事务信息的branch_table表中的相关记录。  \n\t5. XID branch 分支事务, undo_log deleted with GlobalFinished  \n\t回滚操作完成后，分支事务的相关undo_log（撤销日志）被删除。  \n\tundo_log的删除意味着该分支事务的操作已经完全撤销，并且全局事务的状态被标记为GlobalFinished，表示事务已结束。  \n\t6. Branch Rollbacked result: PhaseTwo_Rollbacked  \n\t分支事务的回滚已成功完成，系统记录了“第二阶段回滚完成”（PhaseTwo_Rollbacked）。  \n\t在分布式事务中，Seata一般会分为两个阶段：第一阶段是操作执行，第二阶段是根据事务状态来决定是回滚还是提交。  \n\t7. Suspending current transaction, xid = XID  \n\t当前的全局事务被挂起，表示该事务暂时处于非活动状态。通常发生在事务处理结束后，等待最终的结果确认（如提交或回滚）。 \n\t8. Rollback status: Rollbacked  \n\t最终，系统报告了回滚操作的状态为“回滚完成”（Rollbacked）。  \n\t这意味着所有相关的操作都已恢复至初始状态，事务的回滚操作已经成功执行。\n![AT模式示意图|700x418](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412609649171741260964467.png)\n#### TCC 模式（Try Confirm Cancel）\n- **核心：** 显式定义三段操作：\n    1. **Try：** 资源预留；\n    2. **Confirm：** 真正执行业务提交；\n    3. **Cancel：** 回滚预留资源；\n- **优点：** 高性能、强业务控制；\n- **缺点：** 对业务侵入性强，需要开发者自己实现三段逻辑；\n- **适用：** 高并发、高一致性要求的业务，比如支付、库存冻结等。\n#### SAGA 模式（长事务拆分）\n- **核心：** 将大事务拆分为多个本地子事务，按顺序执行，每个子事务都有对应的补偿操作（非回滚）；\n- **流程：**\n    - 正向执行每个子事务；\n    - 若有失败，按相反顺序执行补偿操作；\n- **特点：**\n    - 弱一致性（最终一致）；\n    - 无需锁定资源；\n    - 适合长事务或异步场景（例如订单 + 发货）；\n- **实现：** 可用 Seata Saga 模块实现（基于状态机或注解模式）。\n### 总结\n- 借由**补偿机制**来解决 分布式事务下的 不同服务间 事务回滚不成功的问题(不同服务, 不同数据库)\n- 例子: 在business服务中启动@Transactional事务, 但是通过feign调用了member服务,business服务发生异常, 由于不在同一个服务中, 对member服务的回滚失败\n- **引入分布式事务导致的性能下降**:\n\t- 网络通信开销(后端微服务与 TC 通信、RM 上报、TM 协调)\n\t- 锁竞争导致的时间变长(全局锁、分支事务锁)\n\t- 日志记录(Undo/Redo日志)也需要开销\n- **优化**: \n\t- 增加节点\n\t- 减少使用全局事务\n\t- 选用合适的seata模式\n\t- 分库分表\n\t- 使用缓存\n\t- 使用队列或者开启异步线程处理特定业务\n## `Sentinel`\n### 序章\n- **Sentinel** 是一款面向**分布式微服务架构**的轻量级 **流量控制与熔断降级** 组件\n- 主要以流量为切入点，从**流量控制(限流)**、实时监控、**熔断降级**、系统负载保护等多个维度帮助用户保护服务的稳定性\n- 限流是做在被调用方(前端用户), 熔断是做在调用方(后端服务)\n### 限流算法\n- **静态窗口(默认):也叫计数器**:\n\t- 静态窗口算法**把时间划分成固定大小的窗口**，每个窗口内都有一个**请求计数器**。当请求数达到限制值时，新的请求将被拒绝。窗口在时间到达后重置。\n\t- 面对突发性的**流量突增**（即请求集中的情况), 会拒绝全部请求\n- **动态窗口**：\n\t- 静态的升级, 通过 **滑动窗口(动态时间内)** 动态调整限流阈值，更加灵活应对流量波动。\n\t- **计算开销较大**，每次请求都需要计算滑动窗口内的请求总数。\n\t- 可以使用 **滑动窗口限流** 进行灵活控制，避免了静态窗口带来的流量爆发问题\n- **漏桶算法**：\n\t- **控制每秒的最大访问请求**，**超过阈值的新请求**会加入队列排队等待，队列慢了就丢弃\n\t- **有请求丢失问题, 将突发性请求变均匀**\n- **令牌桶算法**：\n\t- 令牌桶算法与漏桶相似，但其**令牌发放速率是可调的**。请求必须先获取一个令牌才能执行操作，桶内的令牌数量有限(容量可控)。**当令牌数量为零时，新的请求被拒绝**\n\t- **可能出现令牌空缺**，如果令牌速度过慢，短时间内可能会有大量请求被拒绝(**流量突增**)\n- **令牌大闸**：\n\t- 这是对令牌桶算法的扩展，采用了一个令牌池的管理机制，对令牌进行更加精细的控制\n### 限流\n- 概念: 对**URL**或**请求方法**进行 **QPS** 或**并发线程数**的限制\n- 核心原则\n\t- 资源命名：建议为受保护资源自定义名称，避免直接使用请求路径作为资源名\n\t\t- **@SentinelResource(value = \"saveOrder\", blockHandler = \"flowExceptionHandle\")**\n\t- 限流类型：\n\t\t- **整体限流**：对所有请求线程统一进行限流判断。\n\t\t- **条件限流**：在业务代码中对请求线程做条件判断后，再进行限流。\n\t- 降级策略：\n\t\t- 当请求被限流时，可自定义降级处理逻辑，提供一个兜底信息, 确保用户体验不至于完全断裂。\n\t\t- 限流模式（令牌桶或漏桶）Sentinel 使用滑动窗口限流算法来实现限流。\n- 流控效果:\n\t- **快速失败(默认)**\n\t    - 请求一旦超过限制，**立即被拒绝并返回错误**，不做排队处理。\n\t    - 优点：响应迅速，占用资源少。\n\t    - 适用场景：对响应时间敏感的服务。\n\t- **预热（Warm Up）**\n\t    - 用于处理系统冷启动时的流量激增问题。\n\t    - 设置一个预热时长，在该时段内限制**通过速率逐渐上升**，避免服务刚启动就被压垮。\n\t    - 适用场景：需要冷启动保护的服务（如定时任务、大促活动前）。\n\t- **排队等待（Rate Limiter + Queueing）**\n\t    - 请求超过阈值后，不立即拒绝，而是进入队列排队，等待处理。\n\t    - 可配置最大等待时间。\n\t    - 适用场景：允许延迟、但希望**尽量不丢请求**的业务（如订单处理、消息投递）。\n- 流控模式（控制维度）\n\n| 模式                | 说明                                                  |\n| ----------------- | --------------------------------------------------- |\n| **QPS 限流**        | 基于单位时间内的请求次数（Queries Per Second）进行控制。超出后按照所选流控效果处理。 |\n| **并发线程数限流**       | 控制同时处理请求的线程数，适用于资源敏感的场景。                            |\n| **链路限流（链路调用链控制）** | 对指定调用链上的某一资源进行限流，精细控制调用路径下的热点资源。                    |\n| **参数限流（热点参数限流）**  | 根据请求参数的值进行限流，常用于热点资源防护，例如某商品ID请求频繁。                 |\n| **自定义条件限流**       | 可以结合业务标签或特定字段实现动态限流策略。                              |\n### 熔断\n- 概念: **当某个服务出现故障或异常时，服务熔断可以快速隔离该服务，确保系统稳定可用**\n- 核心原则:\n\t- 类型\n\t\t- **慢调用比例**: 如果调用**响应时间**过长，触发熔断\n\t\t- **异常比例**: 根据一定窗口时间出现异常的比例来判断是否熔断\n\t\t- **异常数**: 根据一定窗口时间出现异常的数量来判断是否熔断\n- 注解保护资源 **@SentinelResource(value = \"GET:/api/hello\", fallback = \"fallback\")**\n- **熔断降级**: 其实跟限流降级是一样的, 都是在触发限流和熔断的情况下提供兜底方案, 自定义异常信息或者返回信息\n\n| 参数名                  | 说明                                                                             |\n| -------------------- | ------------------------------------------------------------------------------ |\n| `resource`           | 熔断作用的资源名（建议自定义）                                                                |\n| `grade`              | 熔断类型（上面 0/1/2）                                                                 |\n| `count`              | 根据类型不同表示不同含义：  <br>• 慢调用：阈值响应时间（ms）  <br>• 异常比例：最大异常比例（如 0.3）  <br>• 异常数：最大异常数 |\n| `minRequestAmount`   | 最小请求数，达到该数量后才会触发熔断                                                             |\n| `slowRatioThreshold` | 慢调用比例阈值（仅适用于慢调用类型）                                                             |\n| `timeWindow`         | 熔断时长（单位：秒）                                                                     |\n| `statIntervalMs`     | 统计时间窗口（毫秒）                                                                     |\n### 限流和熔断的区别\n| 对比项            | 限流（Rate Limiting）              | 熔断（Circuit Breaking）           |\n| -------------- | ------------------------------ | ------------------------------ |\n| 目的             | **保护服务**不被突发高流量压垮              | **阻断不稳定下游服务**，防止故障放大           |\n| 适用对象           | 通常是对**入口请求**做控制（如接口访问、用户请求）    | 通常是对**服务间调用**（如微服务 A → B）做保护   |\n| 判断依据           | 请求的 **QPS（每秒请求数）** 或 **并发线程数** | 请求的 **响应时间**、**异常比例、异常数**      |\n| 行为             | 达到阈值时：  <br>拒绝请求 或  排队等待       | 达到阈值时：  <br>快速失败，不再发请求给下游      |\n| 响应模式           | 通常立即返回或等待排队                    | 熔断期间直接走 fallback               |\n| 核心指标           | - QPS  <br>- 并发线程数  <br>- 排队时间 | - 异常比例  <br>- 异常数  <br>- 慢调用比例 |\n| 常见应用           | API 网关限流、用户行为限流、热点接口保护         | 微服务之间的调用、远程调用超时/不稳定保护          |\n| 配置方式（Sentinel） | 流控规则（FlowRule）                 | 熔断规则（DegradeRule）              |\n| 是否允许重试         | 可以（排队模式）                       | 不允许（熔断期直接失败）                   |\n|                |                                |                                |\n### 注意\n- 跟seata一样, 发生异常时被自定义异常处理器处理, 那么就不会被sentinel认为发生了异常(因为响应头的status是200), 也就不会进入降级的逻辑 \n- 当某个服务出现故障或异常时，服务熔断可以快速隔离该服务\n- 当系统出现异常情况时，服务降级会主动屏蔽一些非核心或可选的功能，而只提供最基本的功能,当服务熔断打开时，Hystrix 可以提供一个备用的降级方法或返回默认值，以保证系统继续正常运行。开发者可以定义降级逻辑，例如返回缓存数据、执行简化的逻辑或调用其他可靠的服务\n- 线程池隔离：Hystrix, Sentinel, Feign将每个依赖服务的请求都放在独立的线程池中执行，避免因某个服务的故障导致整个系统的线程资源耗尽。通过线程池隔离，可以提高系统的稳定性和可用性。\n## 总结\n![17412622159201741262214989.png|700x406](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412622159201741262214989.png)![17412624199221741262419741.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412624199221741262419741.png)","source":"_posts/SpringCloud.md","raw":"---\nbanner: \"[[pixel-banner-image.png]]\"\ntitle: SpringCloud微服务\ntags:\n  - SpringCloud\ncategories: 编程\ndate: 2025-03-06T13:55:00\n---\n\n# SpringCloud微服务\n## 微服务概述\n- **核心是Spring框架**，**利用Spring Boot的自动配置**，力图实现最简化的**分布式**应用程序开发\n- Spring Cloud 是基于 Spring Boot 实现的，它不能独立创建工程或模块，更不能脱离 Spring Boot 独立运行。\n- Spring Cloud 本身并不是一个拿来即可用的框架，它是一套**微服务规范**，**共有两代实现**\n\t- **Spring Cloud Netflix** 是 Spring Cloud 的第一代实现，主要由 **Eureka**、**Ribbon**、**Feign**、**Hystrix** 等组件组成。\n\t- **Spring Cloud Alibaba** 是 Spring Cloud 的第二代实现，主要由 **Nacos**、**Sentinel**、**Seata** 等组件组成。\n- [依赖版本适配说明文档](https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E)\n## `RPC`远程调用\n#### 序章\n- RPC（Remote Procedure Call，远程过程调用）\n\t- 是一种分布式系统中的通信方式，允许不同的服务之间像调用本地方法一样调用远程服务\n- HttpClient, OKHttp, RestTemplate 都是gRPC的典型HTTP请求客户端\n#### RPC和HTTP的区别\n- HTTP 是应用层协议，用于传输超文本数据，基于请求-响应模型，常用于 Web 开发、API 调用等场景。\n- RPC 是远程过程调用协议，用于实现分布式系统中不同节点之间的通信，基于方法调用模型，常用于构建面向服务的微服务架构。\n- 在微服务架构中，Feign 和 Dubbo 都是用于实现远程调用的框架，Feign 基于 HTTP 协议，Dubbo 基于 RPC 协议。\n#### 为什么 WebFlux 使用 Netty 而不是 Tomcat？\n\n\t✅ **非阻塞 I/O**，支持高并发请求  \n\t✅ **事件驱动（Reactor 模式）**，更适合 WebSockets、流式处理  \n\t✅ **适用于 API 网关、微服务架构**（如 Spring Cloud Gateway）\n#### 阻塞和非阻塞IO的区别\n\n| 调用方式        | 描述                                                                  | 场景                 | 优缺点             |\n| ----------- | ------------------------------------------------------------------- | ------------------ | --------------- |\n| 同步调用(阻塞IO)  | 客户端发送请求必须等待服务器返回结果, 如: Tomcat -> SpringMVC -> Servlet               | 需要实时响应的业务，如支付、订单查询 | 阻塞影响性能,但是满足业务需求 |\n| 异步调用(非阻塞IO) | 客户端发送请求后，不会阻塞等待，而是立即返回，后续通过回调函数、轮询或者事件通知的方式获取结果。如: WebFlux -> Netty | 高并发、任务队列，如日志收集     | 不等待需要管理回调或轮询    |\n| 单向调用        | 客户端只发送请求，不关心返回值                                                     | 日志上报、监控数据          | 高效,但是无法确认是否调用成功 |\n| 广播调用        | 请求同时发送给多个服务器                                                        | 配置更新、消息通知          | 需要策略控制（超时、重试等）  |\n\n## `Nacos`\n### 序章\n- 为什么要有服务注册和发现Nacos\n\t- 因为如果是单体项目, 模块之间可以用依赖注入的方式互相调用; 但是对于两个已经启动的进程, 必须通过远程调用(Http, gRPC), 但是ip地址是写死的在配置的, 无法集中化管理 \n- Nacos 本身就是一个中心化的服务平台, 客户端依赖通过**封装好的接口与 Nacos 服务端交互**，从而实现服务注册、配置拉取等操作\n- 全称含义: **Dynamic Naming and Configuration Service** 动态命名与配置服务中心\n- 层级结构梳理如下：\n\t- **命名空间（Namespace） \n\t      └─ 分组（Group） \n\t            └─ 服务/配置（Data ID）**\n![17579852910921757985290713.png|700x396](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17579852910921757985290713.png)\n### Eureka和Nacos的区别\n- Eureka相比于Nacos没有配置中心, 但是都有服务注册和发现的功能\n- Eureka和Nacos的ping健康检测机制不一样\n\t- Eureka\n\t\t- 心跳检测：服务实例每 **30s** 发送一次心跳。\n\t\t- 服务清理：服务端每 **60s** 扫描一次，剔除超过 90s 未续约的服务实例\n\t- Nacos\n\t\t- 心跳检测：客户端每 **5s** 上报一次心跳。\n\t\t- 服务清理：服务端每 **30s** 检查，超过 15s 无心跳标记为不健康，30s 内无心跳剔除。\n### 注意\n- 配置`spring.cloud.nacos.discovery`, 就会注册服务到已经启动的 Nacos 注册中心\n- `bootstrap.*` 里的配置会先于 `application.*`  **优先加载**（适用于 Nacos 这种外部配置中心), 如果有同名配置则会被覆盖\n- 尤其要注意的是所有注册到nacos的服务会自动吃到当前空间下的所有配置, 并且可以**动态刷新**, 但是要在类上加注解`@RefreshScope`\n- nacos有**缓存通讯录和ping心跳检测**, 所以即使挂了也不会影响已经运行的服务\n- nacos可以做**负载均衡**, 但是要引入依赖, 默认是轮询\n\n![17412603872831741260386317.png|700x464](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412603872831741260386317.png)\n### 例子\n```yaml\nspring:\n  profiles:\n    active: dev\n  cloud:\n    nacos:\n      # nacos discovery center\n      discovery:\n        server-addr: ${nacos.address}\n        namespace: ${nacos.namespace}\n\n      # nacos config center\n      config:\n        server-addr: ${nacos.address}\n        namespace: ${nacos.namespace}\n\n        # nacos config extension type\n        file-extension: ${nacos.fileExtension}\n\n\t\t# properties inject list\n        extension-configs:\n          - data-id: ${nacos.dataIds[0].one}\n            refresh: true\n          - data-id: ${nacos.dataIds[1].two}\n            refresh: true\n          - data-id: ${nacos.dataIds[2].three}\n            refresh: true\n```\n## `GateWay`\n#### 序章\n- Spring Cloud Gateway是基于**Netty**的异步服务器，允许我们编写一系列过滤器来实现**黑名单**、**权限检查**、**限流**等功能。\n- 通过 Predicate **断言来实现 Route 路由的匹配规则**。简单点说，Predicate 是路由转发的判断条件，请求只有满足了 Predicate 的条件，才会被转发到指定的服务上进行处理。\n#### 核心概念\n\n| 核心概念          | 描述                                                                                     |\n| ------------- | -------------------------------------------------------------------------------------- |\n| Route(路由)     | 网关最基本的模块。它**由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成**。                         |\n| Predicate(断言) | 路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。 |\n| Filter(过滤器)   | 过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对上文的响应进行再处理。                                               |\n![17412623069201741262305954.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412623069201741262305954.png)\n#### 断言匹配规则\n- Route 路由与 Predicate 断言的对应关系为“**一对多**”，**一个路由可以包含多个不同断言**。\n- 一个请求想要转发到指定的路由上，就必须同时匹配路由上的所有断言。\n- **当一个请求同时满足多个路由的断言条件时，请求只会被首个成功匹配的路由转发****。\n- 共有7种匹配断言规则\n![17412433659841741243365893.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412433659841741243365893.png)\n\n| 断言          | 示例                                                                                                  | 说明                                                                                                                    |\n| ----------- | --------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |\n| **Path**    | - Path=/dept/list/**                                                                                | 当请求路径与 /dept/list/** 匹配时，该请求才能被转发到 <http://localhost:8001> 上。                                                         |\n| **Before**  | - Before=2021-10-20T11:47:34.255+08:00[Asia/Shanghai]                                               | 在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之前的请求，才会被转发到 <http://localhost:8001> 上。                                          |\n| **After**   | - After=2021-10-20T11:47:34.255+08:00[Asia/Shanghai]                                                | 在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之后的请求，才会被转发到 <http://localhost:8001> 上。                                          |\n| **Between** | - Between=2021-10-20T15:18:33.226+08:00[Asia/Shanghai],2021-10-20T15:23:33.226+08:00[Asia/Shanghai] | 在 2021 年 10 月 20 日 15 时 18 分 33.226 秒 到 2021 年 10 月 20 日 15 时 23 分 33.226 秒之间的请求，才会被转发到 <http://localhost:8001> 服务器上。 |\n| **Cookie**  | - Cookie=name, c.biancheng.net                                                                      | 携带 Cookie 且 Cookie 的内容为 name=c.biancheng.net 的请求，才会被转发到 <http://localhost:8001> 上。                                    |\n| **Header**  | - Header=X-Request-Id,\\d+                                                                           | 请求头上携带属性 X-Request-Id 且属性值为整数的请求，才会被转发到 <http://localhost:8001> 上。                                                    |\n| **Method**  | - Method=GET                                                                                        | 只有 GET 请求才会被转发到 <http://localhost:8001> 上。                                                                            |\n| Host        | -Host=`**.nihao.org,**.host.com`                                                                    | 请求必须是某些域名                                                                                                             |\n#### 工作流程\n![17579866481091757986646541.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17579866481091757986646541.png)\n- **Gateway Web Handler（网关处理器）**：网关处理器是 Spring Cloud Gateway 的核心组件，负责将请求转发到匹配的路由上。它根据路由配置和断言条件进行路由匹配，选择合适的路由进行请求转发。网关处理器还会依次应用配置的过滤器链，对请求进行处理和转换。\n- **Gateway Filter Chain（网关过滤器链）**：网关过滤器链由一系列过滤器组成，按照配置的顺序依次执行。每个过滤器可以在请求前、请求后或请求发生错误时进行处理。过滤器链的执行过程可以修改请求、响应以及执行其他自定义逻辑。\n## `OpenForeign`\n#### 序言\n- Spring Cloud OpenFeign把**REST请求封装为Java接口方法**，**实现了一种声明式的RPC服务调用与负载均衡组件**\n- 有RequestInterceptor拦截器\n\n| 注解                  | 说明                                                                                                                                            |\n| ------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |\n| @FeignClient        | 该注解用于通知 OpenFeign 组件对 @RequestMapping 注解下的接口进行解析，并通过动态代理的方式产生实现类，实现负载均衡和服务调用                                                                  |\n| @EnableFeignClients | 该注解用于开启 OpenFeign 功能，OpenFeign 会扫描标有 @FeignClient 注解的接口，生成代理并注册到 Spring 容器中,启动类和配置类中有1个就行 **@EnableFeignClients(\"com.train.business.feign\")** |\n#### 解释\n1. 声明式 API：Feign 允许开发者使用简单的注解来定义和描述对远程服务的访问。通过使用注解，开发者可以轻松地指定 URL、HTTP 方法、请求参数、请求头等信息，使得远程调用变得非常直观和易于理解。\n```java\n@FeignClient(name = \"example\", url = \"https://api.example.com\")\n public interface ExampleService {\n     @GetMapping(\"/endpoint\")\n     String getEndpointData();\n }\n```\n2. 集成负载均衡：Feign 集成了 Ribbon 负载均衡器，可以自动实现客户端的负载均衡。它可以根据服务名和可用实例进行动态路由，并分发请求到不同的服务实例上，提高系统的可用性和可伸缩性。\n3. 容错机制：Feign 支持集成 Hystrix 容错框架，可以在调用远程服务时提供容错和断路器功能。当远程服务不可用或响应时间过长时，Feign 可以快速失败并返回预设的响应结果，避免对整个系统造成级联故障\n#### OpenFeign 和 RestTemplate 的区别\n| 特性   | RestTemplate        | OpenFeign           |\n| ---- | ------------------- | ------------------- |\n| 调用请求 | 手动拼URL，模板调用         | 声明式接口调用Rest风格，像本地方法 |\n| 负载均衡 | 需额外配置 @LoadBalanced | 内置支持                |\n| 扩展能力 | 功能单一，需手动封装          | 日志、拦截器、熔断、重试        |\n| 开发效率 | 低，代码冗余              | 高，简洁优雅              |\n#### OpenFeign 和 Dubbo 的区别\n- 定义上\n\t- feign是一个声明式的用于Web 服务, 简化Http Api调用的框架, 适用于构建 RESTful 风格\n\t- Dubbo 是一个分布式服务框架，用于构建面向服务的微服务架构。\n- 通信方式\n\t- feign基于 HTTP 协议，使用 RESTful 风格的接口进行定义和调用。\n\t- Dubbo 默认基于 Netty 作为通信层\n- 生态\n\t- feign天然集成Spring Cloud 生态\n#### 例子\n```java\n/**  \n * 请求是实际服务地址,为了提高效率 \n * 使用feign拦截器要带上请求头token 否则实际服务的拦截器会报错  \n * 注意: 使用PUT请求时,如果max_header_size过小会报400错误  \n * @author cloud_3111  \n * @since 2025-04-15  \n */\n@FeignClient(name = \"memberService\")  // memberService = ip+端口(通过nacos通讯录拿到的)\npublic interface memberFeign {  \n    @PostMapping(\"/member/ticket/save\")  // 完整uri\n    Result save(@RequestBody TicketDTO ticketDTO);  \n  \n}\n```\n#### 负载均衡算法\n1. **轮询算法（Round Robin）**：轮询算法是最简单的负载均衡算法之一。它按照顺序将请求依次分配给每个后端服务器，循环往复。\n2. **加权轮询算法（Weighted Round Robin）**：加权轮询算法在轮询算法的基础上增加了权重的概念。每个后端服务器都被赋予一个权重值，权重值越高，被选中的概率就越大。\n3. **随机算法（Random）**：随机算法将请求随机分配给后端服务器。每个后端服务器有相等的被选中概率，没有考虑服务器的实际负载情况。这种算法简单快速，适用于后端服务器性能相近且无需考虑请求处理能力的场景。\n4. **加权随机算法（Weighted Random）**：加权随机算法在随机算法的基础上引入了权重的概念。每个后端服务器被赋予一个权重值，权重值越高，被选中的概率就越大。这样可以根据服务器的处理能力和性能调整请求的分配比例。\n5. **最少连接算法（Least Connection）**：最少连接算法会根据后端服务器**当前的连接数**来决定请求的分配。负载均衡器会选择当前连接数最少的服务器进行请求分配，以保证后端服务器的负载均衡。这种算法适用于后端服务器的处理能力不同或者请求的处理时间不同的场景。\n6. **哈希算法（Hash）**：哈希算法会根据请求的某个特定属性（如客户端 IP 地址、请求 URL 等）计算哈希值，然后根据哈希值选择相应的后端服务器。\n#### 什么是服务雪崩\n- 一个或者多个服务出现故障，如果这时候，依赖的服务还在不断发起请求，或者重试，那么这些请求的压力会不断在下游堆积，导致下游服务的负载急剧增加。不断累计之下，可能会导致故障的进一步加剧，可能会导致级联式的失败，甚至导致整个系统崩溃，这就叫服务雪崩。\n- 措施：\n\t1. Cluster集群部署多个\n\t2. 限流和熔断：对服务之间的请求进行限流和熔断，以防止过多的请求涌入导致后端服务不可用。\n\t3. 缓存和降级：合理使用缓存来减轻后端服务的负载压力，并在必要时进行服务降级，保证核心功能的可用性\n## `Seata`\n### 序言\n- 微服务下的 **分布式事务** 处理框架\n- Seata的3个核心组件: \n\t- `TC`: **事务协调者 Coordinator**, 维护全局和分支事务的状态, 驱动全局事务提交或回滚 \n\t- `TM`: **事务管理器 Manager**, 定义全局事务的范围, 开启全局事务, 提交或回滚全局事务\n\t- `RM`: **资源管理器 Manager**, 管理分支事务的资源, 与TC交谈以及注册分支事务和报告分支事务的状态, 启动分支事务的提交与回滚\n- `TC` 以 **Seata Server**形式独立部署(8091)，`TM` 和 `RM` 则是以 **Seata Client** 的形式集成在微服务中运行\n- **Seata 在开启全局事务时，会在业务逻辑执行过程中捕获异常来判断是否需要回滚**\n### 分布式事务的4种模式\n#### XA 模式（两阶段提交协议）\n- **标准：** 来自于 X/Open 组织的分布式事务标准。\n- **流程：**\n    1. 第一阶段：**所有资源准备就绪（prepare），但不提交**；\n    2. 第二阶段：**协调器发送提交命令，所有资源正式提交**；\n- **特点：** 强一致性，自动化程度高；\n- **问题：**\n    - 阻塞资源，性能较低；\n    - 数据库需要支持 XA协议\n#### AT 模式（自动事务，Seata默认）\n- **核心：** 利用业务操作前后的快照，自动生成**反向 SQL**来实现回滚；\n- **流程:** \n\t- 每一次全局事务会在seat数据库表**global_table**生成事务记录, 执行完成就删除\n\t- 每一次全局事务会在seat数据库表**branch_table**生成各自操作持久层的**反向SQL**, 执行完成就删除\n\t- **全局事务会生成一个全局事务ID也叫XID, 上游服务通过设置拦截器设置Header把XID传递给下游服务, 以确保全局事务的唯一性**\n\t- **还要保证抛出的异常正确被seata接收到, 不能被自定义的全局异常处理器处理**\n\t- seata的全局锁和分支事务锁都是通过mysql来做的(key,value,expire)\n- **工作机制：**\n    1. 前置操作：在数据库执行 SQL 之前记录快照（undo_log）**；\n    2. 失败回滚： **自动生成并执行反向 SQL；**\n- **特点：**\n    - 无需业务侵入；\n    - 高性能；\n    - 最终一致性；\n- **缺点**\n\t- Seata的反向SQL不支持复杂的嵌套SQL\n\t- Seata的反向SQL不支持批量更新\n- **适用：** 一般业务场景，性能优先。\n- **控制台日志记录**\n\t1. Begin new global transaction + XID  \n\t日志表示开始一个新的全局事务（Global Transaction），并且系统生成了一个唯一的事务ID（XID）来标识这个全局事务。  \n\t2. 发生异常, 被Seata捕获, RM生成分支事务  \n\t在全局事务的执行过程中发生了异常，Seata框架捕获到该异常并进行处理。  \n\t为了处理事务中的错误，RM（Resource Manager，资源管理器）生成了一个分支事务（Branch Transaction），用于处理失败后的恢复操作。  \n\t3. RM handle branch rollback process: xid=XID, branchId=分支事务ID  \n\tRM开始处理分支事务的回滚过程。通过XID和branchId来标识需要回滚的分支事务。  \n\t4. RM处理分支事务, 开始执行回滚操作，并且删除存储分支事务信息的branch_table表中的相关记录。  \n\t5. XID branch 分支事务, undo_log deleted with GlobalFinished  \n\t回滚操作完成后，分支事务的相关undo_log（撤销日志）被删除。  \n\tundo_log的删除意味着该分支事务的操作已经完全撤销，并且全局事务的状态被标记为GlobalFinished，表示事务已结束。  \n\t6. Branch Rollbacked result: PhaseTwo_Rollbacked  \n\t分支事务的回滚已成功完成，系统记录了“第二阶段回滚完成”（PhaseTwo_Rollbacked）。  \n\t在分布式事务中，Seata一般会分为两个阶段：第一阶段是操作执行，第二阶段是根据事务状态来决定是回滚还是提交。  \n\t7. Suspending current transaction, xid = XID  \n\t当前的全局事务被挂起，表示该事务暂时处于非活动状态。通常发生在事务处理结束后，等待最终的结果确认（如提交或回滚）。 \n\t8. Rollback status: Rollbacked  \n\t最终，系统报告了回滚操作的状态为“回滚完成”（Rollbacked）。  \n\t这意味着所有相关的操作都已恢复至初始状态，事务的回滚操作已经成功执行。\n![AT模式示意图|700x418](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412609649171741260964467.png)\n#### TCC 模式（Try Confirm Cancel）\n- **核心：** 显式定义三段操作：\n    1. **Try：** 资源预留；\n    2. **Confirm：** 真正执行业务提交；\n    3. **Cancel：** 回滚预留资源；\n- **优点：** 高性能、强业务控制；\n- **缺点：** 对业务侵入性强，需要开发者自己实现三段逻辑；\n- **适用：** 高并发、高一致性要求的业务，比如支付、库存冻结等。\n#### SAGA 模式（长事务拆分）\n- **核心：** 将大事务拆分为多个本地子事务，按顺序执行，每个子事务都有对应的补偿操作（非回滚）；\n- **流程：**\n    - 正向执行每个子事务；\n    - 若有失败，按相反顺序执行补偿操作；\n- **特点：**\n    - 弱一致性（最终一致）；\n    - 无需锁定资源；\n    - 适合长事务或异步场景（例如订单 + 发货）；\n- **实现：** 可用 Seata Saga 模块实现（基于状态机或注解模式）。\n### 总结\n- 借由**补偿机制**来解决 分布式事务下的 不同服务间 事务回滚不成功的问题(不同服务, 不同数据库)\n- 例子: 在business服务中启动@Transactional事务, 但是通过feign调用了member服务,business服务发生异常, 由于不在同一个服务中, 对member服务的回滚失败\n- **引入分布式事务导致的性能下降**:\n\t- 网络通信开销(后端微服务与 TC 通信、RM 上报、TM 协调)\n\t- 锁竞争导致的时间变长(全局锁、分支事务锁)\n\t- 日志记录(Undo/Redo日志)也需要开销\n- **优化**: \n\t- 增加节点\n\t- 减少使用全局事务\n\t- 选用合适的seata模式\n\t- 分库分表\n\t- 使用缓存\n\t- 使用队列或者开启异步线程处理特定业务\n## `Sentinel`\n### 序章\n- **Sentinel** 是一款面向**分布式微服务架构**的轻量级 **流量控制与熔断降级** 组件\n- 主要以流量为切入点，从**流量控制(限流)**、实时监控、**熔断降级**、系统负载保护等多个维度帮助用户保护服务的稳定性\n- 限流是做在被调用方(前端用户), 熔断是做在调用方(后端服务)\n### 限流算法\n- **静态窗口(默认):也叫计数器**:\n\t- 静态窗口算法**把时间划分成固定大小的窗口**，每个窗口内都有一个**请求计数器**。当请求数达到限制值时，新的请求将被拒绝。窗口在时间到达后重置。\n\t- 面对突发性的**流量突增**（即请求集中的情况), 会拒绝全部请求\n- **动态窗口**：\n\t- 静态的升级, 通过 **滑动窗口(动态时间内)** 动态调整限流阈值，更加灵活应对流量波动。\n\t- **计算开销较大**，每次请求都需要计算滑动窗口内的请求总数。\n\t- 可以使用 **滑动窗口限流** 进行灵活控制，避免了静态窗口带来的流量爆发问题\n- **漏桶算法**：\n\t- **控制每秒的最大访问请求**，**超过阈值的新请求**会加入队列排队等待，队列慢了就丢弃\n\t- **有请求丢失问题, 将突发性请求变均匀**\n- **令牌桶算法**：\n\t- 令牌桶算法与漏桶相似，但其**令牌发放速率是可调的**。请求必须先获取一个令牌才能执行操作，桶内的令牌数量有限(容量可控)。**当令牌数量为零时，新的请求被拒绝**\n\t- **可能出现令牌空缺**，如果令牌速度过慢，短时间内可能会有大量请求被拒绝(**流量突增**)\n- **令牌大闸**：\n\t- 这是对令牌桶算法的扩展，采用了一个令牌池的管理机制，对令牌进行更加精细的控制\n### 限流\n- 概念: 对**URL**或**请求方法**进行 **QPS** 或**并发线程数**的限制\n- 核心原则\n\t- 资源命名：建议为受保护资源自定义名称，避免直接使用请求路径作为资源名\n\t\t- **@SentinelResource(value = \"saveOrder\", blockHandler = \"flowExceptionHandle\")**\n\t- 限流类型：\n\t\t- **整体限流**：对所有请求线程统一进行限流判断。\n\t\t- **条件限流**：在业务代码中对请求线程做条件判断后，再进行限流。\n\t- 降级策略：\n\t\t- 当请求被限流时，可自定义降级处理逻辑，提供一个兜底信息, 确保用户体验不至于完全断裂。\n\t\t- 限流模式（令牌桶或漏桶）Sentinel 使用滑动窗口限流算法来实现限流。\n- 流控效果:\n\t- **快速失败(默认)**\n\t    - 请求一旦超过限制，**立即被拒绝并返回错误**，不做排队处理。\n\t    - 优点：响应迅速，占用资源少。\n\t    - 适用场景：对响应时间敏感的服务。\n\t- **预热（Warm Up）**\n\t    - 用于处理系统冷启动时的流量激增问题。\n\t    - 设置一个预热时长，在该时段内限制**通过速率逐渐上升**，避免服务刚启动就被压垮。\n\t    - 适用场景：需要冷启动保护的服务（如定时任务、大促活动前）。\n\t- **排队等待（Rate Limiter + Queueing）**\n\t    - 请求超过阈值后，不立即拒绝，而是进入队列排队，等待处理。\n\t    - 可配置最大等待时间。\n\t    - 适用场景：允许延迟、但希望**尽量不丢请求**的业务（如订单处理、消息投递）。\n- 流控模式（控制维度）\n\n| 模式                | 说明                                                  |\n| ----------------- | --------------------------------------------------- |\n| **QPS 限流**        | 基于单位时间内的请求次数（Queries Per Second）进行控制。超出后按照所选流控效果处理。 |\n| **并发线程数限流**       | 控制同时处理请求的线程数，适用于资源敏感的场景。                            |\n| **链路限流（链路调用链控制）** | 对指定调用链上的某一资源进行限流，精细控制调用路径下的热点资源。                    |\n| **参数限流（热点参数限流）**  | 根据请求参数的值进行限流，常用于热点资源防护，例如某商品ID请求频繁。                 |\n| **自定义条件限流**       | 可以结合业务标签或特定字段实现动态限流策略。                              |\n### 熔断\n- 概念: **当某个服务出现故障或异常时，服务熔断可以快速隔离该服务，确保系统稳定可用**\n- 核心原则:\n\t- 类型\n\t\t- **慢调用比例**: 如果调用**响应时间**过长，触发熔断\n\t\t- **异常比例**: 根据一定窗口时间出现异常的比例来判断是否熔断\n\t\t- **异常数**: 根据一定窗口时间出现异常的数量来判断是否熔断\n- 注解保护资源 **@SentinelResource(value = \"GET:/api/hello\", fallback = \"fallback\")**\n- **熔断降级**: 其实跟限流降级是一样的, 都是在触发限流和熔断的情况下提供兜底方案, 自定义异常信息或者返回信息\n\n| 参数名                  | 说明                                                                             |\n| -------------------- | ------------------------------------------------------------------------------ |\n| `resource`           | 熔断作用的资源名（建议自定义）                                                                |\n| `grade`              | 熔断类型（上面 0/1/2）                                                                 |\n| `count`              | 根据类型不同表示不同含义：  <br>• 慢调用：阈值响应时间（ms）  <br>• 异常比例：最大异常比例（如 0.3）  <br>• 异常数：最大异常数 |\n| `minRequestAmount`   | 最小请求数，达到该数量后才会触发熔断                                                             |\n| `slowRatioThreshold` | 慢调用比例阈值（仅适用于慢调用类型）                                                             |\n| `timeWindow`         | 熔断时长（单位：秒）                                                                     |\n| `statIntervalMs`     | 统计时间窗口（毫秒）                                                                     |\n### 限流和熔断的区别\n| 对比项            | 限流（Rate Limiting）              | 熔断（Circuit Breaking）           |\n| -------------- | ------------------------------ | ------------------------------ |\n| 目的             | **保护服务**不被突发高流量压垮              | **阻断不稳定下游服务**，防止故障放大           |\n| 适用对象           | 通常是对**入口请求**做控制（如接口访问、用户请求）    | 通常是对**服务间调用**（如微服务 A → B）做保护   |\n| 判断依据           | 请求的 **QPS（每秒请求数）** 或 **并发线程数** | 请求的 **响应时间**、**异常比例、异常数**      |\n| 行为             | 达到阈值时：  <br>拒绝请求 或  排队等待       | 达到阈值时：  <br>快速失败，不再发请求给下游      |\n| 响应模式           | 通常立即返回或等待排队                    | 熔断期间直接走 fallback               |\n| 核心指标           | - QPS  <br>- 并发线程数  <br>- 排队时间 | - 异常比例  <br>- 异常数  <br>- 慢调用比例 |\n| 常见应用           | API 网关限流、用户行为限流、热点接口保护         | 微服务之间的调用、远程调用超时/不稳定保护          |\n| 配置方式（Sentinel） | 流控规则（FlowRule）                 | 熔断规则（DegradeRule）              |\n| 是否允许重试         | 可以（排队模式）                       | 不允许（熔断期直接失败）                   |\n|                |                                |                                |\n### 注意\n- 跟seata一样, 发生异常时被自定义异常处理器处理, 那么就不会被sentinel认为发生了异常(因为响应头的status是200), 也就不会进入降级的逻辑 \n- 当某个服务出现故障或异常时，服务熔断可以快速隔离该服务\n- 当系统出现异常情况时，服务降级会主动屏蔽一些非核心或可选的功能，而只提供最基本的功能,当服务熔断打开时，Hystrix 可以提供一个备用的降级方法或返回默认值，以保证系统继续正常运行。开发者可以定义降级逻辑，例如返回缓存数据、执行简化的逻辑或调用其他可靠的服务\n- 线程池隔离：Hystrix, Sentinel, Feign将每个依赖服务的请求都放在独立的线程池中执行，避免因某个服务的故障导致整个系统的线程资源耗尽。通过线程池隔离，可以提高系统的稳定性和可用性。\n## 总结\n![17412622159201741262214989.png|700x406](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412622159201741262214989.png)![17412624199221741262419741.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412624199221741262419741.png)","slug":"SpringCloud","published":1,"updated":"2025-09-16T03:18:42.849Z","comments":1,"layout":"post","photos":[],"_id":"cmfw4z09n000puomw75rkaxnr","content":"<h1 id=\"SpringCloud微服务\"><a href=\"#SpringCloud微服务\" class=\"headerlink\" title=\"SpringCloud微服务\"></a>SpringCloud微服务</h1><h2 id=\"微服务概述\"><a href=\"#微服务概述\" class=\"headerlink\" title=\"微服务概述\"></a>微服务概述</h2><ul>\n<li><strong>核心是Spring框架</strong>，<strong>利用Spring Boot的自动配置</strong>，力图实现最简化的<strong>分布式</strong>应用程序开发</li>\n<li>Spring Cloud 是基于 Spring Boot 实现的，它不能独立创建工程或模块，更不能脱离 Spring Boot 独立运行。</li>\n<li>Spring Cloud 本身并不是一个拿来即可用的框架，它是一套<strong>微服务规范</strong>，<strong>共有两代实现</strong><ul>\n<li><strong>Spring Cloud Netflix</strong> 是 Spring Cloud 的第一代实现，主要由 <strong>Eureka</strong>、<strong>Ribbon</strong>、<strong>Feign</strong>、<strong>Hystrix</strong> 等组件组成。</li>\n<li><strong>Spring Cloud Alibaba</strong> 是 Spring Cloud 的第二代实现，主要由 <strong>Nacos</strong>、<strong>Sentinel</strong>、<strong>Seata</strong> 等组件组成。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E\">依赖版本适配说明文档</a><h2 id=\"RPC远程调用\"><a href=\"#RPC远程调用\" class=\"headerlink\" title=\"RPC远程调用\"></a><code>RPC</code>远程调用</h2><h4 id=\"序章\"><a href=\"#序章\" class=\"headerlink\" title=\"序章\"></a>序章</h4></li>\n<li>RPC（Remote Procedure Call，远程过程调用）<ul>\n<li>是一种分布式系统中的通信方式，允许不同的服务之间像调用本地方法一样调用远程服务</li>\n</ul>\n</li>\n<li>HttpClient, OKHttp, RestTemplate 都是gRPC的典型HTTP请求客户端<h4 id=\"RPC和HTTP的区别\"><a href=\"#RPC和HTTP的区别\" class=\"headerlink\" title=\"RPC和HTTP的区别\"></a>RPC和HTTP的区别</h4></li>\n<li>HTTP 是应用层协议，用于传输超文本数据，基于请求-响应模型，常用于 Web 开发、API 调用等场景。</li>\n<li>RPC 是远程过程调用协议，用于实现分布式系统中不同节点之间的通信，基于方法调用模型，常用于构建面向服务的微服务架构。</li>\n<li><p>在微服务架构中，Feign 和 Dubbo 都是用于实现远程调用的框架，Feign 基于 HTTP 协议，Dubbo 基于 RPC 协议。</p>\n<h4 id=\"为什么-WebFlux-使用-Netty-而不是-Tomcat？\"><a href=\"#为什么-WebFlux-使用-Netty-而不是-Tomcat？\" class=\"headerlink\" title=\"为什么 WebFlux 使用 Netty 而不是 Tomcat？\"></a>为什么 WebFlux 使用 Netty 而不是 Tomcat？</h4><p>  ✅ <strong>非阻塞 I/O</strong>，支持高并发请求<br>  ✅ <strong>事件驱动（Reactor 模式）</strong>，更适合 WebSockets、流式处理<br>  ✅ <strong>适用于 API 网关、微服务架构</strong>（如 Spring Cloud Gateway）</p>\n<h4 id=\"阻塞和非阻塞IO的区别\"><a href=\"#阻塞和非阻塞IO的区别\" class=\"headerlink\" title=\"阻塞和非阻塞IO的区别\"></a>阻塞和非阻塞IO的区别</h4></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>调用方式</th>\n<th>描述</th>\n<th>场景</th>\n<th>优缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同步调用(阻塞IO)</td>\n<td>客户端发送请求必须等待服务器返回结果, 如: Tomcat -&gt; SpringMVC -&gt; Servlet</td>\n<td>需要实时响应的业务，如支付、订单查询</td>\n<td>阻塞影响性能,但是满足业务需求</td>\n</tr>\n<tr>\n<td>异步调用(非阻塞IO)</td>\n<td>客户端发送请求后，不会阻塞等待，而是立即返回，后续通过回调函数、轮询或者事件通知的方式获取结果。如: WebFlux -&gt; Netty</td>\n<td>高并发、任务队列，如日志收集</td>\n<td>不等待需要管理回调或轮询</td>\n</tr>\n<tr>\n<td>单向调用</td>\n<td>客户端只发送请求，不关心返回值</td>\n<td>日志上报、监控数据</td>\n<td>高效,但是无法确认是否调用成功</td>\n</tr>\n<tr>\n<td>广播调用</td>\n<td>请求同时发送给多个服务器</td>\n<td>配置更新、消息通知</td>\n<td>需要策略控制（超时、重试等）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"Nacos\"><a href=\"#Nacos\" class=\"headerlink\" title=\"Nacos\"></a><code>Nacos</code></h2><h3 id=\"序章-1\"><a href=\"#序章-1\" class=\"headerlink\" title=\"序章\"></a>序章</h3><ul>\n<li>为什么要有服务注册和发现Nacos<ul>\n<li>因为如果是单体项目, 模块之间可以用依赖注入的方式互相调用; 但是对于两个已经启动的进程, 必须通过远程调用(Http, gRPC), 但是ip地址是写死的在配置的, 无法集中化管理 </li>\n</ul>\n</li>\n<li>Nacos 本身就是一个中心化的服务平台, 客户端依赖通过<strong>封装好的接口与 Nacos 服务端交互</strong>，从而实现服务注册、配置拉取等操作</li>\n<li>全称含义: <strong>Dynamic Naming and Configuration Service</strong> 动态命名与配置服务中心</li>\n<li>层级结构梳理如下：<ul>\n<li>**命名空间（Namespace） <pre><code>└─ 分组（Group） \n      └─ 服务/配置（Data ID）**\n</code></pre><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17579852910921757985290713.png\" alt=\"17579852910921757985290713.png|700x396\"><h3 id=\"Eureka和Nacos的区别\"><a href=\"#Eureka和Nacos的区别\" class=\"headerlink\" title=\"Eureka和Nacos的区别\"></a>Eureka和Nacos的区别</h3></li>\n</ul>\n</li>\n<li>Eureka相比于Nacos没有配置中心, 但是都有服务注册和发现的功能</li>\n<li>Eureka和Nacos的ping健康检测机制不一样<ul>\n<li>Eureka<ul>\n<li>心跳检测：服务实例每 <strong>30s</strong> 发送一次心跳。</li>\n<li>服务清理：服务端每 <strong>60s</strong> 扫描一次，剔除超过 90s 未续约的服务实例</li>\n</ul>\n</li>\n<li>Nacos<ul>\n<li>心跳检测：客户端每 <strong>5s</strong> 上报一次心跳。</li>\n<li>服务清理：服务端每 <strong>30s</strong> 检查，超过 15s 无心跳标记为不健康，30s 内无心跳剔除。<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>配置<code>spring.cloud.nacos.discovery</code>, 就会注册服务到已经启动的 Nacos 注册中心</li>\n<li><code>bootstrap.*</code> 里的配置会先于 <code>application.*</code>  <strong>优先加载</strong>（适用于 Nacos 这种外部配置中心), 如果有同名配置则会被覆盖</li>\n<li>尤其要注意的是所有注册到nacos的服务会自动吃到当前空间下的所有配置, 并且可以<strong>动态刷新</strong>, 但是要在类上加注解<code>@RefreshScope</code></li>\n<li>nacos有<strong>缓存通讯录和ping心跳检测</strong>, 所以即使挂了也不会影响已经运行的服务</li>\n<li>nacos可以做<strong>负载均衡</strong>, 但是要引入依赖, 默认是轮询</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412603872831741260386317.png\" alt=\"17412603872831741260386317.png|700x464\"></p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">profiles:</span></span><br><span class=\"line\">    <span class=\"attr\">active:</span> <span class=\"string\">dev</span></span><br><span class=\"line\">  <span class=\"attr\">cloud:</span></span><br><span class=\"line\">    <span class=\"attr\">nacos:</span></span><br><span class=\"line\">      <span class=\"comment\"># nacos discovery center</span></span><br><span class=\"line\">      <span class=\"attr\">discovery:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">$&#123;nacos.address&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">$&#123;nacos.namespace&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># nacos config center</span></span><br><span class=\"line\">      <span class=\"attr\">config:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">$&#123;nacos.address&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">$&#123;nacos.namespace&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># nacos config extension type</span></span><br><span class=\"line\">        <span class=\"attr\">file-extension:</span> <span class=\"string\">$&#123;nacos.fileExtension&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># properties inject list</span></span><br><span class=\"line\">        <span class=\"attr\">extension-configs:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">data-id:</span> <span class=\"string\">$&#123;nacos.dataIds[0].one&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">data-id:</span> <span class=\"string\">$&#123;nacos.dataIds[1].two&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">data-id:</span> <span class=\"string\">$&#123;nacos.dataIds[2].three&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"GateWay\"><a href=\"#GateWay\" class=\"headerlink\" title=\"GateWay\"></a><code>GateWay</code></h2><h4 id=\"序章-2\"><a href=\"#序章-2\" class=\"headerlink\" title=\"序章\"></a>序章</h4><ul>\n<li>Spring Cloud Gateway是基于<strong>Netty</strong>的异步服务器，允许我们编写一系列过滤器来实现<strong>黑名单</strong>、<strong>权限检查</strong>、<strong>限流</strong>等功能。</li>\n<li>通过 Predicate <strong>断言来实现 Route 路由的匹配规则</strong>。简单点说，Predicate 是路由转发的判断条件，请求只有满足了 Predicate 的条件，才会被转发到指定的服务上进行处理。<h4 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>核心概念</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Route(路由)</td>\n<td>网关最基本的模块。它<strong>由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成</strong>。</td>\n</tr>\n<tr>\n<td>Predicate(断言)</td>\n<td>路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。</td>\n</tr>\n<tr>\n<td>Filter(过滤器)</td>\n<td>过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对上文的响应进行再处理。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412623069201741262305954.png\" alt=\"17412623069201741262305954.png\"></p>\n<h4 id=\"断言匹配规则\"><a href=\"#断言匹配规则\" class=\"headerlink\" title=\"断言匹配规则\"></a>断言匹配规则</h4><ul>\n<li>Route 路由与 Predicate 断言的对应关系为“<strong>一对多</strong>”，<strong>一个路由可以包含多个不同断言</strong>。</li>\n<li>一个请求想要转发到指定的路由上，就必须同时匹配路由上的所有断言。</li>\n<li><strong>当一个请求同时满足多个路由的断言条件时，请求只会被首个成功匹配的路由转发**</strong>。</li>\n<li>共有7种匹配断言规则<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412433659841741243365893.png\" alt=\"17412433659841741243365893.png\"></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>断言</th>\n<th>示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Path</strong></td>\n<td>- Path=/dept/list/**</td>\n<td>当请求路径与 /dept/list/** 匹配时，该请求才能被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 上。</td>\n</tr>\n<tr>\n<td><strong>Before</strong></td>\n<td>- Before=2021-10-20T11:47:34.255+08:00[Asia/Shanghai]</td>\n<td>在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之前的请求，才会被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 上。</td>\n</tr>\n<tr>\n<td><strong>After</strong></td>\n<td>- After=2021-10-20T11:47:34.255+08:00[Asia/Shanghai]</td>\n<td>在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之后的请求，才会被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 上。</td>\n</tr>\n<tr>\n<td><strong>Between</strong></td>\n<td>- Between=2021-10-20T15:18:33.226+08:00[Asia/Shanghai],2021-10-20T15:23:33.226+08:00[Asia/Shanghai]</td>\n<td>在 2021 年 10 月 20 日 15 时 18 分 33.226 秒 到 2021 年 10 月 20 日 15 时 23 分 33.226 秒之间的请求，才会被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 服务器上。</td>\n</tr>\n<tr>\n<td><strong>Cookie</strong></td>\n<td>- Cookie=name, c.biancheng.net</td>\n<td>携带 Cookie 且 Cookie 的内容为 name=c.biancheng.net 的请求，才会被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 上。</td>\n</tr>\n<tr>\n<td><strong>Header</strong></td>\n<td>- Header=X-Request-Id,\\d+</td>\n<td>请求头上携带属性 X-Request-Id 且属性值为整数的请求，才会被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 上。</td>\n</tr>\n<tr>\n<td><strong>Method</strong></td>\n<td>- Method=GET</td>\n<td>只有 GET 请求才会被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 上。</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>-Host=<code>**.nihao.org,**.host.com</code></td>\n<td>请求必须是某些域名</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h4><p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17579866481091757986646541.png\" alt=\"17579866481091757986646541.png\"></p>\n<ul>\n<li><strong>Gateway Web Handler（网关处理器）</strong>：网关处理器是 Spring Cloud Gateway 的核心组件，负责将请求转发到匹配的路由上。它根据路由配置和断言条件进行路由匹配，选择合适的路由进行请求转发。网关处理器还会依次应用配置的过滤器链，对请求进行处理和转换。</li>\n<li><strong>Gateway Filter Chain（网关过滤器链）</strong>：网关过滤器链由一系列过滤器组成，按照配置的顺序依次执行。每个过滤器可以在请求前、请求后或请求发生错误时进行处理。过滤器链的执行过程可以修改请求、响应以及执行其他自定义逻辑。<h2 id=\"OpenForeign\"><a href=\"#OpenForeign\" class=\"headerlink\" title=\"OpenForeign\"></a><code>OpenForeign</code></h2><h4 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h4></li>\n<li>Spring Cloud OpenFeign把<strong>REST请求封装为Java接口方法</strong>，<strong>实现了一种声明式的RPC服务调用与负载均衡组件</strong></li>\n<li>有RequestInterceptor拦截器</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@FeignClient</td>\n<td>该注解用于通知 OpenFeign 组件对 @RequestMapping 注解下的接口进行解析，并通过动态代理的方式产生实现类，实现负载均衡和服务调用</td>\n</tr>\n<tr>\n<td>@EnableFeignClients</td>\n<td>该注解用于开启 OpenFeign 功能，OpenFeign 会扫描标有 @FeignClient 注解的接口，生成代理并注册到 Spring 容器中,启动类和配置类中有1个就行 <strong>@EnableFeignClients(“com.train.business.feign”)</strong></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h4><ol>\n<li>声明式 API：Feign 允许开发者使用简单的注解来定义和描述对远程服务的访问。通过使用注解，开发者可以轻松地指定 URL、HTTP 方法、请求参数、请求头等信息，使得远程调用变得非常直观和易于理解。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FeignClient(name = &quot;example&quot;, url = &quot;https://api.example.com&quot;)</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ExampleService</span> &#123;</span><br><span class=\"line\">     <span class=\"meta\">@GetMapping(&quot;/endpoint&quot;)</span></span><br><span class=\"line\">     String <span class=\"title function_\">getEndpointData</span><span class=\"params\">()</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></li>\n<li>集成负载均衡：Feign 集成了 Ribbon 负载均衡器，可以自动实现客户端的负载均衡。它可以根据服务名和可用实例进行动态路由，并分发请求到不同的服务实例上，提高系统的可用性和可伸缩性。</li>\n<li>容错机制：Feign 支持集成 Hystrix 容错框架，可以在调用远程服务时提供容错和断路器功能。当远程服务不可用或响应时间过长时，Feign 可以快速失败并返回预设的响应结果，避免对整个系统造成级联故障<h4 id=\"OpenFeign-和-RestTemplate-的区别\"><a href=\"#OpenFeign-和-RestTemplate-的区别\" class=\"headerlink\" title=\"OpenFeign 和 RestTemplate 的区别\"></a>OpenFeign 和 RestTemplate 的区别</h4>| 特性   | RestTemplate        | OpenFeign           |<br>| —— | —————————- | —————————- |<br>| 调用请求 | 手动拼URL，模板调用         | 声明式接口调用Rest风格，像本地方法 |<br>| 负载均衡 | 需额外配置 @LoadBalanced | 内置支持                |<br>| 扩展能力 | 功能单一，需手动封装          | 日志、拦截器、熔断、重试        |<br>| 开发效率 | 低，代码冗余              | 高，简洁优雅              |<h4 id=\"OpenFeign-和-Dubbo-的区别\"><a href=\"#OpenFeign-和-Dubbo-的区别\" class=\"headerlink\" title=\"OpenFeign 和 Dubbo 的区别\"></a>OpenFeign 和 Dubbo 的区别</h4></li>\n</ol>\n<ul>\n<li>定义上<ul>\n<li>feign是一个声明式的用于Web 服务, 简化Http Api调用的框架, 适用于构建 RESTful 风格</li>\n<li>Dubbo 是一个分布式服务框架，用于构建面向服务的微服务架构。</li>\n</ul>\n</li>\n<li>通信方式<ul>\n<li>feign基于 HTTP 协议，使用 RESTful 风格的接口进行定义和调用。</li>\n<li>Dubbo 默认基于 Netty 作为通信层</li>\n</ul>\n</li>\n<li>生态<ul>\n<li>feign天然集成Spring Cloud 生态<h4 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子\"></a>例子</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 请求是实际服务地址,为了提高效率 </span></span><br><span class=\"line\"><span class=\"comment\"> * 使用feign拦截器要带上请求头token 否则实际服务的拦截器会报错  </span></span><br><span class=\"line\"><span class=\"comment\"> * 注意: 使用PUT请求时,如果max_header_size过小会报400错误  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> cloud_3111  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2025-04-15  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FeignClient(name = &quot;memberService&quot;)</span>  <span class=\"comment\">// memberService = ip+端口(通过nacos通讯录拿到的)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">memberFeign</span> &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@PostMapping(&quot;/member/ticket/save&quot;)</span>  <span class=\"comment\">// 完整uri</span></span><br><span class=\"line\">    Result <span class=\"title function_\">save</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> TicketDTO ticketDTO)</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"负载均衡算法\"><a href=\"#负载均衡算法\" class=\"headerlink\" title=\"负载均衡算法\"></a>负载均衡算法</h4></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><strong>轮询算法（Round Robin）</strong>：轮询算法是最简单的负载均衡算法之一。它按照顺序将请求依次分配给每个后端服务器，循环往复。</li>\n<li><strong>加权轮询算法（Weighted Round Robin）</strong>：加权轮询算法在轮询算法的基础上增加了权重的概念。每个后端服务器都被赋予一个权重值，权重值越高，被选中的概率就越大。</li>\n<li><strong>随机算法（Random）</strong>：随机算法将请求随机分配给后端服务器。每个后端服务器有相等的被选中概率，没有考虑服务器的实际负载情况。这种算法简单快速，适用于后端服务器性能相近且无需考虑请求处理能力的场景。</li>\n<li><strong>加权随机算法（Weighted Random）</strong>：加权随机算法在随机算法的基础上引入了权重的概念。每个后端服务器被赋予一个权重值，权重值越高，被选中的概率就越大。这样可以根据服务器的处理能力和性能调整请求的分配比例。</li>\n<li><strong>最少连接算法（Least Connection）</strong>：最少连接算法会根据后端服务器<strong>当前的连接数</strong>来决定请求的分配。负载均衡器会选择当前连接数最少的服务器进行请求分配，以保证后端服务器的负载均衡。这种算法适用于后端服务器的处理能力不同或者请求的处理时间不同的场景。</li>\n<li><strong>哈希算法（Hash）</strong>：哈希算法会根据请求的某个特定属性（如客户端 IP 地址、请求 URL 等）计算哈希值，然后根据哈希值选择相应的后端服务器。<h4 id=\"什么是服务雪崩\"><a href=\"#什么是服务雪崩\" class=\"headerlink\" title=\"什么是服务雪崩\"></a>什么是服务雪崩</h4></li>\n</ol>\n<ul>\n<li>一个或者多个服务出现故障，如果这时候，依赖的服务还在不断发起请求，或者重试，那么这些请求的压力会不断在下游堆积，导致下游服务的负载急剧增加。不断累计之下，可能会导致故障的进一步加剧，可能会导致级联式的失败，甚至导致整个系统崩溃，这就叫服务雪崩。</li>\n<li>措施：<ol>\n<li>Cluster集群部署多个</li>\n<li>限流和熔断：对服务之间的请求进行限流和熔断，以防止过多的请求涌入导致后端服务不可用。</li>\n<li>缓存和降级：合理使用缓存来减轻后端服务的负载压力，并在必要时进行服务降级，保证核心功能的可用性<h2 id=\"Seata\"><a href=\"#Seata\" class=\"headerlink\" title=\"Seata\"></a><code>Seata</code></h2><h3 id=\"序言-1\"><a href=\"#序言-1\" class=\"headerlink\" title=\"序言\"></a>序言</h3></li>\n</ol>\n</li>\n<li>微服务下的 <strong>分布式事务</strong> 处理框架</li>\n<li>Seata的3个核心组件: <ul>\n<li><code>TC</code>: <strong>事务协调者 Coordinator</strong>, 维护全局和分支事务的状态, 驱动全局事务提交或回滚 </li>\n<li><code>TM</code>: <strong>事务管理器 Manager</strong>, 定义全局事务的范围, 开启全局事务, 提交或回滚全局事务</li>\n<li><code>RM</code>: <strong>资源管理器 Manager</strong>, 管理分支事务的资源, 与TC交谈以及注册分支事务和报告分支事务的状态, 启动分支事务的提交与回滚</li>\n</ul>\n</li>\n<li><code>TC</code> 以 <strong>Seata Server</strong>形式独立部署(8091)，<code>TM</code> 和 <code>RM</code> 则是以 <strong>Seata Client</strong> 的形式集成在微服务中运行</li>\n<li><strong>Seata 在开启全局事务时，会在业务逻辑执行过程中捕获异常来判断是否需要回滚</strong><h3 id=\"分布式事务的4种模式\"><a href=\"#分布式事务的4种模式\" class=\"headerlink\" title=\"分布式事务的4种模式\"></a>分布式事务的4种模式</h3><h4 id=\"XA-模式（两阶段提交协议）\"><a href=\"#XA-模式（两阶段提交协议）\" class=\"headerlink\" title=\"XA 模式（两阶段提交协议）\"></a>XA 模式（两阶段提交协议）</h4></li>\n<li><strong>标准：</strong> 来自于 X/Open 组织的分布式事务标准。</li>\n<li><strong>流程：</strong><ol>\n<li>第一阶段：<strong>所有资源准备就绪（prepare），但不提交</strong>；</li>\n<li>第二阶段：<strong>协调器发送提交命令，所有资源正式提交</strong>；</li>\n</ol>\n</li>\n<li><strong>特点：</strong> 强一致性，自动化程度高；</li>\n<li><strong>问题：</strong><ul>\n<li>阻塞资源，性能较低；</li>\n<li>数据库需要支持 XA协议<h4 id=\"AT-模式（自动事务，Seata默认）\"><a href=\"#AT-模式（自动事务，Seata默认）\" class=\"headerlink\" title=\"AT 模式（自动事务，Seata默认）\"></a>AT 模式（自动事务，Seata默认）</h4></li>\n</ul>\n</li>\n<li><strong>核心：</strong> 利用业务操作前后的快照，自动生成<strong>反向 SQL</strong>来实现回滚；</li>\n<li><strong>流程:</strong> <ul>\n<li>每一次全局事务会在seat数据库表<strong>global_table</strong>生成事务记录, 执行完成就删除</li>\n<li>每一次全局事务会在seat数据库表<strong>branch_table</strong>生成各自操作持久层的<strong>反向SQL</strong>, 执行完成就删除</li>\n<li><strong>全局事务会生成一个全局事务ID也叫XID, 上游服务通过设置拦截器设置Header把XID传递给下游服务, 以确保全局事务的唯一性</strong></li>\n<li><strong>还要保证抛出的异常正确被seata接收到, 不能被自定义的全局异常处理器处理</strong></li>\n<li>seata的全局锁和分支事务锁都是通过mysql来做的(key,value,expire)</li>\n</ul>\n</li>\n<li><strong>工作机制：</strong><ol>\n<li>前置操作：在数据库执行 SQL 之前记录快照（undo_log）**；</li>\n<li>失败回滚： <strong>自动生成并执行反向 SQL；</strong></li>\n</ol>\n</li>\n<li><strong>特点：</strong><ul>\n<li>无需业务侵入；</li>\n<li>高性能；</li>\n<li>最终一致性；</li>\n</ul>\n</li>\n<li><strong>缺点</strong><ul>\n<li>Seata的反向SQL不支持复杂的嵌套SQL</li>\n<li>Seata的反向SQL不支持批量更新</li>\n</ul>\n</li>\n<li><strong>适用：</strong> 一般业务场景，性能优先。</li>\n<li><strong>控制台日志记录</strong><ol>\n<li>Begin new global transaction + XID<br>日志表示开始一个新的全局事务（Global Transaction），并且系统生成了一个唯一的事务ID（XID）来标识这个全局事务。  </li>\n<li>发生异常, 被Seata捕获, RM生成分支事务<br>在全局事务的执行过程中发生了异常，Seata框架捕获到该异常并进行处理。<br>为了处理事务中的错误，RM（Resource Manager，资源管理器）生成了一个分支事务（Branch Transaction），用于处理失败后的恢复操作。  </li>\n<li>RM handle branch rollback process: xid=XID, branchId=分支事务ID<br>RM开始处理分支事务的回滚过程。通过XID和branchId来标识需要回滚的分支事务。  </li>\n<li>RM处理分支事务, 开始执行回滚操作，并且删除存储分支事务信息的branch_table表中的相关记录。  </li>\n<li>XID branch 分支事务, undo_log deleted with GlobalFinished<br>回滚操作完成后，分支事务的相关undo_log（撤销日志）被删除。<br>undo_log的删除意味着该分支事务的操作已经完全撤销，并且全局事务的状态被标记为GlobalFinished，表示事务已结束。  </li>\n<li>Branch Rollbacked result: PhaseTwo_Rollbacked<br>分支事务的回滚已成功完成，系统记录了“第二阶段回滚完成”（PhaseTwo_Rollbacked）。<br>在分布式事务中，Seata一般会分为两个阶段：第一阶段是操作执行，第二阶段是根据事务状态来决定是回滚还是提交。  </li>\n<li>Suspending current transaction, xid = XID<br>当前的全局事务被挂起，表示该事务暂时处于非活动状态。通常发生在事务处理结束后，等待最终的结果确认（如提交或回滚）。 </li>\n<li>Rollback status: Rollbacked<br>最终，系统报告了回滚操作的状态为“回滚完成”（Rollbacked）。<br>这意味着所有相关的操作都已恢复至初始状态，事务的回滚操作已经成功执行。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412609649171741260964467.png\" alt=\"AT模式示意图|700x418\"><h4 id=\"TCC-模式（Try-Confirm-Cancel）\"><a href=\"#TCC-模式（Try-Confirm-Cancel）\" class=\"headerlink\" title=\"TCC 模式（Try Confirm Cancel）\"></a>TCC 模式（Try Confirm Cancel）</h4></li>\n</ol>\n</li>\n<li><strong>核心：</strong> 显式定义三段操作：<ol>\n<li><strong>Try：</strong> 资源预留；</li>\n<li><strong>Confirm：</strong> 真正执行业务提交；</li>\n<li><strong>Cancel：</strong> 回滚预留资源；</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 高性能、强业务控制；</li>\n<li><strong>缺点：</strong> 对业务侵入性强，需要开发者自己实现三段逻辑；</li>\n<li><strong>适用：</strong> 高并发、高一致性要求的业务，比如支付、库存冻结等。<h4 id=\"SAGA-模式（长事务拆分）\"><a href=\"#SAGA-模式（长事务拆分）\" class=\"headerlink\" title=\"SAGA 模式（长事务拆分）\"></a>SAGA 模式（长事务拆分）</h4></li>\n<li><strong>核心：</strong> 将大事务拆分为多个本地子事务，按顺序执行，每个子事务都有对应的补偿操作（非回滚）；</li>\n<li><strong>流程：</strong><ul>\n<li>正向执行每个子事务；</li>\n<li>若有失败，按相反顺序执行补偿操作；</li>\n</ul>\n</li>\n<li><strong>特点：</strong><ul>\n<li>弱一致性（最终一致）；</li>\n<li>无需锁定资源；</li>\n<li>适合长事务或异步场景（例如订单 + 发货）；</li>\n</ul>\n</li>\n<li><strong>实现：</strong> 可用 Seata Saga 模块实现（基于状态机或注解模式）。<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3></li>\n<li>借由<strong>补偿机制</strong>来解决 分布式事务下的 不同服务间 事务回滚不成功的问题(不同服务, 不同数据库)</li>\n<li>例子: 在business服务中启动@Transactional事务, 但是通过feign调用了member服务,business服务发生异常, 由于不在同一个服务中, 对member服务的回滚失败</li>\n<li><strong>引入分布式事务导致的性能下降</strong>:<ul>\n<li>网络通信开销(后端微服务与 TC 通信、RM 上报、TM 协调)</li>\n<li>锁竞争导致的时间变长(全局锁、分支事务锁)</li>\n<li>日志记录(Undo/Redo日志)也需要开销</li>\n</ul>\n</li>\n<li><strong>优化</strong>: <ul>\n<li>增加节点</li>\n<li>减少使用全局事务</li>\n<li>选用合适的seata模式</li>\n<li>分库分表</li>\n<li>使用缓存</li>\n<li>使用队列或者开启异步线程处理特定业务<h2 id=\"Sentinel\"><a href=\"#Sentinel\" class=\"headerlink\" title=\"Sentinel\"></a><code>Sentinel</code></h2><h3 id=\"序章-3\"><a href=\"#序章-3\" class=\"headerlink\" title=\"序章\"></a>序章</h3></li>\n</ul>\n</li>\n<li><strong>Sentinel</strong> 是一款面向<strong>分布式微服务架构</strong>的轻量级 <strong>流量控制与熔断降级</strong> 组件</li>\n<li>主要以流量为切入点，从<strong>流量控制(限流)</strong>、实时监控、<strong>熔断降级</strong>、系统负载保护等多个维度帮助用户保护服务的稳定性</li>\n<li>限流是做在被调用方(前端用户), 熔断是做在调用方(后端服务)<h3 id=\"限流算法\"><a href=\"#限流算法\" class=\"headerlink\" title=\"限流算法\"></a>限流算法</h3></li>\n<li><strong>静态窗口(默认):也叫计数器</strong>:<ul>\n<li>静态窗口算法<strong>把时间划分成固定大小的窗口</strong>，每个窗口内都有一个<strong>请求计数器</strong>。当请求数达到限制值时，新的请求将被拒绝。窗口在时间到达后重置。</li>\n<li>面对突发性的<strong>流量突增</strong>（即请求集中的情况), 会拒绝全部请求</li>\n</ul>\n</li>\n<li><strong>动态窗口</strong>：<ul>\n<li>静态的升级, 通过 <strong>滑动窗口(动态时间内)</strong> 动态调整限流阈值，更加灵活应对流量波动。</li>\n<li><strong>计算开销较大</strong>，每次请求都需要计算滑动窗口内的请求总数。</li>\n<li>可以使用 <strong>滑动窗口限流</strong> 进行灵活控制，避免了静态窗口带来的流量爆发问题</li>\n</ul>\n</li>\n<li><strong>漏桶算法</strong>：<ul>\n<li><strong>控制每秒的最大访问请求</strong>，<strong>超过阈值的新请求</strong>会加入队列排队等待，队列慢了就丢弃</li>\n<li><strong>有请求丢失问题, 将突发性请求变均匀</strong></li>\n</ul>\n</li>\n<li><strong>令牌桶算法</strong>：<ul>\n<li>令牌桶算法与漏桶相似，但其<strong>令牌发放速率是可调的</strong>。请求必须先获取一个令牌才能执行操作，桶内的令牌数量有限(容量可控)。<strong>当令牌数量为零时，新的请求被拒绝</strong></li>\n<li><strong>可能出现令牌空缺</strong>，如果令牌速度过慢，短时间内可能会有大量请求被拒绝(<strong>流量突增</strong>)</li>\n</ul>\n</li>\n<li><strong>令牌大闸</strong>：<ul>\n<li>这是对令牌桶算法的扩展，采用了一个令牌池的管理机制，对令牌进行更加精细的控制<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3></li>\n</ul>\n</li>\n<li>概念: 对<strong>URL</strong>或<strong>请求方法</strong>进行 <strong>QPS</strong> 或<strong>并发线程数</strong>的限制</li>\n<li>核心原则<ul>\n<li>资源命名：建议为受保护资源自定义名称，避免直接使用请求路径作为资源名<ul>\n<li><strong>@SentinelResource(value = “saveOrder”, blockHandler = “flowExceptionHandle”)</strong></li>\n</ul>\n</li>\n<li>限流类型：<ul>\n<li><strong>整体限流</strong>：对所有请求线程统一进行限流判断。</li>\n<li><strong>条件限流</strong>：在业务代码中对请求线程做条件判断后，再进行限流。</li>\n</ul>\n</li>\n<li>降级策略：<ul>\n<li>当请求被限流时，可自定义降级处理逻辑，提供一个兜底信息, 确保用户体验不至于完全断裂。</li>\n<li>限流模式（令牌桶或漏桶）Sentinel 使用滑动窗口限流算法来实现限流。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>流控效果:<ul>\n<li><strong>快速失败(默认)</strong><ul>\n<li>请求一旦超过限制，<strong>立即被拒绝并返回错误</strong>，不做排队处理。</li>\n<li>优点：响应迅速，占用资源少。</li>\n<li>适用场景：对响应时间敏感的服务。</li>\n</ul>\n</li>\n<li><strong>预热（Warm Up）</strong><ul>\n<li>用于处理系统冷启动时的流量激增问题。</li>\n<li>设置一个预热时长，在该时段内限制<strong>通过速率逐渐上升</strong>，避免服务刚启动就被压垮。</li>\n<li>适用场景：需要冷启动保护的服务（如定时任务、大促活动前）。</li>\n</ul>\n</li>\n<li><strong>排队等待（Rate Limiter + Queueing）</strong><ul>\n<li>请求超过阈值后，不立即拒绝，而是进入队列排队，等待处理。</li>\n<li>可配置最大等待时间。</li>\n<li>适用场景：允许延迟、但希望<strong>尽量不丢请求</strong>的业务（如订单处理、消息投递）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>流控模式（控制维度）</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>QPS 限流</strong></td>\n<td>基于单位时间内的请求次数（Queries Per Second）进行控制。超出后按照所选流控效果处理。</td>\n</tr>\n<tr>\n<td><strong>并发线程数限流</strong></td>\n<td>控制同时处理请求的线程数，适用于资源敏感的场景。</td>\n</tr>\n<tr>\n<td><strong>链路限流（链路调用链控制）</strong></td>\n<td>对指定调用链上的某一资源进行限流，精细控制调用路径下的热点资源。</td>\n</tr>\n<tr>\n<td><strong>参数限流（热点参数限流）</strong></td>\n<td>根据请求参数的值进行限流，常用于热点资源防护，例如某商品ID请求频繁。</td>\n</tr>\n<tr>\n<td><strong>自定义条件限流</strong></td>\n<td>可以结合业务标签或特定字段实现动态限流策略。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"熔断\"><a href=\"#熔断\" class=\"headerlink\" title=\"熔断\"></a>熔断</h3><ul>\n<li>概念: <strong>当某个服务出现故障或异常时，服务熔断可以快速隔离该服务，确保系统稳定可用</strong></li>\n<li>核心原则:<ul>\n<li>类型<ul>\n<li><strong>慢调用比例</strong>: 如果调用<strong>响应时间</strong>过长，触发熔断</li>\n<li><strong>异常比例</strong>: 根据一定窗口时间出现异常的比例来判断是否熔断</li>\n<li><strong>异常数</strong>: 根据一定窗口时间出现异常的数量来判断是否熔断</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>注解保护资源 <strong>@SentinelResource(value = “GET:/api/hello”, fallback = “fallback”)</strong></li>\n<li><strong>熔断降级</strong>: 其实跟限流降级是一样的, 都是在触发限流和熔断的情况下提供兜底方案, 自定义异常信息或者返回信息</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>resource</code></td>\n<td>熔断作用的资源名（建议自定义）</td>\n</tr>\n<tr>\n<td><code>grade</code></td>\n<td>熔断类型（上面 0/1/2）</td>\n</tr>\n<tr>\n<td><code>count</code></td>\n<td>根据类型不同表示不同含义：  <br>• 慢调用：阈值响应时间（ms）  <br>• 异常比例：最大异常比例（如 0.3）  <br>• 异常数：最大异常数</td>\n</tr>\n<tr>\n<td><code>minRequestAmount</code></td>\n<td>最小请求数，达到该数量后才会触发熔断</td>\n</tr>\n<tr>\n<td><code>slowRatioThreshold</code></td>\n<td>慢调用比例阈值（仅适用于慢调用类型）</td>\n</tr>\n<tr>\n<td><code>timeWindow</code></td>\n<td>熔断时长（单位：秒）</td>\n</tr>\n<tr>\n<td><code>statIntervalMs</code></td>\n<td>统计时间窗口（毫秒）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"限流和熔断的区别\"><a href=\"#限流和熔断的区别\" class=\"headerlink\" title=\"限流和熔断的区别\"></a>限流和熔断的区别</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>限流（Rate Limiting）</th>\n<th>熔断（Circuit Breaking）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>目的</td>\n<td><strong>保护服务</strong>不被突发高流量压垮</td>\n<td><strong>阻断不稳定下游服务</strong>，防止故障放大</td>\n</tr>\n<tr>\n<td>适用对象</td>\n<td>通常是对<strong>入口请求</strong>做控制（如接口访问、用户请求）</td>\n<td>通常是对<strong>服务间调用</strong>（如微服务 A → B）做保护</td>\n</tr>\n<tr>\n<td>判断依据</td>\n<td>请求的 <strong>QPS（每秒请求数）</strong> 或 <strong>并发线程数</strong></td>\n<td>请求的 <strong>响应时间</strong>、<strong>异常比例、异常数</strong></td>\n</tr>\n<tr>\n<td>行为</td>\n<td>达到阈值时：  <br>拒绝请求 或  排队等待</td>\n<td>达到阈值时：  <br>快速失败，不再发请求给下游</td>\n</tr>\n<tr>\n<td>响应模式</td>\n<td>通常立即返回或等待排队</td>\n<td>熔断期间直接走 fallback</td>\n</tr>\n<tr>\n<td>核心指标</td>\n<td>- QPS  <br>- 并发线程数  <br>- 排队时间</td>\n<td>- 异常比例  <br>- 异常数  <br>- 慢调用比例</td>\n</tr>\n<tr>\n<td>常见应用</td>\n<td>API 网关限流、用户行为限流、热点接口保护</td>\n<td>微服务之间的调用、远程调用超时/不稳定保护</td>\n</tr>\n<tr>\n<td>配置方式（Sentinel）</td>\n<td>流控规则（FlowRule）</td>\n<td>熔断规则（DegradeRule）</td>\n</tr>\n<tr>\n<td>是否允许重试</td>\n<td>可以（排队模式）</td>\n<td>不允许（熔断期直接失败）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"注意-1\"><a href=\"#注意-1\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ul>\n<li>跟seata一样, 发生异常时被自定义异常处理器处理, 那么就不会被sentinel认为发生了异常(因为响应头的status是200), 也就不会进入降级的逻辑 </li>\n<li>当某个服务出现故障或异常时，服务熔断可以快速隔离该服务</li>\n<li>当系统出现异常情况时，服务降级会主动屏蔽一些非核心或可选的功能，而只提供最基本的功能,当服务熔断打开时，Hystrix 可以提供一个备用的降级方法或返回默认值，以保证系统继续正常运行。开发者可以定义降级逻辑，例如返回缓存数据、执行简化的逻辑或调用其他可靠的服务</li>\n<li>线程池隔离：Hystrix, Sentinel, Feign将每个依赖服务的请求都放在独立的线程池中执行，避免因某个服务的故障导致整个系统的线程资源耗尽。通过线程池隔离，可以提高系统的稳定性和可用性。<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412622159201741262214989.png\" alt=\"17412622159201741262214989.png|700x406\"><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412624199221741262419741.png\" alt=\"17412624199221741262419741.png\"></li>\n</ul>\n","cover":"/img/5.png","cover_type":"img","excerpt":"","more":"<h1 id=\"SpringCloud微服务\"><a href=\"#SpringCloud微服务\" class=\"headerlink\" title=\"SpringCloud微服务\"></a>SpringCloud微服务</h1><h2 id=\"微服务概述\"><a href=\"#微服务概述\" class=\"headerlink\" title=\"微服务概述\"></a>微服务概述</h2><ul>\n<li><strong>核心是Spring框架</strong>，<strong>利用Spring Boot的自动配置</strong>，力图实现最简化的<strong>分布式</strong>应用程序开发</li>\n<li>Spring Cloud 是基于 Spring Boot 实现的，它不能独立创建工程或模块，更不能脱离 Spring Boot 独立运行。</li>\n<li>Spring Cloud 本身并不是一个拿来即可用的框架，它是一套<strong>微服务规范</strong>，<strong>共有两代实现</strong><ul>\n<li><strong>Spring Cloud Netflix</strong> 是 Spring Cloud 的第一代实现，主要由 <strong>Eureka</strong>、<strong>Ribbon</strong>、<strong>Feign</strong>、<strong>Hystrix</strong> 等组件组成。</li>\n<li><strong>Spring Cloud Alibaba</strong> 是 Spring Cloud 的第二代实现，主要由 <strong>Nacos</strong>、<strong>Sentinel</strong>、<strong>Seata</strong> 等组件组成。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E\">依赖版本适配说明文档</a><h2 id=\"RPC远程调用\"><a href=\"#RPC远程调用\" class=\"headerlink\" title=\"RPC远程调用\"></a><code>RPC</code>远程调用</h2><h4 id=\"序章\"><a href=\"#序章\" class=\"headerlink\" title=\"序章\"></a>序章</h4></li>\n<li>RPC（Remote Procedure Call，远程过程调用）<ul>\n<li>是一种分布式系统中的通信方式，允许不同的服务之间像调用本地方法一样调用远程服务</li>\n</ul>\n</li>\n<li>HttpClient, OKHttp, RestTemplate 都是gRPC的典型HTTP请求客户端<h4 id=\"RPC和HTTP的区别\"><a href=\"#RPC和HTTP的区别\" class=\"headerlink\" title=\"RPC和HTTP的区别\"></a>RPC和HTTP的区别</h4></li>\n<li>HTTP 是应用层协议，用于传输超文本数据，基于请求-响应模型，常用于 Web 开发、API 调用等场景。</li>\n<li>RPC 是远程过程调用协议，用于实现分布式系统中不同节点之间的通信，基于方法调用模型，常用于构建面向服务的微服务架构。</li>\n<li><p>在微服务架构中，Feign 和 Dubbo 都是用于实现远程调用的框架，Feign 基于 HTTP 协议，Dubbo 基于 RPC 协议。</p>\n<h4 id=\"为什么-WebFlux-使用-Netty-而不是-Tomcat？\"><a href=\"#为什么-WebFlux-使用-Netty-而不是-Tomcat？\" class=\"headerlink\" title=\"为什么 WebFlux 使用 Netty 而不是 Tomcat？\"></a>为什么 WebFlux 使用 Netty 而不是 Tomcat？</h4><p>  ✅ <strong>非阻塞 I/O</strong>，支持高并发请求<br>  ✅ <strong>事件驱动（Reactor 模式）</strong>，更适合 WebSockets、流式处理<br>  ✅ <strong>适用于 API 网关、微服务架构</strong>（如 Spring Cloud Gateway）</p>\n<h4 id=\"阻塞和非阻塞IO的区别\"><a href=\"#阻塞和非阻塞IO的区别\" class=\"headerlink\" title=\"阻塞和非阻塞IO的区别\"></a>阻塞和非阻塞IO的区别</h4></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>调用方式</th>\n<th>描述</th>\n<th>场景</th>\n<th>优缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同步调用(阻塞IO)</td>\n<td>客户端发送请求必须等待服务器返回结果, 如: Tomcat -&gt; SpringMVC -&gt; Servlet</td>\n<td>需要实时响应的业务，如支付、订单查询</td>\n<td>阻塞影响性能,但是满足业务需求</td>\n</tr>\n<tr>\n<td>异步调用(非阻塞IO)</td>\n<td>客户端发送请求后，不会阻塞等待，而是立即返回，后续通过回调函数、轮询或者事件通知的方式获取结果。如: WebFlux -&gt; Netty</td>\n<td>高并发、任务队列，如日志收集</td>\n<td>不等待需要管理回调或轮询</td>\n</tr>\n<tr>\n<td>单向调用</td>\n<td>客户端只发送请求，不关心返回值</td>\n<td>日志上报、监控数据</td>\n<td>高效,但是无法确认是否调用成功</td>\n</tr>\n<tr>\n<td>广播调用</td>\n<td>请求同时发送给多个服务器</td>\n<td>配置更新、消息通知</td>\n<td>需要策略控制（超时、重试等）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"Nacos\"><a href=\"#Nacos\" class=\"headerlink\" title=\"Nacos\"></a><code>Nacos</code></h2><h3 id=\"序章-1\"><a href=\"#序章-1\" class=\"headerlink\" title=\"序章\"></a>序章</h3><ul>\n<li>为什么要有服务注册和发现Nacos<ul>\n<li>因为如果是单体项目, 模块之间可以用依赖注入的方式互相调用; 但是对于两个已经启动的进程, 必须通过远程调用(Http, gRPC), 但是ip地址是写死的在配置的, 无法集中化管理 </li>\n</ul>\n</li>\n<li>Nacos 本身就是一个中心化的服务平台, 客户端依赖通过<strong>封装好的接口与 Nacos 服务端交互</strong>，从而实现服务注册、配置拉取等操作</li>\n<li>全称含义: <strong>Dynamic Naming and Configuration Service</strong> 动态命名与配置服务中心</li>\n<li>层级结构梳理如下：<ul>\n<li>**命名空间（Namespace） <pre><code>└─ 分组（Group） \n      └─ 服务/配置（Data ID）**\n</code></pre><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17579852910921757985290713.png\" alt=\"17579852910921757985290713.png|700x396\"><h3 id=\"Eureka和Nacos的区别\"><a href=\"#Eureka和Nacos的区别\" class=\"headerlink\" title=\"Eureka和Nacos的区别\"></a>Eureka和Nacos的区别</h3></li>\n</ul>\n</li>\n<li>Eureka相比于Nacos没有配置中心, 但是都有服务注册和发现的功能</li>\n<li>Eureka和Nacos的ping健康检测机制不一样<ul>\n<li>Eureka<ul>\n<li>心跳检测：服务实例每 <strong>30s</strong> 发送一次心跳。</li>\n<li>服务清理：服务端每 <strong>60s</strong> 扫描一次，剔除超过 90s 未续约的服务实例</li>\n</ul>\n</li>\n<li>Nacos<ul>\n<li>心跳检测：客户端每 <strong>5s</strong> 上报一次心跳。</li>\n<li>服务清理：服务端每 <strong>30s</strong> 检查，超过 15s 无心跳标记为不健康，30s 内无心跳剔除。<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>配置<code>spring.cloud.nacos.discovery</code>, 就会注册服务到已经启动的 Nacos 注册中心</li>\n<li><code>bootstrap.*</code> 里的配置会先于 <code>application.*</code>  <strong>优先加载</strong>（适用于 Nacos 这种外部配置中心), 如果有同名配置则会被覆盖</li>\n<li>尤其要注意的是所有注册到nacos的服务会自动吃到当前空间下的所有配置, 并且可以<strong>动态刷新</strong>, 但是要在类上加注解<code>@RefreshScope</code></li>\n<li>nacos有<strong>缓存通讯录和ping心跳检测</strong>, 所以即使挂了也不会影响已经运行的服务</li>\n<li>nacos可以做<strong>负载均衡</strong>, 但是要引入依赖, 默认是轮询</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412603872831741260386317.png\" alt=\"17412603872831741260386317.png|700x464\"></p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">profiles:</span></span><br><span class=\"line\">    <span class=\"attr\">active:</span> <span class=\"string\">dev</span></span><br><span class=\"line\">  <span class=\"attr\">cloud:</span></span><br><span class=\"line\">    <span class=\"attr\">nacos:</span></span><br><span class=\"line\">      <span class=\"comment\"># nacos discovery center</span></span><br><span class=\"line\">      <span class=\"attr\">discovery:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">$&#123;nacos.address&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">$&#123;nacos.namespace&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># nacos config center</span></span><br><span class=\"line\">      <span class=\"attr\">config:</span></span><br><span class=\"line\">        <span class=\"attr\">server-addr:</span> <span class=\"string\">$&#123;nacos.address&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">namespace:</span> <span class=\"string\">$&#123;nacos.namespace&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># nacos config extension type</span></span><br><span class=\"line\">        <span class=\"attr\">file-extension:</span> <span class=\"string\">$&#123;nacos.fileExtension&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\"># properties inject list</span></span><br><span class=\"line\">        <span class=\"attr\">extension-configs:</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">data-id:</span> <span class=\"string\">$&#123;nacos.dataIds[0].one&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">data-id:</span> <span class=\"string\">$&#123;nacos.dataIds[1].two&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"bullet\">-</span> <span class=\"attr\">data-id:</span> <span class=\"string\">$&#123;nacos.dataIds[2].three&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">refresh:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"GateWay\"><a href=\"#GateWay\" class=\"headerlink\" title=\"GateWay\"></a><code>GateWay</code></h2><h4 id=\"序章-2\"><a href=\"#序章-2\" class=\"headerlink\" title=\"序章\"></a>序章</h4><ul>\n<li>Spring Cloud Gateway是基于<strong>Netty</strong>的异步服务器，允许我们编写一系列过滤器来实现<strong>黑名单</strong>、<strong>权限检查</strong>、<strong>限流</strong>等功能。</li>\n<li>通过 Predicate <strong>断言来实现 Route 路由的匹配规则</strong>。简单点说，Predicate 是路由转发的判断条件，请求只有满足了 Predicate 的条件，才会被转发到指定的服务上进行处理。<h4 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>核心概念</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Route(路由)</td>\n<td>网关最基本的模块。它<strong>由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成</strong>。</td>\n</tr>\n<tr>\n<td>Predicate(断言)</td>\n<td>路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。</td>\n</tr>\n<tr>\n<td>Filter(过滤器)</td>\n<td>过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对上文的响应进行再处理。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412623069201741262305954.png\" alt=\"17412623069201741262305954.png\"></p>\n<h4 id=\"断言匹配规则\"><a href=\"#断言匹配规则\" class=\"headerlink\" title=\"断言匹配规则\"></a>断言匹配规则</h4><ul>\n<li>Route 路由与 Predicate 断言的对应关系为“<strong>一对多</strong>”，<strong>一个路由可以包含多个不同断言</strong>。</li>\n<li>一个请求想要转发到指定的路由上，就必须同时匹配路由上的所有断言。</li>\n<li><strong>当一个请求同时满足多个路由的断言条件时，请求只会被首个成功匹配的路由转发**</strong>。</li>\n<li>共有7种匹配断言规则<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412433659841741243365893.png\" alt=\"17412433659841741243365893.png\"></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>断言</th>\n<th>示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Path</strong></td>\n<td>- Path=/dept/list/**</td>\n<td>当请求路径与 /dept/list/** 匹配时，该请求才能被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 上。</td>\n</tr>\n<tr>\n<td><strong>Before</strong></td>\n<td>- Before=2021-10-20T11:47:34.255+08:00[Asia/Shanghai]</td>\n<td>在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之前的请求，才会被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 上。</td>\n</tr>\n<tr>\n<td><strong>After</strong></td>\n<td>- After=2021-10-20T11:47:34.255+08:00[Asia/Shanghai]</td>\n<td>在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之后的请求，才会被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 上。</td>\n</tr>\n<tr>\n<td><strong>Between</strong></td>\n<td>- Between=2021-10-20T15:18:33.226+08:00[Asia/Shanghai],2021-10-20T15:23:33.226+08:00[Asia/Shanghai]</td>\n<td>在 2021 年 10 月 20 日 15 时 18 分 33.226 秒 到 2021 年 10 月 20 日 15 时 23 分 33.226 秒之间的请求，才会被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 服务器上。</td>\n</tr>\n<tr>\n<td><strong>Cookie</strong></td>\n<td>- Cookie=name, c.biancheng.net</td>\n<td>携带 Cookie 且 Cookie 的内容为 name=c.biancheng.net 的请求，才会被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 上。</td>\n</tr>\n<tr>\n<td><strong>Header</strong></td>\n<td>- Header=X-Request-Id,\\d+</td>\n<td>请求头上携带属性 X-Request-Id 且属性值为整数的请求，才会被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 上。</td>\n</tr>\n<tr>\n<td><strong>Method</strong></td>\n<td>- Method=GET</td>\n<td>只有 GET 请求才会被转发到 <a href=\"http://localhost:8001\">http://localhost:8001</a> 上。</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>-Host=<code>**.nihao.org,**.host.com</code></td>\n<td>请求必须是某些域名</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h4><p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17579866481091757986646541.png\" alt=\"17579866481091757986646541.png\"></p>\n<ul>\n<li><strong>Gateway Web Handler（网关处理器）</strong>：网关处理器是 Spring Cloud Gateway 的核心组件，负责将请求转发到匹配的路由上。它根据路由配置和断言条件进行路由匹配，选择合适的路由进行请求转发。网关处理器还会依次应用配置的过滤器链，对请求进行处理和转换。</li>\n<li><strong>Gateway Filter Chain（网关过滤器链）</strong>：网关过滤器链由一系列过滤器组成，按照配置的顺序依次执行。每个过滤器可以在请求前、请求后或请求发生错误时进行处理。过滤器链的执行过程可以修改请求、响应以及执行其他自定义逻辑。<h2 id=\"OpenForeign\"><a href=\"#OpenForeign\" class=\"headerlink\" title=\"OpenForeign\"></a><code>OpenForeign</code></h2><h4 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h4></li>\n<li>Spring Cloud OpenFeign把<strong>REST请求封装为Java接口方法</strong>，<strong>实现了一种声明式的RPC服务调用与负载均衡组件</strong></li>\n<li>有RequestInterceptor拦截器</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@FeignClient</td>\n<td>该注解用于通知 OpenFeign 组件对 @RequestMapping 注解下的接口进行解析，并通过动态代理的方式产生实现类，实现负载均衡和服务调用</td>\n</tr>\n<tr>\n<td>@EnableFeignClients</td>\n<td>该注解用于开启 OpenFeign 功能，OpenFeign 会扫描标有 @FeignClient 注解的接口，生成代理并注册到 Spring 容器中,启动类和配置类中有1个就行 <strong>@EnableFeignClients(“com.train.business.feign”)</strong></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h4><ol>\n<li>声明式 API：Feign 允许开发者使用简单的注解来定义和描述对远程服务的访问。通过使用注解，开发者可以轻松地指定 URL、HTTP 方法、请求参数、请求头等信息，使得远程调用变得非常直观和易于理解。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FeignClient(name = &quot;example&quot;, url = &quot;https://api.example.com&quot;)</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ExampleService</span> &#123;</span><br><span class=\"line\">     <span class=\"meta\">@GetMapping(&quot;/endpoint&quot;)</span></span><br><span class=\"line\">     String <span class=\"title function_\">getEndpointData</span><span class=\"params\">()</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></li>\n<li>集成负载均衡：Feign 集成了 Ribbon 负载均衡器，可以自动实现客户端的负载均衡。它可以根据服务名和可用实例进行动态路由，并分发请求到不同的服务实例上，提高系统的可用性和可伸缩性。</li>\n<li>容错机制：Feign 支持集成 Hystrix 容错框架，可以在调用远程服务时提供容错和断路器功能。当远程服务不可用或响应时间过长时，Feign 可以快速失败并返回预设的响应结果，避免对整个系统造成级联故障<h4 id=\"OpenFeign-和-RestTemplate-的区别\"><a href=\"#OpenFeign-和-RestTemplate-的区别\" class=\"headerlink\" title=\"OpenFeign 和 RestTemplate 的区别\"></a>OpenFeign 和 RestTemplate 的区别</h4>| 特性   | RestTemplate        | OpenFeign           |<br>| —— | —————————- | —————————- |<br>| 调用请求 | 手动拼URL，模板调用         | 声明式接口调用Rest风格，像本地方法 |<br>| 负载均衡 | 需额外配置 @LoadBalanced | 内置支持                |<br>| 扩展能力 | 功能单一，需手动封装          | 日志、拦截器、熔断、重试        |<br>| 开发效率 | 低，代码冗余              | 高，简洁优雅              |<h4 id=\"OpenFeign-和-Dubbo-的区别\"><a href=\"#OpenFeign-和-Dubbo-的区别\" class=\"headerlink\" title=\"OpenFeign 和 Dubbo 的区别\"></a>OpenFeign 和 Dubbo 的区别</h4></li>\n</ol>\n<ul>\n<li>定义上<ul>\n<li>feign是一个声明式的用于Web 服务, 简化Http Api调用的框架, 适用于构建 RESTful 风格</li>\n<li>Dubbo 是一个分布式服务框架，用于构建面向服务的微服务架构。</li>\n</ul>\n</li>\n<li>通信方式<ul>\n<li>feign基于 HTTP 协议，使用 RESTful 风格的接口进行定义和调用。</li>\n<li>Dubbo 默认基于 Netty 作为通信层</li>\n</ul>\n</li>\n<li>生态<ul>\n<li>feign天然集成Spring Cloud 生态<h4 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子\"></a>例子</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 请求是实际服务地址,为了提高效率 </span></span><br><span class=\"line\"><span class=\"comment\"> * 使用feign拦截器要带上请求头token 否则实际服务的拦截器会报错  </span></span><br><span class=\"line\"><span class=\"comment\"> * 注意: 使用PUT请求时,如果max_header_size过小会报400错误  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> cloud_3111  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2025-04-15  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@FeignClient(name = &quot;memberService&quot;)</span>  <span class=\"comment\">// memberService = ip+端口(通过nacos通讯录拿到的)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">memberFeign</span> &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@PostMapping(&quot;/member/ticket/save&quot;)</span>  <span class=\"comment\">// 完整uri</span></span><br><span class=\"line\">    Result <span class=\"title function_\">save</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> TicketDTO ticketDTO)</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"负载均衡算法\"><a href=\"#负载均衡算法\" class=\"headerlink\" title=\"负载均衡算法\"></a>负载均衡算法</h4></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><strong>轮询算法（Round Robin）</strong>：轮询算法是最简单的负载均衡算法之一。它按照顺序将请求依次分配给每个后端服务器，循环往复。</li>\n<li><strong>加权轮询算法（Weighted Round Robin）</strong>：加权轮询算法在轮询算法的基础上增加了权重的概念。每个后端服务器都被赋予一个权重值，权重值越高，被选中的概率就越大。</li>\n<li><strong>随机算法（Random）</strong>：随机算法将请求随机分配给后端服务器。每个后端服务器有相等的被选中概率，没有考虑服务器的实际负载情况。这种算法简单快速，适用于后端服务器性能相近且无需考虑请求处理能力的场景。</li>\n<li><strong>加权随机算法（Weighted Random）</strong>：加权随机算法在随机算法的基础上引入了权重的概念。每个后端服务器被赋予一个权重值，权重值越高，被选中的概率就越大。这样可以根据服务器的处理能力和性能调整请求的分配比例。</li>\n<li><strong>最少连接算法（Least Connection）</strong>：最少连接算法会根据后端服务器<strong>当前的连接数</strong>来决定请求的分配。负载均衡器会选择当前连接数最少的服务器进行请求分配，以保证后端服务器的负载均衡。这种算法适用于后端服务器的处理能力不同或者请求的处理时间不同的场景。</li>\n<li><strong>哈希算法（Hash）</strong>：哈希算法会根据请求的某个特定属性（如客户端 IP 地址、请求 URL 等）计算哈希值，然后根据哈希值选择相应的后端服务器。<h4 id=\"什么是服务雪崩\"><a href=\"#什么是服务雪崩\" class=\"headerlink\" title=\"什么是服务雪崩\"></a>什么是服务雪崩</h4></li>\n</ol>\n<ul>\n<li>一个或者多个服务出现故障，如果这时候，依赖的服务还在不断发起请求，或者重试，那么这些请求的压力会不断在下游堆积，导致下游服务的负载急剧增加。不断累计之下，可能会导致故障的进一步加剧，可能会导致级联式的失败，甚至导致整个系统崩溃，这就叫服务雪崩。</li>\n<li>措施：<ol>\n<li>Cluster集群部署多个</li>\n<li>限流和熔断：对服务之间的请求进行限流和熔断，以防止过多的请求涌入导致后端服务不可用。</li>\n<li>缓存和降级：合理使用缓存来减轻后端服务的负载压力，并在必要时进行服务降级，保证核心功能的可用性<h2 id=\"Seata\"><a href=\"#Seata\" class=\"headerlink\" title=\"Seata\"></a><code>Seata</code></h2><h3 id=\"序言-1\"><a href=\"#序言-1\" class=\"headerlink\" title=\"序言\"></a>序言</h3></li>\n</ol>\n</li>\n<li>微服务下的 <strong>分布式事务</strong> 处理框架</li>\n<li>Seata的3个核心组件: <ul>\n<li><code>TC</code>: <strong>事务协调者 Coordinator</strong>, 维护全局和分支事务的状态, 驱动全局事务提交或回滚 </li>\n<li><code>TM</code>: <strong>事务管理器 Manager</strong>, 定义全局事务的范围, 开启全局事务, 提交或回滚全局事务</li>\n<li><code>RM</code>: <strong>资源管理器 Manager</strong>, 管理分支事务的资源, 与TC交谈以及注册分支事务和报告分支事务的状态, 启动分支事务的提交与回滚</li>\n</ul>\n</li>\n<li><code>TC</code> 以 <strong>Seata Server</strong>形式独立部署(8091)，<code>TM</code> 和 <code>RM</code> 则是以 <strong>Seata Client</strong> 的形式集成在微服务中运行</li>\n<li><strong>Seata 在开启全局事务时，会在业务逻辑执行过程中捕获异常来判断是否需要回滚</strong><h3 id=\"分布式事务的4种模式\"><a href=\"#分布式事务的4种模式\" class=\"headerlink\" title=\"分布式事务的4种模式\"></a>分布式事务的4种模式</h3><h4 id=\"XA-模式（两阶段提交协议）\"><a href=\"#XA-模式（两阶段提交协议）\" class=\"headerlink\" title=\"XA 模式（两阶段提交协议）\"></a>XA 模式（两阶段提交协议）</h4></li>\n<li><strong>标准：</strong> 来自于 X/Open 组织的分布式事务标准。</li>\n<li><strong>流程：</strong><ol>\n<li>第一阶段：<strong>所有资源准备就绪（prepare），但不提交</strong>；</li>\n<li>第二阶段：<strong>协调器发送提交命令，所有资源正式提交</strong>；</li>\n</ol>\n</li>\n<li><strong>特点：</strong> 强一致性，自动化程度高；</li>\n<li><strong>问题：</strong><ul>\n<li>阻塞资源，性能较低；</li>\n<li>数据库需要支持 XA协议<h4 id=\"AT-模式（自动事务，Seata默认）\"><a href=\"#AT-模式（自动事务，Seata默认）\" class=\"headerlink\" title=\"AT 模式（自动事务，Seata默认）\"></a>AT 模式（自动事务，Seata默认）</h4></li>\n</ul>\n</li>\n<li><strong>核心：</strong> 利用业务操作前后的快照，自动生成<strong>反向 SQL</strong>来实现回滚；</li>\n<li><strong>流程:</strong> <ul>\n<li>每一次全局事务会在seat数据库表<strong>global_table</strong>生成事务记录, 执行完成就删除</li>\n<li>每一次全局事务会在seat数据库表<strong>branch_table</strong>生成各自操作持久层的<strong>反向SQL</strong>, 执行完成就删除</li>\n<li><strong>全局事务会生成一个全局事务ID也叫XID, 上游服务通过设置拦截器设置Header把XID传递给下游服务, 以确保全局事务的唯一性</strong></li>\n<li><strong>还要保证抛出的异常正确被seata接收到, 不能被自定义的全局异常处理器处理</strong></li>\n<li>seata的全局锁和分支事务锁都是通过mysql来做的(key,value,expire)</li>\n</ul>\n</li>\n<li><strong>工作机制：</strong><ol>\n<li>前置操作：在数据库执行 SQL 之前记录快照（undo_log）**；</li>\n<li>失败回滚： <strong>自动生成并执行反向 SQL；</strong></li>\n</ol>\n</li>\n<li><strong>特点：</strong><ul>\n<li>无需业务侵入；</li>\n<li>高性能；</li>\n<li>最终一致性；</li>\n</ul>\n</li>\n<li><strong>缺点</strong><ul>\n<li>Seata的反向SQL不支持复杂的嵌套SQL</li>\n<li>Seata的反向SQL不支持批量更新</li>\n</ul>\n</li>\n<li><strong>适用：</strong> 一般业务场景，性能优先。</li>\n<li><strong>控制台日志记录</strong><ol>\n<li>Begin new global transaction + XID<br>日志表示开始一个新的全局事务（Global Transaction），并且系统生成了一个唯一的事务ID（XID）来标识这个全局事务。  </li>\n<li>发生异常, 被Seata捕获, RM生成分支事务<br>在全局事务的执行过程中发生了异常，Seata框架捕获到该异常并进行处理。<br>为了处理事务中的错误，RM（Resource Manager，资源管理器）生成了一个分支事务（Branch Transaction），用于处理失败后的恢复操作。  </li>\n<li>RM handle branch rollback process: xid=XID, branchId=分支事务ID<br>RM开始处理分支事务的回滚过程。通过XID和branchId来标识需要回滚的分支事务。  </li>\n<li>RM处理分支事务, 开始执行回滚操作，并且删除存储分支事务信息的branch_table表中的相关记录。  </li>\n<li>XID branch 分支事务, undo_log deleted with GlobalFinished<br>回滚操作完成后，分支事务的相关undo_log（撤销日志）被删除。<br>undo_log的删除意味着该分支事务的操作已经完全撤销，并且全局事务的状态被标记为GlobalFinished，表示事务已结束。  </li>\n<li>Branch Rollbacked result: PhaseTwo_Rollbacked<br>分支事务的回滚已成功完成，系统记录了“第二阶段回滚完成”（PhaseTwo_Rollbacked）。<br>在分布式事务中，Seata一般会分为两个阶段：第一阶段是操作执行，第二阶段是根据事务状态来决定是回滚还是提交。  </li>\n<li>Suspending current transaction, xid = XID<br>当前的全局事务被挂起，表示该事务暂时处于非活动状态。通常发生在事务处理结束后，等待最终的结果确认（如提交或回滚）。 </li>\n<li>Rollback status: Rollbacked<br>最终，系统报告了回滚操作的状态为“回滚完成”（Rollbacked）。<br>这意味着所有相关的操作都已恢复至初始状态，事务的回滚操作已经成功执行。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412609649171741260964467.png\" alt=\"AT模式示意图|700x418\"><h4 id=\"TCC-模式（Try-Confirm-Cancel）\"><a href=\"#TCC-模式（Try-Confirm-Cancel）\" class=\"headerlink\" title=\"TCC 模式（Try Confirm Cancel）\"></a>TCC 模式（Try Confirm Cancel）</h4></li>\n</ol>\n</li>\n<li><strong>核心：</strong> 显式定义三段操作：<ol>\n<li><strong>Try：</strong> 资源预留；</li>\n<li><strong>Confirm：</strong> 真正执行业务提交；</li>\n<li><strong>Cancel：</strong> 回滚预留资源；</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 高性能、强业务控制；</li>\n<li><strong>缺点：</strong> 对业务侵入性强，需要开发者自己实现三段逻辑；</li>\n<li><strong>适用：</strong> 高并发、高一致性要求的业务，比如支付、库存冻结等。<h4 id=\"SAGA-模式（长事务拆分）\"><a href=\"#SAGA-模式（长事务拆分）\" class=\"headerlink\" title=\"SAGA 模式（长事务拆分）\"></a>SAGA 模式（长事务拆分）</h4></li>\n<li><strong>核心：</strong> 将大事务拆分为多个本地子事务，按顺序执行，每个子事务都有对应的补偿操作（非回滚）；</li>\n<li><strong>流程：</strong><ul>\n<li>正向执行每个子事务；</li>\n<li>若有失败，按相反顺序执行补偿操作；</li>\n</ul>\n</li>\n<li><strong>特点：</strong><ul>\n<li>弱一致性（最终一致）；</li>\n<li>无需锁定资源；</li>\n<li>适合长事务或异步场景（例如订单 + 发货）；</li>\n</ul>\n</li>\n<li><strong>实现：</strong> 可用 Seata Saga 模块实现（基于状态机或注解模式）。<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3></li>\n<li>借由<strong>补偿机制</strong>来解决 分布式事务下的 不同服务间 事务回滚不成功的问题(不同服务, 不同数据库)</li>\n<li>例子: 在business服务中启动@Transactional事务, 但是通过feign调用了member服务,business服务发生异常, 由于不在同一个服务中, 对member服务的回滚失败</li>\n<li><strong>引入分布式事务导致的性能下降</strong>:<ul>\n<li>网络通信开销(后端微服务与 TC 通信、RM 上报、TM 协调)</li>\n<li>锁竞争导致的时间变长(全局锁、分支事务锁)</li>\n<li>日志记录(Undo/Redo日志)也需要开销</li>\n</ul>\n</li>\n<li><strong>优化</strong>: <ul>\n<li>增加节点</li>\n<li>减少使用全局事务</li>\n<li>选用合适的seata模式</li>\n<li>分库分表</li>\n<li>使用缓存</li>\n<li>使用队列或者开启异步线程处理特定业务<h2 id=\"Sentinel\"><a href=\"#Sentinel\" class=\"headerlink\" title=\"Sentinel\"></a><code>Sentinel</code></h2><h3 id=\"序章-3\"><a href=\"#序章-3\" class=\"headerlink\" title=\"序章\"></a>序章</h3></li>\n</ul>\n</li>\n<li><strong>Sentinel</strong> 是一款面向<strong>分布式微服务架构</strong>的轻量级 <strong>流量控制与熔断降级</strong> 组件</li>\n<li>主要以流量为切入点，从<strong>流量控制(限流)</strong>、实时监控、<strong>熔断降级</strong>、系统负载保护等多个维度帮助用户保护服务的稳定性</li>\n<li>限流是做在被调用方(前端用户), 熔断是做在调用方(后端服务)<h3 id=\"限流算法\"><a href=\"#限流算法\" class=\"headerlink\" title=\"限流算法\"></a>限流算法</h3></li>\n<li><strong>静态窗口(默认):也叫计数器</strong>:<ul>\n<li>静态窗口算法<strong>把时间划分成固定大小的窗口</strong>，每个窗口内都有一个<strong>请求计数器</strong>。当请求数达到限制值时，新的请求将被拒绝。窗口在时间到达后重置。</li>\n<li>面对突发性的<strong>流量突增</strong>（即请求集中的情况), 会拒绝全部请求</li>\n</ul>\n</li>\n<li><strong>动态窗口</strong>：<ul>\n<li>静态的升级, 通过 <strong>滑动窗口(动态时间内)</strong> 动态调整限流阈值，更加灵活应对流量波动。</li>\n<li><strong>计算开销较大</strong>，每次请求都需要计算滑动窗口内的请求总数。</li>\n<li>可以使用 <strong>滑动窗口限流</strong> 进行灵活控制，避免了静态窗口带来的流量爆发问题</li>\n</ul>\n</li>\n<li><strong>漏桶算法</strong>：<ul>\n<li><strong>控制每秒的最大访问请求</strong>，<strong>超过阈值的新请求</strong>会加入队列排队等待，队列慢了就丢弃</li>\n<li><strong>有请求丢失问题, 将突发性请求变均匀</strong></li>\n</ul>\n</li>\n<li><strong>令牌桶算法</strong>：<ul>\n<li>令牌桶算法与漏桶相似，但其<strong>令牌发放速率是可调的</strong>。请求必须先获取一个令牌才能执行操作，桶内的令牌数量有限(容量可控)。<strong>当令牌数量为零时，新的请求被拒绝</strong></li>\n<li><strong>可能出现令牌空缺</strong>，如果令牌速度过慢，短时间内可能会有大量请求被拒绝(<strong>流量突增</strong>)</li>\n</ul>\n</li>\n<li><strong>令牌大闸</strong>：<ul>\n<li>这是对令牌桶算法的扩展，采用了一个令牌池的管理机制，对令牌进行更加精细的控制<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3></li>\n</ul>\n</li>\n<li>概念: 对<strong>URL</strong>或<strong>请求方法</strong>进行 <strong>QPS</strong> 或<strong>并发线程数</strong>的限制</li>\n<li>核心原则<ul>\n<li>资源命名：建议为受保护资源自定义名称，避免直接使用请求路径作为资源名<ul>\n<li><strong>@SentinelResource(value = “saveOrder”, blockHandler = “flowExceptionHandle”)</strong></li>\n</ul>\n</li>\n<li>限流类型：<ul>\n<li><strong>整体限流</strong>：对所有请求线程统一进行限流判断。</li>\n<li><strong>条件限流</strong>：在业务代码中对请求线程做条件判断后，再进行限流。</li>\n</ul>\n</li>\n<li>降级策略：<ul>\n<li>当请求被限流时，可自定义降级处理逻辑，提供一个兜底信息, 确保用户体验不至于完全断裂。</li>\n<li>限流模式（令牌桶或漏桶）Sentinel 使用滑动窗口限流算法来实现限流。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>流控效果:<ul>\n<li><strong>快速失败(默认)</strong><ul>\n<li>请求一旦超过限制，<strong>立即被拒绝并返回错误</strong>，不做排队处理。</li>\n<li>优点：响应迅速，占用资源少。</li>\n<li>适用场景：对响应时间敏感的服务。</li>\n</ul>\n</li>\n<li><strong>预热（Warm Up）</strong><ul>\n<li>用于处理系统冷启动时的流量激增问题。</li>\n<li>设置一个预热时长，在该时段内限制<strong>通过速率逐渐上升</strong>，避免服务刚启动就被压垮。</li>\n<li>适用场景：需要冷启动保护的服务（如定时任务、大促活动前）。</li>\n</ul>\n</li>\n<li><strong>排队等待（Rate Limiter + Queueing）</strong><ul>\n<li>请求超过阈值后，不立即拒绝，而是进入队列排队，等待处理。</li>\n<li>可配置最大等待时间。</li>\n<li>适用场景：允许延迟、但希望<strong>尽量不丢请求</strong>的业务（如订单处理、消息投递）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>流控模式（控制维度）</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>QPS 限流</strong></td>\n<td>基于单位时间内的请求次数（Queries Per Second）进行控制。超出后按照所选流控效果处理。</td>\n</tr>\n<tr>\n<td><strong>并发线程数限流</strong></td>\n<td>控制同时处理请求的线程数，适用于资源敏感的场景。</td>\n</tr>\n<tr>\n<td><strong>链路限流（链路调用链控制）</strong></td>\n<td>对指定调用链上的某一资源进行限流，精细控制调用路径下的热点资源。</td>\n</tr>\n<tr>\n<td><strong>参数限流（热点参数限流）</strong></td>\n<td>根据请求参数的值进行限流，常用于热点资源防护，例如某商品ID请求频繁。</td>\n</tr>\n<tr>\n<td><strong>自定义条件限流</strong></td>\n<td>可以结合业务标签或特定字段实现动态限流策略。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"熔断\"><a href=\"#熔断\" class=\"headerlink\" title=\"熔断\"></a>熔断</h3><ul>\n<li>概念: <strong>当某个服务出现故障或异常时，服务熔断可以快速隔离该服务，确保系统稳定可用</strong></li>\n<li>核心原则:<ul>\n<li>类型<ul>\n<li><strong>慢调用比例</strong>: 如果调用<strong>响应时间</strong>过长，触发熔断</li>\n<li><strong>异常比例</strong>: 根据一定窗口时间出现异常的比例来判断是否熔断</li>\n<li><strong>异常数</strong>: 根据一定窗口时间出现异常的数量来判断是否熔断</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>注解保护资源 <strong>@SentinelResource(value = “GET:/api/hello”, fallback = “fallback”)</strong></li>\n<li><strong>熔断降级</strong>: 其实跟限流降级是一样的, 都是在触发限流和熔断的情况下提供兜底方案, 自定义异常信息或者返回信息</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>resource</code></td>\n<td>熔断作用的资源名（建议自定义）</td>\n</tr>\n<tr>\n<td><code>grade</code></td>\n<td>熔断类型（上面 0/1/2）</td>\n</tr>\n<tr>\n<td><code>count</code></td>\n<td>根据类型不同表示不同含义：  <br>• 慢调用：阈值响应时间（ms）  <br>• 异常比例：最大异常比例（如 0.3）  <br>• 异常数：最大异常数</td>\n</tr>\n<tr>\n<td><code>minRequestAmount</code></td>\n<td>最小请求数，达到该数量后才会触发熔断</td>\n</tr>\n<tr>\n<td><code>slowRatioThreshold</code></td>\n<td>慢调用比例阈值（仅适用于慢调用类型）</td>\n</tr>\n<tr>\n<td><code>timeWindow</code></td>\n<td>熔断时长（单位：秒）</td>\n</tr>\n<tr>\n<td><code>statIntervalMs</code></td>\n<td>统计时间窗口（毫秒）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"限流和熔断的区别\"><a href=\"#限流和熔断的区别\" class=\"headerlink\" title=\"限流和熔断的区别\"></a>限流和熔断的区别</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>限流（Rate Limiting）</th>\n<th>熔断（Circuit Breaking）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>目的</td>\n<td><strong>保护服务</strong>不被突发高流量压垮</td>\n<td><strong>阻断不稳定下游服务</strong>，防止故障放大</td>\n</tr>\n<tr>\n<td>适用对象</td>\n<td>通常是对<strong>入口请求</strong>做控制（如接口访问、用户请求）</td>\n<td>通常是对<strong>服务间调用</strong>（如微服务 A → B）做保护</td>\n</tr>\n<tr>\n<td>判断依据</td>\n<td>请求的 <strong>QPS（每秒请求数）</strong> 或 <strong>并发线程数</strong></td>\n<td>请求的 <strong>响应时间</strong>、<strong>异常比例、异常数</strong></td>\n</tr>\n<tr>\n<td>行为</td>\n<td>达到阈值时：  <br>拒绝请求 或  排队等待</td>\n<td>达到阈值时：  <br>快速失败，不再发请求给下游</td>\n</tr>\n<tr>\n<td>响应模式</td>\n<td>通常立即返回或等待排队</td>\n<td>熔断期间直接走 fallback</td>\n</tr>\n<tr>\n<td>核心指标</td>\n<td>- QPS  <br>- 并发线程数  <br>- 排队时间</td>\n<td>- 异常比例  <br>- 异常数  <br>- 慢调用比例</td>\n</tr>\n<tr>\n<td>常见应用</td>\n<td>API 网关限流、用户行为限流、热点接口保护</td>\n<td>微服务之间的调用、远程调用超时/不稳定保护</td>\n</tr>\n<tr>\n<td>配置方式（Sentinel）</td>\n<td>流控规则（FlowRule）</td>\n<td>熔断规则（DegradeRule）</td>\n</tr>\n<tr>\n<td>是否允许重试</td>\n<td>可以（排队模式）</td>\n<td>不允许（熔断期直接失败）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"注意-1\"><a href=\"#注意-1\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ul>\n<li>跟seata一样, 发生异常时被自定义异常处理器处理, 那么就不会被sentinel认为发生了异常(因为响应头的status是200), 也就不会进入降级的逻辑 </li>\n<li>当某个服务出现故障或异常时，服务熔断可以快速隔离该服务</li>\n<li>当系统出现异常情况时，服务降级会主动屏蔽一些非核心或可选的功能，而只提供最基本的功能,当服务熔断打开时，Hystrix 可以提供一个备用的降级方法或返回默认值，以保证系统继续正常运行。开发者可以定义降级逻辑，例如返回缓存数据、执行简化的逻辑或调用其他可靠的服务</li>\n<li>线程池隔离：Hystrix, Sentinel, Feign将每个依赖服务的请求都放在独立的线程池中执行，避免因某个服务的故障导致整个系统的线程资源耗尽。通过线程池隔离，可以提高系统的稳定性和可用性。<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412622159201741262214989.png\" alt=\"17412622159201741262214989.png|700x406\"><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412624199221741262419741.png\" alt=\"17412624199221741262419741.png\"></li>\n</ul>\n"},{"title":"会话存储技术","date":"2024-12-28T10:16:14.000Z","_content":"\n# 会话存储技术\n\n## 本地/会话存储\n\n| 对比维度           | `localStorage`                                                 | `sessionStorage`                                                  |\n| -------------- | -------------------------------------------------------------- | ----------------------------------------------------------------- |\n| **存储方式**       | 键值对（Key-Value）                                                 | 键值对（Key-Value）                                                    |\n| **容量限制**       | 一般为 **5MB**                                                    | 一般为 **5MB**                                                       |\n| **生命周期**       | 持久存储，除非手动清除或代码删除，否则长期存在                                        | 仅在 **当前标签页/会话** 存活，关闭标签页即清除                                       |\n| **作用范围**       | 同源下的所有窗口和标签页共享                                                 | 仅限当前标签页，不能跨窗口共享                                                   |\n| **是否随请求自动发送**  | ❌ 不会                                                           | ❌ 不会                                                              |\n| **是否可被 JS 访问** | ✅ 可以（易受 **XSS** 攻击）                                            | ✅ 可以（易受 **XSS** 攻击）                                               |\n| **安全性**        | 数据明文存储，无加密，容易被 XSS 读取                                          | 数据明文存储，无加密，容易被 XSS 读取                                             |\n| **适用场景**       | - 长期保存用户登录状态（token，除非安全要求高）- 长期保存用户配置（比如主题、语言偏好）- 防止页面刷新导致数据丢失 | - 保存一次会话内的临时数据（表单数据、步骤状态）- 用户信息（userInfo）- 缓存静态 HTML 或请求结果以减少重复请求 |\n| **清除方式**       | 手动清除缓存 / JS 调用 `localStorage.clear()` 或 `removeItem()`         | 关闭标签页 / JS 调用 `sessionStorage.clear()` 或 `removeItem()`           |\n\n## Cookie存储\n- **特点**：\n  - 每次 HTTP 请求时自动携带到服务器。\n  - 数据存储大小限制约为 4KB, 容量较小\n  - 支持设置过期时间，数据可以是会话级别(也就是Session级别)或持久化。\n  - 支持 `HttpOnly` 和 `Secure` 标志以提升安全性。\n  - 用户身份验证（如存储登录标识: token）->> 用cookie存储token易受csrf攻击\n\n![17353826990101735382698082.png|701x412](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17353826990101735382698082.png)\n## Session\n- Session的存储离不开Cookie, 都是依存于请求头的\n\n| 维度         | 内容                                                                                                                    |\n| ---------- | --------------------------------------------------------------------------------------------------------------------- |\n| **存储位置**   | 服务器端（内存、文件或外部存储如 Redis）                                                                                               |\n| **标识方式**   | **Session ID**，通常存储在 **Cookie** 中，也可通过 URL 参数传递                                                                       |\n| **生命周期**   | 与用户会话相关：- 用户关闭浏览器- 会话超时- 手动销毁- 后端心跳检测                                                                                 |\n| **客户端依赖**  | 客户端必须携带 Session ID 才能与服务器匹配会话数据                                                                                       |\n| **数据存储容量** | 存储在服务器端，用户量大时可能占用大量内存或存储                                                                                              |\n| **安全性**    | 数据不暴露在客户端（比 localStorage/cookie 安全），但 Session ID 泄露可能导致会话劫持                                                           |\n| **分布式处理**  | - **Sticky Session（ip_hash）**：请求固定路由到同一服务器- **Session 复制**：多服务器同步 Session 数据- **集中式存储（Redis）**：所有服务器统一访问同一 Session 存储 |\n### 工作原理(Websocket)\n1. **首次访问**\n    - 服务器生成唯一 **Session ID**。\n    - 返回客户端，通常放在 Cookie 中：`Set-Cookie: JSESSIONID=xxx; Path=/; HttpOnly`。\n    - 服务器将 Session 数据存入 `SessionMap` 或 Redis。\n2. **后续请求**\n    - 客户端自动携带 **Session ID**（Cookie 或 URL）。\n    - 服务器通过 `SessionMap.get(SessionID)` 获取对应会话数据。\n    - 可以读取或更新会话数据。\n3. **更新 & 销毁**\n    - 开发者可向会话存储数据。\n    - 会话超时或用户登出时，服务器清理会话数据。\n## Session和Cookie的区别\n- 作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。\n- 存取方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等。\n- 有效期不同，Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。\n- 隐私策略不同，Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些。\n- 存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。\n\n![17353838920091735383891446.png|700x276](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17353838920091735383891446.png)\n","source":"_posts/SessionCookie.md","raw":"---\ntitle: 会话存储技术\ntags:\n  - session\n  - cookie\ncategories: 编程\ndate: 2024-12-28 18:16:14\n---\n\n# 会话存储技术\n\n## 本地/会话存储\n\n| 对比维度           | `localStorage`                                                 | `sessionStorage`                                                  |\n| -------------- | -------------------------------------------------------------- | ----------------------------------------------------------------- |\n| **存储方式**       | 键值对（Key-Value）                                                 | 键值对（Key-Value）                                                    |\n| **容量限制**       | 一般为 **5MB**                                                    | 一般为 **5MB**                                                       |\n| **生命周期**       | 持久存储，除非手动清除或代码删除，否则长期存在                                        | 仅在 **当前标签页/会话** 存活，关闭标签页即清除                                       |\n| **作用范围**       | 同源下的所有窗口和标签页共享                                                 | 仅限当前标签页，不能跨窗口共享                                                   |\n| **是否随请求自动发送**  | ❌ 不会                                                           | ❌ 不会                                                              |\n| **是否可被 JS 访问** | ✅ 可以（易受 **XSS** 攻击）                                            | ✅ 可以（易受 **XSS** 攻击）                                               |\n| **安全性**        | 数据明文存储，无加密，容易被 XSS 读取                                          | 数据明文存储，无加密，容易被 XSS 读取                                             |\n| **适用场景**       | - 长期保存用户登录状态（token，除非安全要求高）- 长期保存用户配置（比如主题、语言偏好）- 防止页面刷新导致数据丢失 | - 保存一次会话内的临时数据（表单数据、步骤状态）- 用户信息（userInfo）- 缓存静态 HTML 或请求结果以减少重复请求 |\n| **清除方式**       | 手动清除缓存 / JS 调用 `localStorage.clear()` 或 `removeItem()`         | 关闭标签页 / JS 调用 `sessionStorage.clear()` 或 `removeItem()`           |\n\n## Cookie存储\n- **特点**：\n  - 每次 HTTP 请求时自动携带到服务器。\n  - 数据存储大小限制约为 4KB, 容量较小\n  - 支持设置过期时间，数据可以是会话级别(也就是Session级别)或持久化。\n  - 支持 `HttpOnly` 和 `Secure` 标志以提升安全性。\n  - 用户身份验证（如存储登录标识: token）->> 用cookie存储token易受csrf攻击\n\n![17353826990101735382698082.png|701x412](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17353826990101735382698082.png)\n## Session\n- Session的存储离不开Cookie, 都是依存于请求头的\n\n| 维度         | 内容                                                                                                                    |\n| ---------- | --------------------------------------------------------------------------------------------------------------------- |\n| **存储位置**   | 服务器端（内存、文件或外部存储如 Redis）                                                                                               |\n| **标识方式**   | **Session ID**，通常存储在 **Cookie** 中，也可通过 URL 参数传递                                                                       |\n| **生命周期**   | 与用户会话相关：- 用户关闭浏览器- 会话超时- 手动销毁- 后端心跳检测                                                                                 |\n| **客户端依赖**  | 客户端必须携带 Session ID 才能与服务器匹配会话数据                                                                                       |\n| **数据存储容量** | 存储在服务器端，用户量大时可能占用大量内存或存储                                                                                              |\n| **安全性**    | 数据不暴露在客户端（比 localStorage/cookie 安全），但 Session ID 泄露可能导致会话劫持                                                           |\n| **分布式处理**  | - **Sticky Session（ip_hash）**：请求固定路由到同一服务器- **Session 复制**：多服务器同步 Session 数据- **集中式存储（Redis）**：所有服务器统一访问同一 Session 存储 |\n### 工作原理(Websocket)\n1. **首次访问**\n    - 服务器生成唯一 **Session ID**。\n    - 返回客户端，通常放在 Cookie 中：`Set-Cookie: JSESSIONID=xxx; Path=/; HttpOnly`。\n    - 服务器将 Session 数据存入 `SessionMap` 或 Redis。\n2. **后续请求**\n    - 客户端自动携带 **Session ID**（Cookie 或 URL）。\n    - 服务器通过 `SessionMap.get(SessionID)` 获取对应会话数据。\n    - 可以读取或更新会话数据。\n3. **更新 & 销毁**\n    - 开发者可向会话存储数据。\n    - 会话超时或用户登出时，服务器清理会话数据。\n## Session和Cookie的区别\n- 作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。\n- 存取方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等。\n- 有效期不同，Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。\n- 隐私策略不同，Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些。\n- 存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。\n\n![17353838920091735383891446.png|700x276](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17353838920091735383891446.png)\n","slug":"SessionCookie","published":1,"updated":"2025-09-10T04:26:47.619Z","comments":1,"layout":"post","photos":[],"_id":"cmfw4z09q000tuomwgy2wh6rs","content":"<h1 id=\"会话存储技术\"><a href=\"#会话存储技术\" class=\"headerlink\" title=\"会话存储技术\"></a>会话存储技术</h1><h2 id=\"本地-会话存储\"><a href=\"#本地-会话存储\" class=\"headerlink\" title=\"本地/会话存储\"></a>本地/会话存储</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th><code>localStorage</code></th>\n<th><code>sessionStorage</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存储方式</strong></td>\n<td>键值对（Key-Value）</td>\n<td>键值对（Key-Value）</td>\n</tr>\n<tr>\n<td><strong>容量限制</strong></td>\n<td>一般为 <strong>5MB</strong></td>\n<td>一般为 <strong>5MB</strong></td>\n</tr>\n<tr>\n<td><strong>生命周期</strong></td>\n<td>持久存储，除非手动清除或代码删除，否则长期存在</td>\n<td>仅在 <strong>当前标签页/会话</strong> 存活，关闭标签页即清除</td>\n</tr>\n<tr>\n<td><strong>作用范围</strong></td>\n<td>同源下的所有窗口和标签页共享</td>\n<td>仅限当前标签页，不能跨窗口共享</td>\n</tr>\n<tr>\n<td><strong>是否随请求自动发送</strong></td>\n<td>❌ 不会</td>\n<td>❌ 不会</td>\n</tr>\n<tr>\n<td><strong>是否可被 JS 访问</strong></td>\n<td>✅ 可以（易受 <strong>XSS</strong> 攻击）</td>\n<td>✅ 可以（易受 <strong>XSS</strong> 攻击）</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>数据明文存储，无加密，容易被 XSS 读取</td>\n<td>数据明文存储，无加密，容易被 XSS 读取</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>- 长期保存用户登录状态（token，除非安全要求高）- 长期保存用户配置（比如主题、语言偏好）- 防止页面刷新导致数据丢失</td>\n<td>- 保存一次会话内的临时数据（表单数据、步骤状态）- 用户信息（userInfo）- 缓存静态 HTML 或请求结果以减少重复请求</td>\n</tr>\n<tr>\n<td><strong>清除方式</strong></td>\n<td>手动清除缓存 / JS 调用 <code>localStorage.clear()</code> 或 <code>removeItem()</code></td>\n<td>关闭标签页 / JS 调用 <code>sessionStorage.clear()</code> 或 <code>removeItem()</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"Cookie存储\"><a href=\"#Cookie存储\" class=\"headerlink\" title=\"Cookie存储\"></a>Cookie存储</h2><ul>\n<li><strong>特点</strong>：<ul>\n<li>每次 HTTP 请求时自动携带到服务器。</li>\n<li>数据存储大小限制约为 4KB, 容量较小</li>\n<li>支持设置过期时间，数据可以是会话级别(也就是Session级别)或持久化。</li>\n<li>支持 <code>HttpOnly</code> 和 <code>Secure</code> 标志以提升安全性。</li>\n<li>用户身份验证（如存储登录标识: token）-&gt;&gt; 用cookie存储token易受csrf攻击</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17353826990101735382698082.png\" alt=\"17353826990101735382698082.png|701x412\"></p>\n<h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><ul>\n<li>Session的存储离不开Cookie, 都是依存于请求头的</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存储位置</strong></td>\n<td>服务器端（内存、文件或外部存储如 Redis）</td>\n</tr>\n<tr>\n<td><strong>标识方式</strong></td>\n<td><strong>Session ID</strong>，通常存储在 <strong>Cookie</strong> 中，也可通过 URL 参数传递</td>\n</tr>\n<tr>\n<td><strong>生命周期</strong></td>\n<td>与用户会话相关：- 用户关闭浏览器- 会话超时- 手动销毁- 后端心跳检测</td>\n</tr>\n<tr>\n<td><strong>客户端依赖</strong></td>\n<td>客户端必须携带 Session ID 才能与服务器匹配会话数据</td>\n</tr>\n<tr>\n<td><strong>数据存储容量</strong></td>\n<td>存储在服务器端，用户量大时可能占用大量内存或存储</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>数据不暴露在客户端（比 localStorage/cookie 安全），但 Session ID 泄露可能导致会话劫持</td>\n</tr>\n<tr>\n<td><strong>分布式处理</strong></td>\n<td>- <strong>Sticky Session（ip_hash）</strong>：请求固定路由到同一服务器- <strong>Session 复制</strong>：多服务器同步 Session 数据- <strong>集中式存储（Redis）</strong>：所有服务器统一访问同一 Session 存储</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"工作原理-Websocket\"><a href=\"#工作原理-Websocket\" class=\"headerlink\" title=\"工作原理(Websocket)\"></a>工作原理(Websocket)</h3><ol>\n<li><strong>首次访问</strong><ul>\n<li>服务器生成唯一 <strong>Session ID</strong>。</li>\n<li>返回客户端，通常放在 Cookie 中：<code>Set-Cookie: JSESSIONID=xxx; Path=/; HttpOnly</code>。</li>\n<li>服务器将 Session 数据存入 <code>SessionMap</code> 或 Redis。</li>\n</ul>\n</li>\n<li><strong>后续请求</strong><ul>\n<li>客户端自动携带 <strong>Session ID</strong>（Cookie 或 URL）。</li>\n<li>服务器通过 <code>SessionMap.get(SessionID)</code> 获取对应会话数据。</li>\n<li>可以读取或更新会话数据。</li>\n</ul>\n</li>\n<li><strong>更新 &amp; 销毁</strong><ul>\n<li>开发者可向会话存储数据。</li>\n<li>会话超时或用户登出时，服务器清理会话数据。<h2 id=\"Session和Cookie的区别\"><a href=\"#Session和Cookie的区别\" class=\"headerlink\" title=\"Session和Cookie的区别\"></a>Session和Cookie的区别</h2></li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。</li>\n<li>存取方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等。</li>\n<li>有效期不同，Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。</li>\n<li>隐私策略不同，Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些。</li>\n<li>存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17353838920091735383891446.png\" alt=\"17353838920091735383891446.png|700x276\"></p>\n","cover":"/img/3.png","cover_type":"img","excerpt":"","more":"<h1 id=\"会话存储技术\"><a href=\"#会话存储技术\" class=\"headerlink\" title=\"会话存储技术\"></a>会话存储技术</h1><h2 id=\"本地-会话存储\"><a href=\"#本地-会话存储\" class=\"headerlink\" title=\"本地/会话存储\"></a>本地/会话存储</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th><code>localStorage</code></th>\n<th><code>sessionStorage</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存储方式</strong></td>\n<td>键值对（Key-Value）</td>\n<td>键值对（Key-Value）</td>\n</tr>\n<tr>\n<td><strong>容量限制</strong></td>\n<td>一般为 <strong>5MB</strong></td>\n<td>一般为 <strong>5MB</strong></td>\n</tr>\n<tr>\n<td><strong>生命周期</strong></td>\n<td>持久存储，除非手动清除或代码删除，否则长期存在</td>\n<td>仅在 <strong>当前标签页/会话</strong> 存活，关闭标签页即清除</td>\n</tr>\n<tr>\n<td><strong>作用范围</strong></td>\n<td>同源下的所有窗口和标签页共享</td>\n<td>仅限当前标签页，不能跨窗口共享</td>\n</tr>\n<tr>\n<td><strong>是否随请求自动发送</strong></td>\n<td>❌ 不会</td>\n<td>❌ 不会</td>\n</tr>\n<tr>\n<td><strong>是否可被 JS 访问</strong></td>\n<td>✅ 可以（易受 <strong>XSS</strong> 攻击）</td>\n<td>✅ 可以（易受 <strong>XSS</strong> 攻击）</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>数据明文存储，无加密，容易被 XSS 读取</td>\n<td>数据明文存储，无加密，容易被 XSS 读取</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>- 长期保存用户登录状态（token，除非安全要求高）- 长期保存用户配置（比如主题、语言偏好）- 防止页面刷新导致数据丢失</td>\n<td>- 保存一次会话内的临时数据（表单数据、步骤状态）- 用户信息（userInfo）- 缓存静态 HTML 或请求结果以减少重复请求</td>\n</tr>\n<tr>\n<td><strong>清除方式</strong></td>\n<td>手动清除缓存 / JS 调用 <code>localStorage.clear()</code> 或 <code>removeItem()</code></td>\n<td>关闭标签页 / JS 调用 <code>sessionStorage.clear()</code> 或 <code>removeItem()</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"Cookie存储\"><a href=\"#Cookie存储\" class=\"headerlink\" title=\"Cookie存储\"></a>Cookie存储</h2><ul>\n<li><strong>特点</strong>：<ul>\n<li>每次 HTTP 请求时自动携带到服务器。</li>\n<li>数据存储大小限制约为 4KB, 容量较小</li>\n<li>支持设置过期时间，数据可以是会话级别(也就是Session级别)或持久化。</li>\n<li>支持 <code>HttpOnly</code> 和 <code>Secure</code> 标志以提升安全性。</li>\n<li>用户身份验证（如存储登录标识: token）-&gt;&gt; 用cookie存储token易受csrf攻击</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17353826990101735382698082.png\" alt=\"17353826990101735382698082.png|701x412\"></p>\n<h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><ul>\n<li>Session的存储离不开Cookie, 都是依存于请求头的</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>维度</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存储位置</strong></td>\n<td>服务器端（内存、文件或外部存储如 Redis）</td>\n</tr>\n<tr>\n<td><strong>标识方式</strong></td>\n<td><strong>Session ID</strong>，通常存储在 <strong>Cookie</strong> 中，也可通过 URL 参数传递</td>\n</tr>\n<tr>\n<td><strong>生命周期</strong></td>\n<td>与用户会话相关：- 用户关闭浏览器- 会话超时- 手动销毁- 后端心跳检测</td>\n</tr>\n<tr>\n<td><strong>客户端依赖</strong></td>\n<td>客户端必须携带 Session ID 才能与服务器匹配会话数据</td>\n</tr>\n<tr>\n<td><strong>数据存储容量</strong></td>\n<td>存储在服务器端，用户量大时可能占用大量内存或存储</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>数据不暴露在客户端（比 localStorage/cookie 安全），但 Session ID 泄露可能导致会话劫持</td>\n</tr>\n<tr>\n<td><strong>分布式处理</strong></td>\n<td>- <strong>Sticky Session（ip_hash）</strong>：请求固定路由到同一服务器- <strong>Session 复制</strong>：多服务器同步 Session 数据- <strong>集中式存储（Redis）</strong>：所有服务器统一访问同一 Session 存储</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"工作原理-Websocket\"><a href=\"#工作原理-Websocket\" class=\"headerlink\" title=\"工作原理(Websocket)\"></a>工作原理(Websocket)</h3><ol>\n<li><strong>首次访问</strong><ul>\n<li>服务器生成唯一 <strong>Session ID</strong>。</li>\n<li>返回客户端，通常放在 Cookie 中：<code>Set-Cookie: JSESSIONID=xxx; Path=/; HttpOnly</code>。</li>\n<li>服务器将 Session 数据存入 <code>SessionMap</code> 或 Redis。</li>\n</ul>\n</li>\n<li><strong>后续请求</strong><ul>\n<li>客户端自动携带 <strong>Session ID</strong>（Cookie 或 URL）。</li>\n<li>服务器通过 <code>SessionMap.get(SessionID)</code> 获取对应会话数据。</li>\n<li>可以读取或更新会话数据。</li>\n</ul>\n</li>\n<li><strong>更新 &amp; 销毁</strong><ul>\n<li>开发者可向会话存储数据。</li>\n<li>会话超时或用户登出时，服务器清理会话数据。<h2 id=\"Session和Cookie的区别\"><a href=\"#Session和Cookie的区别\" class=\"headerlink\" title=\"Session和Cookie的区别\"></a>Session和Cookie的区别</h2></li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。</li>\n<li>存取方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等。</li>\n<li>有效期不同，Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。</li>\n<li>隐私策略不同，Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些。</li>\n<li>存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17353838920091735383891446.png\" alt=\"17353838920091735383891446.png|700x276\"></p>\n"},{"banner":"[[pixel-banner-image.png]]","title":"SpringSecurity权限校验框架","date":"2025-09-09T13:05:00.000Z","_content":"\n\t没有永远的朋友,只有永远的利益\n# SpringSecurity\n## 安全框架\n- 是一个**对用户进行认证和授权的框架**, 类似的还有像Shrio框架等等\n- 认证:  就是 对来访者进行**登陆校验和后面的认证校验**; \n- 授权:  是对用户的操作进行**权限校验**\n- 其实认证的底层其实是**过滤器链的调用**, 使用了提供各种功能的过滤器: 核心过滤器链有\n\t- **UsernamePasswordAuthenticationFilter**: 处理填写账号密码后的登陆逻辑\n\t- **CsrfFilter**: 处理跨域问题的过滤器\n\t- **ExceptionTranslationFilter**: 处理过滤器链中发生的任何异常\n\t- **FilterSecurityInterceptor**: 负责权限校验的过滤器\n\n## 认证流程\n### 概念理解\n- **Authentication接口**: 它的实现类UsernamePasswordAuthenticationToken，表示当前访问系统的用户，封装了用户名和密码.\n- **AuthenticationManager接口**：定义了认证Authentication的方法叫authenticate\n- **UserDetailsService接口**：加载用户特定数据的核心接口。UserDetailsServiceImpl里面定义了一个根据用户名查询用户信息的方法loadUserByUsername。\n- **UserDetails接口**：用户实体类接口。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回通过用 LoginUser implements UserDetails。然后将这些信息封装到Authentication对象中。LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n### 分类\n- **登陆校验**: 用户首次点击登陆按钮之后的登陆操作\n- **后续校验**: 用户在首次登陆后不需要每次都进行登陆校验, 只需要保存登陆凭证Token即可\n### 流程\n- 登陆: 也就是首次登陆时的进行的校验, 校验通过生成JWT令牌, 并将令牌存入Redis, 除此之外, 定义了一个UserDetailsService, 在这个实现类中去查询数据库\n- 认证: 之后不需要每次都进行登陆校验, 只需要对Redis中的JWT令牌做校验就行, 使用userid去redis中获取对应的LoginUser对象, 然后**封装Authentication对象存入SecurityContextHolder,** 所以需要一个认证过滤器做这些事\n## 授权流程\n### 概念理解\n- 在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作\n- ​ **RBAC权限模型**（Role-Based Access Control）即：**基于角色的权限控制**。\n### 流程\n- 使用默认的**FilterSecurityInterceptor**来进行权限校验\n- 在FilterSecurityInterceptor中会**从SecurityContextHolder获取其中的Authentication**，然后获取其中的权限信息\n- 在项目中需要把当前登录用户的权限信息也存入Authentication\n- 所以权限的查询是在UserDetailsService的loadUserByUsername方法中查到的\n### 注解使用\n- 使用@PreAuthorize注解，它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中\n## 异常处理\n- 认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json\n- 出现了异常会被**ExceptionTranslationFilter**捕获到\n- 如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。\n- ​ 如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。\n- ​ 所以如果我们需要**自定义异常处理**，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可\n## CSRF攻击\n### 概念理解\n- 用户正常登陆网站a, 登陆成功后有一个只允许a访问的cookie, 只要cookie不失效, 在这个期间就可以携带cookie正常访问网站a\n- 但是用户也登陆了网站b, 也有一个b的cookie, 在访问b的过程中有一个指向a的资源跳转, **使得用户携带a的cookie在不知情的情况下去访问a获取资源**, 这就是CSRF攻击\n- CSRF攻击防御的重点是利用cookie的值只能被第一方读取，无法读取第三方的cookie值。这上面的案例中再b网站中去访问a网站, b网站的cookie就是第一方cookie\n### 防御手段\n1. 验证 HTTP **Referer** 字段(来源网站)\n2. ​ SpringSecurity去防止CSRF攻击的方式就是通过**csrf_token**。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问\n3. 在HTTP头中自定义属性并验证；\n4. Chrome 浏览器端启用 **SameSite cookie**\n\n- 总结: **CSRF攻击依靠的是cookie中所携带的认证信息。以前的项目是把token存储在cookie中, 请求时自动携带, 现在的项目都是存储在本地/会话存储中, 并且在请求的时候是手动设置token到请求头中, 所以没有csrf攻击的可能性**\n## XSS攻击\n### 概念理解\n- 跟SQL注入有点类似, 两者都是把“攻击载荷”塞进应用的数据流中，最后在不该执行的地方被执行\n### SQL注入\n- 什么是SQL注入: SQL 注入是攻击者把恶意的 SQL 代码作为输入注入到应用中，使数据库在未经预期的情况下执行这些语句\n\t- `' OR '1'='1` —— 常见的“总是真”的条件，用来绕过认证（示意）\n\t- `'; DROP TABLE users; --` —— 示例说明拼接带来的风险（危险且破坏性强）\n- 但是我们现在的数据库都是采用预编译语句, 所有不用担心SQL注入\n### XSS\n- 当带有js攻击脚本的评论被存储到数据库中时, 读取评论列表可能会有这条带有攻击的评论, 前端在进行数据展示的时候如果没有防护的话, 这段js代码就会把恶意执行造成攻击\n- 如何应对 XSS 攻击?\n\t- 对输入进行过滤，过滤标签等，只允许合法值。\n\t- HTML 转义\n\t- 对于链接跳转，如`<a href=\"xxx\"` >等，要校验内容，禁止以 script 开头的非法链接。\n\t- 限制输入长度","source":"_posts/SpringSecurity.md","raw":"---\nbanner: \"[[pixel-banner-image.png]]\"\ntitle: SpringSecurity权限校验框架\ntags:\n  - SpringSecurity\n  - CSRF\n  - XSS\ncategories: 编程\ndate: 2025-09-09T21:05:00\n---\n\n\t没有永远的朋友,只有永远的利益\n# SpringSecurity\n## 安全框架\n- 是一个**对用户进行认证和授权的框架**, 类似的还有像Shrio框架等等\n- 认证:  就是 对来访者进行**登陆校验和后面的认证校验**; \n- 授权:  是对用户的操作进行**权限校验**\n- 其实认证的底层其实是**过滤器链的调用**, 使用了提供各种功能的过滤器: 核心过滤器链有\n\t- **UsernamePasswordAuthenticationFilter**: 处理填写账号密码后的登陆逻辑\n\t- **CsrfFilter**: 处理跨域问题的过滤器\n\t- **ExceptionTranslationFilter**: 处理过滤器链中发生的任何异常\n\t- **FilterSecurityInterceptor**: 负责权限校验的过滤器\n\n## 认证流程\n### 概念理解\n- **Authentication接口**: 它的实现类UsernamePasswordAuthenticationToken，表示当前访问系统的用户，封装了用户名和密码.\n- **AuthenticationManager接口**：定义了认证Authentication的方法叫authenticate\n- **UserDetailsService接口**：加载用户特定数据的核心接口。UserDetailsServiceImpl里面定义了一个根据用户名查询用户信息的方法loadUserByUsername。\n- **UserDetails接口**：用户实体类接口。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回通过用 LoginUser implements UserDetails。然后将这些信息封装到Authentication对象中。LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n### 分类\n- **登陆校验**: 用户首次点击登陆按钮之后的登陆操作\n- **后续校验**: 用户在首次登陆后不需要每次都进行登陆校验, 只需要保存登陆凭证Token即可\n### 流程\n- 登陆: 也就是首次登陆时的进行的校验, 校验通过生成JWT令牌, 并将令牌存入Redis, 除此之外, 定义了一个UserDetailsService, 在这个实现类中去查询数据库\n- 认证: 之后不需要每次都进行登陆校验, 只需要对Redis中的JWT令牌做校验就行, 使用userid去redis中获取对应的LoginUser对象, 然后**封装Authentication对象存入SecurityContextHolder,** 所以需要一个认证过滤器做这些事\n## 授权流程\n### 概念理解\n- 在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作\n- ​ **RBAC权限模型**（Role-Based Access Control）即：**基于角色的权限控制**。\n### 流程\n- 使用默认的**FilterSecurityInterceptor**来进行权限校验\n- 在FilterSecurityInterceptor中会**从SecurityContextHolder获取其中的Authentication**，然后获取其中的权限信息\n- 在项目中需要把当前登录用户的权限信息也存入Authentication\n- 所以权限的查询是在UserDetailsService的loadUserByUsername方法中查到的\n### 注解使用\n- 使用@PreAuthorize注解，它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中\n## 异常处理\n- 认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json\n- 出现了异常会被**ExceptionTranslationFilter**捕获到\n- 如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。\n- ​ 如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。\n- ​ 所以如果我们需要**自定义异常处理**，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可\n## CSRF攻击\n### 概念理解\n- 用户正常登陆网站a, 登陆成功后有一个只允许a访问的cookie, 只要cookie不失效, 在这个期间就可以携带cookie正常访问网站a\n- 但是用户也登陆了网站b, 也有一个b的cookie, 在访问b的过程中有一个指向a的资源跳转, **使得用户携带a的cookie在不知情的情况下去访问a获取资源**, 这就是CSRF攻击\n- CSRF攻击防御的重点是利用cookie的值只能被第一方读取，无法读取第三方的cookie值。这上面的案例中再b网站中去访问a网站, b网站的cookie就是第一方cookie\n### 防御手段\n1. 验证 HTTP **Referer** 字段(来源网站)\n2. ​ SpringSecurity去防止CSRF攻击的方式就是通过**csrf_token**。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问\n3. 在HTTP头中自定义属性并验证；\n4. Chrome 浏览器端启用 **SameSite cookie**\n\n- 总结: **CSRF攻击依靠的是cookie中所携带的认证信息。以前的项目是把token存储在cookie中, 请求时自动携带, 现在的项目都是存储在本地/会话存储中, 并且在请求的时候是手动设置token到请求头中, 所以没有csrf攻击的可能性**\n## XSS攻击\n### 概念理解\n- 跟SQL注入有点类似, 两者都是把“攻击载荷”塞进应用的数据流中，最后在不该执行的地方被执行\n### SQL注入\n- 什么是SQL注入: SQL 注入是攻击者把恶意的 SQL 代码作为输入注入到应用中，使数据库在未经预期的情况下执行这些语句\n\t- `' OR '1'='1` —— 常见的“总是真”的条件，用来绕过认证（示意）\n\t- `'; DROP TABLE users; --` —— 示例说明拼接带来的风险（危险且破坏性强）\n- 但是我们现在的数据库都是采用预编译语句, 所有不用担心SQL注入\n### XSS\n- 当带有js攻击脚本的评论被存储到数据库中时, 读取评论列表可能会有这条带有攻击的评论, 前端在进行数据展示的时候如果没有防护的话, 这段js代码就会把恶意执行造成攻击\n- 如何应对 XSS 攻击?\n\t- 对输入进行过滤，过滤标签等，只允许合法值。\n\t- HTML 转义\n\t- 对于链接跳转，如`<a href=\"xxx\"` >等，要校验内容，禁止以 script 开头的非法链接。\n\t- 限制输入长度","slug":"SpringSecurity","published":1,"updated":"2025-11-13T14:50:19.309Z","_id":"cmfw4z09t000xuomwbfv519fg","comments":1,"layout":"post","photos":[],"content":"<pre><code>没有永远的朋友,只有永远的利益\n</code></pre><h1 id=\"SpringSecurity\"><a href=\"#SpringSecurity\" class=\"headerlink\" title=\"SpringSecurity\"></a>SpringSecurity</h1><h2 id=\"安全框架\"><a href=\"#安全框架\" class=\"headerlink\" title=\"安全框架\"></a>安全框架</h2><ul>\n<li>是一个<strong>对用户进行认证和授权的框架</strong>, 类似的还有像Shrio框架等等</li>\n<li>认证:  就是 对来访者进行<strong>登陆校验和后面的认证校验</strong>; </li>\n<li>授权:  是对用户的操作进行<strong>权限校验</strong></li>\n<li>其实认证的底层其实是<strong>过滤器链的调用</strong>, 使用了提供各种功能的过滤器: 核心过滤器链有<ul>\n<li><strong>UsernamePasswordAuthenticationFilter</strong>: 处理填写账号密码后的登陆逻辑</li>\n<li><strong>CsrfFilter</strong>: 处理跨域问题的过滤器</li>\n<li><strong>ExceptionTranslationFilter</strong>: 处理过滤器链中发生的任何异常</li>\n<li><strong>FilterSecurityInterceptor</strong>: 负责权限校验的过滤器</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"认证流程\"><a href=\"#认证流程\" class=\"headerlink\" title=\"认证流程\"></a>认证流程</h2><h3 id=\"概念理解\"><a href=\"#概念理解\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h3><ul>\n<li><strong>Authentication接口</strong>: 它的实现类UsernamePasswordAuthenticationToken，表示当前访问系统的用户，封装了用户名和密码.</li>\n<li><strong>AuthenticationManager接口</strong>：定义了认证Authentication的方法叫authenticate</li>\n<li><strong>UserDetailsService接口</strong>：加载用户特定数据的核心接口。UserDetailsServiceImpl里面定义了一个根据用户名查询用户信息的方法loadUserByUsername。</li>\n<li><strong>UserDetails接口</strong>：用户实体类接口。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回通过用 LoginUser implements UserDetails。然后将这些信息封装到Authentication对象中。LoginUser loginUser = (LoginUser) authenticate.getPrincipal();<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3></li>\n<li><strong>登陆校验</strong>: 用户首次点击登陆按钮之后的登陆操作</li>\n<li><strong>后续校验</strong>: 用户在首次登陆后不需要每次都进行登陆校验, 只需要保存登陆凭证Token即可<h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3></li>\n<li>登陆: 也就是首次登陆时的进行的校验, 校验通过生成JWT令牌, 并将令牌存入Redis, 除此之外, 定义了一个UserDetailsService, 在这个实现类中去查询数据库</li>\n<li>认证: 之后不需要每次都进行登陆校验, 只需要对Redis中的JWT令牌做校验就行, 使用userid去redis中获取对应的LoginUser对象, 然后<strong>封装Authentication对象存入SecurityContextHolder,</strong> 所以需要一个认证过滤器做这些事<h2 id=\"授权流程\"><a href=\"#授权流程\" class=\"headerlink\" title=\"授权流程\"></a>授权流程</h2><h3 id=\"概念理解-1\"><a href=\"#概念理解-1\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h3></li>\n<li>在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作</li>\n<li>​ <strong>RBAC权限模型</strong>（Role-Based Access Control）即：<strong>基于角色的权限控制</strong>。<h3 id=\"流程-1\"><a href=\"#流程-1\" class=\"headerlink\" title=\"流程\"></a>流程</h3></li>\n<li>使用默认的<strong>FilterSecurityInterceptor</strong>来进行权限校验</li>\n<li>在FilterSecurityInterceptor中会<strong>从SecurityContextHolder获取其中的Authentication</strong>，然后获取其中的权限信息</li>\n<li>在项目中需要把当前登录用户的权限信息也存入Authentication</li>\n<li>所以权限的查询是在UserDetailsService的loadUserByUsername方法中查到的<h3 id=\"注解使用\"><a href=\"#注解使用\" class=\"headerlink\" title=\"注解使用\"></a>注解使用</h3></li>\n<li>使用@PreAuthorize注解，它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2></li>\n<li>认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json</li>\n<li>出现了异常会被<strong>ExceptionTranslationFilter</strong>捕获到</li>\n<li>如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。</li>\n<li>​ 如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。</li>\n<li>​ 所以如果我们需要<strong>自定义异常处理</strong>，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可<h2 id=\"CSRF攻击\"><a href=\"#CSRF攻击\" class=\"headerlink\" title=\"CSRF攻击\"></a>CSRF攻击</h2><h3 id=\"概念理解-2\"><a href=\"#概念理解-2\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h3></li>\n<li>用户正常登陆网站a, 登陆成功后有一个只允许a访问的cookie, 只要cookie不失效, 在这个期间就可以携带cookie正常访问网站a</li>\n<li>但是用户也登陆了网站b, 也有一个b的cookie, 在访问b的过程中有一个指向a的资源跳转, <strong>使得用户携带a的cookie在不知情的情况下去访问a获取资源</strong>, 这就是CSRF攻击</li>\n<li>CSRF攻击防御的重点是利用cookie的值只能被第一方读取，无法读取第三方的cookie值。这上面的案例中再b网站中去访问a网站, b网站的cookie就是第一方cookie<h3 id=\"防御手段\"><a href=\"#防御手段\" class=\"headerlink\" title=\"防御手段\"></a>防御手段</h3></li>\n</ul>\n<ol>\n<li>验证 HTTP <strong>Referer</strong> 字段(来源网站)</li>\n<li>​ SpringSecurity去防止CSRF攻击的方式就是通过<strong>csrf_token</strong>。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问</li>\n<li>在HTTP头中自定义属性并验证；</li>\n<li>Chrome 浏览器端启用 <strong>SameSite cookie</strong></li>\n</ol>\n<ul>\n<li>总结: <strong>CSRF攻击依靠的是cookie中所携带的认证信息。以前的项目是把token存储在cookie中, 请求时自动携带, 现在的项目都是存储在本地/会话存储中, 并且在请求的时候是手动设置token到请求头中, 所以没有csrf攻击的可能性</strong><h2 id=\"XSS攻击\"><a href=\"#XSS攻击\" class=\"headerlink\" title=\"XSS攻击\"></a>XSS攻击</h2><h3 id=\"概念理解-3\"><a href=\"#概念理解-3\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h3></li>\n<li>跟SQL注入有点类似, 两者都是把“攻击载荷”塞进应用的数据流中，最后在不该执行的地方被执行<h3 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h3></li>\n<li>什么是SQL注入: SQL 注入是攻击者把恶意的 SQL 代码作为输入注入到应用中，使数据库在未经预期的情况下执行这些语句<ul>\n<li><code>&#39; OR &#39;1&#39;=&#39;1</code> —— 常见的“总是真”的条件，用来绕过认证（示意）</li>\n<li><code>&#39;; DROP TABLE users; --</code> —— 示例说明拼接带来的风险（危险且破坏性强）</li>\n</ul>\n</li>\n<li>但是我们现在的数据库都是采用预编译语句, 所有不用担心SQL注入<h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3></li>\n<li>当带有js攻击脚本的评论被存储到数据库中时, 读取评论列表可能会有这条带有攻击的评论, 前端在进行数据展示的时候如果没有防护的话, 这段js代码就会把恶意执行造成攻击</li>\n<li>如何应对 XSS 攻击?<ul>\n<li>对输入进行过滤，过滤标签等，只允许合法值。</li>\n<li>HTML 转义</li>\n<li>对于链接跳转，如<code>&lt;a href=&quot;xxx&quot;</code> &gt;等，要校验内容，禁止以 script 开头的非法链接。</li>\n<li>限制输入长度</li>\n</ul>\n</li>\n</ul>\n","cover":"/img/4.png","cover_type":"img","excerpt":"","more":"<pre><code>没有永远的朋友,只有永远的利益\n</code></pre><h1 id=\"SpringSecurity\"><a href=\"#SpringSecurity\" class=\"headerlink\" title=\"SpringSecurity\"></a>SpringSecurity</h1><h2 id=\"安全框架\"><a href=\"#安全框架\" class=\"headerlink\" title=\"安全框架\"></a>安全框架</h2><ul>\n<li>是一个<strong>对用户进行认证和授权的框架</strong>, 类似的还有像Shrio框架等等</li>\n<li>认证:  就是 对来访者进行<strong>登陆校验和后面的认证校验</strong>; </li>\n<li>授权:  是对用户的操作进行<strong>权限校验</strong></li>\n<li>其实认证的底层其实是<strong>过滤器链的调用</strong>, 使用了提供各种功能的过滤器: 核心过滤器链有<ul>\n<li><strong>UsernamePasswordAuthenticationFilter</strong>: 处理填写账号密码后的登陆逻辑</li>\n<li><strong>CsrfFilter</strong>: 处理跨域问题的过滤器</li>\n<li><strong>ExceptionTranslationFilter</strong>: 处理过滤器链中发生的任何异常</li>\n<li><strong>FilterSecurityInterceptor</strong>: 负责权限校验的过滤器</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"认证流程\"><a href=\"#认证流程\" class=\"headerlink\" title=\"认证流程\"></a>认证流程</h2><h3 id=\"概念理解\"><a href=\"#概念理解\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h3><ul>\n<li><strong>Authentication接口</strong>: 它的实现类UsernamePasswordAuthenticationToken，表示当前访问系统的用户，封装了用户名和密码.</li>\n<li><strong>AuthenticationManager接口</strong>：定义了认证Authentication的方法叫authenticate</li>\n<li><strong>UserDetailsService接口</strong>：加载用户特定数据的核心接口。UserDetailsServiceImpl里面定义了一个根据用户名查询用户信息的方法loadUserByUsername。</li>\n<li><strong>UserDetails接口</strong>：用户实体类接口。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回通过用 LoginUser implements UserDetails。然后将这些信息封装到Authentication对象中。LoginUser loginUser = (LoginUser) authenticate.getPrincipal();<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3></li>\n<li><strong>登陆校验</strong>: 用户首次点击登陆按钮之后的登陆操作</li>\n<li><strong>后续校验</strong>: 用户在首次登陆后不需要每次都进行登陆校验, 只需要保存登陆凭证Token即可<h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3></li>\n<li>登陆: 也就是首次登陆时的进行的校验, 校验通过生成JWT令牌, 并将令牌存入Redis, 除此之外, 定义了一个UserDetailsService, 在这个实现类中去查询数据库</li>\n<li>认证: 之后不需要每次都进行登陆校验, 只需要对Redis中的JWT令牌做校验就行, 使用userid去redis中获取对应的LoginUser对象, 然后<strong>封装Authentication对象存入SecurityContextHolder,</strong> 所以需要一个认证过滤器做这些事<h2 id=\"授权流程\"><a href=\"#授权流程\" class=\"headerlink\" title=\"授权流程\"></a>授权流程</h2><h3 id=\"概念理解-1\"><a href=\"#概念理解-1\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h3></li>\n<li>在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作</li>\n<li>​ <strong>RBAC权限模型</strong>（Role-Based Access Control）即：<strong>基于角色的权限控制</strong>。<h3 id=\"流程-1\"><a href=\"#流程-1\" class=\"headerlink\" title=\"流程\"></a>流程</h3></li>\n<li>使用默认的<strong>FilterSecurityInterceptor</strong>来进行权限校验</li>\n<li>在FilterSecurityInterceptor中会<strong>从SecurityContextHolder获取其中的Authentication</strong>，然后获取其中的权限信息</li>\n<li>在项目中需要把当前登录用户的权限信息也存入Authentication</li>\n<li>所以权限的查询是在UserDetailsService的loadUserByUsername方法中查到的<h3 id=\"注解使用\"><a href=\"#注解使用\" class=\"headerlink\" title=\"注解使用\"></a>注解使用</h3></li>\n<li>使用@PreAuthorize注解，它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2></li>\n<li>认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json</li>\n<li>出现了异常会被<strong>ExceptionTranslationFilter</strong>捕获到</li>\n<li>如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。</li>\n<li>​ 如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。</li>\n<li>​ 所以如果我们需要<strong>自定义异常处理</strong>，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可<h2 id=\"CSRF攻击\"><a href=\"#CSRF攻击\" class=\"headerlink\" title=\"CSRF攻击\"></a>CSRF攻击</h2><h3 id=\"概念理解-2\"><a href=\"#概念理解-2\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h3></li>\n<li>用户正常登陆网站a, 登陆成功后有一个只允许a访问的cookie, 只要cookie不失效, 在这个期间就可以携带cookie正常访问网站a</li>\n<li>但是用户也登陆了网站b, 也有一个b的cookie, 在访问b的过程中有一个指向a的资源跳转, <strong>使得用户携带a的cookie在不知情的情况下去访问a获取资源</strong>, 这就是CSRF攻击</li>\n<li>CSRF攻击防御的重点是利用cookie的值只能被第一方读取，无法读取第三方的cookie值。这上面的案例中再b网站中去访问a网站, b网站的cookie就是第一方cookie<h3 id=\"防御手段\"><a href=\"#防御手段\" class=\"headerlink\" title=\"防御手段\"></a>防御手段</h3></li>\n</ul>\n<ol>\n<li>验证 HTTP <strong>Referer</strong> 字段(来源网站)</li>\n<li>​ SpringSecurity去防止CSRF攻击的方式就是通过<strong>csrf_token</strong>。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问</li>\n<li>在HTTP头中自定义属性并验证；</li>\n<li>Chrome 浏览器端启用 <strong>SameSite cookie</strong></li>\n</ol>\n<ul>\n<li>总结: <strong>CSRF攻击依靠的是cookie中所携带的认证信息。以前的项目是把token存储在cookie中, 请求时自动携带, 现在的项目都是存储在本地/会话存储中, 并且在请求的时候是手动设置token到请求头中, 所以没有csrf攻击的可能性</strong><h2 id=\"XSS攻击\"><a href=\"#XSS攻击\" class=\"headerlink\" title=\"XSS攻击\"></a>XSS攻击</h2><h3 id=\"概念理解-3\"><a href=\"#概念理解-3\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h3></li>\n<li>跟SQL注入有点类似, 两者都是把“攻击载荷”塞进应用的数据流中，最后在不该执行的地方被执行<h3 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h3></li>\n<li>什么是SQL注入: SQL 注入是攻击者把恶意的 SQL 代码作为输入注入到应用中，使数据库在未经预期的情况下执行这些语句<ul>\n<li><code>&#39; OR &#39;1&#39;=&#39;1</code> —— 常见的“总是真”的条件，用来绕过认证（示意）</li>\n<li><code>&#39;; DROP TABLE users; --</code> —— 示例说明拼接带来的风险（危险且破坏性强）</li>\n</ul>\n</li>\n<li>但是我们现在的数据库都是采用预编译语句, 所有不用担心SQL注入<h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3></li>\n<li>当带有js攻击脚本的评论被存储到数据库中时, 读取评论列表可能会有这条带有攻击的评论, 前端在进行数据展示的时候如果没有防护的话, 这段js代码就会把恶意执行造成攻击</li>\n<li>如何应对 XSS 攻击?<ul>\n<li>对输入进行过滤，过滤标签等，只允许合法值。</li>\n<li>HTML 转义</li>\n<li>对于链接跳转，如<code>&lt;a href=&quot;xxx&quot;</code> &gt;等，要校验内容，禁止以 script 开头的非法链接。</li>\n<li>限制输入长度</li>\n</ul>\n</li>\n</ul>\n"},{"title":"深入理解注解","date":"2024-11-01T12:48:29.000Z","_content":"\n# Annotation\n\n> 凡心所向🚀素履所往 🌟生如逆旅 ✨一苇以航\n\n## 什么是注解\n\n- **注解和注释不同,当编译器运行时,注释会被跳过**\n- 而注解不会,反而会反过来影响程序 如:Tomcat, 编译器, 框架\n- 通过直接描述代码的行为来告诉框架或编译器应该做什么\n- **注解通常与反射机制结合使用，通过反射来在运行时获取注解信息，从而根据注解内容执行特定逻辑**\n## 注解的作用\n- **标识 类**:  当程序启动时,扫描所有类的时候, 标识当前类为… 例如:@WebServlet用来标识当前类为Servlet, 并管理类的生命周期(启动,运行,销毁)\n- **赋予 类**:  标识类时赋予类的作用时间(`RetentionPolicy.RUNTIME`)   Spring 使用注解来自动配置 Bean(使bean在程序执行运行时return唯一实例)\n- **调用 类**:  本身不做实现, 利用反射, 比如加了一个运行时注解, 那这个程序就会在运行时被执行, 而不用去创建实例对象.方法\n- **标识方法的过程解析**: 遍历所有方法 找到被标识的方法 反射执行\n## 注解的组成\n**两个核心元注解:@Target 和 @Retention**\n- `@Target`: 指定注解的作用对象  class method field \n- `@Retention`:指定注解的生命周期\n\t  - SOURCE      源代码级别，由编译器处理，处理之后就不再保留\n\t  - CLASS         注解信息保留到类对应的字节码文件中\n\t  - RUNTIME    由JVM(解释器)读取，运行时使用\n## 例子\n```java\n// 作用: 标识类方法,反射调用类方法执行\n@Target(ElementType.METHOD) \n@Retention(RetentionPolicy.RUNTIME)\npublic @interface InitMethod { \n}\n```\n\n```java\npublic class testAnnotation {\n\n    @InitMethod\n    public void ImMethod() {\n        System.out.println(\"我在没有实例化的情况下启动了\");\n    }\n\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"com.function.testAnnotation\");\n        Constructor<?> constructor = clazz.getDeclaredConstructor();\n        Object instance = constructor.newInstance();\n\n        // 标识方法的过程解析: 遍历所有方法 找到被标识的方法 反射执行\n        Method[] methods = clazz.getDeclaredMethods();\n        // 查证方法是否有这个注解存在\n        System.out.println(\"方法名: 是否存在注解\");\n        for (Method method : methods) {\n            // (本质)注解的字节码文件有一个flag: 所以只要判断flag里面有没有ACC_ANNOTATION\n            boolean present = method.isAnnotationPresent(InitMethod.class); \n            System.out.println(method.getName() + \": \" + present);\n            // 如果存在,反射执行\n            if (present) {\n                method.invoke(instance);\n            }\n        }\n    }\n}\n```\n\n## 补充\n\n- `AnnotatedElement` 接口是 Java 反射 API 中的一个关键接口，用于操作和读取注解。它由 `Class`、`Method`、`Field` 等类实现，允许在**运行时检查注解信息**。`AnnotatedElement` 的接口方法使得我们可以在运行时灵活地检查并获取注解的详细信息，从而决定如何动态处理类、方法或字段。\n- Spring 就大量使用了这一模式：扫描注解来**注入依赖**、**管理事务**、**控制请求**等。\n- **注解底层利用反射实现功能**\n- **注解类型本身也是接口, 一个类是注解类型,那它一定是接口类型**\n\n","source":"_posts/annotation.md","raw":"---\ntitle: 深入理解注解\ntags:\n  - Annotation\ndate: 2024-11-01 20:48:29\ncategories: 编程\n---\n\n# Annotation\n\n> 凡心所向🚀素履所往 🌟生如逆旅 ✨一苇以航\n\n## 什么是注解\n\n- **注解和注释不同,当编译器运行时,注释会被跳过**\n- 而注解不会,反而会反过来影响程序 如:Tomcat, 编译器, 框架\n- 通过直接描述代码的行为来告诉框架或编译器应该做什么\n- **注解通常与反射机制结合使用，通过反射来在运行时获取注解信息，从而根据注解内容执行特定逻辑**\n## 注解的作用\n- **标识 类**:  当程序启动时,扫描所有类的时候, 标识当前类为… 例如:@WebServlet用来标识当前类为Servlet, 并管理类的生命周期(启动,运行,销毁)\n- **赋予 类**:  标识类时赋予类的作用时间(`RetentionPolicy.RUNTIME`)   Spring 使用注解来自动配置 Bean(使bean在程序执行运行时return唯一实例)\n- **调用 类**:  本身不做实现, 利用反射, 比如加了一个运行时注解, 那这个程序就会在运行时被执行, 而不用去创建实例对象.方法\n- **标识方法的过程解析**: 遍历所有方法 找到被标识的方法 反射执行\n## 注解的组成\n**两个核心元注解:@Target 和 @Retention**\n- `@Target`: 指定注解的作用对象  class method field \n- `@Retention`:指定注解的生命周期\n\t  - SOURCE      源代码级别，由编译器处理，处理之后就不再保留\n\t  - CLASS         注解信息保留到类对应的字节码文件中\n\t  - RUNTIME    由JVM(解释器)读取，运行时使用\n## 例子\n```java\n// 作用: 标识类方法,反射调用类方法执行\n@Target(ElementType.METHOD) \n@Retention(RetentionPolicy.RUNTIME)\npublic @interface InitMethod { \n}\n```\n\n```java\npublic class testAnnotation {\n\n    @InitMethod\n    public void ImMethod() {\n        System.out.println(\"我在没有实例化的情况下启动了\");\n    }\n\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName(\"com.function.testAnnotation\");\n        Constructor<?> constructor = clazz.getDeclaredConstructor();\n        Object instance = constructor.newInstance();\n\n        // 标识方法的过程解析: 遍历所有方法 找到被标识的方法 反射执行\n        Method[] methods = clazz.getDeclaredMethods();\n        // 查证方法是否有这个注解存在\n        System.out.println(\"方法名: 是否存在注解\");\n        for (Method method : methods) {\n            // (本质)注解的字节码文件有一个flag: 所以只要判断flag里面有没有ACC_ANNOTATION\n            boolean present = method.isAnnotationPresent(InitMethod.class); \n            System.out.println(method.getName() + \": \" + present);\n            // 如果存在,反射执行\n            if (present) {\n                method.invoke(instance);\n            }\n        }\n    }\n}\n```\n\n## 补充\n\n- `AnnotatedElement` 接口是 Java 反射 API 中的一个关键接口，用于操作和读取注解。它由 `Class`、`Method`、`Field` 等类实现，允许在**运行时检查注解信息**。`AnnotatedElement` 的接口方法使得我们可以在运行时灵活地检查并获取注解的详细信息，从而决定如何动态处理类、方法或字段。\n- Spring 就大量使用了这一模式：扫描注解来**注入依赖**、**管理事务**、**控制请求**等。\n- **注解底层利用反射实现功能**\n- **注解类型本身也是接口, 一个类是注解类型,那它一定是接口类型**\n\n","slug":"annotation","published":1,"updated":"2025-10-13T12:15:06.121Z","_id":"cmfw4z09v0012uomw2to7axx3","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Annotation\"><a href=\"#Annotation\" class=\"headerlink\" title=\"Annotation\"></a>Annotation</h1><blockquote>\n<p>凡心所向🚀素履所往 🌟生如逆旅 ✨一苇以航</p>\n</blockquote>\n<h2 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h2><ul>\n<li><strong>注解和注释不同,当编译器运行时,注释会被跳过</strong></li>\n<li>而注解不会,反而会反过来影响程序 如:Tomcat, 编译器, 框架</li>\n<li>通过直接描述代码的行为来告诉框架或编译器应该做什么</li>\n<li><strong>注解通常与反射机制结合使用，通过反射来在运行时获取注解信息，从而根据注解内容执行特定逻辑</strong><h2 id=\"注解的作用\"><a href=\"#注解的作用\" class=\"headerlink\" title=\"注解的作用\"></a>注解的作用</h2></li>\n<li><strong>标识 类</strong>:  当程序启动时,扫描所有类的时候, 标识当前类为… 例如:@WebServlet用来标识当前类为Servlet, 并管理类的生命周期(启动,运行,销毁)</li>\n<li><strong>赋予 类</strong>:  标识类时赋予类的作用时间(<code>RetentionPolicy.RUNTIME</code>)   Spring 使用注解来自动配置 Bean(使bean在程序执行运行时return唯一实例)</li>\n<li><strong>调用 类</strong>:  本身不做实现, 利用反射, 比如加了一个运行时注解, 那这个程序就会在运行时被执行, 而不用去创建实例对象.方法</li>\n<li><strong>标识方法的过程解析</strong>: 遍历所有方法 找到被标识的方法 反射执行<h2 id=\"注解的组成\"><a href=\"#注解的组成\" class=\"headerlink\" title=\"注解的组成\"></a>注解的组成</h2><strong>两个核心元注解:@Target 和 @Retention</strong></li>\n<li><code>@Target</code>: 指定注解的作用对象  class method field </li>\n<li><code>@Retention</code>:指定注解的生命周期<pre><code>- SOURCE      源代码级别，由编译器处理，处理之后就不再保留\n- CLASS         注解信息保留到类对应的字节码文件中\n- RUNTIME    由JVM(解释器)读取，运行时使用\n</code></pre><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 作用: 标识类方法,反射调用类方法执行</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span> </span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> InitMethod &#123; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testAnnotation</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@InitMethod</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ImMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我在没有实例化的情况下启动了&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        Class&lt;?&gt; clazz = Class.forName(<span class=\"string\">&quot;com.function.testAnnotation&quot;</span>);</span><br><span class=\"line\">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> constructor.newInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 标识方法的过程解析: 遍历所有方法 找到被标识的方法 反射执行</span></span><br><span class=\"line\">        Method[] methods = clazz.getDeclaredMethods();</span><br><span class=\"line\">        <span class=\"comment\">// 查证方法是否有这个注解存在</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;方法名: 是否存在注解&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Method method : methods) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// (本质)注解的字节码文件有一个flag: 所以只要判断flag里面有没有ACC_ANNOTATION</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">present</span> <span class=\"operator\">=</span> method.isAnnotationPresent(InitMethod.class); </span><br><span class=\"line\">            System.out.println(method.getName() + <span class=\"string\">&quot;: &quot;</span> + present);</span><br><span class=\"line\">            <span class=\"comment\">// 如果存在,反射执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (present) &#123;</span><br><span class=\"line\">                method.invoke(instance);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><ul>\n<li><code>AnnotatedElement</code> 接口是 Java 反射 API 中的一个关键接口，用于操作和读取注解。它由 <code>Class</code>、<code>Method</code>、<code>Field</code> 等类实现，允许在<strong>运行时检查注解信息</strong>。<code>AnnotatedElement</code> 的接口方法使得我们可以在运行时灵活地检查并获取注解的详细信息，从而决定如何动态处理类、方法或字段。</li>\n<li>Spring 就大量使用了这一模式：扫描注解来<strong>注入依赖</strong>、<strong>管理事务</strong>、<strong>控制请求</strong>等。</li>\n<li><strong>注解底层利用反射实现功能</strong></li>\n<li><strong>注解类型本身也是接口, 一个类是注解类型,那它一定是接口类型</strong></li>\n</ul>\n","cover":"/img/3.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Annotation\"><a href=\"#Annotation\" class=\"headerlink\" title=\"Annotation\"></a>Annotation</h1><blockquote>\n<p>凡心所向🚀素履所往 🌟生如逆旅 ✨一苇以航</p>\n</blockquote>\n<h2 id=\"什么是注解\"><a href=\"#什么是注解\" class=\"headerlink\" title=\"什么是注解\"></a>什么是注解</h2><ul>\n<li><strong>注解和注释不同,当编译器运行时,注释会被跳过</strong></li>\n<li>而注解不会,反而会反过来影响程序 如:Tomcat, 编译器, 框架</li>\n<li>通过直接描述代码的行为来告诉框架或编译器应该做什么</li>\n<li><strong>注解通常与反射机制结合使用，通过反射来在运行时获取注解信息，从而根据注解内容执行特定逻辑</strong><h2 id=\"注解的作用\"><a href=\"#注解的作用\" class=\"headerlink\" title=\"注解的作用\"></a>注解的作用</h2></li>\n<li><strong>标识 类</strong>:  当程序启动时,扫描所有类的时候, 标识当前类为… 例如:@WebServlet用来标识当前类为Servlet, 并管理类的生命周期(启动,运行,销毁)</li>\n<li><strong>赋予 类</strong>:  标识类时赋予类的作用时间(<code>RetentionPolicy.RUNTIME</code>)   Spring 使用注解来自动配置 Bean(使bean在程序执行运行时return唯一实例)</li>\n<li><strong>调用 类</strong>:  本身不做实现, 利用反射, 比如加了一个运行时注解, 那这个程序就会在运行时被执行, 而不用去创建实例对象.方法</li>\n<li><strong>标识方法的过程解析</strong>: 遍历所有方法 找到被标识的方法 反射执行<h2 id=\"注解的组成\"><a href=\"#注解的组成\" class=\"headerlink\" title=\"注解的组成\"></a>注解的组成</h2><strong>两个核心元注解:@Target 和 @Retention</strong></li>\n<li><code>@Target</code>: 指定注解的作用对象  class method field </li>\n<li><code>@Retention</code>:指定注解的生命周期<pre><code>- SOURCE      源代码级别，由编译器处理，处理之后就不再保留\n- CLASS         注解信息保留到类对应的字节码文件中\n- RUNTIME    由JVM(解释器)读取，运行时使用\n</code></pre><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 作用: 标识类方法,反射调用类方法执行</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span> </span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> InitMethod &#123; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testAnnotation</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@InitMethod</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ImMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我在没有实例化的情况下启动了&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        Class&lt;?&gt; clazz = Class.forName(<span class=\"string\">&quot;com.function.testAnnotation&quot;</span>);</span><br><span class=\"line\">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> constructor.newInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 标识方法的过程解析: 遍历所有方法 找到被标识的方法 反射执行</span></span><br><span class=\"line\">        Method[] methods = clazz.getDeclaredMethods();</span><br><span class=\"line\">        <span class=\"comment\">// 查证方法是否有这个注解存在</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;方法名: 是否存在注解&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Method method : methods) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// (本质)注解的字节码文件有一个flag: 所以只要判断flag里面有没有ACC_ANNOTATION</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">present</span> <span class=\"operator\">=</span> method.isAnnotationPresent(InitMethod.class); </span><br><span class=\"line\">            System.out.println(method.getName() + <span class=\"string\">&quot;: &quot;</span> + present);</span><br><span class=\"line\">            <span class=\"comment\">// 如果存在,反射执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (present) &#123;</span><br><span class=\"line\">                method.invoke(instance);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><ul>\n<li><code>AnnotatedElement</code> 接口是 Java 反射 API 中的一个关键接口，用于操作和读取注解。它由 <code>Class</code>、<code>Method</code>、<code>Field</code> 等类实现，允许在<strong>运行时检查注解信息</strong>。<code>AnnotatedElement</code> 的接口方法使得我们可以在运行时灵活地检查并获取注解的详细信息，从而决定如何动态处理类、方法或字段。</li>\n<li>Spring 就大量使用了这一模式：扫描注解来<strong>注入依赖</strong>、<strong>管理事务</strong>、<strong>控制请求</strong>等。</li>\n<li><strong>注解底层利用反射实现功能</strong></li>\n<li><strong>注解类型本身也是接口, 一个类是注解类型,那它一定是接口类型</strong></li>\n</ul>\n"},{"title":"数据存储单位及带宽传输","date":"2024-12-02T07:02:26.000Z","_content":"\n# 数据存储单位及带宽传输\n\n## 序言\n\n\t本文将介绍数据存储单位及其内存换算（包括Bit, Byte, KB, MB等）, Java中数据类型和`String`的内存占用以及带宽单位和数据存储单位的区别\n\n## 一、常见数据存储单位及其换算关系\n\n- **Bit**（比特）\n\t- 定义：Bit是计算机中最小的数据存储单位，表示一个二进制位（0或1）。\n\t- 换算：1 Byte = 8 Bits\n\n- **Byte**（字节）\n\t- 定义：Byte是计算机数据存储的基本单位之一，常用于表示一个字符（例如，一个英文字母或数字）。\n\t- 大小：1 Byte = 8 Bits\n\n- **Kilobyte**（KB，千字节）\n\t- 定义：Kilobyte是常用的数据存储单位，适用于表示较小文件或数据块的大小。\n\t- 大小：1 KB = 1024 Bytes = 8192 Bits\n\n- **Megabyte**（MB，兆字节）\n\t- 定义：Megabyte是常见的数据存储单位，适用于表示较大的文件或数据块，如图片、音频等。\n\t- 大小：1 MB = 1024 KB = 1048576 Bytes = 8388608 Bits\n\n- **Gigabyte**（GB，千兆字节）\n\t- 定义：Gigabyte通常用于表示硬盘、内存等存储设备的容量。\n\t- 大小：1 GB = 1024 MB = 1073741824 Bytes = 8589934592 Bits\n\n- **Terabyte**（TB，太字节）\n\t- 定义：Terabyte用于表示大容量的存储，尤其适用于硬盘或数据中心存储。\n\t- 大小：1 TB = 1024 GB = 1099511627776 Bytes = 8796093022208 Bits\n\n------\n\n## 二、Java中常见数据类型的内存占用\n\n\t在 Java 中，数据类型的内存占用是固定的，并且有明确的标准。以下是常见数据类型的内存占用情况：\n\n| 数据类型      | 内存大小 (字节)   | 描述                     |\n| --------- | ----------- | ---------------------- |\n| `byte`    | 1 Byte      | 8位带符号整数                |\n| `short`   | 2 Bytes     | 16位带符号整数               |\n| `int`     | 4 Bytes     | 32位带符号整数               |\n| `long`    | 8 Bytes     | 64位带符号整数               |\n| `char`    | 2 Bytes     | 16位Unicode字符           |\n| `float`   | 4 Bytes     | 32位单精度浮点数              |\n| `double`  | 8 Bytes     | 64位双精度浮点数              |\n| `boolean` | 1 Byte (可能) | 布尔值，通常占用1位，但具体取决于JVM实现 |\n\n- **`byte`** 占用 1 字节，范围是 -128 到 127。\n- **`short`** 占用 2 字节，范围是 -32,768 到 32,767。\n- **`int`** 占用 4 字节，范围是 -2^31 到 2^31 - 1。\n- **`long`** 占用 8 字节，范围是 -2^63 到 2^63 - 1。\n- **`char`** 占用 2 字节，用于表示单个 Unicode 字符，范围是 0 到 65535。\n- **`float`** 占用 4 字节，表示单精度浮点数，精度为6-7位十进制数。\n- **`double`** 占用 8 字节，表示双精度浮点数，精度为15-16位十进制数。\n- **`boolean`** 的内存占用是 JVM 实现的具体实现，可能占用 1 位，也可能是 1 字节。\n\n------\n\n## 三、String类型的内存占用\n\n`String` 是 Java 中最常用的数据类型之一，但它的内存占用可能比其他基本类型要复杂，特别是它与 JVM 的实现和对象模型密切相关。\n\n#### 1. **`String` 内存结构**\n\nJava 中的 `String` 是一个不可变类，表示字符序列。其内存结构包括：\n\n- **对象头**：每个对象（包括 `String` 对象）都有一个对象头，在 32 位 JVM 上通常是 8 字节，在 64 位 JVM 上通常是 16 字节。\n- **字符数组**：`String` 内部实际上是由一个字符数组（`char[]`）来存储字符的(现在改成了用 **byte[ ]** )。每个 `char` 占 2 字节（因为 `char` 使用 UTF-16 编码，每个字符占 2 字节）。例如，`\"hello\"` 字符串将使用一个包含 5 个 `char` 元素的数组，总共占用 10 字节, 现在直接表示10字节.\n- **字符串常量池**：所有字面量字符串（例如 `\"hello\"`）都会存储在 JVM 的字符串常量池中，这是为了共享相同的字符串对象而减少内存使用。\n\n#### 2. **`String` 对象的内存计算**\n\n以字符串 `\"hello\"` 为例，假设我们在 64 位 JVM 上运行，并且启用了压缩指针：\n\n1. **对象头**：16 字节\n2. 字符数组\n   - `\"hello\"` 中有 5 个字符，`char[]` 数组需要 5 * 2 = 10 字节。\n3. **引用的内存**：字符数组的引用通常占用 4 字节。\n4. **字符串常量池**：常量池中会存储该字符串，但这部分内存不直接计算在对象本身的内存中。\n\n因此， `\"hello\"` 字符串对象的内存占用大概为：\n\n- 对象头：16 字节\n- 字符数组：10 字节\n- 字符数组引用：4 字节\n- 总计：16 + 10 + 4 = 30 字节\n\n如果 `String` 以更复杂的形式存在（例如通过拼接或构建 `StringBuilder`），则内存占用可能会更大。\n\n#### 3. **`String` 对象的共享与常量池**\n\n在 Java 中，所有常量字符串会被存储在 **字符串常量池** 中，这是一个特定区域，目的是避免多个相同的字符串对象占用重复的内存。也就是说，**相同内容的字符串对象会共享同一内存**。例如，以下代码：\n\n```java\nString str1 = \"hello\";\nString str2 = \"hello\";\n```\n\n在内存中，`str1` 和 `str2` 将引用同一个字符串对象，而不会分别占用额外的内存。\n\n------\n\n## 四、内存引用占用的详细解释\n\n#### 1. **引用的内存占用**\n\n在 Java 中，引用类型的变量（如类的实例、数组、`String` 等）存储的并不是数据本身，而是指向实际数据的**引用**。引用本身占用一定的内存。\n\n- **引用大小**：在 32 位的 JVM 上，引用占 4 字节；在 64 位的 JVM 上，引用占 8 字节（如果启用指针压缩）。引用类型的变量指向的对象本身存储在堆内存中，引用变量只是存储这个对象的内存地址。\n\n#### 2. **数组引用占用**\n\n对于数组，数组本身在堆上分配内存，数组的引用变量存储在栈上。\n\n- **引用类型数组**：数组的引用变量占用 4 字节（32 位 JVM）或 8 字节（64 位 JVM）。\n- **数组元素内存**：数组元素本身的内存取决于数组的类型。例如，`int[]` 数组的元素是 `int` 类型，占 4 字节，而 `String[]` 数组的元素是 `String` 类型，且 `String` 占用更大的内存。\n\n------\n\n## 五.数据传输速率与存储容量对比\n\n- **数据传输速率** 是指 **单位时间内** 能传输的数据量，强调的是 **时间** 和 **速度**。\n- **存储容量** 是指计算机或硬盘能容纳的 **数据总量**，强调的是 **空间** 和 **容量**。\n\n#### 1. 数据传输速率（网络带宽）\n\n**数据传输速率** 通常是指网络中单位时间内可以传输的数据量，通常以 **比特/秒**（bit per second，bps）为单位。常见的单位有：\n\n- **Kbps (千比特每秒)**：千比特每秒，1 Kbps = 1,000 bps\n- **Mbps (兆比特每秒)**：兆比特每秒，1 Mbps = 1,000,000 bps\n- **Gbps (吉比特每秒)**：吉比特每秒，1 Gbps = 1,000,000,000 bps\n\n例如，家庭宽带的速度可能是 **100 Mbps**，这意味着网络每秒能够传输 100,000,000 比特的数据。\n\n#### 2. 存储容量\n\n**存储容量** 指的是计算机、硬盘、SSD 或云存储中用于存放数据的大小。存储容量通常以 **字节**（Byte）为单位，1 字节等于 8 比特。常见的存储单位有：\n\n- **KB (千字节)**：1 KB = 1,024 字节\n- **MB (兆字节)**：1 MB = 1,024 KB = 1,048,576 字节\n- **GB (千兆字节)**：1 GB = 1,024 MB = 1,073,741,824 字节\n- **TB (太字节)**：1 TB = 1,024 GB\n\n比如，你的硬盘容量可能是 **1TB**，即 **1,024 GB**，表示硬盘上可以存储大约 1,073 亿字节的数据。\n\n#### 3. 网络带宽的实际含义\n\n网络带宽的大小决定了在特定时间内，网络能够传输多少数据。例如：\n\n- **10 Mbps** 的带宽意味着每秒钟可以传输 10,000,000 比特的数据，或 **1,250,000 字节**（约 1.25 MB）。\n- 如果网络带宽为 **100 Mbps**，每秒可以传输 **12.5 MB** 的数据。\n\n换句话说，带宽越大，数据传输的速度就越快，文件上传、下载或在线视频流的质量也会更好。\n\n#### 4. 存储容量的实际含义\n\n存储容量决定了设备能存储多少数据。例如：\n\n- 一块 **256GB** 的固态硬盘可以存储 **256,000 MB** 的数据。\n- 如果存储容量是 **2TB**，这意味着它能存储大约 **2,048,000 MB** 的数据。\n\n存储容量的大小主要影响的是设备能够保存多少文件、应用程序或其他类型的数据，它与设备的性能和数据的持久存储相关。\n\n#### 5.举例\n\n假如有1G文件需要传输,那么转换成比特就是:\n$$\n1GB = 1,024 × 1,024 × 1,024 × 8 = 8,589,934,592 bit\n$$\n传输公式如下: \n$$\n\\text{传\\,输\\,时\\,间} = \\frac{\\text{文件大小（比特）}}{\\text{带宽（比特/秒）}}\n$$\n\n- **网络带宽为 10 Mbps**，即每秒传输 10,000,000 比特。传输时间可以通过以下公式计算：\n\n$$\n\\text{传\\ 输\\ 时\\ 间} = \\frac{8,589,934,592 \\, \\text{比特}}{10,000,000 \\, \\text{比特/秒}} = 858.99 \\, \\text{秒} \\approx 14.3 \\, \\text{分钟}\n$$\n\n所以，传输一个 **1GB** 的文件，使用 **10 Mbps** 的带宽大约需要 **14.3 分钟**。\n\n- **带宽为 100 Mbps**（即 100,000,000 bps）：\n\n$$\n\\text{传\\ 输\\ 时\\ 间} = \\frac{8,589,934,592 \\, \\text{比特}}{100,000,000 \\, \\text{比特/秒}} = 85.9 \\, \\text{秒} \\approx 1.43 \\, \\text{分钟}\n$$\n\n所以，传输一个 **1GB** 的文件，使用 **100 Mbps** 的带宽大约需要 **1.43 分钟**。\n\n## 六、总结\n\n1. **数据存储单位**：Bit、Byte、KB、MB、GB 等单位之间有明确的换算关系，需要牢记：\n   - 1 Byte = 8 Bits\n   - 1 KB = 1024 Bytes\n   - 1 MB = 1024 KB\n   - 1 GB = 1024 MB\n2. **Java 数据类型内存占用**：Java 中的基本数据类型有固定的内存占用，引用类型的内存占用较为复杂，涉及对象头、字段的内存、引用的其他对象等。\n3. **`String` 类型的内存占用**：`String` 对象不仅包含字符数据，还包含对象头、字符数组及其引用、常量池中的存储等。\n4. **引用内存占用**：Java 中的引用类型变量占用一定的内存，通常是 4 字节（32 位 JVM）或 8 字节（64 位 JVM），它们存储的仅仅是对象的引用，而不是数据本身。\n5. 带宽关注的是 **传输过程中的速度**，而存储容量关注的是 **数据存储的总量**\n6. mb和MB的区别: mb的b代表的是bit; MB的B代表的是Byte ,所以**1MB = 8mb**，即1兆字节等于8兆比特，因为1字节=8比特。\n","source":"_posts/bitByte.md","raw":"---\ntitle: 数据存储单位及带宽传输\ntags:\n  - byte\n  - bit\ncategories: 编程\ndate: 2024-12-02 15:02:26\n---\n\n# 数据存储单位及带宽传输\n\n## 序言\n\n\t本文将介绍数据存储单位及其内存换算（包括Bit, Byte, KB, MB等）, Java中数据类型和`String`的内存占用以及带宽单位和数据存储单位的区别\n\n## 一、常见数据存储单位及其换算关系\n\n- **Bit**（比特）\n\t- 定义：Bit是计算机中最小的数据存储单位，表示一个二进制位（0或1）。\n\t- 换算：1 Byte = 8 Bits\n\n- **Byte**（字节）\n\t- 定义：Byte是计算机数据存储的基本单位之一，常用于表示一个字符（例如，一个英文字母或数字）。\n\t- 大小：1 Byte = 8 Bits\n\n- **Kilobyte**（KB，千字节）\n\t- 定义：Kilobyte是常用的数据存储单位，适用于表示较小文件或数据块的大小。\n\t- 大小：1 KB = 1024 Bytes = 8192 Bits\n\n- **Megabyte**（MB，兆字节）\n\t- 定义：Megabyte是常见的数据存储单位，适用于表示较大的文件或数据块，如图片、音频等。\n\t- 大小：1 MB = 1024 KB = 1048576 Bytes = 8388608 Bits\n\n- **Gigabyte**（GB，千兆字节）\n\t- 定义：Gigabyte通常用于表示硬盘、内存等存储设备的容量。\n\t- 大小：1 GB = 1024 MB = 1073741824 Bytes = 8589934592 Bits\n\n- **Terabyte**（TB，太字节）\n\t- 定义：Terabyte用于表示大容量的存储，尤其适用于硬盘或数据中心存储。\n\t- 大小：1 TB = 1024 GB = 1099511627776 Bytes = 8796093022208 Bits\n\n------\n\n## 二、Java中常见数据类型的内存占用\n\n\t在 Java 中，数据类型的内存占用是固定的，并且有明确的标准。以下是常见数据类型的内存占用情况：\n\n| 数据类型      | 内存大小 (字节)   | 描述                     |\n| --------- | ----------- | ---------------------- |\n| `byte`    | 1 Byte      | 8位带符号整数                |\n| `short`   | 2 Bytes     | 16位带符号整数               |\n| `int`     | 4 Bytes     | 32位带符号整数               |\n| `long`    | 8 Bytes     | 64位带符号整数               |\n| `char`    | 2 Bytes     | 16位Unicode字符           |\n| `float`   | 4 Bytes     | 32位单精度浮点数              |\n| `double`  | 8 Bytes     | 64位双精度浮点数              |\n| `boolean` | 1 Byte (可能) | 布尔值，通常占用1位，但具体取决于JVM实现 |\n\n- **`byte`** 占用 1 字节，范围是 -128 到 127。\n- **`short`** 占用 2 字节，范围是 -32,768 到 32,767。\n- **`int`** 占用 4 字节，范围是 -2^31 到 2^31 - 1。\n- **`long`** 占用 8 字节，范围是 -2^63 到 2^63 - 1。\n- **`char`** 占用 2 字节，用于表示单个 Unicode 字符，范围是 0 到 65535。\n- **`float`** 占用 4 字节，表示单精度浮点数，精度为6-7位十进制数。\n- **`double`** 占用 8 字节，表示双精度浮点数，精度为15-16位十进制数。\n- **`boolean`** 的内存占用是 JVM 实现的具体实现，可能占用 1 位，也可能是 1 字节。\n\n------\n\n## 三、String类型的内存占用\n\n`String` 是 Java 中最常用的数据类型之一，但它的内存占用可能比其他基本类型要复杂，特别是它与 JVM 的实现和对象模型密切相关。\n\n#### 1. **`String` 内存结构**\n\nJava 中的 `String` 是一个不可变类，表示字符序列。其内存结构包括：\n\n- **对象头**：每个对象（包括 `String` 对象）都有一个对象头，在 32 位 JVM 上通常是 8 字节，在 64 位 JVM 上通常是 16 字节。\n- **字符数组**：`String` 内部实际上是由一个字符数组（`char[]`）来存储字符的(现在改成了用 **byte[ ]** )。每个 `char` 占 2 字节（因为 `char` 使用 UTF-16 编码，每个字符占 2 字节）。例如，`\"hello\"` 字符串将使用一个包含 5 个 `char` 元素的数组，总共占用 10 字节, 现在直接表示10字节.\n- **字符串常量池**：所有字面量字符串（例如 `\"hello\"`）都会存储在 JVM 的字符串常量池中，这是为了共享相同的字符串对象而减少内存使用。\n\n#### 2. **`String` 对象的内存计算**\n\n以字符串 `\"hello\"` 为例，假设我们在 64 位 JVM 上运行，并且启用了压缩指针：\n\n1. **对象头**：16 字节\n2. 字符数组\n   - `\"hello\"` 中有 5 个字符，`char[]` 数组需要 5 * 2 = 10 字节。\n3. **引用的内存**：字符数组的引用通常占用 4 字节。\n4. **字符串常量池**：常量池中会存储该字符串，但这部分内存不直接计算在对象本身的内存中。\n\n因此， `\"hello\"` 字符串对象的内存占用大概为：\n\n- 对象头：16 字节\n- 字符数组：10 字节\n- 字符数组引用：4 字节\n- 总计：16 + 10 + 4 = 30 字节\n\n如果 `String` 以更复杂的形式存在（例如通过拼接或构建 `StringBuilder`），则内存占用可能会更大。\n\n#### 3. **`String` 对象的共享与常量池**\n\n在 Java 中，所有常量字符串会被存储在 **字符串常量池** 中，这是一个特定区域，目的是避免多个相同的字符串对象占用重复的内存。也就是说，**相同内容的字符串对象会共享同一内存**。例如，以下代码：\n\n```java\nString str1 = \"hello\";\nString str2 = \"hello\";\n```\n\n在内存中，`str1` 和 `str2` 将引用同一个字符串对象，而不会分别占用额外的内存。\n\n------\n\n## 四、内存引用占用的详细解释\n\n#### 1. **引用的内存占用**\n\n在 Java 中，引用类型的变量（如类的实例、数组、`String` 等）存储的并不是数据本身，而是指向实际数据的**引用**。引用本身占用一定的内存。\n\n- **引用大小**：在 32 位的 JVM 上，引用占 4 字节；在 64 位的 JVM 上，引用占 8 字节（如果启用指针压缩）。引用类型的变量指向的对象本身存储在堆内存中，引用变量只是存储这个对象的内存地址。\n\n#### 2. **数组引用占用**\n\n对于数组，数组本身在堆上分配内存，数组的引用变量存储在栈上。\n\n- **引用类型数组**：数组的引用变量占用 4 字节（32 位 JVM）或 8 字节（64 位 JVM）。\n- **数组元素内存**：数组元素本身的内存取决于数组的类型。例如，`int[]` 数组的元素是 `int` 类型，占 4 字节，而 `String[]` 数组的元素是 `String` 类型，且 `String` 占用更大的内存。\n\n------\n\n## 五.数据传输速率与存储容量对比\n\n- **数据传输速率** 是指 **单位时间内** 能传输的数据量，强调的是 **时间** 和 **速度**。\n- **存储容量** 是指计算机或硬盘能容纳的 **数据总量**，强调的是 **空间** 和 **容量**。\n\n#### 1. 数据传输速率（网络带宽）\n\n**数据传输速率** 通常是指网络中单位时间内可以传输的数据量，通常以 **比特/秒**（bit per second，bps）为单位。常见的单位有：\n\n- **Kbps (千比特每秒)**：千比特每秒，1 Kbps = 1,000 bps\n- **Mbps (兆比特每秒)**：兆比特每秒，1 Mbps = 1,000,000 bps\n- **Gbps (吉比特每秒)**：吉比特每秒，1 Gbps = 1,000,000,000 bps\n\n例如，家庭宽带的速度可能是 **100 Mbps**，这意味着网络每秒能够传输 100,000,000 比特的数据。\n\n#### 2. 存储容量\n\n**存储容量** 指的是计算机、硬盘、SSD 或云存储中用于存放数据的大小。存储容量通常以 **字节**（Byte）为单位，1 字节等于 8 比特。常见的存储单位有：\n\n- **KB (千字节)**：1 KB = 1,024 字节\n- **MB (兆字节)**：1 MB = 1,024 KB = 1,048,576 字节\n- **GB (千兆字节)**：1 GB = 1,024 MB = 1,073,741,824 字节\n- **TB (太字节)**：1 TB = 1,024 GB\n\n比如，你的硬盘容量可能是 **1TB**，即 **1,024 GB**，表示硬盘上可以存储大约 1,073 亿字节的数据。\n\n#### 3. 网络带宽的实际含义\n\n网络带宽的大小决定了在特定时间内，网络能够传输多少数据。例如：\n\n- **10 Mbps** 的带宽意味着每秒钟可以传输 10,000,000 比特的数据，或 **1,250,000 字节**（约 1.25 MB）。\n- 如果网络带宽为 **100 Mbps**，每秒可以传输 **12.5 MB** 的数据。\n\n换句话说，带宽越大，数据传输的速度就越快，文件上传、下载或在线视频流的质量也会更好。\n\n#### 4. 存储容量的实际含义\n\n存储容量决定了设备能存储多少数据。例如：\n\n- 一块 **256GB** 的固态硬盘可以存储 **256,000 MB** 的数据。\n- 如果存储容量是 **2TB**，这意味着它能存储大约 **2,048,000 MB** 的数据。\n\n存储容量的大小主要影响的是设备能够保存多少文件、应用程序或其他类型的数据，它与设备的性能和数据的持久存储相关。\n\n#### 5.举例\n\n假如有1G文件需要传输,那么转换成比特就是:\n$$\n1GB = 1,024 × 1,024 × 1,024 × 8 = 8,589,934,592 bit\n$$\n传输公式如下: \n$$\n\\text{传\\,输\\,时\\,间} = \\frac{\\text{文件大小（比特）}}{\\text{带宽（比特/秒）}}\n$$\n\n- **网络带宽为 10 Mbps**，即每秒传输 10,000,000 比特。传输时间可以通过以下公式计算：\n\n$$\n\\text{传\\ 输\\ 时\\ 间} = \\frac{8,589,934,592 \\, \\text{比特}}{10,000,000 \\, \\text{比特/秒}} = 858.99 \\, \\text{秒} \\approx 14.3 \\, \\text{分钟}\n$$\n\n所以，传输一个 **1GB** 的文件，使用 **10 Mbps** 的带宽大约需要 **14.3 分钟**。\n\n- **带宽为 100 Mbps**（即 100,000,000 bps）：\n\n$$\n\\text{传\\ 输\\ 时\\ 间} = \\frac{8,589,934,592 \\, \\text{比特}}{100,000,000 \\, \\text{比特/秒}} = 85.9 \\, \\text{秒} \\approx 1.43 \\, \\text{分钟}\n$$\n\n所以，传输一个 **1GB** 的文件，使用 **100 Mbps** 的带宽大约需要 **1.43 分钟**。\n\n## 六、总结\n\n1. **数据存储单位**：Bit、Byte、KB、MB、GB 等单位之间有明确的换算关系，需要牢记：\n   - 1 Byte = 8 Bits\n   - 1 KB = 1024 Bytes\n   - 1 MB = 1024 KB\n   - 1 GB = 1024 MB\n2. **Java 数据类型内存占用**：Java 中的基本数据类型有固定的内存占用，引用类型的内存占用较为复杂，涉及对象头、字段的内存、引用的其他对象等。\n3. **`String` 类型的内存占用**：`String` 对象不仅包含字符数据，还包含对象头、字符数组及其引用、常量池中的存储等。\n4. **引用内存占用**：Java 中的引用类型变量占用一定的内存，通常是 4 字节（32 位 JVM）或 8 字节（64 位 JVM），它们存储的仅仅是对象的引用，而不是数据本身。\n5. 带宽关注的是 **传输过程中的速度**，而存储容量关注的是 **数据存储的总量**\n6. mb和MB的区别: mb的b代表的是bit; MB的B代表的是Byte ,所以**1MB = 8mb**，即1兆字节等于8兆比特，因为1字节=8比特。\n","slug":"bitByte","published":1,"updated":"2025-04-27T05:01:03.948Z","comments":1,"layout":"post","photos":[],"_id":"cmfw4z09x0016uomw0c967y3o","content":"<h1 id=\"数据存储单位及带宽传输\"><a href=\"#数据存储单位及带宽传输\" class=\"headerlink\" title=\"数据存储单位及带宽传输\"></a>数据存储单位及带宽传输</h1><h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><pre><code>本文将介绍数据存储单位及其内存换算（包括Bit, Byte, KB, MB等）, Java中数据类型和`String`的内存占用以及带宽单位和数据存储单位的区别\n</code></pre><h2 id=\"一、常见数据存储单位及其换算关系\"><a href=\"#一、常见数据存储单位及其换算关系\" class=\"headerlink\" title=\"一、常见数据存储单位及其换算关系\"></a>一、常见数据存储单位及其换算关系</h2><ul>\n<li><p><strong>Bit</strong>（比特）</p>\n<ul>\n<li>定义：Bit是计算机中最小的数据存储单位，表示一个二进制位（0或1）。</li>\n<li>换算：1 Byte = 8 Bits</li>\n</ul>\n</li>\n<li><p><strong>Byte</strong>（字节）</p>\n<ul>\n<li>定义：Byte是计算机数据存储的基本单位之一，常用于表示一个字符（例如，一个英文字母或数字）。</li>\n<li>大小：1 Byte = 8 Bits</li>\n</ul>\n</li>\n<li><p><strong>Kilobyte</strong>（KB，千字节）</p>\n<ul>\n<li>定义：Kilobyte是常用的数据存储单位，适用于表示较小文件或数据块的大小。</li>\n<li>大小：1 KB = 1024 Bytes = 8192 Bits</li>\n</ul>\n</li>\n<li><p><strong>Megabyte</strong>（MB，兆字节）</p>\n<ul>\n<li>定义：Megabyte是常见的数据存储单位，适用于表示较大的文件或数据块，如图片、音频等。</li>\n<li>大小：1 MB = 1024 KB = 1048576 Bytes = 8388608 Bits</li>\n</ul>\n</li>\n<li><p><strong>Gigabyte</strong>（GB，千兆字节）</p>\n<ul>\n<li>定义：Gigabyte通常用于表示硬盘、内存等存储设备的容量。</li>\n<li>大小：1 GB = 1024 MB = 1073741824 Bytes = 8589934592 Bits</li>\n</ul>\n</li>\n<li><p><strong>Terabyte</strong>（TB，太字节）</p>\n<ul>\n<li>定义：Terabyte用于表示大容量的存储，尤其适用于硬盘或数据中心存储。</li>\n<li>大小：1 TB = 1024 GB = 1099511627776 Bytes = 8796093022208 Bits</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"二、Java中常见数据类型的内存占用\"><a href=\"#二、Java中常见数据类型的内存占用\" class=\"headerlink\" title=\"二、Java中常见数据类型的内存占用\"></a>二、Java中常见数据类型的内存占用</h2><pre><code>在 Java 中，数据类型的内存占用是固定的，并且有明确的标准。以下是常见数据类型的内存占用情况：\n</code></pre><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>内存大小 (字节)</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>byte</code></td>\n<td>1 Byte</td>\n<td>8位带符号整数</td>\n</tr>\n<tr>\n<td><code>short</code></td>\n<td>2 Bytes</td>\n<td>16位带符号整数</td>\n</tr>\n<tr>\n<td><code>int</code></td>\n<td>4 Bytes</td>\n<td>32位带符号整数</td>\n</tr>\n<tr>\n<td><code>long</code></td>\n<td>8 Bytes</td>\n<td>64位带符号整数</td>\n</tr>\n<tr>\n<td><code>char</code></td>\n<td>2 Bytes</td>\n<td>16位Unicode字符</td>\n</tr>\n<tr>\n<td><code>float</code></td>\n<td>4 Bytes</td>\n<td>32位单精度浮点数</td>\n</tr>\n<tr>\n<td><code>double</code></td>\n<td>8 Bytes</td>\n<td>64位双精度浮点数</td>\n</tr>\n<tr>\n<td><code>boolean</code></td>\n<td>1 Byte (可能)</td>\n<td>布尔值，通常占用1位，但具体取决于JVM实现</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><strong><code>byte</code></strong> 占用 1 字节，范围是 -128 到 127。</li>\n<li><strong><code>short</code></strong> 占用 2 字节，范围是 -32,768 到 32,767。</li>\n<li><strong><code>int</code></strong> 占用 4 字节，范围是 -2^31 到 2^31 - 1。</li>\n<li><strong><code>long</code></strong> 占用 8 字节，范围是 -2^63 到 2^63 - 1。</li>\n<li><strong><code>char</code></strong> 占用 2 字节，用于表示单个 Unicode 字符，范围是 0 到 65535。</li>\n<li><strong><code>float</code></strong> 占用 4 字节，表示单精度浮点数，精度为6-7位十进制数。</li>\n<li><strong><code>double</code></strong> 占用 8 字节，表示双精度浮点数，精度为15-16位十进制数。</li>\n<li><strong><code>boolean</code></strong> 的内存占用是 JVM 实现的具体实现，可能占用 1 位，也可能是 1 字节。</li>\n</ul>\n<hr>\n<h2 id=\"三、String类型的内存占用\"><a href=\"#三、String类型的内存占用\" class=\"headerlink\" title=\"三、String类型的内存占用\"></a>三、String类型的内存占用</h2><p><code>String</code> 是 Java 中最常用的数据类型之一，但它的内存占用可能比其他基本类型要复杂，特别是它与 JVM 的实现和对象模型密切相关。</p>\n<h4 id=\"1-String-内存结构\"><a href=\"#1-String-内存结构\" class=\"headerlink\" title=\"1. String 内存结构\"></a>1. <strong><code>String</code> 内存结构</strong></h4><p>Java 中的 <code>String</code> 是一个不可变类，表示字符序列。其内存结构包括：</p>\n<ul>\n<li><strong>对象头</strong>：每个对象（包括 <code>String</code> 对象）都有一个对象头，在 32 位 JVM 上通常是 8 字节，在 64 位 JVM 上通常是 16 字节。</li>\n<li><strong>字符数组</strong>：<code>String</code> 内部实际上是由一个字符数组（<code>char[]</code>）来存储字符的(现在改成了用 <strong>byte[ ]</strong> )。每个 <code>char</code> 占 2 字节（因为 <code>char</code> 使用 UTF-16 编码，每个字符占 2 字节）。例如，<code>&quot;hello&quot;</code> 字符串将使用一个包含 5 个 <code>char</code> 元素的数组，总共占用 10 字节, 现在直接表示10字节.</li>\n<li><strong>字符串常量池</strong>：所有字面量字符串（例如 <code>&quot;hello&quot;</code>）都会存储在 JVM 的字符串常量池中，这是为了共享相同的字符串对象而减少内存使用。</li>\n</ul>\n<h4 id=\"2-String-对象的内存计算\"><a href=\"#2-String-对象的内存计算\" class=\"headerlink\" title=\"2. String 对象的内存计算\"></a>2. <strong><code>String</code> 对象的内存计算</strong></h4><p>以字符串 <code>&quot;hello&quot;</code> 为例，假设我们在 64 位 JVM 上运行，并且启用了压缩指针：</p>\n<ol>\n<li><strong>对象头</strong>：16 字节</li>\n<li>字符数组<ul>\n<li><code>&quot;hello&quot;</code> 中有 5 个字符，<code>char[]</code> 数组需要 5 * 2 = 10 字节。</li>\n</ul>\n</li>\n<li><strong>引用的内存</strong>：字符数组的引用通常占用 4 字节。</li>\n<li><strong>字符串常量池</strong>：常量池中会存储该字符串，但这部分内存不直接计算在对象本身的内存中。</li>\n</ol>\n<p>因此， <code>&quot;hello&quot;</code> 字符串对象的内存占用大概为：</p>\n<ul>\n<li>对象头：16 字节</li>\n<li>字符数组：10 字节</li>\n<li>字符数组引用：4 字节</li>\n<li>总计：16 + 10 + 4 = 30 字节</li>\n</ul>\n<p>如果 <code>String</code> 以更复杂的形式存在（例如通过拼接或构建 <code>StringBuilder</code>），则内存占用可能会更大。</p>\n<h4 id=\"3-String-对象的共享与常量池\"><a href=\"#3-String-对象的共享与常量池\" class=\"headerlink\" title=\"3. String 对象的共享与常量池\"></a>3. <strong><code>String</code> 对象的共享与常量池</strong></h4><p>在 Java 中，所有常量字符串会被存储在 <strong>字符串常量池</strong> 中，这是一个特定区域，目的是避免多个相同的字符串对象占用重复的内存。也就是说，<strong>相同内容的字符串对象会共享同一内存</strong>。例如，以下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>在内存中，<code>str1</code> 和 <code>str2</code> 将引用同一个字符串对象，而不会分别占用额外的内存。</p>\n<hr>\n<h2 id=\"四、内存引用占用的详细解释\"><a href=\"#四、内存引用占用的详细解释\" class=\"headerlink\" title=\"四、内存引用占用的详细解释\"></a>四、内存引用占用的详细解释</h2><h4 id=\"1-引用的内存占用\"><a href=\"#1-引用的内存占用\" class=\"headerlink\" title=\"1. 引用的内存占用\"></a>1. <strong>引用的内存占用</strong></h4><p>在 Java 中，引用类型的变量（如类的实例、数组、<code>String</code> 等）存储的并不是数据本身，而是指向实际数据的<strong>引用</strong>。引用本身占用一定的内存。</p>\n<ul>\n<li><strong>引用大小</strong>：在 32 位的 JVM 上，引用占 4 字节；在 64 位的 JVM 上，引用占 8 字节（如果启用指针压缩）。引用类型的变量指向的对象本身存储在堆内存中，引用变量只是存储这个对象的内存地址。</li>\n</ul>\n<h4 id=\"2-数组引用占用\"><a href=\"#2-数组引用占用\" class=\"headerlink\" title=\"2. 数组引用占用\"></a>2. <strong>数组引用占用</strong></h4><p>对于数组，数组本身在堆上分配内存，数组的引用变量存储在栈上。</p>\n<ul>\n<li><strong>引用类型数组</strong>：数组的引用变量占用 4 字节（32 位 JVM）或 8 字节（64 位 JVM）。</li>\n<li><strong>数组元素内存</strong>：数组元素本身的内存取决于数组的类型。例如，<code>int[]</code> 数组的元素是 <code>int</code> 类型，占 4 字节，而 <code>String[]</code> 数组的元素是 <code>String</code> 类型，且 <code>String</code> 占用更大的内存。</li>\n</ul>\n<hr>\n<h2 id=\"五-数据传输速率与存储容量对比\"><a href=\"#五-数据传输速率与存储容量对比\" class=\"headerlink\" title=\"五.数据传输速率与存储容量对比\"></a>五.数据传输速率与存储容量对比</h2><ul>\n<li><strong>数据传输速率</strong> 是指 <strong>单位时间内</strong> 能传输的数据量，强调的是 <strong>时间</strong> 和 <strong>速度</strong>。</li>\n<li><strong>存储容量</strong> 是指计算机或硬盘能容纳的 <strong>数据总量</strong>，强调的是 <strong>空间</strong> 和 <strong>容量</strong>。</li>\n</ul>\n<h4 id=\"1-数据传输速率（网络带宽）\"><a href=\"#1-数据传输速率（网络带宽）\" class=\"headerlink\" title=\"1. 数据传输速率（网络带宽）\"></a>1. 数据传输速率（网络带宽）</h4><p><strong>数据传输速率</strong> 通常是指网络中单位时间内可以传输的数据量，通常以 <strong>比特/秒</strong>（bit per second，bps）为单位。常见的单位有：</p>\n<ul>\n<li><strong>Kbps (千比特每秒)</strong>：千比特每秒，1 Kbps = 1,000 bps</li>\n<li><strong>Mbps (兆比特每秒)</strong>：兆比特每秒，1 Mbps = 1,000,000 bps</li>\n<li><strong>Gbps (吉比特每秒)</strong>：吉比特每秒，1 Gbps = 1,000,000,000 bps</li>\n</ul>\n<p>例如，家庭宽带的速度可能是 <strong>100 Mbps</strong>，这意味着网络每秒能够传输 100,000,000 比特的数据。</p>\n<h4 id=\"2-存储容量\"><a href=\"#2-存储容量\" class=\"headerlink\" title=\"2. 存储容量\"></a>2. 存储容量</h4><p><strong>存储容量</strong> 指的是计算机、硬盘、SSD 或云存储中用于存放数据的大小。存储容量通常以 <strong>字节</strong>（Byte）为单位，1 字节等于 8 比特。常见的存储单位有：</p>\n<ul>\n<li><strong>KB (千字节)</strong>：1 KB = 1,024 字节</li>\n<li><strong>MB (兆字节)</strong>：1 MB = 1,024 KB = 1,048,576 字节</li>\n<li><strong>GB (千兆字节)</strong>：1 GB = 1,024 MB = 1,073,741,824 字节</li>\n<li><strong>TB (太字节)</strong>：1 TB = 1,024 GB</li>\n</ul>\n<p>比如，你的硬盘容量可能是 <strong>1TB</strong>，即 <strong>1,024 GB</strong>，表示硬盘上可以存储大约 1,073 亿字节的数据。</p>\n<h4 id=\"3-网络带宽的实际含义\"><a href=\"#3-网络带宽的实际含义\" class=\"headerlink\" title=\"3. 网络带宽的实际含义\"></a>3. 网络带宽的实际含义</h4><p>网络带宽的大小决定了在特定时间内，网络能够传输多少数据。例如：</p>\n<ul>\n<li><strong>10 Mbps</strong> 的带宽意味着每秒钟可以传输 10,000,000 比特的数据，或 <strong>1,250,000 字节</strong>（约 1.25 MB）。</li>\n<li>如果网络带宽为 <strong>100 Mbps</strong>，每秒可以传输 <strong>12.5 MB</strong> 的数据。</li>\n</ul>\n<p>换句话说，带宽越大，数据传输的速度就越快，文件上传、下载或在线视频流的质量也会更好。</p>\n<h4 id=\"4-存储容量的实际含义\"><a href=\"#4-存储容量的实际含义\" class=\"headerlink\" title=\"4. 存储容量的实际含义\"></a>4. 存储容量的实际含义</h4><p>存储容量决定了设备能存储多少数据。例如：</p>\n<ul>\n<li>一块 <strong>256GB</strong> 的固态硬盘可以存储 <strong>256,000 MB</strong> 的数据。</li>\n<li>如果存储容量是 <strong>2TB</strong>，这意味着它能存储大约 <strong>2,048,000 MB</strong> 的数据。</li>\n</ul>\n<p>存储容量的大小主要影响的是设备能够保存多少文件、应用程序或其他类型的数据，它与设备的性能和数据的持久存储相关。</p>\n<h4 id=\"5-举例\"><a href=\"#5-举例\" class=\"headerlink\" title=\"5.举例\"></a>5.举例</h4><p>假如有1G文件需要传输,那么转换成比特就是:</p>\n<script type=\"math/tex; mode=display\">\n1GB = 1,024 × 1,024 × 1,024 × 8 = 8,589,934,592 bit</script><p>传输公式如下: </p>\n<script type=\"math/tex; mode=display\">\n\\text{传\\,输\\,时\\,间} = \\frac{\\text{文件大小（比特）}}{\\text{带宽（比特/秒）}}</script><ul>\n<li><strong>网络带宽为 10 Mbps</strong>，即每秒传输 10,000,000 比特。传输时间可以通过以下公式计算：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\text{传\\ 输\\ 时\\ 间} = \\frac{8,589,934,592 \\, \\text{比特}}{10,000,000 \\, \\text{比特/秒}} = 858.99 \\, \\text{秒} \\approx 14.3 \\, \\text{分钟}</script><p>所以，传输一个 <strong>1GB</strong> 的文件，使用 <strong>10 Mbps</strong> 的带宽大约需要 <strong>14.3 分钟</strong>。</p>\n<ul>\n<li><strong>带宽为 100 Mbps</strong>（即 100,000,000 bps）：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\text{传\\ 输\\ 时\\ 间} = \\frac{8,589,934,592 \\, \\text{比特}}{100,000,000 \\, \\text{比特/秒}} = 85.9 \\, \\text{秒} \\approx 1.43 \\, \\text{分钟}</script><p>所以，传输一个 <strong>1GB</strong> 的文件，使用 <strong>100 Mbps</strong> 的带宽大约需要 <strong>1.43 分钟</strong>。</p>\n<h2 id=\"六、总结\"><a href=\"#六、总结\" class=\"headerlink\" title=\"六、总结\"></a>六、总结</h2><ol>\n<li><strong>数据存储单位</strong>：Bit、Byte、KB、MB、GB 等单位之间有明确的换算关系，需要牢记：<ul>\n<li>1 Byte = 8 Bits</li>\n<li>1 KB = 1024 Bytes</li>\n<li>1 MB = 1024 KB</li>\n<li>1 GB = 1024 MB</li>\n</ul>\n</li>\n<li><strong>Java 数据类型内存占用</strong>：Java 中的基本数据类型有固定的内存占用，引用类型的内存占用较为复杂，涉及对象头、字段的内存、引用的其他对象等。</li>\n<li><strong><code>String</code> 类型的内存占用</strong>：<code>String</code> 对象不仅包含字符数据，还包含对象头、字符数组及其引用、常量池中的存储等。</li>\n<li><strong>引用内存占用</strong>：Java 中的引用类型变量占用一定的内存，通常是 4 字节（32 位 JVM）或 8 字节（64 位 JVM），它们存储的仅仅是对象的引用，而不是数据本身。</li>\n<li>带宽关注的是 <strong>传输过程中的速度</strong>，而存储容量关注的是 <strong>数据存储的总量</strong></li>\n<li>mb和MB的区别: mb的b代表的是bit; MB的B代表的是Byte ,所以<strong>1MB = 8mb</strong>，即1兆字节等于8兆比特，因为1字节=8比特。</li>\n</ol>\n","cover":"/img/2.png","cover_type":"img","excerpt":"","more":"<h1 id=\"数据存储单位及带宽传输\"><a href=\"#数据存储单位及带宽传输\" class=\"headerlink\" title=\"数据存储单位及带宽传输\"></a>数据存储单位及带宽传输</h1><h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><pre><code>本文将介绍数据存储单位及其内存换算（包括Bit, Byte, KB, MB等）, Java中数据类型和`String`的内存占用以及带宽单位和数据存储单位的区别\n</code></pre><h2 id=\"一、常见数据存储单位及其换算关系\"><a href=\"#一、常见数据存储单位及其换算关系\" class=\"headerlink\" title=\"一、常见数据存储单位及其换算关系\"></a>一、常见数据存储单位及其换算关系</h2><ul>\n<li><p><strong>Bit</strong>（比特）</p>\n<ul>\n<li>定义：Bit是计算机中最小的数据存储单位，表示一个二进制位（0或1）。</li>\n<li>换算：1 Byte = 8 Bits</li>\n</ul>\n</li>\n<li><p><strong>Byte</strong>（字节）</p>\n<ul>\n<li>定义：Byte是计算机数据存储的基本单位之一，常用于表示一个字符（例如，一个英文字母或数字）。</li>\n<li>大小：1 Byte = 8 Bits</li>\n</ul>\n</li>\n<li><p><strong>Kilobyte</strong>（KB，千字节）</p>\n<ul>\n<li>定义：Kilobyte是常用的数据存储单位，适用于表示较小文件或数据块的大小。</li>\n<li>大小：1 KB = 1024 Bytes = 8192 Bits</li>\n</ul>\n</li>\n<li><p><strong>Megabyte</strong>（MB，兆字节）</p>\n<ul>\n<li>定义：Megabyte是常见的数据存储单位，适用于表示较大的文件或数据块，如图片、音频等。</li>\n<li>大小：1 MB = 1024 KB = 1048576 Bytes = 8388608 Bits</li>\n</ul>\n</li>\n<li><p><strong>Gigabyte</strong>（GB，千兆字节）</p>\n<ul>\n<li>定义：Gigabyte通常用于表示硬盘、内存等存储设备的容量。</li>\n<li>大小：1 GB = 1024 MB = 1073741824 Bytes = 8589934592 Bits</li>\n</ul>\n</li>\n<li><p><strong>Terabyte</strong>（TB，太字节）</p>\n<ul>\n<li>定义：Terabyte用于表示大容量的存储，尤其适用于硬盘或数据中心存储。</li>\n<li>大小：1 TB = 1024 GB = 1099511627776 Bytes = 8796093022208 Bits</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"二、Java中常见数据类型的内存占用\"><a href=\"#二、Java中常见数据类型的内存占用\" class=\"headerlink\" title=\"二、Java中常见数据类型的内存占用\"></a>二、Java中常见数据类型的内存占用</h2><pre><code>在 Java 中，数据类型的内存占用是固定的，并且有明确的标准。以下是常见数据类型的内存占用情况：\n</code></pre><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>内存大小 (字节)</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>byte</code></td>\n<td>1 Byte</td>\n<td>8位带符号整数</td>\n</tr>\n<tr>\n<td><code>short</code></td>\n<td>2 Bytes</td>\n<td>16位带符号整数</td>\n</tr>\n<tr>\n<td><code>int</code></td>\n<td>4 Bytes</td>\n<td>32位带符号整数</td>\n</tr>\n<tr>\n<td><code>long</code></td>\n<td>8 Bytes</td>\n<td>64位带符号整数</td>\n</tr>\n<tr>\n<td><code>char</code></td>\n<td>2 Bytes</td>\n<td>16位Unicode字符</td>\n</tr>\n<tr>\n<td><code>float</code></td>\n<td>4 Bytes</td>\n<td>32位单精度浮点数</td>\n</tr>\n<tr>\n<td><code>double</code></td>\n<td>8 Bytes</td>\n<td>64位双精度浮点数</td>\n</tr>\n<tr>\n<td><code>boolean</code></td>\n<td>1 Byte (可能)</td>\n<td>布尔值，通常占用1位，但具体取决于JVM实现</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><strong><code>byte</code></strong> 占用 1 字节，范围是 -128 到 127。</li>\n<li><strong><code>short</code></strong> 占用 2 字节，范围是 -32,768 到 32,767。</li>\n<li><strong><code>int</code></strong> 占用 4 字节，范围是 -2^31 到 2^31 - 1。</li>\n<li><strong><code>long</code></strong> 占用 8 字节，范围是 -2^63 到 2^63 - 1。</li>\n<li><strong><code>char</code></strong> 占用 2 字节，用于表示单个 Unicode 字符，范围是 0 到 65535。</li>\n<li><strong><code>float</code></strong> 占用 4 字节，表示单精度浮点数，精度为6-7位十进制数。</li>\n<li><strong><code>double</code></strong> 占用 8 字节，表示双精度浮点数，精度为15-16位十进制数。</li>\n<li><strong><code>boolean</code></strong> 的内存占用是 JVM 实现的具体实现，可能占用 1 位，也可能是 1 字节。</li>\n</ul>\n<hr>\n<h2 id=\"三、String类型的内存占用\"><a href=\"#三、String类型的内存占用\" class=\"headerlink\" title=\"三、String类型的内存占用\"></a>三、String类型的内存占用</h2><p><code>String</code> 是 Java 中最常用的数据类型之一，但它的内存占用可能比其他基本类型要复杂，特别是它与 JVM 的实现和对象模型密切相关。</p>\n<h4 id=\"1-String-内存结构\"><a href=\"#1-String-内存结构\" class=\"headerlink\" title=\"1. String 内存结构\"></a>1. <strong><code>String</code> 内存结构</strong></h4><p>Java 中的 <code>String</code> 是一个不可变类，表示字符序列。其内存结构包括：</p>\n<ul>\n<li><strong>对象头</strong>：每个对象（包括 <code>String</code> 对象）都有一个对象头，在 32 位 JVM 上通常是 8 字节，在 64 位 JVM 上通常是 16 字节。</li>\n<li><strong>字符数组</strong>：<code>String</code> 内部实际上是由一个字符数组（<code>char[]</code>）来存储字符的(现在改成了用 <strong>byte[ ]</strong> )。每个 <code>char</code> 占 2 字节（因为 <code>char</code> 使用 UTF-16 编码，每个字符占 2 字节）。例如，<code>&quot;hello&quot;</code> 字符串将使用一个包含 5 个 <code>char</code> 元素的数组，总共占用 10 字节, 现在直接表示10字节.</li>\n<li><strong>字符串常量池</strong>：所有字面量字符串（例如 <code>&quot;hello&quot;</code>）都会存储在 JVM 的字符串常量池中，这是为了共享相同的字符串对象而减少内存使用。</li>\n</ul>\n<h4 id=\"2-String-对象的内存计算\"><a href=\"#2-String-对象的内存计算\" class=\"headerlink\" title=\"2. String 对象的内存计算\"></a>2. <strong><code>String</code> 对象的内存计算</strong></h4><p>以字符串 <code>&quot;hello&quot;</code> 为例，假设我们在 64 位 JVM 上运行，并且启用了压缩指针：</p>\n<ol>\n<li><strong>对象头</strong>：16 字节</li>\n<li>字符数组<ul>\n<li><code>&quot;hello&quot;</code> 中有 5 个字符，<code>char[]</code> 数组需要 5 * 2 = 10 字节。</li>\n</ul>\n</li>\n<li><strong>引用的内存</strong>：字符数组的引用通常占用 4 字节。</li>\n<li><strong>字符串常量池</strong>：常量池中会存储该字符串，但这部分内存不直接计算在对象本身的内存中。</li>\n</ol>\n<p>因此， <code>&quot;hello&quot;</code> 字符串对象的内存占用大概为：</p>\n<ul>\n<li>对象头：16 字节</li>\n<li>字符数组：10 字节</li>\n<li>字符数组引用：4 字节</li>\n<li>总计：16 + 10 + 4 = 30 字节</li>\n</ul>\n<p>如果 <code>String</code> 以更复杂的形式存在（例如通过拼接或构建 <code>StringBuilder</code>），则内存占用可能会更大。</p>\n<h4 id=\"3-String-对象的共享与常量池\"><a href=\"#3-String-对象的共享与常量池\" class=\"headerlink\" title=\"3. String 对象的共享与常量池\"></a>3. <strong><code>String</code> 对象的共享与常量池</strong></h4><p>在 Java 中，所有常量字符串会被存储在 <strong>字符串常量池</strong> 中，这是一个特定区域，目的是避免多个相同的字符串对象占用重复的内存。也就是说，<strong>相同内容的字符串对象会共享同一内存</strong>。例如，以下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>在内存中，<code>str1</code> 和 <code>str2</code> 将引用同一个字符串对象，而不会分别占用额外的内存。</p>\n<hr>\n<h2 id=\"四、内存引用占用的详细解释\"><a href=\"#四、内存引用占用的详细解释\" class=\"headerlink\" title=\"四、内存引用占用的详细解释\"></a>四、内存引用占用的详细解释</h2><h4 id=\"1-引用的内存占用\"><a href=\"#1-引用的内存占用\" class=\"headerlink\" title=\"1. 引用的内存占用\"></a>1. <strong>引用的内存占用</strong></h4><p>在 Java 中，引用类型的变量（如类的实例、数组、<code>String</code> 等）存储的并不是数据本身，而是指向实际数据的<strong>引用</strong>。引用本身占用一定的内存。</p>\n<ul>\n<li><strong>引用大小</strong>：在 32 位的 JVM 上，引用占 4 字节；在 64 位的 JVM 上，引用占 8 字节（如果启用指针压缩）。引用类型的变量指向的对象本身存储在堆内存中，引用变量只是存储这个对象的内存地址。</li>\n</ul>\n<h4 id=\"2-数组引用占用\"><a href=\"#2-数组引用占用\" class=\"headerlink\" title=\"2. 数组引用占用\"></a>2. <strong>数组引用占用</strong></h4><p>对于数组，数组本身在堆上分配内存，数组的引用变量存储在栈上。</p>\n<ul>\n<li><strong>引用类型数组</strong>：数组的引用变量占用 4 字节（32 位 JVM）或 8 字节（64 位 JVM）。</li>\n<li><strong>数组元素内存</strong>：数组元素本身的内存取决于数组的类型。例如，<code>int[]</code> 数组的元素是 <code>int</code> 类型，占 4 字节，而 <code>String[]</code> 数组的元素是 <code>String</code> 类型，且 <code>String</code> 占用更大的内存。</li>\n</ul>\n<hr>\n<h2 id=\"五-数据传输速率与存储容量对比\"><a href=\"#五-数据传输速率与存储容量对比\" class=\"headerlink\" title=\"五.数据传输速率与存储容量对比\"></a>五.数据传输速率与存储容量对比</h2><ul>\n<li><strong>数据传输速率</strong> 是指 <strong>单位时间内</strong> 能传输的数据量，强调的是 <strong>时间</strong> 和 <strong>速度</strong>。</li>\n<li><strong>存储容量</strong> 是指计算机或硬盘能容纳的 <strong>数据总量</strong>，强调的是 <strong>空间</strong> 和 <strong>容量</strong>。</li>\n</ul>\n<h4 id=\"1-数据传输速率（网络带宽）\"><a href=\"#1-数据传输速率（网络带宽）\" class=\"headerlink\" title=\"1. 数据传输速率（网络带宽）\"></a>1. 数据传输速率（网络带宽）</h4><p><strong>数据传输速率</strong> 通常是指网络中单位时间内可以传输的数据量，通常以 <strong>比特/秒</strong>（bit per second，bps）为单位。常见的单位有：</p>\n<ul>\n<li><strong>Kbps (千比特每秒)</strong>：千比特每秒，1 Kbps = 1,000 bps</li>\n<li><strong>Mbps (兆比特每秒)</strong>：兆比特每秒，1 Mbps = 1,000,000 bps</li>\n<li><strong>Gbps (吉比特每秒)</strong>：吉比特每秒，1 Gbps = 1,000,000,000 bps</li>\n</ul>\n<p>例如，家庭宽带的速度可能是 <strong>100 Mbps</strong>，这意味着网络每秒能够传输 100,000,000 比特的数据。</p>\n<h4 id=\"2-存储容量\"><a href=\"#2-存储容量\" class=\"headerlink\" title=\"2. 存储容量\"></a>2. 存储容量</h4><p><strong>存储容量</strong> 指的是计算机、硬盘、SSD 或云存储中用于存放数据的大小。存储容量通常以 <strong>字节</strong>（Byte）为单位，1 字节等于 8 比特。常见的存储单位有：</p>\n<ul>\n<li><strong>KB (千字节)</strong>：1 KB = 1,024 字节</li>\n<li><strong>MB (兆字节)</strong>：1 MB = 1,024 KB = 1,048,576 字节</li>\n<li><strong>GB (千兆字节)</strong>：1 GB = 1,024 MB = 1,073,741,824 字节</li>\n<li><strong>TB (太字节)</strong>：1 TB = 1,024 GB</li>\n</ul>\n<p>比如，你的硬盘容量可能是 <strong>1TB</strong>，即 <strong>1,024 GB</strong>，表示硬盘上可以存储大约 1,073 亿字节的数据。</p>\n<h4 id=\"3-网络带宽的实际含义\"><a href=\"#3-网络带宽的实际含义\" class=\"headerlink\" title=\"3. 网络带宽的实际含义\"></a>3. 网络带宽的实际含义</h4><p>网络带宽的大小决定了在特定时间内，网络能够传输多少数据。例如：</p>\n<ul>\n<li><strong>10 Mbps</strong> 的带宽意味着每秒钟可以传输 10,000,000 比特的数据，或 <strong>1,250,000 字节</strong>（约 1.25 MB）。</li>\n<li>如果网络带宽为 <strong>100 Mbps</strong>，每秒可以传输 <strong>12.5 MB</strong> 的数据。</li>\n</ul>\n<p>换句话说，带宽越大，数据传输的速度就越快，文件上传、下载或在线视频流的质量也会更好。</p>\n<h4 id=\"4-存储容量的实际含义\"><a href=\"#4-存储容量的实际含义\" class=\"headerlink\" title=\"4. 存储容量的实际含义\"></a>4. 存储容量的实际含义</h4><p>存储容量决定了设备能存储多少数据。例如：</p>\n<ul>\n<li>一块 <strong>256GB</strong> 的固态硬盘可以存储 <strong>256,000 MB</strong> 的数据。</li>\n<li>如果存储容量是 <strong>2TB</strong>，这意味着它能存储大约 <strong>2,048,000 MB</strong> 的数据。</li>\n</ul>\n<p>存储容量的大小主要影响的是设备能够保存多少文件、应用程序或其他类型的数据，它与设备的性能和数据的持久存储相关。</p>\n<h4 id=\"5-举例\"><a href=\"#5-举例\" class=\"headerlink\" title=\"5.举例\"></a>5.举例</h4><p>假如有1G文件需要传输,那么转换成比特就是:</p>\n<script type=\"math/tex; mode=display\">\n1GB = 1,024 × 1,024 × 1,024 × 8 = 8,589,934,592 bit</script><p>传输公式如下: </p>\n<script type=\"math/tex; mode=display\">\n\\text{传\\,输\\,时\\,间} = \\frac{\\text{文件大小（比特）}}{\\text{带宽（比特/秒）}}</script><ul>\n<li><strong>网络带宽为 10 Mbps</strong>，即每秒传输 10,000,000 比特。传输时间可以通过以下公式计算：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\text{传\\ 输\\ 时\\ 间} = \\frac{8,589,934,592 \\, \\text{比特}}{10,000,000 \\, \\text{比特/秒}} = 858.99 \\, \\text{秒} \\approx 14.3 \\, \\text{分钟}</script><p>所以，传输一个 <strong>1GB</strong> 的文件，使用 <strong>10 Mbps</strong> 的带宽大约需要 <strong>14.3 分钟</strong>。</p>\n<ul>\n<li><strong>带宽为 100 Mbps</strong>（即 100,000,000 bps）：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\text{传\\ 输\\ 时\\ 间} = \\frac{8,589,934,592 \\, \\text{比特}}{100,000,000 \\, \\text{比特/秒}} = 85.9 \\, \\text{秒} \\approx 1.43 \\, \\text{分钟}</script><p>所以，传输一个 <strong>1GB</strong> 的文件，使用 <strong>100 Mbps</strong> 的带宽大约需要 <strong>1.43 分钟</strong>。</p>\n<h2 id=\"六、总结\"><a href=\"#六、总结\" class=\"headerlink\" title=\"六、总结\"></a>六、总结</h2><ol>\n<li><strong>数据存储单位</strong>：Bit、Byte、KB、MB、GB 等单位之间有明确的换算关系，需要牢记：<ul>\n<li>1 Byte = 8 Bits</li>\n<li>1 KB = 1024 Bytes</li>\n<li>1 MB = 1024 KB</li>\n<li>1 GB = 1024 MB</li>\n</ul>\n</li>\n<li><strong>Java 数据类型内存占用</strong>：Java 中的基本数据类型有固定的内存占用，引用类型的内存占用较为复杂，涉及对象头、字段的内存、引用的其他对象等。</li>\n<li><strong><code>String</code> 类型的内存占用</strong>：<code>String</code> 对象不仅包含字符数据，还包含对象头、字符数组及其引用、常量池中的存储等。</li>\n<li><strong>引用内存占用</strong>：Java 中的引用类型变量占用一定的内存，通常是 4 字节（32 位 JVM）或 8 字节（64 位 JVM），它们存储的仅仅是对象的引用，而不是数据本身。</li>\n<li>带宽关注的是 <strong>传输过程中的速度</strong>，而存储容量关注的是 <strong>数据存储的总量</strong></li>\n<li>mb和MB的区别: mb的b代表的是bit; MB的B代表的是Byte ,所以<strong>1MB = 8mb</strong>，即1兆字节等于8兆比特，因为1字节=8比特。</li>\n</ol>\n"},{"banner":"[[pixel-banner-image.png]]","title":"了解缓存的各种表现以及实现方法","date":"2025-04-15T13:12:00.000Z","_content":"\n\tNo matter what happens, I’ve got your back.\n# 缓存处理提高并发速率\n\t在高并发系统中，缓存是提升性能、减轻数据库压力的关键手段。本文从数据库缓存、前端缓存、SpringCache 多种缓存管理器等角度，系统性地梳理了缓存机制与实践经验。\n---\n## 数据库的内部缓存\n### 引擎缓存池(InnoDB Buffer Pool)\n- 可以缓存**磁盘上经常操作的真实数据**，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。\n#### 存储空间\n\n| 缓存内容             | 说明   |\n| :--------------- | :--- |\n| 数据页（Data Pages）  | 表的数据 |\n| 索引页（Index Pages） | 索引结构 |\n| undo log、插入缓冲等   | 内部使用 |\n#### 优点\n- 不需要手动写逻辑，MySQL 自动将**热点数据**缓存进内存\n- 读操作速度快, **缓存在缓存池内存中**，读取数据就像从 `RAM` 里拿，速度比磁盘快几个数量级\n- 缓存的页与磁盘数据由 `InnoDB` 自己维护，不存在“缓存不一致”的问题\n- 不仅是数据页，索引结构也会缓存在内存中，提高复杂查询的执行效率\n#### 缺点\n- `InnoDB` 缓存是**本地内存缓存**，**不能跨服务、跨节点共享，不适合分布式环境**\n- **无法像 Redis 那样对特定 key 设置 TTL、失效策略, 不可自定义**\n- 没有 `@Cacheable` 那种“缓存先读，数据库兜底”的能力\n- 缓存命中率低, 热点业务不会优先\n### `Mybatis` 缓存\n#### 一级缓存\n- 同一个事务前提下, 保存重复的sql语句执行结果, **默认在一个会话线程有效**, 默认开启\n- 生效条件: **事务 中途不发生增删改(发生就清空缓存)**\n```java\n@Transactional\npublic void testCache() {\n    userMapper.selectById(1L); // 第一次查\n    userMapper.selectById(1L); // 第二次查，命中缓存（只要 Spring 管理的是同一个会话线程）\n}\n```\n#### 二级缓存\n-  **在xml文件中使用<cache />开启, 不同会话下保存sql执行结果保存到本地缓存\n- 当前 xxxMapper.xml范围有效,  nameSpace中方法为key, 缓存数据为value\n- 提高查询效率，减少数据库访问次数, 缓存命中率: Cache HitRatio 0.5\n- 生效条件: **手动开启 只能在xml文件中定义 中途不发生增删改(发生就清空数据) 实体类需要序列化**\n```xml\n<mapper namespace=\"com.example.mapper.UserMapper\">\n  <cache /> <!-- 开启二级缓存 -->\n  <select>缓存内容</select>\n</mapper>\n```\n## 前端缓存\n| 缓存方式             | 生命周期 | 特点           |\n| ---------------- | ---- | ------------ |\n| `sessionStorage` | 会话级  | 页面关闭即清空缓存    |\n| `localStorage`   | 持久级  | 缓存持久存在，需手动清除 |\n## SpringCache 缓存管理器体系\n\n| 基本注解        | 说明                          |\n| ----------- | --------------------------- |\n| @Cacheable  | **缓存方法返回值**,当方法执行时有缓存直接返回缓存 |\n| @CachePut   | 更新缓存内容                      |\n| @CacheEvict | 删除缓存内容, 可以一次性指定前缀下的所有键值对    |\n| @Caching    | 支持多个注解组合使用                  |\n\n| 参数名                | 作用说明                                                                                                      |\n| ------------------ | --------------------------------------------------------------------------------------------------------- |\n| cacheManager       | 指定使用哪个**缓存管理器**（如本地或者Redis）你可以在配置中自定义多个管理器。                                                               |\n| value / cacheNames | 缓存的名字，对应配置的缓存区域名，可以是 **Redis 中的前缀**。二者等价，推荐使用 `value`。                                                    |\n| key                | 缓存的 key，支持 SpEL 表达式，如 `#id`、`#user.name`。默认使用方法所有参数作为 key。                                                |\n| condition          | 缓存的“执行前”判断，只有满足条件才执行缓存操作。支持 `SpEL`。                                                                       |\n| unless             | 缓存的“执行后”判断，如果为 true，则**不缓存**返回结果。支持 SpEL。                                                                 |\n| keyGenerator       | 如果你想自定义缓存 key 生成规则（而不是 key），可以配置 key 生成器的 bean 名称。                                                        |\n| sync               | 避免缓存击穿热点key问题，设置为 `true` 时，当多个线程访问同一个 key 时，只有一个线程去执行方法，其它线程阻塞等待结果（只有 RedisCacheManager 支持这个参数, **加锁行为**! |\n| cacheResolve       | 替代 `cacheManager` 来决定用哪个缓存,需要配置类进行策略行为@Cacheable(cacheResolver = \"myCacheResolver\")                       |\n\n### 本地缓存\n#### SimpleCacheManager(默认)\n- Spring Cache 默认实现 = `SimpleCacheManager` + **`ConcurrentMap`**（**基于内存**的Map缓存）\n- 这个 `ConcurrentMap` 就是一个普通的线程安全 `Map`，存放在应用的 JVM 堆内存中\n- 无法设置过期策略，**永远不会失效**, 所以可能需要一个定时任务来检查是否需要手动删除缓存\n- 不能设置最大容量，**风险是 `OOM`（内存溢出）**\n#### CaffeineManager\n- Caffeine 是一个 **高性能的本地缓存库**，是 Java 里速度最快、最强大的缓存框架之一，用来替代传统的 简单的 `Map` 缓存，非常适合对性能要求高的单体项目\n- **使用`ConcurrentLinkedHashMap`作为容器**\n- 使用分段 `CAS` + `LRU` 策略\n- 支持配置 `expireAfterWrite`, `maximumSize` 等\n- 功能强大, 支持异步刷新、统计分析\n- 支持大多数的缓存过期策略\n![17447245005311744724500093.png|700x355](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17447245005311744724500093.png)\n\n### 分布式缓存(多节点)\n#### RedisManger\n\t在微服务架构中推荐使用分布式缓存实现缓存共享、状态同步。\n- 支持 TTL、自定义序列化、跨服务访问\n- 适用于高并发、高可用系统\n- 但需要额外部署 Redis 服务，复杂度略高\n## 多级缓存（Multi-Level Cache）\n- 将 **本地缓存（如 Caffeine）+ 分布式缓存（如 Redis）** 结合，先查本地未命中再查 Redis，兼顾**速度与一致性**。\n```java\n@Cached(name=\"userCache-\", key=\"#userId\", expire = 3600, cacheType = CacheType.BOTH)\npublic User getUserById(Long userId) {\n    return userRepository.findById(userId);\n}\n```\n### 例子\n#### 目标类上的注解\n```java\n@Cacheable(cacheManager = \"redisManager\",  \n        value = \"user\",  \n        key = \"pageQuery + '_' + #userDTO.id\"\n        condition = \"#userDTO.id != null \",  \n        unless = \"#result == null || #result.total == 0\"  // 查询结果为空就不缓存  \n)\n```\n#### 配置类\n```java\n/**  \n * 不同缓存管理器的配置类Manager + caffeine基本配置  \n * @author cloud_3111  \n * @since 2025-04-16  \n */@Configuration(enforceUniqueMethods = false)  \npublic class cacheConfig {  \n  \n    /**  \n     * SpringCache默认使用ConcurrentHashMap作为缓存Map  \n     * @return {@code CacheManager }  \n     */  \n    @Bean(name = \"mapManager\")  \n    public CacheManager SimpleCacheManager() {  \n        // 创建一个简单缓存管理器  \n        SimpleCacheManager manager = new SimpleCacheManager();  \n  \n        List<ConcurrentMapCache> caches = new ArrayList<>();  \n        caches.add(new ConcurrentMapCache(\"default\"));  \n        caches.add(new ConcurrentMapCache(\"userCache\"));  \n        caches.add(new ConcurrentMapCache(\"productCache\"));  \n  \n        manager.setCaches(caches);  \n        return manager;  \n    }  \n  \n    /**  \n     * 虽然跟ConcurrentHashMap一样是本地缓存, 但是caffeine框架支持自定义过期时间,大小…  \n     * 使用concurrentLinkedHashMap作为容器,采用segment分段cas来适应高并发访问,支持异步处理(需开启)  \n     * @return {@code CacheManager }  \n     */  \n    @Bean(name = \"caffeineManager\")  \n    public CacheManager caffeineManager() {  \n        CaffeineCacheManager cacheManager = new CaffeineCacheManager();  \n  \n        // 配置 Caffeine 缓存  \n        cacheManager.setCaffeine(Caffeine.newBuilder()  \n                .expireAfterWrite(10, TimeUnit.MINUTES) // 设置缓存过期时间  \n                .maximumSize(100) // 设置缓存最大条目  \n                .weakKeys() // 使用弱引用来保存缓存的键,可被回收  \n                .recordStats()); // 启用统计信息  \n  \n        return cacheManager;  \n    }  \n  \n    /**  \n     * 使用redis做分布式缓存  \n     * 因为Jackson 在进行 Redis 缓存序列化时，无法处理 Java 8 的 LocalTime LocalDatetime… 类型和反序列的问题,需要注册转换器模块  \n     * @param connectionFactory 连接工厂  \n     * @return {@code CacheManager }  \n     */  \n    @Primary  \n    @Bean(name = \"redisManager\")  \n    public CacheManager redisManager(RedisConnectionFactory connectionFactory) {  \n        // 1. 自定义 ObjectMapper       \n         ObjectMapper objectMapper = new ObjectMapper();  \n         // 支持 LocalDate、LocalDateTime、LocalTime  \n        objectMapper.registerModule(new JavaTimeModule()); \n        // 不以时间戳形式序列化  \n        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); \n        //让 Jackson 在序列化时加上类型信息（如 \"@class\": \"com.xxx.pageVO\"），这样反序列化才不会成 LinkedHashMap        \n        objectMapper.activateDefaultTyping(  \n                LaissezFaireSubTypeValidator.instance,  \n                ObjectMapper.DefaultTyping.NON_FINAL,  \n                JsonTypeInfo.As.PROPERTY  \n        );  \n  \n        // 2. 创建 JSON 序列化器  \n        GenericJackson2JsonRedisSerializer jackson2JsonRedisSerializer =  \n                new GenericJackson2JsonRedisSerializer(objectMapper);  \n  \n        // 3.创建默认的序列化配置  \n        RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()  \n                // 设置默认缓存有效期为10分钟  \n                .entryTtl(Duration.ofMinutes(10))  \n                // Key序列化  \n            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))  \n                // Value序列化  \n                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))  \n                //  配置 key 前缀: 默认允许前缀和空值  \n                .prefixCacheNameWith(\"train:business:\");  \n  \n        // 4.创建RedisCacheManager  \n        return RedisCacheManager.builder(connectionFactory)  \n                .cacheDefaults(cacheConfig)  \n                .build();  \n    }  \n  \n    /**  \n     * caffeine框架自带的包(不与SpringCache关联的用法)  \n     * 更底层、更灵活，适合手动操作缓存：  \n     * 使用方法: 也是操作底层map  \n     * cache.put(\"key\", value);  \n     * cache.getIfPresent(\"key\");  \n     * cache.invalidate(\"key\");  \n     */    @Bean(name = \"caffeine\")  \n    public Cache<Object, Object> caffeine() {  \n        return Caffeine.newBuilder()  \n                // 设置最后一次写入或访问后经过固定时间过期  \n                .expireAfterWrite(30, TimeUnit.SECONDS)  \n                // 初始的缓存空间大小  \n                .initialCapacity(100)  \n                // 缓存的最大条数  \n                .maximumSize(1000)  \n                .build();  \n    }  \n}\n```\n#### 验证CaffeineManager的正常工作\n```java\n@SpringBootTest(classes = businessApplication.class, properties = \"spring.config.location=classpath:/application-test.yaml\")  \n//@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})  \npublic class businessTest {  \n  \n    @Qualifier(\"caffeineManager\")  \n    @Autowired  \n    private CacheManager caffeineManager;  \n    \n\t@Qualifier(\"SimpleCacheManager\")  \n\t@Autowired  \n\tprivate CacheManager SimpleCacheManager;\n  \n    @Autowired  \n    private DailyTrainService dailyTrainService;  \n  \n    @Test  \n    public void testCaffeineManager() {  \n        DailyTrainQuery dailyTrainQuery = new DailyTrainQuery();  \n        dailyTrainQuery.setTrainCode(\"D3306\");  \n        dailyTrainQuery.setPageNum(1);  \n        dailyTrainQuery.setPageSize(5);  \n\t\t// 第一次查询数据库,第二次查询缓存\n        dailyTrainService.queryList(dailyTrainQuery);  \n        dailyTrainService.queryList(dailyTrainQuery);  \n        for (String cacheName : caffeineManager.getCacheNames()) {  \n            Cache cache = caffeineManager.getCache(cacheName);  \n            if (cache instanceof CaffeineCache caffeineCache) {  \n\t            // 底层map容器: ConcurrentLinkedHashMap\n                ConcurrentMap<Object, Object> map =     caffeineCache.getNativeCache().asMap();  \n                System.out.println(\"打印缓存map开始\");  \n                map.forEach((key, value) -> System.out.println(key + \" : \" + value));  \n                System.out.println(\"打印缓存map结束\");  \n                break;  \n            }  \n            System.out.println(\"未找到\");  \n        }  \n    }  \n    @Test  \n\tpublic void testSimpleCacheManager() {  \n\t    DailyTrainCarriageQuery dailyTrainCarriageQuery = new DailyTrainCarriageQuery();  \n\t    dailyTrainCarriageQuery.setTrainCode(\"D3307\");  \n\t    dailyTrainCarriageQuery.setPageNum(1);  \n\t    dailyTrainCarriageQuery.setPageSize(5);  \n\t  \n\t    dailyTrainCarriageService.queryList(dailyTrainCarriageQuery);  \n\t    dailyTrainCarriageService.queryList(dailyTrainCarriageQuery);  \n\t    Cache cache = SimpleCacheManager.getCache(\"DailyTrainCarriage\");  \n\t    System.out.println(cache.getNativeCache());  \n\t}\n}\n```\n### 总结\n| 类型          | 特性                    | 场景推荐      |\n| ----------- | --------------------- | --------- |\n| InnoDB 缓存   | 引擎自动缓存，无需配置           | 基础数据库访问优化 |\n| MyBatis 缓存  | 降低 SQL 重复执行，需小心失效     | 简单系统      |\n| 本地缓存        | 快速访问，单机系统最佳           | 单体应用      |\n| Caffeine 缓存 | 高性能本地缓存，支持 TTL等, 功能丰富 | 高频操作本地数据  |\n| Redis 缓存    | 分布式缓存，支持共享与持久化        | 微服务/多节点系统 |\n- 所有的缓存管理器下的缓存管理组成\n![17448769185421744876917946.png|519x437](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17448769185421744876917946.png)\n## 缓存过期策略","source":"_posts/cacheManager.md","raw":"---\nbanner: \"[[pixel-banner-image.png]]\"\ntitle: 了解缓存的各种表现以及实现方法\ntags:\n  - Cache\n  - Redis\ncategories: 编程\ndate: 2025-04-15T21:12:00\n---\n\n\tNo matter what happens, I’ve got your back.\n# 缓存处理提高并发速率\n\t在高并发系统中，缓存是提升性能、减轻数据库压力的关键手段。本文从数据库缓存、前端缓存、SpringCache 多种缓存管理器等角度，系统性地梳理了缓存机制与实践经验。\n---\n## 数据库的内部缓存\n### 引擎缓存池(InnoDB Buffer Pool)\n- 可以缓存**磁盘上经常操作的真实数据**，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。\n#### 存储空间\n\n| 缓存内容             | 说明   |\n| :--------------- | :--- |\n| 数据页（Data Pages）  | 表的数据 |\n| 索引页（Index Pages） | 索引结构 |\n| undo log、插入缓冲等   | 内部使用 |\n#### 优点\n- 不需要手动写逻辑，MySQL 自动将**热点数据**缓存进内存\n- 读操作速度快, **缓存在缓存池内存中**，读取数据就像从 `RAM` 里拿，速度比磁盘快几个数量级\n- 缓存的页与磁盘数据由 `InnoDB` 自己维护，不存在“缓存不一致”的问题\n- 不仅是数据页，索引结构也会缓存在内存中，提高复杂查询的执行效率\n#### 缺点\n- `InnoDB` 缓存是**本地内存缓存**，**不能跨服务、跨节点共享，不适合分布式环境**\n- **无法像 Redis 那样对特定 key 设置 TTL、失效策略, 不可自定义**\n- 没有 `@Cacheable` 那种“缓存先读，数据库兜底”的能力\n- 缓存命中率低, 热点业务不会优先\n### `Mybatis` 缓存\n#### 一级缓存\n- 同一个事务前提下, 保存重复的sql语句执行结果, **默认在一个会话线程有效**, 默认开启\n- 生效条件: **事务 中途不发生增删改(发生就清空缓存)**\n```java\n@Transactional\npublic void testCache() {\n    userMapper.selectById(1L); // 第一次查\n    userMapper.selectById(1L); // 第二次查，命中缓存（只要 Spring 管理的是同一个会话线程）\n}\n```\n#### 二级缓存\n-  **在xml文件中使用<cache />开启, 不同会话下保存sql执行结果保存到本地缓存\n- 当前 xxxMapper.xml范围有效,  nameSpace中方法为key, 缓存数据为value\n- 提高查询效率，减少数据库访问次数, 缓存命中率: Cache HitRatio 0.5\n- 生效条件: **手动开启 只能在xml文件中定义 中途不发生增删改(发生就清空数据) 实体类需要序列化**\n```xml\n<mapper namespace=\"com.example.mapper.UserMapper\">\n  <cache /> <!-- 开启二级缓存 -->\n  <select>缓存内容</select>\n</mapper>\n```\n## 前端缓存\n| 缓存方式             | 生命周期 | 特点           |\n| ---------------- | ---- | ------------ |\n| `sessionStorage` | 会话级  | 页面关闭即清空缓存    |\n| `localStorage`   | 持久级  | 缓存持久存在，需手动清除 |\n## SpringCache 缓存管理器体系\n\n| 基本注解        | 说明                          |\n| ----------- | --------------------------- |\n| @Cacheable  | **缓存方法返回值**,当方法执行时有缓存直接返回缓存 |\n| @CachePut   | 更新缓存内容                      |\n| @CacheEvict | 删除缓存内容, 可以一次性指定前缀下的所有键值对    |\n| @Caching    | 支持多个注解组合使用                  |\n\n| 参数名                | 作用说明                                                                                                      |\n| ------------------ | --------------------------------------------------------------------------------------------------------- |\n| cacheManager       | 指定使用哪个**缓存管理器**（如本地或者Redis）你可以在配置中自定义多个管理器。                                                               |\n| value / cacheNames | 缓存的名字，对应配置的缓存区域名，可以是 **Redis 中的前缀**。二者等价，推荐使用 `value`。                                                    |\n| key                | 缓存的 key，支持 SpEL 表达式，如 `#id`、`#user.name`。默认使用方法所有参数作为 key。                                                |\n| condition          | 缓存的“执行前”判断，只有满足条件才执行缓存操作。支持 `SpEL`。                                                                       |\n| unless             | 缓存的“执行后”判断，如果为 true，则**不缓存**返回结果。支持 SpEL。                                                                 |\n| keyGenerator       | 如果你想自定义缓存 key 生成规则（而不是 key），可以配置 key 生成器的 bean 名称。                                                        |\n| sync               | 避免缓存击穿热点key问题，设置为 `true` 时，当多个线程访问同一个 key 时，只有一个线程去执行方法，其它线程阻塞等待结果（只有 RedisCacheManager 支持这个参数, **加锁行为**! |\n| cacheResolve       | 替代 `cacheManager` 来决定用哪个缓存,需要配置类进行策略行为@Cacheable(cacheResolver = \"myCacheResolver\")                       |\n\n### 本地缓存\n#### SimpleCacheManager(默认)\n- Spring Cache 默认实现 = `SimpleCacheManager` + **`ConcurrentMap`**（**基于内存**的Map缓存）\n- 这个 `ConcurrentMap` 就是一个普通的线程安全 `Map`，存放在应用的 JVM 堆内存中\n- 无法设置过期策略，**永远不会失效**, 所以可能需要一个定时任务来检查是否需要手动删除缓存\n- 不能设置最大容量，**风险是 `OOM`（内存溢出）**\n#### CaffeineManager\n- Caffeine 是一个 **高性能的本地缓存库**，是 Java 里速度最快、最强大的缓存框架之一，用来替代传统的 简单的 `Map` 缓存，非常适合对性能要求高的单体项目\n- **使用`ConcurrentLinkedHashMap`作为容器**\n- 使用分段 `CAS` + `LRU` 策略\n- 支持配置 `expireAfterWrite`, `maximumSize` 等\n- 功能强大, 支持异步刷新、统计分析\n- 支持大多数的缓存过期策略\n![17447245005311744724500093.png|700x355](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17447245005311744724500093.png)\n\n### 分布式缓存(多节点)\n#### RedisManger\n\t在微服务架构中推荐使用分布式缓存实现缓存共享、状态同步。\n- 支持 TTL、自定义序列化、跨服务访问\n- 适用于高并发、高可用系统\n- 但需要额外部署 Redis 服务，复杂度略高\n## 多级缓存（Multi-Level Cache）\n- 将 **本地缓存（如 Caffeine）+ 分布式缓存（如 Redis）** 结合，先查本地未命中再查 Redis，兼顾**速度与一致性**。\n```java\n@Cached(name=\"userCache-\", key=\"#userId\", expire = 3600, cacheType = CacheType.BOTH)\npublic User getUserById(Long userId) {\n    return userRepository.findById(userId);\n}\n```\n### 例子\n#### 目标类上的注解\n```java\n@Cacheable(cacheManager = \"redisManager\",  \n        value = \"user\",  \n        key = \"pageQuery + '_' + #userDTO.id\"\n        condition = \"#userDTO.id != null \",  \n        unless = \"#result == null || #result.total == 0\"  // 查询结果为空就不缓存  \n)\n```\n#### 配置类\n```java\n/**  \n * 不同缓存管理器的配置类Manager + caffeine基本配置  \n * @author cloud_3111  \n * @since 2025-04-16  \n */@Configuration(enforceUniqueMethods = false)  \npublic class cacheConfig {  \n  \n    /**  \n     * SpringCache默认使用ConcurrentHashMap作为缓存Map  \n     * @return {@code CacheManager }  \n     */  \n    @Bean(name = \"mapManager\")  \n    public CacheManager SimpleCacheManager() {  \n        // 创建一个简单缓存管理器  \n        SimpleCacheManager manager = new SimpleCacheManager();  \n  \n        List<ConcurrentMapCache> caches = new ArrayList<>();  \n        caches.add(new ConcurrentMapCache(\"default\"));  \n        caches.add(new ConcurrentMapCache(\"userCache\"));  \n        caches.add(new ConcurrentMapCache(\"productCache\"));  \n  \n        manager.setCaches(caches);  \n        return manager;  \n    }  \n  \n    /**  \n     * 虽然跟ConcurrentHashMap一样是本地缓存, 但是caffeine框架支持自定义过期时间,大小…  \n     * 使用concurrentLinkedHashMap作为容器,采用segment分段cas来适应高并发访问,支持异步处理(需开启)  \n     * @return {@code CacheManager }  \n     */  \n    @Bean(name = \"caffeineManager\")  \n    public CacheManager caffeineManager() {  \n        CaffeineCacheManager cacheManager = new CaffeineCacheManager();  \n  \n        // 配置 Caffeine 缓存  \n        cacheManager.setCaffeine(Caffeine.newBuilder()  \n                .expireAfterWrite(10, TimeUnit.MINUTES) // 设置缓存过期时间  \n                .maximumSize(100) // 设置缓存最大条目  \n                .weakKeys() // 使用弱引用来保存缓存的键,可被回收  \n                .recordStats()); // 启用统计信息  \n  \n        return cacheManager;  \n    }  \n  \n    /**  \n     * 使用redis做分布式缓存  \n     * 因为Jackson 在进行 Redis 缓存序列化时，无法处理 Java 8 的 LocalTime LocalDatetime… 类型和反序列的问题,需要注册转换器模块  \n     * @param connectionFactory 连接工厂  \n     * @return {@code CacheManager }  \n     */  \n    @Primary  \n    @Bean(name = \"redisManager\")  \n    public CacheManager redisManager(RedisConnectionFactory connectionFactory) {  \n        // 1. 自定义 ObjectMapper       \n         ObjectMapper objectMapper = new ObjectMapper();  \n         // 支持 LocalDate、LocalDateTime、LocalTime  \n        objectMapper.registerModule(new JavaTimeModule()); \n        // 不以时间戳形式序列化  \n        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); \n        //让 Jackson 在序列化时加上类型信息（如 \"@class\": \"com.xxx.pageVO\"），这样反序列化才不会成 LinkedHashMap        \n        objectMapper.activateDefaultTyping(  \n                LaissezFaireSubTypeValidator.instance,  \n                ObjectMapper.DefaultTyping.NON_FINAL,  \n                JsonTypeInfo.As.PROPERTY  \n        );  \n  \n        // 2. 创建 JSON 序列化器  \n        GenericJackson2JsonRedisSerializer jackson2JsonRedisSerializer =  \n                new GenericJackson2JsonRedisSerializer(objectMapper);  \n  \n        // 3.创建默认的序列化配置  \n        RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig()  \n                // 设置默认缓存有效期为10分钟  \n                .entryTtl(Duration.ofMinutes(10))  \n                // Key序列化  \n            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))  \n                // Value序列化  \n                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))  \n                //  配置 key 前缀: 默认允许前缀和空值  \n                .prefixCacheNameWith(\"train:business:\");  \n  \n        // 4.创建RedisCacheManager  \n        return RedisCacheManager.builder(connectionFactory)  \n                .cacheDefaults(cacheConfig)  \n                .build();  \n    }  \n  \n    /**  \n     * caffeine框架自带的包(不与SpringCache关联的用法)  \n     * 更底层、更灵活，适合手动操作缓存：  \n     * 使用方法: 也是操作底层map  \n     * cache.put(\"key\", value);  \n     * cache.getIfPresent(\"key\");  \n     * cache.invalidate(\"key\");  \n     */    @Bean(name = \"caffeine\")  \n    public Cache<Object, Object> caffeine() {  \n        return Caffeine.newBuilder()  \n                // 设置最后一次写入或访问后经过固定时间过期  \n                .expireAfterWrite(30, TimeUnit.SECONDS)  \n                // 初始的缓存空间大小  \n                .initialCapacity(100)  \n                // 缓存的最大条数  \n                .maximumSize(1000)  \n                .build();  \n    }  \n}\n```\n#### 验证CaffeineManager的正常工作\n```java\n@SpringBootTest(classes = businessApplication.class, properties = \"spring.config.location=classpath:/application-test.yaml\")  \n//@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})  \npublic class businessTest {  \n  \n    @Qualifier(\"caffeineManager\")  \n    @Autowired  \n    private CacheManager caffeineManager;  \n    \n\t@Qualifier(\"SimpleCacheManager\")  \n\t@Autowired  \n\tprivate CacheManager SimpleCacheManager;\n  \n    @Autowired  \n    private DailyTrainService dailyTrainService;  \n  \n    @Test  \n    public void testCaffeineManager() {  \n        DailyTrainQuery dailyTrainQuery = new DailyTrainQuery();  \n        dailyTrainQuery.setTrainCode(\"D3306\");  \n        dailyTrainQuery.setPageNum(1);  \n        dailyTrainQuery.setPageSize(5);  \n\t\t// 第一次查询数据库,第二次查询缓存\n        dailyTrainService.queryList(dailyTrainQuery);  \n        dailyTrainService.queryList(dailyTrainQuery);  \n        for (String cacheName : caffeineManager.getCacheNames()) {  \n            Cache cache = caffeineManager.getCache(cacheName);  \n            if (cache instanceof CaffeineCache caffeineCache) {  \n\t            // 底层map容器: ConcurrentLinkedHashMap\n                ConcurrentMap<Object, Object> map =     caffeineCache.getNativeCache().asMap();  \n                System.out.println(\"打印缓存map开始\");  \n                map.forEach((key, value) -> System.out.println(key + \" : \" + value));  \n                System.out.println(\"打印缓存map结束\");  \n                break;  \n            }  \n            System.out.println(\"未找到\");  \n        }  \n    }  \n    @Test  \n\tpublic void testSimpleCacheManager() {  \n\t    DailyTrainCarriageQuery dailyTrainCarriageQuery = new DailyTrainCarriageQuery();  \n\t    dailyTrainCarriageQuery.setTrainCode(\"D3307\");  \n\t    dailyTrainCarriageQuery.setPageNum(1);  \n\t    dailyTrainCarriageQuery.setPageSize(5);  \n\t  \n\t    dailyTrainCarriageService.queryList(dailyTrainCarriageQuery);  \n\t    dailyTrainCarriageService.queryList(dailyTrainCarriageQuery);  \n\t    Cache cache = SimpleCacheManager.getCache(\"DailyTrainCarriage\");  \n\t    System.out.println(cache.getNativeCache());  \n\t}\n}\n```\n### 总结\n| 类型          | 特性                    | 场景推荐      |\n| ----------- | --------------------- | --------- |\n| InnoDB 缓存   | 引擎自动缓存，无需配置           | 基础数据库访问优化 |\n| MyBatis 缓存  | 降低 SQL 重复执行，需小心失效     | 简单系统      |\n| 本地缓存        | 快速访问，单机系统最佳           | 单体应用      |\n| Caffeine 缓存 | 高性能本地缓存，支持 TTL等, 功能丰富 | 高频操作本地数据  |\n| Redis 缓存    | 分布式缓存，支持共享与持久化        | 微服务/多节点系统 |\n- 所有的缓存管理器下的缓存管理组成\n![17448769185421744876917946.png|519x437](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17448769185421744876917946.png)\n## 缓存过期策略","slug":"cacheManager","published":1,"updated":"2025-10-15T12:59:59.276Z","_id":"cmfw4z09z0019uomw9e3lbvit","comments":1,"layout":"post","photos":[],"content":"<pre><code>No matter what happens, I’ve got your back.\n</code></pre><h1 id=\"缓存处理提高并发速率\"><a href=\"#缓存处理提高并发速率\" class=\"headerlink\" title=\"缓存处理提高并发速率\"></a>缓存处理提高并发速率</h1><pre><code>在高并发系统中，缓存是提升性能、减轻数据库压力的关键手段。本文从数据库缓存、前端缓存、SpringCache 多种缓存管理器等角度，系统性地梳理了缓存机制与实践经验。\n</code></pre><hr>\n<h2 id=\"数据库的内部缓存\"><a href=\"#数据库的内部缓存\" class=\"headerlink\" title=\"数据库的内部缓存\"></a>数据库的内部缓存</h2><h3 id=\"引擎缓存池-InnoDB-Buffer-Pool\"><a href=\"#引擎缓存池-InnoDB-Buffer-Pool\" class=\"headerlink\" title=\"引擎缓存池(InnoDB Buffer Pool)\"></a>引擎缓存池(InnoDB Buffer Pool)</h3><ul>\n<li>可以缓存<strong>磁盘上经常操作的真实数据</strong>，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。<h4 id=\"存储空间\"><a href=\"#存储空间\" class=\"headerlink\" title=\"存储空间\"></a>存储空间</h4></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">缓存内容</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">数据页（Data Pages）</td>\n<td style=\"text-align:left\">表的数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">索引页（Index Pages）</td>\n<td style=\"text-align:left\">索引结构</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">undo log、插入缓冲等</td>\n<td style=\"text-align:left\">内部使用</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>不需要手动写逻辑，MySQL 自动将<strong>热点数据</strong>缓存进内存</li>\n<li>读操作速度快, <strong>缓存在缓存池内存中</strong>，读取数据就像从 <code>RAM</code> 里拿，速度比磁盘快几个数量级</li>\n<li>缓存的页与磁盘数据由 <code>InnoDB</code> 自己维护，不存在“缓存不一致”的问题</li>\n<li>不仅是数据页，索引结构也会缓存在内存中，提高复杂查询的执行效率<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4></li>\n<li><code>InnoDB</code> 缓存是<strong>本地内存缓存</strong>，<strong>不能跨服务、跨节点共享，不适合分布式环境</strong></li>\n<li><strong>无法像 Redis 那样对特定 key 设置 TTL、失效策略, 不可自定义</strong></li>\n<li>没有 <code>@Cacheable</code> 那种“缓存先读，数据库兜底”的能力</li>\n<li>缓存命中率低, 热点业务不会优先<h3 id=\"Mybatis-缓存\"><a href=\"#Mybatis-缓存\" class=\"headerlink\" title=\"Mybatis 缓存\"></a><code>Mybatis</code> 缓存</h3><h4 id=\"一级缓存\"><a href=\"#一级缓存\" class=\"headerlink\" title=\"一级缓存\"></a>一级缓存</h4></li>\n<li>同一个事务前提下, 保存重复的sql语句执行结果, <strong>默认在一个会话线程有效</strong>, 默认开启</li>\n<li>生效条件: <strong>事务 中途不发生增删改(发生就清空缓存)</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testCache</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    userMapper.selectById(<span class=\"number\">1L</span>); <span class=\"comment\">// 第一次查</span></span><br><span class=\"line\">    userMapper.selectById(<span class=\"number\">1L</span>); <span class=\"comment\">// 第二次查，命中缓存（只要 Spring 管理的是同一个会话线程）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二级缓存\"><a href=\"#二级缓存\" class=\"headerlink\" title=\"二级缓存\"></a>二级缓存</h4></li>\n<li>**在xml文件中使用<cache />开启, 不同会话下保存sql执行结果保存到本地缓存</li>\n<li>当前 xxxMapper.xml范围有效,  nameSpace中方法为key, 缓存数据为value</li>\n<li>提高查询效率，减少数据库访问次数, 缓存命中率: Cache HitRatio 0.5</li>\n<li>生效条件: <strong>手动开启 只能在xml文件中定义 中途不发生增删改(发生就清空数据) 实体类需要序列化</strong><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">cache</span> /&gt;</span> <span class=\"comment\">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span>缓存内容<span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"前端缓存\"><a href=\"#前端缓存\" class=\"headerlink\" title=\"前端缓存\"></a>前端缓存</h2>| 缓存方式             | 生命周期 | 特点           |<br>| ———————— | —— | —————— |<br>| <code>sessionStorage</code> | 会话级  | 页面关闭即清空缓存    |<br>| <code>localStorage</code>   | 持久级  | 缓存持久存在，需手动清除 |<h2 id=\"SpringCache-缓存管理器体系\"><a href=\"#SpringCache-缓存管理器体系\" class=\"headerlink\" title=\"SpringCache 缓存管理器体系\"></a>SpringCache 缓存管理器体系</h2></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>基本注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@Cacheable</td>\n<td><strong>缓存方法返回值</strong>,当方法执行时有缓存直接返回缓存</td>\n</tr>\n<tr>\n<td>@CachePut</td>\n<td>更新缓存内容</td>\n</tr>\n<tr>\n<td>@CacheEvict</td>\n<td>删除缓存内容, 可以一次性指定前缀下的所有键值对</td>\n</tr>\n<tr>\n<td>@Caching</td>\n<td>支持多个注解组合使用</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>作用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cacheManager</td>\n<td>指定使用哪个<strong>缓存管理器</strong>（如本地或者Redis）你可以在配置中自定义多个管理器。</td>\n</tr>\n<tr>\n<td>value / cacheNames</td>\n<td>缓存的名字，对应配置的缓存区域名，可以是 <strong>Redis 中的前缀</strong>。二者等价，推荐使用 <code>value</code>。</td>\n</tr>\n<tr>\n<td>key</td>\n<td>缓存的 key，支持 SpEL 表达式，如 <code>#id</code>、<code>#user.name</code>。默认使用方法所有参数作为 key。</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>缓存的“执行前”判断，只有满足条件才执行缓存操作。支持 <code>SpEL</code>。</td>\n</tr>\n<tr>\n<td>unless</td>\n<td>缓存的“执行后”判断，如果为 true，则<strong>不缓存</strong>返回结果。支持 SpEL。</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>如果你想自定义缓存 key 生成规则（而不是 key），可以配置 key 生成器的 bean 名称。</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>避免缓存击穿热点key问题，设置为 <code>true</code> 时，当多个线程访问同一个 key 时，只有一个线程去执行方法，其它线程阻塞等待结果（只有 RedisCacheManager 支持这个参数, <strong>加锁行为</strong>!</td>\n</tr>\n<tr>\n<td>cacheResolve</td>\n<td>替代 <code>cacheManager</code> 来决定用哪个缓存,需要配置类进行策略行为@Cacheable(cacheResolver = “myCacheResolver”)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"本地缓存\"><a href=\"#本地缓存\" class=\"headerlink\" title=\"本地缓存\"></a>本地缓存</h3><h4 id=\"SimpleCacheManager-默认\"><a href=\"#SimpleCacheManager-默认\" class=\"headerlink\" title=\"SimpleCacheManager(默认)\"></a>SimpleCacheManager(默认)</h4><ul>\n<li>Spring Cache 默认实现 = <code>SimpleCacheManager</code> + <strong><code>ConcurrentMap</code></strong>（<strong>基于内存</strong>的Map缓存）</li>\n<li>这个 <code>ConcurrentMap</code> 就是一个普通的线程安全 <code>Map</code>，存放在应用的 JVM 堆内存中</li>\n<li>无法设置过期策略，<strong>永远不会失效</strong>, 所以可能需要一个定时任务来检查是否需要手动删除缓存</li>\n<li>不能设置最大容量，<strong>风险是 <code>OOM</code>（内存溢出）</strong><h4 id=\"CaffeineManager\"><a href=\"#CaffeineManager\" class=\"headerlink\" title=\"CaffeineManager\"></a>CaffeineManager</h4></li>\n<li>Caffeine 是一个 <strong>高性能的本地缓存库</strong>，是 Java 里速度最快、最强大的缓存框架之一，用来替代传统的 简单的 <code>Map</code> 缓存，非常适合对性能要求高的单体项目</li>\n<li><strong>使用<code>ConcurrentLinkedHashMap</code>作为容器</strong></li>\n<li>使用分段 <code>CAS</code> + <code>LRU</code> 策略</li>\n<li>支持配置 <code>expireAfterWrite</code>, <code>maximumSize</code> 等</li>\n<li>功能强大, 支持异步刷新、统计分析</li>\n<li>支持大多数的缓存过期策略<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17447245005311744724500093.png\" alt=\"17447245005311744724500093.png|700x355\"></li>\n</ul>\n<h3 id=\"分布式缓存-多节点\"><a href=\"#分布式缓存-多节点\" class=\"headerlink\" title=\"分布式缓存(多节点)\"></a>分布式缓存(多节点)</h3><h4 id=\"RedisManger\"><a href=\"#RedisManger\" class=\"headerlink\" title=\"RedisManger\"></a>RedisManger</h4><pre><code>在微服务架构中推荐使用分布式缓存实现缓存共享、状态同步。\n</code></pre><ul>\n<li>支持 TTL、自定义序列化、跨服务访问</li>\n<li>适用于高并发、高可用系统</li>\n<li>但需要额外部署 Redis 服务，复杂度略高<h2 id=\"多级缓存（Multi-Level-Cache）\"><a href=\"#多级缓存（Multi-Level-Cache）\" class=\"headerlink\" title=\"多级缓存（Multi-Level Cache）\"></a>多级缓存（Multi-Level Cache）</h2></li>\n<li>将 <strong>本地缓存（如 Caffeine）+ 分布式缓存（如 Redis）</strong> 结合，先查本地未命中再查 Redis，兼顾<strong>速度与一致性</strong>。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cached(name=&quot;userCache-&quot;, key=&quot;#userId&quot;, expire = 3600, cacheType = CacheType.BOTH)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> User <span class=\"title function_\">getUserById</span><span class=\"params\">(Long userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userRepository.findById(userId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><h4 id=\"目标类上的注解\"><a href=\"#目标类上的注解\" class=\"headerlink\" title=\"目标类上的注解\"></a>目标类上的注解</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable(cacheManager = &quot;redisManager&quot;,  </span></span><br><span class=\"line\"><span class=\"meta\">        value = &quot;user&quot;,  </span></span><br><span class=\"line\"><span class=\"meta\">        key = &quot;pageQuery + &#x27;_&#x27; + #userDTO.id&quot;</span></span><br><span class=\"line\"><span class=\"meta\">        condition = &quot;#userDTO.id != null &quot;,  </span></span><br><span class=\"line\"><span class=\"meta\">        unless = &quot;#result == null || #result.total == 0&quot;  // 查询结果为空就不缓存  </span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"配置类\"><a href=\"#配置类\" class=\"headerlink\" title=\"配置类\"></a>配置类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 不同缓存管理器的配置类Manager + caffeine基本配置  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> cloud_3111  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2025-04-16  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span><span class=\"meta\">@Configuration(enforceUniqueMethods = false)</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">cacheConfig</span> &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * SpringCache默认使用ConcurrentHashMap作为缓存Map  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> CacheManager &#125;  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;mapManager&quot;)</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheManager <span class=\"title function_\">SimpleCacheManager</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 创建一个简单缓存管理器  </span></span><br><span class=\"line\">        <span class=\"type\">SimpleCacheManager</span> <span class=\"variable\">manager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleCacheManager</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        List&lt;ConcurrentMapCache&gt; caches = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">        caches.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentMapCache</span>(<span class=\"string\">&quot;default&quot;</span>));  </span><br><span class=\"line\">        caches.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentMapCache</span>(<span class=\"string\">&quot;userCache&quot;</span>));  </span><br><span class=\"line\">        caches.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentMapCache</span>(<span class=\"string\">&quot;productCache&quot;</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        manager.setCaches(caches);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> manager;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * 虽然跟ConcurrentHashMap一样是本地缓存, 但是caffeine框架支持自定义过期时间,大小…  </span></span><br><span class=\"line\"><span class=\"comment\">     * 使用concurrentLinkedHashMap作为容器,采用segment分段cas来适应高并发访问,支持异步处理(需开启)  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> CacheManager &#125;  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;caffeineManager&quot;)</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheManager <span class=\"title function_\">caffeineManager</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">CaffeineCacheManager</span> <span class=\"variable\">cacheManager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CaffeineCacheManager</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 配置 Caffeine 缓存  </span></span><br><span class=\"line\">        cacheManager.setCaffeine(Caffeine.newBuilder()  </span><br><span class=\"line\">                .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.MINUTES) <span class=\"comment\">// 设置缓存过期时间  </span></span><br><span class=\"line\">                .maximumSize(<span class=\"number\">100</span>) <span class=\"comment\">// 设置缓存最大条目  </span></span><br><span class=\"line\">                .weakKeys() <span class=\"comment\">// 使用弱引用来保存缓存的键,可被回收  </span></span><br><span class=\"line\">                .recordStats()); <span class=\"comment\">// 启用统计信息  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheManager;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * 使用redis做分布式缓存  </span></span><br><span class=\"line\"><span class=\"comment\">     * 因为Jackson 在进行 Redis 缓存序列化时，无法处理 Java 8 的 LocalTime LocalDatetime… 类型和反序列的问题,需要注册转换器模块  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> connectionFactory 连接工厂  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> CacheManager &#125;  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Primary</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;redisManager&quot;)</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheManager <span class=\"title function_\">redisManager</span><span class=\"params\">(RedisConnectionFactory connectionFactory)</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 1. 自定义 ObjectMapper       </span></span><br><span class=\"line\">         <span class=\"type\">ObjectMapper</span> <span class=\"variable\">objectMapper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();  </span><br><span class=\"line\">         <span class=\"comment\">// 支持 LocalDate、LocalDateTime、LocalTime  </span></span><br><span class=\"line\">        objectMapper.registerModule(<span class=\"keyword\">new</span> <span class=\"title class_\">JavaTimeModule</span>()); </span><br><span class=\"line\">        <span class=\"comment\">// 不以时间戳形式序列化  </span></span><br><span class=\"line\">        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); </span><br><span class=\"line\">        <span class=\"comment\">//让 Jackson 在序列化时加上类型信息（如 &quot;@class&quot;: &quot;com.xxx.pageVO&quot;），这样反序列化才不会成 LinkedHashMap        </span></span><br><span class=\"line\">        objectMapper.activateDefaultTyping(  </span><br><span class=\"line\">                LaissezFaireSubTypeValidator.instance,  </span><br><span class=\"line\">                ObjectMapper.DefaultTyping.NON_FINAL,  </span><br><span class=\"line\">                JsonTypeInfo.As.PROPERTY  </span><br><span class=\"line\">        );  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 2. 创建 JSON 序列化器  </span></span><br><span class=\"line\">        <span class=\"type\">GenericJackson2JsonRedisSerializer</span> <span class=\"variable\">jackson2JsonRedisSerializer</span> <span class=\"operator\">=</span>  </span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">GenericJackson2JsonRedisSerializer</span>(objectMapper);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 3.创建默认的序列化配置  </span></span><br><span class=\"line\">        <span class=\"type\">RedisCacheConfiguration</span> <span class=\"variable\">cacheConfig</span> <span class=\"operator\">=</span> RedisCacheConfiguration.defaultCacheConfig()  </span><br><span class=\"line\">                <span class=\"comment\">// 设置默认缓存有效期为10分钟  </span></span><br><span class=\"line\">                .entryTtl(Duration.ofMinutes(<span class=\"number\">10</span>))  </span><br><span class=\"line\">                <span class=\"comment\">// Key序列化  </span></span><br><span class=\"line\">            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>()))  </span><br><span class=\"line\">                <span class=\"comment\">// Value序列化  </span></span><br><span class=\"line\">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))  </span><br><span class=\"line\">                <span class=\"comment\">//  配置 key 前缀: 默认允许前缀和空值  </span></span><br><span class=\"line\">                .prefixCacheNameWith(<span class=\"string\">&quot;train:business:&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 4.创建RedisCacheManager  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> RedisCacheManager.builder(connectionFactory)  </span><br><span class=\"line\">                .cacheDefaults(cacheConfig)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * caffeine框架自带的包(不与SpringCache关联的用法)  </span></span><br><span class=\"line\"><span class=\"comment\">     * 更底层、更灵活，适合手动操作缓存：  </span></span><br><span class=\"line\"><span class=\"comment\">     * 使用方法: 也是操作底层map  </span></span><br><span class=\"line\"><span class=\"comment\">     * cache.put(&quot;key&quot;, value);  </span></span><br><span class=\"line\"><span class=\"comment\">     * cache.getIfPresent(&quot;key&quot;);  </span></span><br><span class=\"line\"><span class=\"comment\">     * cache.invalidate(&quot;key&quot;);  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>    <span class=\"meta\">@Bean(name = &quot;caffeine&quot;)</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Cache&lt;Object, Object&gt; <span class=\"title function_\">caffeine</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> Caffeine.newBuilder()  </span><br><span class=\"line\">                <span class=\"comment\">// 设置最后一次写入或访问后经过固定时间过期  </span></span><br><span class=\"line\">                .expireAfterWrite(<span class=\"number\">30</span>, TimeUnit.SECONDS)  </span><br><span class=\"line\">                <span class=\"comment\">// 初始的缓存空间大小  </span></span><br><span class=\"line\">                .initialCapacity(<span class=\"number\">100</span>)  </span><br><span class=\"line\">                <span class=\"comment\">// 缓存的最大条数  </span></span><br><span class=\"line\">                .maximumSize(<span class=\"number\">1000</span>)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"验证CaffeineManager的正常工作\"><a href=\"#验证CaffeineManager的正常工作\" class=\"headerlink\" title=\"验证CaffeineManager的正常工作\"></a>验证CaffeineManager的正常工作</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootTest(classes = businessApplication.class, properties = &quot;spring.config.location=classpath:/application-test.yaml&quot;)</span>  </span><br><span class=\"line\"><span class=\"comment\">//@EnableAutoConfiguration(exclude = &#123;DataSourceAutoConfiguration.class&#125;)  </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">businessTest</span> &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Qualifier(&quot;caffeineManager&quot;)</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> CacheManager caffeineManager;  </span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier(&quot;SimpleCacheManager&quot;)</span>  </span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\">\t<span class=\"keyword\">private</span> CacheManager SimpleCacheManager;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> DailyTrainService dailyTrainService;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Test</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testCaffeineManager</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">DailyTrainQuery</span> <span class=\"variable\">dailyTrainQuery</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DailyTrainQuery</span>();  </span><br><span class=\"line\">        dailyTrainQuery.setTrainCode(<span class=\"string\">&quot;D3306&quot;</span>);  </span><br><span class=\"line\">        dailyTrainQuery.setPageNum(<span class=\"number\">1</span>);  </span><br><span class=\"line\">        dailyTrainQuery.setPageSize(<span class=\"number\">5</span>);  </span><br><span class=\"line\">\t\t<span class=\"comment\">// 第一次查询数据库,第二次查询缓存</span></span><br><span class=\"line\">        dailyTrainService.queryList(dailyTrainQuery);  </span><br><span class=\"line\">        dailyTrainService.queryList(dailyTrainQuery);  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String cacheName : caffeineManager.getCacheNames()) &#123;  </span><br><span class=\"line\">            <span class=\"type\">Cache</span> <span class=\"variable\">cache</span> <span class=\"operator\">=</span> caffeineManager.getCache(cacheName);  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache <span class=\"keyword\">instanceof</span> CaffeineCache caffeineCache) &#123;  </span><br><span class=\"line\">\t            <span class=\"comment\">// 底层map容器: ConcurrentLinkedHashMap</span></span><br><span class=\"line\">                ConcurrentMap&lt;Object, Object&gt; map =     caffeineCache.getNativeCache().asMap();  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;打印缓存map开始&quot;</span>);  </span><br><span class=\"line\">                map.forEach((key, value) -&gt; System.out.println(key + <span class=\"string\">&quot; : &quot;</span> + value));  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;打印缓存map结束&quot;</span>);  </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;未找到&quot;</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"meta\">@Test</span>  </span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testSimpleCacheManager</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">\t    <span class=\"type\">DailyTrainCarriageQuery</span> <span class=\"variable\">dailyTrainCarriageQuery</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DailyTrainCarriageQuery</span>();  </span><br><span class=\"line\">\t    dailyTrainCarriageQuery.setTrainCode(<span class=\"string\">&quot;D3307&quot;</span>);  </span><br><span class=\"line\">\t    dailyTrainCarriageQuery.setPageNum(<span class=\"number\">1</span>);  </span><br><span class=\"line\">\t    dailyTrainCarriageQuery.setPageSize(<span class=\"number\">5</span>);  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t    dailyTrainCarriageService.queryList(dailyTrainCarriageQuery);  </span><br><span class=\"line\">\t    dailyTrainCarriageService.queryList(dailyTrainCarriageQuery);  </span><br><span class=\"line\">\t    <span class=\"type\">Cache</span> <span class=\"variable\">cache</span> <span class=\"operator\">=</span> SimpleCacheManager.getCache(<span class=\"string\">&quot;DailyTrainCarriage&quot;</span>);  </span><br><span class=\"line\">\t    System.out.println(cache.getNativeCache());  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>| 类型          | 特性                    | 场景推荐      |<br>| —————- | ——————————- | ————- |<br>| InnoDB 缓存   | 引擎自动缓存，无需配置           | 基础数据库访问优化 |<br>| MyBatis 缓存  | 降低 SQL 重复执行，需小心失效     | 简单系统      |<br>| 本地缓存        | 快速访问，单机系统最佳           | 单体应用      |<br>| Caffeine 缓存 | 高性能本地缓存，支持 TTL等, 功能丰富 | 高频操作本地数据  |<br>| Redis 缓存    | 分布式缓存，支持共享与持久化        | 微服务/多节点系统 |</li>\n<li>所有的缓存管理器下的缓存管理组成<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17448769185421744876917946.png\" alt=\"17448769185421744876917946.png|519x437\"><h2 id=\"缓存过期策略\"><a href=\"#缓存过期策略\" class=\"headerlink\" title=\"缓存过期策略\"></a>缓存过期策略</h2></li>\n</ul>\n","cover":"/img/4.png","cover_type":"img","excerpt":"","more":"<pre><code>No matter what happens, I’ve got your back.\n</code></pre><h1 id=\"缓存处理提高并发速率\"><a href=\"#缓存处理提高并发速率\" class=\"headerlink\" title=\"缓存处理提高并发速率\"></a>缓存处理提高并发速率</h1><pre><code>在高并发系统中，缓存是提升性能、减轻数据库压力的关键手段。本文从数据库缓存、前端缓存、SpringCache 多种缓存管理器等角度，系统性地梳理了缓存机制与实践经验。\n</code></pre><hr>\n<h2 id=\"数据库的内部缓存\"><a href=\"#数据库的内部缓存\" class=\"headerlink\" title=\"数据库的内部缓存\"></a>数据库的内部缓存</h2><h3 id=\"引擎缓存池-InnoDB-Buffer-Pool\"><a href=\"#引擎缓存池-InnoDB-Buffer-Pool\" class=\"headerlink\" title=\"引擎缓存池(InnoDB Buffer Pool)\"></a>引擎缓存池(InnoDB Buffer Pool)</h3><ul>\n<li>可以缓存<strong>磁盘上经常操作的真实数据</strong>，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。<h4 id=\"存储空间\"><a href=\"#存储空间\" class=\"headerlink\" title=\"存储空间\"></a>存储空间</h4></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">缓存内容</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">数据页（Data Pages）</td>\n<td style=\"text-align:left\">表的数据</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">索引页（Index Pages）</td>\n<td style=\"text-align:left\">索引结构</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">undo log、插入缓冲等</td>\n<td style=\"text-align:left\">内部使用</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>不需要手动写逻辑，MySQL 自动将<strong>热点数据</strong>缓存进内存</li>\n<li>读操作速度快, <strong>缓存在缓存池内存中</strong>，读取数据就像从 <code>RAM</code> 里拿，速度比磁盘快几个数量级</li>\n<li>缓存的页与磁盘数据由 <code>InnoDB</code> 自己维护，不存在“缓存不一致”的问题</li>\n<li>不仅是数据页，索引结构也会缓存在内存中，提高复杂查询的执行效率<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4></li>\n<li><code>InnoDB</code> 缓存是<strong>本地内存缓存</strong>，<strong>不能跨服务、跨节点共享，不适合分布式环境</strong></li>\n<li><strong>无法像 Redis 那样对特定 key 设置 TTL、失效策略, 不可自定义</strong></li>\n<li>没有 <code>@Cacheable</code> 那种“缓存先读，数据库兜底”的能力</li>\n<li>缓存命中率低, 热点业务不会优先<h3 id=\"Mybatis-缓存\"><a href=\"#Mybatis-缓存\" class=\"headerlink\" title=\"Mybatis 缓存\"></a><code>Mybatis</code> 缓存</h3><h4 id=\"一级缓存\"><a href=\"#一级缓存\" class=\"headerlink\" title=\"一级缓存\"></a>一级缓存</h4></li>\n<li>同一个事务前提下, 保存重复的sql语句执行结果, <strong>默认在一个会话线程有效</strong>, 默认开启</li>\n<li>生效条件: <strong>事务 中途不发生增删改(发生就清空缓存)</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testCache</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    userMapper.selectById(<span class=\"number\">1L</span>); <span class=\"comment\">// 第一次查</span></span><br><span class=\"line\">    userMapper.selectById(<span class=\"number\">1L</span>); <span class=\"comment\">// 第二次查，命中缓存（只要 Spring 管理的是同一个会话线程）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二级缓存\"><a href=\"#二级缓存\" class=\"headerlink\" title=\"二级缓存\"></a>二级缓存</h4></li>\n<li>**在xml文件中使用<cache />开启, 不同会话下保存sql执行结果保存到本地缓存</li>\n<li>当前 xxxMapper.xml范围有效,  nameSpace中方法为key, 缓存数据为value</li>\n<li>提高查询效率，减少数据库访问次数, 缓存命中率: Cache HitRatio 0.5</li>\n<li>生效条件: <strong>手动开启 只能在xml文件中定义 中途不发生增删改(发生就清空数据) 实体类需要序列化</strong><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">cache</span> /&gt;</span> <span class=\"comment\">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span>缓存内容<span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"前端缓存\"><a href=\"#前端缓存\" class=\"headerlink\" title=\"前端缓存\"></a>前端缓存</h2>| 缓存方式             | 生命周期 | 特点           |<br>| ———————— | —— | —————— |<br>| <code>sessionStorage</code> | 会话级  | 页面关闭即清空缓存    |<br>| <code>localStorage</code>   | 持久级  | 缓存持久存在，需手动清除 |<h2 id=\"SpringCache-缓存管理器体系\"><a href=\"#SpringCache-缓存管理器体系\" class=\"headerlink\" title=\"SpringCache 缓存管理器体系\"></a>SpringCache 缓存管理器体系</h2></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>基本注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@Cacheable</td>\n<td><strong>缓存方法返回值</strong>,当方法执行时有缓存直接返回缓存</td>\n</tr>\n<tr>\n<td>@CachePut</td>\n<td>更新缓存内容</td>\n</tr>\n<tr>\n<td>@CacheEvict</td>\n<td>删除缓存内容, 可以一次性指定前缀下的所有键值对</td>\n</tr>\n<tr>\n<td>@Caching</td>\n<td>支持多个注解组合使用</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>作用说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cacheManager</td>\n<td>指定使用哪个<strong>缓存管理器</strong>（如本地或者Redis）你可以在配置中自定义多个管理器。</td>\n</tr>\n<tr>\n<td>value / cacheNames</td>\n<td>缓存的名字，对应配置的缓存区域名，可以是 <strong>Redis 中的前缀</strong>。二者等价，推荐使用 <code>value</code>。</td>\n</tr>\n<tr>\n<td>key</td>\n<td>缓存的 key，支持 SpEL 表达式，如 <code>#id</code>、<code>#user.name</code>。默认使用方法所有参数作为 key。</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>缓存的“执行前”判断，只有满足条件才执行缓存操作。支持 <code>SpEL</code>。</td>\n</tr>\n<tr>\n<td>unless</td>\n<td>缓存的“执行后”判断，如果为 true，则<strong>不缓存</strong>返回结果。支持 SpEL。</td>\n</tr>\n<tr>\n<td>keyGenerator</td>\n<td>如果你想自定义缓存 key 生成规则（而不是 key），可以配置 key 生成器的 bean 名称。</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>避免缓存击穿热点key问题，设置为 <code>true</code> 时，当多个线程访问同一个 key 时，只有一个线程去执行方法，其它线程阻塞等待结果（只有 RedisCacheManager 支持这个参数, <strong>加锁行为</strong>!</td>\n</tr>\n<tr>\n<td>cacheResolve</td>\n<td>替代 <code>cacheManager</code> 来决定用哪个缓存,需要配置类进行策略行为@Cacheable(cacheResolver = “myCacheResolver”)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"本地缓存\"><a href=\"#本地缓存\" class=\"headerlink\" title=\"本地缓存\"></a>本地缓存</h3><h4 id=\"SimpleCacheManager-默认\"><a href=\"#SimpleCacheManager-默认\" class=\"headerlink\" title=\"SimpleCacheManager(默认)\"></a>SimpleCacheManager(默认)</h4><ul>\n<li>Spring Cache 默认实现 = <code>SimpleCacheManager</code> + <strong><code>ConcurrentMap</code></strong>（<strong>基于内存</strong>的Map缓存）</li>\n<li>这个 <code>ConcurrentMap</code> 就是一个普通的线程安全 <code>Map</code>，存放在应用的 JVM 堆内存中</li>\n<li>无法设置过期策略，<strong>永远不会失效</strong>, 所以可能需要一个定时任务来检查是否需要手动删除缓存</li>\n<li>不能设置最大容量，<strong>风险是 <code>OOM</code>（内存溢出）</strong><h4 id=\"CaffeineManager\"><a href=\"#CaffeineManager\" class=\"headerlink\" title=\"CaffeineManager\"></a>CaffeineManager</h4></li>\n<li>Caffeine 是一个 <strong>高性能的本地缓存库</strong>，是 Java 里速度最快、最强大的缓存框架之一，用来替代传统的 简单的 <code>Map</code> 缓存，非常适合对性能要求高的单体项目</li>\n<li><strong>使用<code>ConcurrentLinkedHashMap</code>作为容器</strong></li>\n<li>使用分段 <code>CAS</code> + <code>LRU</code> 策略</li>\n<li>支持配置 <code>expireAfterWrite</code>, <code>maximumSize</code> 等</li>\n<li>功能强大, 支持异步刷新、统计分析</li>\n<li>支持大多数的缓存过期策略<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17447245005311744724500093.png\" alt=\"17447245005311744724500093.png|700x355\"></li>\n</ul>\n<h3 id=\"分布式缓存-多节点\"><a href=\"#分布式缓存-多节点\" class=\"headerlink\" title=\"分布式缓存(多节点)\"></a>分布式缓存(多节点)</h3><h4 id=\"RedisManger\"><a href=\"#RedisManger\" class=\"headerlink\" title=\"RedisManger\"></a>RedisManger</h4><pre><code>在微服务架构中推荐使用分布式缓存实现缓存共享、状态同步。\n</code></pre><ul>\n<li>支持 TTL、自定义序列化、跨服务访问</li>\n<li>适用于高并发、高可用系统</li>\n<li>但需要额外部署 Redis 服务，复杂度略高<h2 id=\"多级缓存（Multi-Level-Cache）\"><a href=\"#多级缓存（Multi-Level-Cache）\" class=\"headerlink\" title=\"多级缓存（Multi-Level Cache）\"></a>多级缓存（Multi-Level Cache）</h2></li>\n<li>将 <strong>本地缓存（如 Caffeine）+ 分布式缓存（如 Redis）</strong> 结合，先查本地未命中再查 Redis，兼顾<strong>速度与一致性</strong>。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cached(name=&quot;userCache-&quot;, key=&quot;#userId&quot;, expire = 3600, cacheType = CacheType.BOTH)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> User <span class=\"title function_\">getUserById</span><span class=\"params\">(Long userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userRepository.findById(userId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><h4 id=\"目标类上的注解\"><a href=\"#目标类上的注解\" class=\"headerlink\" title=\"目标类上的注解\"></a>目标类上的注解</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable(cacheManager = &quot;redisManager&quot;,  </span></span><br><span class=\"line\"><span class=\"meta\">        value = &quot;user&quot;,  </span></span><br><span class=\"line\"><span class=\"meta\">        key = &quot;pageQuery + &#x27;_&#x27; + #userDTO.id&quot;</span></span><br><span class=\"line\"><span class=\"meta\">        condition = &quot;#userDTO.id != null &quot;,  </span></span><br><span class=\"line\"><span class=\"meta\">        unless = &quot;#result == null || #result.total == 0&quot;  // 查询结果为空就不缓存  </span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"配置类\"><a href=\"#配置类\" class=\"headerlink\" title=\"配置类\"></a>配置类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 不同缓存管理器的配置类Manager + caffeine基本配置  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> cloud_3111  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 2025-04-16  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span><span class=\"meta\">@Configuration(enforceUniqueMethods = false)</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">cacheConfig</span> &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * SpringCache默认使用ConcurrentHashMap作为缓存Map  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> CacheManager &#125;  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;mapManager&quot;)</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheManager <span class=\"title function_\">SimpleCacheManager</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 创建一个简单缓存管理器  </span></span><br><span class=\"line\">        <span class=\"type\">SimpleCacheManager</span> <span class=\"variable\">manager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleCacheManager</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        List&lt;ConcurrentMapCache&gt; caches = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">        caches.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentMapCache</span>(<span class=\"string\">&quot;default&quot;</span>));  </span><br><span class=\"line\">        caches.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentMapCache</span>(<span class=\"string\">&quot;userCache&quot;</span>));  </span><br><span class=\"line\">        caches.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentMapCache</span>(<span class=\"string\">&quot;productCache&quot;</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\">        manager.setCaches(caches);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> manager;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * 虽然跟ConcurrentHashMap一样是本地缓存, 但是caffeine框架支持自定义过期时间,大小…  </span></span><br><span class=\"line\"><span class=\"comment\">     * 使用concurrentLinkedHashMap作为容器,采用segment分段cas来适应高并发访问,支持异步处理(需开启)  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> CacheManager &#125;  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;caffeineManager&quot;)</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheManager <span class=\"title function_\">caffeineManager</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">CaffeineCacheManager</span> <span class=\"variable\">cacheManager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CaffeineCacheManager</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 配置 Caffeine 缓存  </span></span><br><span class=\"line\">        cacheManager.setCaffeine(Caffeine.newBuilder()  </span><br><span class=\"line\">                .expireAfterWrite(<span class=\"number\">10</span>, TimeUnit.MINUTES) <span class=\"comment\">// 设置缓存过期时间  </span></span><br><span class=\"line\">                .maximumSize(<span class=\"number\">100</span>) <span class=\"comment\">// 设置缓存最大条目  </span></span><br><span class=\"line\">                .weakKeys() <span class=\"comment\">// 使用弱引用来保存缓存的键,可被回收  </span></span><br><span class=\"line\">                .recordStats()); <span class=\"comment\">// 启用统计信息  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheManager;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * 使用redis做分布式缓存  </span></span><br><span class=\"line\"><span class=\"comment\">     * 因为Jackson 在进行 Redis 缓存序列化时，无法处理 Java 8 的 LocalTime LocalDatetime… 类型和反序列的问题,需要注册转换器模块  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> connectionFactory 连接工厂  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> CacheManager &#125;  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Primary</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;redisManager&quot;)</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> CacheManager <span class=\"title function_\">redisManager</span><span class=\"params\">(RedisConnectionFactory connectionFactory)</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 1. 自定义 ObjectMapper       </span></span><br><span class=\"line\">         <span class=\"type\">ObjectMapper</span> <span class=\"variable\">objectMapper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();  </span><br><span class=\"line\">         <span class=\"comment\">// 支持 LocalDate、LocalDateTime、LocalTime  </span></span><br><span class=\"line\">        objectMapper.registerModule(<span class=\"keyword\">new</span> <span class=\"title class_\">JavaTimeModule</span>()); </span><br><span class=\"line\">        <span class=\"comment\">// 不以时间戳形式序列化  </span></span><br><span class=\"line\">        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); </span><br><span class=\"line\">        <span class=\"comment\">//让 Jackson 在序列化时加上类型信息（如 &quot;@class&quot;: &quot;com.xxx.pageVO&quot;），这样反序列化才不会成 LinkedHashMap        </span></span><br><span class=\"line\">        objectMapper.activateDefaultTyping(  </span><br><span class=\"line\">                LaissezFaireSubTypeValidator.instance,  </span><br><span class=\"line\">                ObjectMapper.DefaultTyping.NON_FINAL,  </span><br><span class=\"line\">                JsonTypeInfo.As.PROPERTY  </span><br><span class=\"line\">        );  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 2. 创建 JSON 序列化器  </span></span><br><span class=\"line\">        <span class=\"type\">GenericJackson2JsonRedisSerializer</span> <span class=\"variable\">jackson2JsonRedisSerializer</span> <span class=\"operator\">=</span>  </span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">GenericJackson2JsonRedisSerializer</span>(objectMapper);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 3.创建默认的序列化配置  </span></span><br><span class=\"line\">        <span class=\"type\">RedisCacheConfiguration</span> <span class=\"variable\">cacheConfig</span> <span class=\"operator\">=</span> RedisCacheConfiguration.defaultCacheConfig()  </span><br><span class=\"line\">                <span class=\"comment\">// 设置默认缓存有效期为10分钟  </span></span><br><span class=\"line\">                .entryTtl(Duration.ofMinutes(<span class=\"number\">10</span>))  </span><br><span class=\"line\">                <span class=\"comment\">// Key序列化  </span></span><br><span class=\"line\">            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>()))  </span><br><span class=\"line\">                <span class=\"comment\">// Value序列化  </span></span><br><span class=\"line\">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))  </span><br><span class=\"line\">                <span class=\"comment\">//  配置 key 前缀: 默认允许前缀和空值  </span></span><br><span class=\"line\">                .prefixCacheNameWith(<span class=\"string\">&quot;train:business:&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 4.创建RedisCacheManager  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> RedisCacheManager.builder(connectionFactory)  </span><br><span class=\"line\">                .cacheDefaults(cacheConfig)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * caffeine框架自带的包(不与SpringCache关联的用法)  </span></span><br><span class=\"line\"><span class=\"comment\">     * 更底层、更灵活，适合手动操作缓存：  </span></span><br><span class=\"line\"><span class=\"comment\">     * 使用方法: 也是操作底层map  </span></span><br><span class=\"line\"><span class=\"comment\">     * cache.put(&quot;key&quot;, value);  </span></span><br><span class=\"line\"><span class=\"comment\">     * cache.getIfPresent(&quot;key&quot;);  </span></span><br><span class=\"line\"><span class=\"comment\">     * cache.invalidate(&quot;key&quot;);  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>    <span class=\"meta\">@Bean(name = &quot;caffeine&quot;)</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Cache&lt;Object, Object&gt; <span class=\"title function_\">caffeine</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> Caffeine.newBuilder()  </span><br><span class=\"line\">                <span class=\"comment\">// 设置最后一次写入或访问后经过固定时间过期  </span></span><br><span class=\"line\">                .expireAfterWrite(<span class=\"number\">30</span>, TimeUnit.SECONDS)  </span><br><span class=\"line\">                <span class=\"comment\">// 初始的缓存空间大小  </span></span><br><span class=\"line\">                .initialCapacity(<span class=\"number\">100</span>)  </span><br><span class=\"line\">                <span class=\"comment\">// 缓存的最大条数  </span></span><br><span class=\"line\">                .maximumSize(<span class=\"number\">1000</span>)  </span><br><span class=\"line\">                .build();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"验证CaffeineManager的正常工作\"><a href=\"#验证CaffeineManager的正常工作\" class=\"headerlink\" title=\"验证CaffeineManager的正常工作\"></a>验证CaffeineManager的正常工作</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootTest(classes = businessApplication.class, properties = &quot;spring.config.location=classpath:/application-test.yaml&quot;)</span>  </span><br><span class=\"line\"><span class=\"comment\">//@EnableAutoConfiguration(exclude = &#123;DataSourceAutoConfiguration.class&#125;)  </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">businessTest</span> &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Qualifier(&quot;caffeineManager&quot;)</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> CacheManager caffeineManager;  </span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"meta\">@Qualifier(&quot;SimpleCacheManager&quot;)</span>  </span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\">\t<span class=\"keyword\">private</span> CacheManager SimpleCacheManager;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> DailyTrainService dailyTrainService;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Test</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testCaffeineManager</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"type\">DailyTrainQuery</span> <span class=\"variable\">dailyTrainQuery</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DailyTrainQuery</span>();  </span><br><span class=\"line\">        dailyTrainQuery.setTrainCode(<span class=\"string\">&quot;D3306&quot;</span>);  </span><br><span class=\"line\">        dailyTrainQuery.setPageNum(<span class=\"number\">1</span>);  </span><br><span class=\"line\">        dailyTrainQuery.setPageSize(<span class=\"number\">5</span>);  </span><br><span class=\"line\">\t\t<span class=\"comment\">// 第一次查询数据库,第二次查询缓存</span></span><br><span class=\"line\">        dailyTrainService.queryList(dailyTrainQuery);  </span><br><span class=\"line\">        dailyTrainService.queryList(dailyTrainQuery);  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String cacheName : caffeineManager.getCacheNames()) &#123;  </span><br><span class=\"line\">            <span class=\"type\">Cache</span> <span class=\"variable\">cache</span> <span class=\"operator\">=</span> caffeineManager.getCache(cacheName);  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cache <span class=\"keyword\">instanceof</span> CaffeineCache caffeineCache) &#123;  </span><br><span class=\"line\">\t            <span class=\"comment\">// 底层map容器: ConcurrentLinkedHashMap</span></span><br><span class=\"line\">                ConcurrentMap&lt;Object, Object&gt; map =     caffeineCache.getNativeCache().asMap();  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;打印缓存map开始&quot;</span>);  </span><br><span class=\"line\">                map.forEach((key, value) -&gt; System.out.println(key + <span class=\"string\">&quot; : &quot;</span> + value));  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;打印缓存map结束&quot;</span>);  </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;未找到&quot;</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"meta\">@Test</span>  </span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testSimpleCacheManager</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">\t    <span class=\"type\">DailyTrainCarriageQuery</span> <span class=\"variable\">dailyTrainCarriageQuery</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DailyTrainCarriageQuery</span>();  </span><br><span class=\"line\">\t    dailyTrainCarriageQuery.setTrainCode(<span class=\"string\">&quot;D3307&quot;</span>);  </span><br><span class=\"line\">\t    dailyTrainCarriageQuery.setPageNum(<span class=\"number\">1</span>);  </span><br><span class=\"line\">\t    dailyTrainCarriageQuery.setPageSize(<span class=\"number\">5</span>);  </span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t    dailyTrainCarriageService.queryList(dailyTrainCarriageQuery);  </span><br><span class=\"line\">\t    dailyTrainCarriageService.queryList(dailyTrainCarriageQuery);  </span><br><span class=\"line\">\t    <span class=\"type\">Cache</span> <span class=\"variable\">cache</span> <span class=\"operator\">=</span> SimpleCacheManager.getCache(<span class=\"string\">&quot;DailyTrainCarriage&quot;</span>);  </span><br><span class=\"line\">\t    System.out.println(cache.getNativeCache());  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>| 类型          | 特性                    | 场景推荐      |<br>| —————- | ——————————- | ————- |<br>| InnoDB 缓存   | 引擎自动缓存，无需配置           | 基础数据库访问优化 |<br>| MyBatis 缓存  | 降低 SQL 重复执行，需小心失效     | 简单系统      |<br>| 本地缓存        | 快速访问，单机系统最佳           | 单体应用      |<br>| Caffeine 缓存 | 高性能本地缓存，支持 TTL等, 功能丰富 | 高频操作本地数据  |<br>| Redis 缓存    | 分布式缓存，支持共享与持久化        | 微服务/多节点系统 |</li>\n<li>所有的缓存管理器下的缓存管理组成<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17448769185421744876917946.png\" alt=\"17448769185421744876917946.png|519x437\"><h2 id=\"缓存过期策略\"><a href=\"#缓存过期策略\" class=\"headerlink\" title=\"缓存过期策略\"></a>缓存过期策略</h2></li>\n</ul>\n"},{"title":"Docker总结","date":"2024-11-25T07:24:35.000Z","_content":"\n# Docker 架构与常用命令详解\n\n## Docker 架构\n### 仓库\n- 也分为**本地仓库**和**远程仓库**, 可以通过仓库拉取镜像(pull)\n- 仓库是用于存储 Docker 镜像的地方, 最常使用的 Registry 公开服务是官方的 **Docker Hub**, 网址为：[搜索镜像官网](https://hub.docker.com/ \"https://hub.docker.com/\")\n### 镜像\n- Docker 镜像就像是一个 root 文件系统，包含应用程序和运行环境的静态定义。\n- 镜像是 只读的模板，用于创建容器。\n### 容器\n- 容器是镜像运行时的实例，类似于面向对象中的类和对象。\n  - 镜像：静态定义（类）\n  - 容器：运行时实例（对象）\n- 容器是一个独立运行的应用实例，支持多种操作：创建、启动、停止、删除、暂停等。\n- 容器内部就是一个独立系统空间\n## Docker 常用命令\n### 基础操作命令\n\n| **命令**                    | **功能**           |\n| ------------------------- | ---------------- |\n| `systemctl status docker` | 查看 Docker 服务状态   |\n| `systemctl start docker`  | 启动 Docker 服务     |\n| `systemctl enable docker` | 开机自动启动 Docker 服务 |\n\n### 镜像操作命令\n\n| **命令**                            | **功能**                    |\n| --------------------------------- | ------------------------- |\n| `docker images`                   | 查看本地镜像                    |\n| `docker images -q`                | 查看所有镜像的 ID                |\n| `docker search 镜像名称`              | 搜索镜像                      |\n| `docker pull 镜像名称`                | 拉取镜像                      |\n| `docker rmi 镜像ID`                 | 删除指定的本地镜像                 |\n| `docker build -t imageName:1.0.0` | 指定一个Dockerfile时, 读取指令构建镜像 |\n\n### 容器操作命令\n\n| **命令**                | **功能**                        |\n| --------------------- | ----------------------------- |\n| `docker ps`           | 查看正在运行的容器                     |\n| `docker ps -a`        | 查看所有容器                        |\n| `docker ps -ap`       | 查看所有容器(只带容器id参数)              |\n| `docker start 容器名称`   | 启动容器                          |\n| `docker inspect 容器名称` | 查看容器详细信息                      |\n| `docker rm -f 容器名称`   | 删除指定容器                        |\n| `docker status mysql` | 查看指定容器资源占用状况，比如cpu、内存、网络、io状态 |\n| **自定义简化命令**           |                               |\n| `dps`                 | 查看所有容器并简化信息（别名命令）             |\n\n### 数据卷命令\n- 容器的数据卷默认存储在主机的文件夹：   `/var/lib/docker/volumes`\n- 每个数据卷在此目录下有一个独立文件夹，格式：   `/数据卷名/_data`\n\n| **命令**                       | **功能**  |\n| ---------------------------- | ------- |\n| `docker volume create my-vo` | 创建一个数据卷 |\n| `docker volume ls`           | 查看所有数据卷 |\n| `docker inspect my-vo`       | 查看数据卷详情 |\n| `docker volume rm my-vo`     | 删除数据卷   |\n\n### 网络管理命令\n\n| **命令**                                          | **功能**                            |\n| ----------------------------------------------- | --------------------------------- |\n| `docker network ls`                             | 查看所有网络                            |\n| `docker network create 网络名`                     | 创建新的 Docker 网络                    |\n| `docker network connect hmall mysql --alias db` | 将 mysql 容器连接到 hmall 网络，指定别名为 `db` |\n| `docker network connect hmall db`               | 将 db 容器连接到 hmall 网络               |\n\n### 容器内部命令\n\n| **命令**                     | **功能**       |\n| -------------------------- | ------------ |\n| `docker exec -it 容器名 bash` | 进入指定容器的命令行环境 |\n\n| 命令(进入容器后的命令)          | 功能说明: 与Linux系统操作一致(相当于一个小系统) |     |\n| --------------------- | ---------------------------- | --- |\n| `ls`                  | 查看当前目录文件                     |     |\n| `cd /路径`              | 切换到指定目录                      |     |\n| `pwd`                 | 查看当前路径                       |     |\n| `cat 文件名`             | 查看文件内容                       |     |\n| `vi 文件名` / `nano 文件名` | 编辑文件（需先安装）                   |     |\n| `apt update`          | 更新 apt 包管理源（Debian/Ubuntu）   |     |\n| `apt install 软件名`     | 安装常用软件                       |     |\n| `top` / `ps aux`      | 查看容器中的运行进程                   |     |\n| `env`                 | 查看环境变量                       |     |\n| `exit`                | 退出容器命令行                      |     |\n## 案例解析\n### 在 Nginx 容器中挂载配置文件和静态资源目录\n假设需要将 Nginx 的配置文件和静态文件挂载到本地：\n1. 创建数据卷目录：  \n   ```java\n   mkdir -p /mydata/nginx/{conf,html}\n   ```\n2. 数据卷挂载方式\n- `--mount` 可以有两种\n\t-  一种是挂载到数据卷volume上面(type=volume)\n\t- 另一种是直接挂载到宿主机上面(type=bind)\n- `-v` 对应的是宿主机路径:容器路径\n1. 运行容器时挂载数据卷：  \n   ```bash\n   docker run -d -p 80:80 \\\n       -v /mydata/nginx/conf:/etc/nginx/conf.d \\\n       -v /mydata/nginx/html:/usr/share/nginx/html \\\n       --name my-nginx nginx\n   ```\n2. 修改本地配置生效：  \n   - 修改 `/mydata/nginx/conf` 下的配置文件后，重启容器即可生效。\n### 为 Java 项目配置网络\n1. 创建网络：  \n   ```java\n   docker network create hmall\n   ```\n2. 将 MySQL 容器加入网络，并设置别名：  \n   ```java\n   docker network connect hmall mysql --alias db\n   ```\n3. 将 Java 项目容器加入网络：  \n   ```java\n   docker network connect hmall db\n   ```\n4. 连接测试：   在 Java 项目中, 数据库连接地址可以直接写为：`db:3306`。\n### 如何创建一个实例\n```bash\n# 模板\ndocker run -id \\\n\t-p 主机port:容器port \\\n\t--name=实例名 \\\n\t-v ./宿主机目录:实例主目录 \\\n\t-e 环境参数(例如:MYSQL_ROOT_PASSWORD=root) \\\n\t镜像名\n\ndocker run -d \\\n  --name nginx \\\n  -p 18080:18080 \\\n  -p 18081:18081 \\\n  -v /root/nginx/html:/usr/share/nginx/html \\\n  -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \\\n  --network hmall \\\n  nginx\n  \ndocker run -d \\\n  --name mysql \\\n  -p 3306:3306 \\\n  -e TZ=Asia/Shanghai \\\n  -e MYSQL_ROOT_PASSWORD=123 \\\n  -v ./mysql/data:/var/lib/mysql \\\n  -v ./mysql/conf:/etc/mysql/conf.d \\\n  -v ./mysql/init:/docker-entrypoint-initdb.d \\\n  --network hmall    \n  mysql \n```\n\t\t\t\n- `-v ./logs:/logs`：将主机当前目录下的./logs目录挂载到容器的 /logs\n- `-d`:让容器在后台运行\n- `-P`:将容器内部使用的网络端口映射到我们使用的主机上\n- 一个容器也可以被挂载多个数据卷\n- 多个容器是可以挂载同一个数据卷\n## `Docker Compose`(yaml)\n- Docker Compose 是 用来定义和管理多个容器服务。  \n- 它通过一个叫 `docker-compose.yml` 的配置文件，把多个 `docker run` 命令整合起来，一键启动，统一管理\n\n| 命令                       | 介绍          |\n| ------------------------ | ----------- |\n| `docker-compose version` | 查看版本        |\n| `docker-compose images`  | 列出所有容器使用的镜像 |\n| `docker-compose kill`    | 强制停止服务的容器   |\n| `docker-compose exec`    | 在容器中执行命令    |\n| `docker-compose logs`    | 查看日志        |\n| `docker-compose pause`   | 暂停服务        |\n| `docker-compose unpause` | 恢复服务        |\n| `docker-compose push`    | 推送服务镜像      |\n| `docker-compose start`   | 启动当前停止的某个容器 |\n| `docker-compose stop`    | 停止当前运行的某个容器 |\n| `docker-compose rm`      | 删除服务停止的容器   |\n| `docker-compose top`     | 查看进程        |\n\n\n```yaml\nversion: '3.8'  # Docker Compose 文件的版本\n\nservices:\n  app:  # 服务名称，可以自定义\n    image: 镜像  # 使用的镜像（如：node, nginx, mysql等）\n    container_name: container_name  # 指定容器名称\n    ports:\n      - \"宿主机port:容器port\"  # 映射端口：宿主机:容器（容器端口是8080，宿主机也映射8080）\n    volumes:\n      - ./app:/app  # 将./app宿主机当前目录下的app挂载到容器的/app目录\n    environment:\n      - ENV=dev  # 设置环境变量，可以根据需要调整\n\tbuild:\n\t  -          #构建目录\n    depends_on:\n      - db  # 依赖数据库服务:必须等db服务启动后才能启动\n    networks:\n      - backend  # 使用的网络，容器间可以通过这个网络相互通信\n\n  db:  # 另一个服务：数据库\n    image: mysql:8.0  # 使用 MySQL 8.0 镜像\n    container_name: mysql_db  # 数据库容器名称\n    ports:\n      - \"3306:3306\"  # 映射数据库端口\n    environment:\n      - MYSQL_ROOT_PASSWORD=root  # 设置 root 用户密码\n      - MYSQL_DATABASE=demo  # 设置数据库名称\n      - MYSQL_USER=user  # 设置数据库用户\n      - MYSQL_PASSWORD=pass  # 设置用户密码\n    volumes:\n      - ./mysql/data:/var/lib/mysql  # 持久化数据\n    networks:\n      - backend  # 使用相同的网络\n\nnetworks:\n  backend:\n    driver: bridge  # 使用默认的 bridge 网络驱动\n```\n## `Dockerfile`\n- Dockerfile 是一个**构建镜像**的脚本文件, 用命令docker build，创建一个 Dockerfile 文件\n- 比如你有一个 Spring Boot 项目用 MySQL 和 Redis。\n\t- 用 Dockerfile 构建你自己的 Java 应用镜像。\n\t- 用 Docker Compose 启动 Java 应用 + MySQL + Redis 三个容器，它会自动组建成一个小型微服务环境。\n\n| 对比点      | Dockerfile      | Docker Compose     |\n| -------- | --------------- | ------------------ |\n| 用途       | 构建镜像            | 一键式启动镜像容器          |\n| 文件格式     | name.Dockerfile | docker-compose.yml |\n| 是否可以独立使用 | 是               | 是                  |\n| 是否构建镜像   | 是               | 可以（如果用了 `build`）   |\n| 是否启动容器   | 否               | 是                  |\n| 是否支持多个服务 | 否               | 是                  |\n## 如何查看容器错误日志\n- 适用于服务没用启动或者服务异常关闭的排错\n```bash\n例：实时查看docker容器名为user-uat的最后10行日志 \ndocker logs -f -t --tail 10 user-uat \n例：查看指定时间后的日志，只显示最后100行： docker logs -f -t --since=\"2018-02-08\" --tail=100 user-uat \n例：查看最近30分钟的日志: docker logs --since 30m user-uat \n例：查看某时间之后的日志： docker logs -t --since=\"2018-02-08T13:23:37\" user-uat \n例：查看某时间段日志： docker logs -t --since=\"2018-02-08T13:23:37\" --until \"2018-02-09T12:23:37\" user-uat \n例：将错误日志写入文件： docker logs -f -t --since=\"2018-02-18\" user-uat | grep error >> logs_error.txt\n```\n## 注意\n- 容器想要访问宿主机的端口需要通过DNS\n\t- Docker专门提供了一个特殊DNS名称 `host.docker.internal`，这个名称在容器内表示“宿主机地址\"\n\t- 如果容器想要访问宿主Ollama的服务  可以通过dns映射直接来访问\n\t\t- `http://host.docker.internal:11434`\n- docker的作用\n\t- 通过docker我们可以快速打包并一键式部署我们自己的服务在各种环境中, 不管你是在 Windows、Linux、Mac，还是在云服务器、K8s 集群","source":"_posts/docker.md","raw":"---\ntitle: Docker总结\ntags:\n  - Docker\ncategories: 编程\ndate: 2024-11-25 15:24:35\n---\n\n# Docker 架构与常用命令详解\n\n## Docker 架构\n### 仓库\n- 也分为**本地仓库**和**远程仓库**, 可以通过仓库拉取镜像(pull)\n- 仓库是用于存储 Docker 镜像的地方, 最常使用的 Registry 公开服务是官方的 **Docker Hub**, 网址为：[搜索镜像官网](https://hub.docker.com/ \"https://hub.docker.com/\")\n### 镜像\n- Docker 镜像就像是一个 root 文件系统，包含应用程序和运行环境的静态定义。\n- 镜像是 只读的模板，用于创建容器。\n### 容器\n- 容器是镜像运行时的实例，类似于面向对象中的类和对象。\n  - 镜像：静态定义（类）\n  - 容器：运行时实例（对象）\n- 容器是一个独立运行的应用实例，支持多种操作：创建、启动、停止、删除、暂停等。\n- 容器内部就是一个独立系统空间\n## Docker 常用命令\n### 基础操作命令\n\n| **命令**                    | **功能**           |\n| ------------------------- | ---------------- |\n| `systemctl status docker` | 查看 Docker 服务状态   |\n| `systemctl start docker`  | 启动 Docker 服务     |\n| `systemctl enable docker` | 开机自动启动 Docker 服务 |\n\n### 镜像操作命令\n\n| **命令**                            | **功能**                    |\n| --------------------------------- | ------------------------- |\n| `docker images`                   | 查看本地镜像                    |\n| `docker images -q`                | 查看所有镜像的 ID                |\n| `docker search 镜像名称`              | 搜索镜像                      |\n| `docker pull 镜像名称`                | 拉取镜像                      |\n| `docker rmi 镜像ID`                 | 删除指定的本地镜像                 |\n| `docker build -t imageName:1.0.0` | 指定一个Dockerfile时, 读取指令构建镜像 |\n\n### 容器操作命令\n\n| **命令**                | **功能**                        |\n| --------------------- | ----------------------------- |\n| `docker ps`           | 查看正在运行的容器                     |\n| `docker ps -a`        | 查看所有容器                        |\n| `docker ps -ap`       | 查看所有容器(只带容器id参数)              |\n| `docker start 容器名称`   | 启动容器                          |\n| `docker inspect 容器名称` | 查看容器详细信息                      |\n| `docker rm -f 容器名称`   | 删除指定容器                        |\n| `docker status mysql` | 查看指定容器资源占用状况，比如cpu、内存、网络、io状态 |\n| **自定义简化命令**           |                               |\n| `dps`                 | 查看所有容器并简化信息（别名命令）             |\n\n### 数据卷命令\n- 容器的数据卷默认存储在主机的文件夹：   `/var/lib/docker/volumes`\n- 每个数据卷在此目录下有一个独立文件夹，格式：   `/数据卷名/_data`\n\n| **命令**                       | **功能**  |\n| ---------------------------- | ------- |\n| `docker volume create my-vo` | 创建一个数据卷 |\n| `docker volume ls`           | 查看所有数据卷 |\n| `docker inspect my-vo`       | 查看数据卷详情 |\n| `docker volume rm my-vo`     | 删除数据卷   |\n\n### 网络管理命令\n\n| **命令**                                          | **功能**                            |\n| ----------------------------------------------- | --------------------------------- |\n| `docker network ls`                             | 查看所有网络                            |\n| `docker network create 网络名`                     | 创建新的 Docker 网络                    |\n| `docker network connect hmall mysql --alias db` | 将 mysql 容器连接到 hmall 网络，指定别名为 `db` |\n| `docker network connect hmall db`               | 将 db 容器连接到 hmall 网络               |\n\n### 容器内部命令\n\n| **命令**                     | **功能**       |\n| -------------------------- | ------------ |\n| `docker exec -it 容器名 bash` | 进入指定容器的命令行环境 |\n\n| 命令(进入容器后的命令)          | 功能说明: 与Linux系统操作一致(相当于一个小系统) |     |\n| --------------------- | ---------------------------- | --- |\n| `ls`                  | 查看当前目录文件                     |     |\n| `cd /路径`              | 切换到指定目录                      |     |\n| `pwd`                 | 查看当前路径                       |     |\n| `cat 文件名`             | 查看文件内容                       |     |\n| `vi 文件名` / `nano 文件名` | 编辑文件（需先安装）                   |     |\n| `apt update`          | 更新 apt 包管理源（Debian/Ubuntu）   |     |\n| `apt install 软件名`     | 安装常用软件                       |     |\n| `top` / `ps aux`      | 查看容器中的运行进程                   |     |\n| `env`                 | 查看环境变量                       |     |\n| `exit`                | 退出容器命令行                      |     |\n## 案例解析\n### 在 Nginx 容器中挂载配置文件和静态资源目录\n假设需要将 Nginx 的配置文件和静态文件挂载到本地：\n1. 创建数据卷目录：  \n   ```java\n   mkdir -p /mydata/nginx/{conf,html}\n   ```\n2. 数据卷挂载方式\n- `--mount` 可以有两种\n\t-  一种是挂载到数据卷volume上面(type=volume)\n\t- 另一种是直接挂载到宿主机上面(type=bind)\n- `-v` 对应的是宿主机路径:容器路径\n1. 运行容器时挂载数据卷：  \n   ```bash\n   docker run -d -p 80:80 \\\n       -v /mydata/nginx/conf:/etc/nginx/conf.d \\\n       -v /mydata/nginx/html:/usr/share/nginx/html \\\n       --name my-nginx nginx\n   ```\n2. 修改本地配置生效：  \n   - 修改 `/mydata/nginx/conf` 下的配置文件后，重启容器即可生效。\n### 为 Java 项目配置网络\n1. 创建网络：  \n   ```java\n   docker network create hmall\n   ```\n2. 将 MySQL 容器加入网络，并设置别名：  \n   ```java\n   docker network connect hmall mysql --alias db\n   ```\n3. 将 Java 项目容器加入网络：  \n   ```java\n   docker network connect hmall db\n   ```\n4. 连接测试：   在 Java 项目中, 数据库连接地址可以直接写为：`db:3306`。\n### 如何创建一个实例\n```bash\n# 模板\ndocker run -id \\\n\t-p 主机port:容器port \\\n\t--name=实例名 \\\n\t-v ./宿主机目录:实例主目录 \\\n\t-e 环境参数(例如:MYSQL_ROOT_PASSWORD=root) \\\n\t镜像名\n\ndocker run -d \\\n  --name nginx \\\n  -p 18080:18080 \\\n  -p 18081:18081 \\\n  -v /root/nginx/html:/usr/share/nginx/html \\\n  -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \\\n  --network hmall \\\n  nginx\n  \ndocker run -d \\\n  --name mysql \\\n  -p 3306:3306 \\\n  -e TZ=Asia/Shanghai \\\n  -e MYSQL_ROOT_PASSWORD=123 \\\n  -v ./mysql/data:/var/lib/mysql \\\n  -v ./mysql/conf:/etc/mysql/conf.d \\\n  -v ./mysql/init:/docker-entrypoint-initdb.d \\\n  --network hmall    \n  mysql \n```\n\t\t\t\n- `-v ./logs:/logs`：将主机当前目录下的./logs目录挂载到容器的 /logs\n- `-d`:让容器在后台运行\n- `-P`:将容器内部使用的网络端口映射到我们使用的主机上\n- 一个容器也可以被挂载多个数据卷\n- 多个容器是可以挂载同一个数据卷\n## `Docker Compose`(yaml)\n- Docker Compose 是 用来定义和管理多个容器服务。  \n- 它通过一个叫 `docker-compose.yml` 的配置文件，把多个 `docker run` 命令整合起来，一键启动，统一管理\n\n| 命令                       | 介绍          |\n| ------------------------ | ----------- |\n| `docker-compose version` | 查看版本        |\n| `docker-compose images`  | 列出所有容器使用的镜像 |\n| `docker-compose kill`    | 强制停止服务的容器   |\n| `docker-compose exec`    | 在容器中执行命令    |\n| `docker-compose logs`    | 查看日志        |\n| `docker-compose pause`   | 暂停服务        |\n| `docker-compose unpause` | 恢复服务        |\n| `docker-compose push`    | 推送服务镜像      |\n| `docker-compose start`   | 启动当前停止的某个容器 |\n| `docker-compose stop`    | 停止当前运行的某个容器 |\n| `docker-compose rm`      | 删除服务停止的容器   |\n| `docker-compose top`     | 查看进程        |\n\n\n```yaml\nversion: '3.8'  # Docker Compose 文件的版本\n\nservices:\n  app:  # 服务名称，可以自定义\n    image: 镜像  # 使用的镜像（如：node, nginx, mysql等）\n    container_name: container_name  # 指定容器名称\n    ports:\n      - \"宿主机port:容器port\"  # 映射端口：宿主机:容器（容器端口是8080，宿主机也映射8080）\n    volumes:\n      - ./app:/app  # 将./app宿主机当前目录下的app挂载到容器的/app目录\n    environment:\n      - ENV=dev  # 设置环境变量，可以根据需要调整\n\tbuild:\n\t  -          #构建目录\n    depends_on:\n      - db  # 依赖数据库服务:必须等db服务启动后才能启动\n    networks:\n      - backend  # 使用的网络，容器间可以通过这个网络相互通信\n\n  db:  # 另一个服务：数据库\n    image: mysql:8.0  # 使用 MySQL 8.0 镜像\n    container_name: mysql_db  # 数据库容器名称\n    ports:\n      - \"3306:3306\"  # 映射数据库端口\n    environment:\n      - MYSQL_ROOT_PASSWORD=root  # 设置 root 用户密码\n      - MYSQL_DATABASE=demo  # 设置数据库名称\n      - MYSQL_USER=user  # 设置数据库用户\n      - MYSQL_PASSWORD=pass  # 设置用户密码\n    volumes:\n      - ./mysql/data:/var/lib/mysql  # 持久化数据\n    networks:\n      - backend  # 使用相同的网络\n\nnetworks:\n  backend:\n    driver: bridge  # 使用默认的 bridge 网络驱动\n```\n## `Dockerfile`\n- Dockerfile 是一个**构建镜像**的脚本文件, 用命令docker build，创建一个 Dockerfile 文件\n- 比如你有一个 Spring Boot 项目用 MySQL 和 Redis。\n\t- 用 Dockerfile 构建你自己的 Java 应用镜像。\n\t- 用 Docker Compose 启动 Java 应用 + MySQL + Redis 三个容器，它会自动组建成一个小型微服务环境。\n\n| 对比点      | Dockerfile      | Docker Compose     |\n| -------- | --------------- | ------------------ |\n| 用途       | 构建镜像            | 一键式启动镜像容器          |\n| 文件格式     | name.Dockerfile | docker-compose.yml |\n| 是否可以独立使用 | 是               | 是                  |\n| 是否构建镜像   | 是               | 可以（如果用了 `build`）   |\n| 是否启动容器   | 否               | 是                  |\n| 是否支持多个服务 | 否               | 是                  |\n## 如何查看容器错误日志\n- 适用于服务没用启动或者服务异常关闭的排错\n```bash\n例：实时查看docker容器名为user-uat的最后10行日志 \ndocker logs -f -t --tail 10 user-uat \n例：查看指定时间后的日志，只显示最后100行： docker logs -f -t --since=\"2018-02-08\" --tail=100 user-uat \n例：查看最近30分钟的日志: docker logs --since 30m user-uat \n例：查看某时间之后的日志： docker logs -t --since=\"2018-02-08T13:23:37\" user-uat \n例：查看某时间段日志： docker logs -t --since=\"2018-02-08T13:23:37\" --until \"2018-02-09T12:23:37\" user-uat \n例：将错误日志写入文件： docker logs -f -t --since=\"2018-02-18\" user-uat | grep error >> logs_error.txt\n```\n## 注意\n- 容器想要访问宿主机的端口需要通过DNS\n\t- Docker专门提供了一个特殊DNS名称 `host.docker.internal`，这个名称在容器内表示“宿主机地址\"\n\t- 如果容器想要访问宿主Ollama的服务  可以通过dns映射直接来访问\n\t\t- `http://host.docker.internal:11434`\n- docker的作用\n\t- 通过docker我们可以快速打包并一键式部署我们自己的服务在各种环境中, 不管你是在 Windows、Linux、Mac，还是在云服务器、K8s 集群","slug":"docker","published":1,"updated":"2025-09-19T05:05:18.521Z","comments":1,"layout":"post","photos":[],"_id":"cmfw4z0a5001duomw3wbfhbpv","content":"<h1 id=\"Docker-架构与常用命令详解\"><a href=\"#Docker-架构与常用命令详解\" class=\"headerlink\" title=\"Docker 架构与常用命令详解\"></a>Docker 架构与常用命令详解</h1><h2 id=\"Docker-架构\"><a href=\"#Docker-架构\" class=\"headerlink\" title=\"Docker 架构\"></a>Docker 架构</h2><h3 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h3><ul>\n<li>也分为<strong>本地仓库</strong>和<strong>远程仓库</strong>, 可以通过仓库拉取镜像(pull)</li>\n<li>仓库是用于存储 Docker 镜像的地方, 最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong>, 网址为：<a href=\"https://hub.docker.com/\" title=\"https://hub.docker.com/\">搜索镜像官网</a><h3 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h3></li>\n<li>Docker 镜像就像是一个 root 文件系统，包含应用程序和运行环境的静态定义。</li>\n<li>镜像是 只读的模板，用于创建容器。<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3></li>\n<li>容器是镜像运行时的实例，类似于面向对象中的类和对象。<ul>\n<li>镜像：静态定义（类）</li>\n<li>容器：运行时实例（对象）</li>\n</ul>\n</li>\n<li>容器是一个独立运行的应用实例，支持多种操作：创建、启动、停止、删除、暂停等。</li>\n<li>容器内部就是一个独立系统空间<h2 id=\"Docker-常用命令\"><a href=\"#Docker-常用命令\" class=\"headerlink\" title=\"Docker 常用命令\"></a>Docker 常用命令</h2><h3 id=\"基础操作命令\"><a href=\"#基础操作命令\" class=\"headerlink\" title=\"基础操作命令\"></a>基础操作命令</h3></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>systemctl status docker</code></td>\n<td>查看 Docker 服务状态</td>\n</tr>\n<tr>\n<td><code>systemctl start docker</code></td>\n<td>启动 Docker 服务</td>\n</tr>\n<tr>\n<td><code>systemctl enable docker</code></td>\n<td>开机自动启动 Docker 服务</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"镜像操作命令\"><a href=\"#镜像操作命令\" class=\"headerlink\" title=\"镜像操作命令\"></a>镜像操作命令</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker images</code></td>\n<td>查看本地镜像</td>\n</tr>\n<tr>\n<td><code>docker images -q</code></td>\n<td>查看所有镜像的 ID</td>\n</tr>\n<tr>\n<td><code>docker search 镜像名称</code></td>\n<td>搜索镜像</td>\n</tr>\n<tr>\n<td><code>docker pull 镜像名称</code></td>\n<td>拉取镜像</td>\n</tr>\n<tr>\n<td><code>docker rmi 镜像ID</code></td>\n<td>删除指定的本地镜像</td>\n</tr>\n<tr>\n<td><code>docker build -t imageName:1.0.0</code></td>\n<td>指定一个Dockerfile时, 读取指令构建镜像</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"容器操作命令\"><a href=\"#容器操作命令\" class=\"headerlink\" title=\"容器操作命令\"></a>容器操作命令</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker ps</code></td>\n<td>查看正在运行的容器</td>\n</tr>\n<tr>\n<td><code>docker ps -a</code></td>\n<td>查看所有容器</td>\n</tr>\n<tr>\n<td><code>docker ps -ap</code></td>\n<td>查看所有容器(只带容器id参数)</td>\n</tr>\n<tr>\n<td><code>docker start 容器名称</code></td>\n<td>启动容器</td>\n</tr>\n<tr>\n<td><code>docker inspect 容器名称</code></td>\n<td>查看容器详细信息</td>\n</tr>\n<tr>\n<td><code>docker rm -f 容器名称</code></td>\n<td>删除指定容器</td>\n</tr>\n<tr>\n<td><code>docker status mysql</code></td>\n<td>查看指定容器资源占用状况，比如cpu、内存、网络、io状态</td>\n</tr>\n<tr>\n<td><strong>自定义简化命令</strong></td>\n<td></td>\n</tr>\n<tr>\n<td><code>dps</code></td>\n<td>查看所有容器并简化信息（别名命令）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"数据卷命令\"><a href=\"#数据卷命令\" class=\"headerlink\" title=\"数据卷命令\"></a>数据卷命令</h3><ul>\n<li>容器的数据卷默认存储在主机的文件夹：   <code>/var/lib/docker/volumes</code></li>\n<li>每个数据卷在此目录下有一个独立文件夹，格式：   <code>/数据卷名/_data</code></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker volume create my-vo</code></td>\n<td>创建一个数据卷</td>\n</tr>\n<tr>\n<td><code>docker volume ls</code></td>\n<td>查看所有数据卷</td>\n</tr>\n<tr>\n<td><code>docker inspect my-vo</code></td>\n<td>查看数据卷详情</td>\n</tr>\n<tr>\n<td><code>docker volume rm my-vo</code></td>\n<td>删除数据卷</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"网络管理命令\"><a href=\"#网络管理命令\" class=\"headerlink\" title=\"网络管理命令\"></a>网络管理命令</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker network ls</code></td>\n<td>查看所有网络</td>\n</tr>\n<tr>\n<td><code>docker network create 网络名</code></td>\n<td>创建新的 Docker 网络</td>\n</tr>\n<tr>\n<td><code>docker network connect hmall mysql --alias db</code></td>\n<td>将 mysql 容器连接到 hmall 网络，指定别名为 <code>db</code></td>\n</tr>\n<tr>\n<td><code>docker network connect hmall db</code></td>\n<td>将 db 容器连接到 hmall 网络</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"容器内部命令\"><a href=\"#容器内部命令\" class=\"headerlink\" title=\"容器内部命令\"></a>容器内部命令</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker exec -it 容器名 bash</code></td>\n<td>进入指定容器的命令行环境</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令(进入容器后的命令)</th>\n<th>功能说明: 与Linux系统操作一致(相当于一个小系统)</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ls</code></td>\n<td>查看当前目录文件</td>\n<td></td>\n</tr>\n<tr>\n<td><code>cd /路径</code></td>\n<td>切换到指定目录</td>\n<td></td>\n</tr>\n<tr>\n<td><code>pwd</code></td>\n<td>查看当前路径</td>\n<td></td>\n</tr>\n<tr>\n<td><code>cat 文件名</code></td>\n<td>查看文件内容</td>\n<td></td>\n</tr>\n<tr>\n<td><code>vi 文件名</code> / <code>nano 文件名</code></td>\n<td>编辑文件（需先安装）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>apt update</code></td>\n<td>更新 apt 包管理源（Debian/Ubuntu）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>apt install 软件名</code></td>\n<td>安装常用软件</td>\n<td></td>\n</tr>\n<tr>\n<td><code>top</code> / <code>ps aux</code></td>\n<td>查看容器中的运行进程</td>\n<td></td>\n</tr>\n<tr>\n<td><code>env</code></td>\n<td>查看环境变量</td>\n<td></td>\n</tr>\n<tr>\n<td><code>exit</code></td>\n<td>退出容器命令行</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"案例解析\"><a href=\"#案例解析\" class=\"headerlink\" title=\"案例解析\"></a>案例解析</h2><h3 id=\"在-Nginx-容器中挂载配置文件和静态资源目录\"><a href=\"#在-Nginx-容器中挂载配置文件和静态资源目录\" class=\"headerlink\" title=\"在 Nginx 容器中挂载配置文件和静态资源目录\"></a>在 Nginx 容器中挂载配置文件和静态资源目录</h3><p>假设需要将 Nginx 的配置文件和静态文件挂载到本地：</p>\n<ol>\n<li>创建数据卷目录：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /mydata/nginx/&#123;conf,html&#125;</span><br></pre></td></tr></table></figure></li>\n<li>数据卷挂载方式</li>\n</ol>\n<ul>\n<li><code>--mount</code> 可以有两种<ul>\n<li>一种是挂载到数据卷volume上面(type=volume)</li>\n<li>另一种是直接挂载到宿主机上面(type=bind)</li>\n</ul>\n</li>\n<li><code>-v</code> 对应的是宿主机路径:容器路径</li>\n</ul>\n<ol>\n<li>运行容器时挂载数据卷：  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 80:80 \\</span><br><span class=\"line\">    -v /mydata/nginx/conf:/etc/nginx/conf.d \\</span><br><span class=\"line\">    -v /mydata/nginx/html:/usr/share/nginx/html \\</span><br><span class=\"line\">    --name my-nginx nginx</span><br></pre></td></tr></table></figure></li>\n<li>修改本地配置生效：  <ul>\n<li>修改 <code>/mydata/nginx/conf</code> 下的配置文件后，重启容器即可生效。<h3 id=\"为-Java-项目配置网络\"><a href=\"#为-Java-项目配置网络\" class=\"headerlink\" title=\"为 Java 项目配置网络\"></a>为 Java 项目配置网络</h3></li>\n</ul>\n</li>\n<li>创建网络：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network create hmall</span><br></pre></td></tr></table></figure></li>\n<li>将 MySQL 容器加入网络，并设置别名：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network connect hmall mysql --alias db</span><br></pre></td></tr></table></figure></li>\n<li>将 Java 项目容器加入网络：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network connect hmall db</span><br></pre></td></tr></table></figure></li>\n<li>连接测试：   在 Java 项目中, 数据库连接地址可以直接写为：<code>db:3306</code>。<h3 id=\"如何创建一个实例\"><a href=\"#如何创建一个实例\" class=\"headerlink\" title=\"如何创建一个实例\"></a>如何创建一个实例</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 模板</span></span><br><span class=\"line\">docker run -<span class=\"built_in\">id</span> \\</span><br><span class=\"line\">\t-p 主机port:容器port \\</span><br><span class=\"line\">\t--name=实例名 \\</span><br><span class=\"line\">\t-v ./宿主机目录:实例主目录 \\</span><br><span class=\"line\">\t-e 环境参数(例如:MYSQL_ROOT_PASSWORD=root) \\</span><br><span class=\"line\">\t镜像名</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name nginx \\</span><br><span class=\"line\">  -p 18080:18080 \\</span><br><span class=\"line\">  -p 18081:18081 \\</span><br><span class=\"line\">  -v /root/nginx/html:/usr/share/nginx/html \\</span><br><span class=\"line\">  -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \\</span><br><span class=\"line\">  --network hmall \\</span><br><span class=\"line\">  nginx</span><br><span class=\"line\">  </span><br><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name mysql \\</span><br><span class=\"line\">  -p 3306:3306 \\</span><br><span class=\"line\">  -e TZ=Asia/Shanghai \\</span><br><span class=\"line\">  -e MYSQL_ROOT_PASSWORD=123 \\</span><br><span class=\"line\">  -v ./mysql/data:/var/lib/mysql \\</span><br><span class=\"line\">  -v ./mysql/conf:/etc/mysql/conf.d \\</span><br><span class=\"line\">  -v ./mysql/init:/docker-entrypoint-initdb.d \\</span><br><span class=\"line\">  --network hmall    </span><br><span class=\"line\">  mysql </span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><code>-v ./logs:/logs</code>：将主机当前目录下的./logs目录挂载到容器的 /logs</li>\n<li><code>-d</code>:让容器在后台运行</li>\n<li><code>-P</code>:将容器内部使用的网络端口映射到我们使用的主机上</li>\n<li>一个容器也可以被挂载多个数据卷</li>\n<li>多个容器是可以挂载同一个数据卷<h2 id=\"Docker-Compose-yaml\"><a href=\"#Docker-Compose-yaml\" class=\"headerlink\" title=\"Docker Compose(yaml)\"></a><code>Docker Compose</code>(yaml)</h2></li>\n<li>Docker Compose 是 用来定义和管理多个容器服务。  </li>\n<li>它通过一个叫 <code>docker-compose.yml</code> 的配置文件，把多个 <code>docker run</code> 命令整合起来，一键启动，统一管理</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker-compose version</code></td>\n<td>查看版本</td>\n</tr>\n<tr>\n<td><code>docker-compose images</code></td>\n<td>列出所有容器使用的镜像</td>\n</tr>\n<tr>\n<td><code>docker-compose kill</code></td>\n<td>强制停止服务的容器</td>\n</tr>\n<tr>\n<td><code>docker-compose exec</code></td>\n<td>在容器中执行命令</td>\n</tr>\n<tr>\n<td><code>docker-compose logs</code></td>\n<td>查看日志</td>\n</tr>\n<tr>\n<td><code>docker-compose pause</code></td>\n<td>暂停服务</td>\n</tr>\n<tr>\n<td><code>docker-compose unpause</code></td>\n<td>恢复服务</td>\n</tr>\n<tr>\n<td><code>docker-compose push</code></td>\n<td>推送服务镜像</td>\n</tr>\n<tr>\n<td><code>docker-compose start</code></td>\n<td>启动当前停止的某个容器</td>\n</tr>\n<tr>\n<td><code>docker-compose stop</code></td>\n<td>停止当前运行的某个容器</td>\n</tr>\n<tr>\n<td><code>docker-compose rm</code></td>\n<td>删除服务停止的容器</td>\n</tr>\n<tr>\n<td><code>docker-compose top</code></td>\n<td>查看进程</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span>  <span class=\"comment\"># Docker Compose 文件的版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span>  <span class=\"comment\"># 服务名称，可以自定义</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">镜像</span>  <span class=\"comment\"># 使用的镜像（如：node, nginx, mysql等）</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">container_name</span>  <span class=\"comment\"># 指定容器名称</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;宿主机port:容器port&quot;</span>  <span class=\"comment\"># 映射端口：宿主机:容器（容器端口是8080，宿主机也映射8080）</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./app:/app</span>  <span class=\"comment\"># 将./app宿主机当前目录下的app挂载到容器的/app目录</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ENV=dev</span>  <span class=\"comment\"># 设置环境变量，可以根据需要调整</span></span><br><span class=\"line\">\t<span class=\"attr\">build:</span></span><br><span class=\"line\">\t  <span class=\"bullet\">-</span>          <span class=\"comment\">#构建目录</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db</span>  <span class=\"comment\"># 依赖数据库服务:必须等db服务启动后才能启动</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend</span>  <span class=\"comment\"># 使用的网络，容器间可以通过这个网络相互通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span>  <span class=\"comment\"># 另一个服务：数据库</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:8.0</span>  <span class=\"comment\"># 使用 MySQL 8.0 镜像</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">mysql_db</span>  <span class=\"comment\"># 数据库容器名称</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3306:3306&quot;</span>  <span class=\"comment\"># 映射数据库端口</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=root</span>  <span class=\"comment\"># 设置 root 用户密码</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=demo</span>  <span class=\"comment\"># 设置数据库名称</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_USER=user</span>  <span class=\"comment\"># 设置数据库用户</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_PASSWORD=pass</span>  <span class=\"comment\"># 设置用户密码</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./mysql/data:/var/lib/mysql</span>  <span class=\"comment\"># 持久化数据</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend</span>  <span class=\"comment\"># 使用相同的网络</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">bridge</span>  <span class=\"comment\"># 使用默认的 bridge 网络驱动</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a><code>Dockerfile</code></h2><ul>\n<li>Dockerfile 是一个<strong>构建镜像</strong>的脚本文件, 用命令docker build，创建一个 Dockerfile 文件</li>\n<li>比如你有一个 Spring Boot 项目用 MySQL 和 Redis。<ul>\n<li>用 Dockerfile 构建你自己的 Java 应用镜像。</li>\n<li>用 Docker Compose 启动 Java 应用 + MySQL + Redis 三个容器，它会自动组建成一个小型微服务环境。</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>对比点</th>\n<th>Dockerfile</th>\n<th>Docker Compose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用途</td>\n<td>构建镜像</td>\n<td>一键式启动镜像容器</td>\n</tr>\n<tr>\n<td>文件格式</td>\n<td>name.Dockerfile</td>\n<td>docker-compose.yml</td>\n</tr>\n<tr>\n<td>是否可以独立使用</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>是否构建镜像</td>\n<td>是</td>\n<td>可以（如果用了 <code>build</code>）</td>\n</tr>\n<tr>\n<td>是否启动容器</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>是否支持多个服务</td>\n<td>否</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"如何查看容器错误日志\"><a href=\"#如何查看容器错误日志\" class=\"headerlink\" title=\"如何查看容器错误日志\"></a>如何查看容器错误日志</h2><ul>\n<li>适用于服务没用启动或者服务异常关闭的排错<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：实时查看docker容器名为user-uat的最后10行日志 </span><br><span class=\"line\">docker logs -f -t --<span class=\"built_in\">tail</span> 10 user-uat </span><br><span class=\"line\">例：查看指定时间后的日志，只显示最后100行： docker logs -f -t --since=<span class=\"string\">&quot;2018-02-08&quot;</span> --<span class=\"built_in\">tail</span>=100 user-uat </span><br><span class=\"line\">例：查看最近30分钟的日志: docker logs --since 30m user-uat </span><br><span class=\"line\">例：查看某时间之后的日志： docker logs -t --since=<span class=\"string\">&quot;2018-02-08T13:23:37&quot;</span> user-uat </span><br><span class=\"line\">例：查看某时间段日志： docker logs -t --since=<span class=\"string\">&quot;2018-02-08T13:23:37&quot;</span> --<span class=\"keyword\">until</span> <span class=\"string\">&quot;2018-02-09T12:23:37&quot;</span> user-uat </span><br><span class=\"line\">例：将错误日志写入文件： docker logs -f -t --since=<span class=\"string\">&quot;2018-02-18&quot;</span> user-uat | grep error &gt;&gt; logs_error.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2></li>\n<li>容器想要访问宿主机的端口需要通过DNS<ul>\n<li>Docker专门提供了一个特殊DNS名称 <code>host.docker.internal</code>，这个名称在容器内表示“宿主机地址”</li>\n<li>如果容器想要访问宿主Ollama的服务  可以通过dns映射直接来访问<ul>\n<li><code>http://host.docker.internal:11434</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>docker的作用<ul>\n<li>通过docker我们可以快速打包并一键式部署我们自己的服务在各种环境中, 不管你是在 Windows、Linux、Mac，还是在云服务器、K8s 集群</li>\n</ul>\n</li>\n</ul>\n","cover":"/img/view9.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"Docker-架构与常用命令详解\"><a href=\"#Docker-架构与常用命令详解\" class=\"headerlink\" title=\"Docker 架构与常用命令详解\"></a>Docker 架构与常用命令详解</h1><h2 id=\"Docker-架构\"><a href=\"#Docker-架构\" class=\"headerlink\" title=\"Docker 架构\"></a>Docker 架构</h2><h3 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h3><ul>\n<li>也分为<strong>本地仓库</strong>和<strong>远程仓库</strong>, 可以通过仓库拉取镜像(pull)</li>\n<li>仓库是用于存储 Docker 镜像的地方, 最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong>, 网址为：<a href=\"https://hub.docker.com/\" title=\"https://hub.docker.com/\">搜索镜像官网</a><h3 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h3></li>\n<li>Docker 镜像就像是一个 root 文件系统，包含应用程序和运行环境的静态定义。</li>\n<li>镜像是 只读的模板，用于创建容器。<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3></li>\n<li>容器是镜像运行时的实例，类似于面向对象中的类和对象。<ul>\n<li>镜像：静态定义（类）</li>\n<li>容器：运行时实例（对象）</li>\n</ul>\n</li>\n<li>容器是一个独立运行的应用实例，支持多种操作：创建、启动、停止、删除、暂停等。</li>\n<li>容器内部就是一个独立系统空间<h2 id=\"Docker-常用命令\"><a href=\"#Docker-常用命令\" class=\"headerlink\" title=\"Docker 常用命令\"></a>Docker 常用命令</h2><h3 id=\"基础操作命令\"><a href=\"#基础操作命令\" class=\"headerlink\" title=\"基础操作命令\"></a>基础操作命令</h3></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>systemctl status docker</code></td>\n<td>查看 Docker 服务状态</td>\n</tr>\n<tr>\n<td><code>systemctl start docker</code></td>\n<td>启动 Docker 服务</td>\n</tr>\n<tr>\n<td><code>systemctl enable docker</code></td>\n<td>开机自动启动 Docker 服务</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"镜像操作命令\"><a href=\"#镜像操作命令\" class=\"headerlink\" title=\"镜像操作命令\"></a>镜像操作命令</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker images</code></td>\n<td>查看本地镜像</td>\n</tr>\n<tr>\n<td><code>docker images -q</code></td>\n<td>查看所有镜像的 ID</td>\n</tr>\n<tr>\n<td><code>docker search 镜像名称</code></td>\n<td>搜索镜像</td>\n</tr>\n<tr>\n<td><code>docker pull 镜像名称</code></td>\n<td>拉取镜像</td>\n</tr>\n<tr>\n<td><code>docker rmi 镜像ID</code></td>\n<td>删除指定的本地镜像</td>\n</tr>\n<tr>\n<td><code>docker build -t imageName:1.0.0</code></td>\n<td>指定一个Dockerfile时, 读取指令构建镜像</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"容器操作命令\"><a href=\"#容器操作命令\" class=\"headerlink\" title=\"容器操作命令\"></a>容器操作命令</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker ps</code></td>\n<td>查看正在运行的容器</td>\n</tr>\n<tr>\n<td><code>docker ps -a</code></td>\n<td>查看所有容器</td>\n</tr>\n<tr>\n<td><code>docker ps -ap</code></td>\n<td>查看所有容器(只带容器id参数)</td>\n</tr>\n<tr>\n<td><code>docker start 容器名称</code></td>\n<td>启动容器</td>\n</tr>\n<tr>\n<td><code>docker inspect 容器名称</code></td>\n<td>查看容器详细信息</td>\n</tr>\n<tr>\n<td><code>docker rm -f 容器名称</code></td>\n<td>删除指定容器</td>\n</tr>\n<tr>\n<td><code>docker status mysql</code></td>\n<td>查看指定容器资源占用状况，比如cpu、内存、网络、io状态</td>\n</tr>\n<tr>\n<td><strong>自定义简化命令</strong></td>\n<td></td>\n</tr>\n<tr>\n<td><code>dps</code></td>\n<td>查看所有容器并简化信息（别名命令）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"数据卷命令\"><a href=\"#数据卷命令\" class=\"headerlink\" title=\"数据卷命令\"></a>数据卷命令</h3><ul>\n<li>容器的数据卷默认存储在主机的文件夹：   <code>/var/lib/docker/volumes</code></li>\n<li>每个数据卷在此目录下有一个独立文件夹，格式：   <code>/数据卷名/_data</code></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker volume create my-vo</code></td>\n<td>创建一个数据卷</td>\n</tr>\n<tr>\n<td><code>docker volume ls</code></td>\n<td>查看所有数据卷</td>\n</tr>\n<tr>\n<td><code>docker inspect my-vo</code></td>\n<td>查看数据卷详情</td>\n</tr>\n<tr>\n<td><code>docker volume rm my-vo</code></td>\n<td>删除数据卷</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"网络管理命令\"><a href=\"#网络管理命令\" class=\"headerlink\" title=\"网络管理命令\"></a>网络管理命令</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker network ls</code></td>\n<td>查看所有网络</td>\n</tr>\n<tr>\n<td><code>docker network create 网络名</code></td>\n<td>创建新的 Docker 网络</td>\n</tr>\n<tr>\n<td><code>docker network connect hmall mysql --alias db</code></td>\n<td>将 mysql 容器连接到 hmall 网络，指定别名为 <code>db</code></td>\n</tr>\n<tr>\n<td><code>docker network connect hmall db</code></td>\n<td>将 db 容器连接到 hmall 网络</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"容器内部命令\"><a href=\"#容器内部命令\" class=\"headerlink\" title=\"容器内部命令\"></a>容器内部命令</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker exec -it 容器名 bash</code></td>\n<td>进入指定容器的命令行环境</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令(进入容器后的命令)</th>\n<th>功能说明: 与Linux系统操作一致(相当于一个小系统)</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ls</code></td>\n<td>查看当前目录文件</td>\n<td></td>\n</tr>\n<tr>\n<td><code>cd /路径</code></td>\n<td>切换到指定目录</td>\n<td></td>\n</tr>\n<tr>\n<td><code>pwd</code></td>\n<td>查看当前路径</td>\n<td></td>\n</tr>\n<tr>\n<td><code>cat 文件名</code></td>\n<td>查看文件内容</td>\n<td></td>\n</tr>\n<tr>\n<td><code>vi 文件名</code> / <code>nano 文件名</code></td>\n<td>编辑文件（需先安装）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>apt update</code></td>\n<td>更新 apt 包管理源（Debian/Ubuntu）</td>\n<td></td>\n</tr>\n<tr>\n<td><code>apt install 软件名</code></td>\n<td>安装常用软件</td>\n<td></td>\n</tr>\n<tr>\n<td><code>top</code> / <code>ps aux</code></td>\n<td>查看容器中的运行进程</td>\n<td></td>\n</tr>\n<tr>\n<td><code>env</code></td>\n<td>查看环境变量</td>\n<td></td>\n</tr>\n<tr>\n<td><code>exit</code></td>\n<td>退出容器命令行</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"案例解析\"><a href=\"#案例解析\" class=\"headerlink\" title=\"案例解析\"></a>案例解析</h2><h3 id=\"在-Nginx-容器中挂载配置文件和静态资源目录\"><a href=\"#在-Nginx-容器中挂载配置文件和静态资源目录\" class=\"headerlink\" title=\"在 Nginx 容器中挂载配置文件和静态资源目录\"></a>在 Nginx 容器中挂载配置文件和静态资源目录</h3><p>假设需要将 Nginx 的配置文件和静态文件挂载到本地：</p>\n<ol>\n<li>创建数据卷目录：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /mydata/nginx/&#123;conf,html&#125;</span><br></pre></td></tr></table></figure></li>\n<li>数据卷挂载方式</li>\n</ol>\n<ul>\n<li><code>--mount</code> 可以有两种<ul>\n<li>一种是挂载到数据卷volume上面(type=volume)</li>\n<li>另一种是直接挂载到宿主机上面(type=bind)</li>\n</ul>\n</li>\n<li><code>-v</code> 对应的是宿主机路径:容器路径</li>\n</ul>\n<ol>\n<li>运行容器时挂载数据卷：  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 80:80 \\</span><br><span class=\"line\">    -v /mydata/nginx/conf:/etc/nginx/conf.d \\</span><br><span class=\"line\">    -v /mydata/nginx/html:/usr/share/nginx/html \\</span><br><span class=\"line\">    --name my-nginx nginx</span><br></pre></td></tr></table></figure></li>\n<li>修改本地配置生效：  <ul>\n<li>修改 <code>/mydata/nginx/conf</code> 下的配置文件后，重启容器即可生效。<h3 id=\"为-Java-项目配置网络\"><a href=\"#为-Java-项目配置网络\" class=\"headerlink\" title=\"为 Java 项目配置网络\"></a>为 Java 项目配置网络</h3></li>\n</ul>\n</li>\n<li>创建网络：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network create hmall</span><br></pre></td></tr></table></figure></li>\n<li>将 MySQL 容器加入网络，并设置别名：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network connect hmall mysql --alias db</span><br></pre></td></tr></table></figure></li>\n<li>将 Java 项目容器加入网络：  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker network connect hmall db</span><br></pre></td></tr></table></figure></li>\n<li>连接测试：   在 Java 项目中, 数据库连接地址可以直接写为：<code>db:3306</code>。<h3 id=\"如何创建一个实例\"><a href=\"#如何创建一个实例\" class=\"headerlink\" title=\"如何创建一个实例\"></a>如何创建一个实例</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 模板</span></span><br><span class=\"line\">docker run -<span class=\"built_in\">id</span> \\</span><br><span class=\"line\">\t-p 主机port:容器port \\</span><br><span class=\"line\">\t--name=实例名 \\</span><br><span class=\"line\">\t-v ./宿主机目录:实例主目录 \\</span><br><span class=\"line\">\t-e 环境参数(例如:MYSQL_ROOT_PASSWORD=root) \\</span><br><span class=\"line\">\t镜像名</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name nginx \\</span><br><span class=\"line\">  -p 18080:18080 \\</span><br><span class=\"line\">  -p 18081:18081 \\</span><br><span class=\"line\">  -v /root/nginx/html:/usr/share/nginx/html \\</span><br><span class=\"line\">  -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \\</span><br><span class=\"line\">  --network hmall \\</span><br><span class=\"line\">  nginx</span><br><span class=\"line\">  </span><br><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name mysql \\</span><br><span class=\"line\">  -p 3306:3306 \\</span><br><span class=\"line\">  -e TZ=Asia/Shanghai \\</span><br><span class=\"line\">  -e MYSQL_ROOT_PASSWORD=123 \\</span><br><span class=\"line\">  -v ./mysql/data:/var/lib/mysql \\</span><br><span class=\"line\">  -v ./mysql/conf:/etc/mysql/conf.d \\</span><br><span class=\"line\">  -v ./mysql/init:/docker-entrypoint-initdb.d \\</span><br><span class=\"line\">  --network hmall    </span><br><span class=\"line\">  mysql </span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><code>-v ./logs:/logs</code>：将主机当前目录下的./logs目录挂载到容器的 /logs</li>\n<li><code>-d</code>:让容器在后台运行</li>\n<li><code>-P</code>:将容器内部使用的网络端口映射到我们使用的主机上</li>\n<li>一个容器也可以被挂载多个数据卷</li>\n<li>多个容器是可以挂载同一个数据卷<h2 id=\"Docker-Compose-yaml\"><a href=\"#Docker-Compose-yaml\" class=\"headerlink\" title=\"Docker Compose(yaml)\"></a><code>Docker Compose</code>(yaml)</h2></li>\n<li>Docker Compose 是 用来定义和管理多个容器服务。  </li>\n<li>它通过一个叫 <code>docker-compose.yml</code> 的配置文件，把多个 <code>docker run</code> 命令整合起来，一键启动，统一管理</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker-compose version</code></td>\n<td>查看版本</td>\n</tr>\n<tr>\n<td><code>docker-compose images</code></td>\n<td>列出所有容器使用的镜像</td>\n</tr>\n<tr>\n<td><code>docker-compose kill</code></td>\n<td>强制停止服务的容器</td>\n</tr>\n<tr>\n<td><code>docker-compose exec</code></td>\n<td>在容器中执行命令</td>\n</tr>\n<tr>\n<td><code>docker-compose logs</code></td>\n<td>查看日志</td>\n</tr>\n<tr>\n<td><code>docker-compose pause</code></td>\n<td>暂停服务</td>\n</tr>\n<tr>\n<td><code>docker-compose unpause</code></td>\n<td>恢复服务</td>\n</tr>\n<tr>\n<td><code>docker-compose push</code></td>\n<td>推送服务镜像</td>\n</tr>\n<tr>\n<td><code>docker-compose start</code></td>\n<td>启动当前停止的某个容器</td>\n</tr>\n<tr>\n<td><code>docker-compose stop</code></td>\n<td>停止当前运行的某个容器</td>\n</tr>\n<tr>\n<td><code>docker-compose rm</code></td>\n<td>删除服务停止的容器</td>\n</tr>\n<tr>\n<td><code>docker-compose top</code></td>\n<td>查看进程</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span>  <span class=\"comment\"># Docker Compose 文件的版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span>  <span class=\"comment\"># 服务名称，可以自定义</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">镜像</span>  <span class=\"comment\"># 使用的镜像（如：node, nginx, mysql等）</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">container_name</span>  <span class=\"comment\"># 指定容器名称</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;宿主机port:容器port&quot;</span>  <span class=\"comment\"># 映射端口：宿主机:容器（容器端口是8080，宿主机也映射8080）</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./app:/app</span>  <span class=\"comment\"># 将./app宿主机当前目录下的app挂载到容器的/app目录</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ENV=dev</span>  <span class=\"comment\"># 设置环境变量，可以根据需要调整</span></span><br><span class=\"line\">\t<span class=\"attr\">build:</span></span><br><span class=\"line\">\t  <span class=\"bullet\">-</span>          <span class=\"comment\">#构建目录</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db</span>  <span class=\"comment\"># 依赖数据库服务:必须等db服务启动后才能启动</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend</span>  <span class=\"comment\"># 使用的网络，容器间可以通过这个网络相互通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span>  <span class=\"comment\"># 另一个服务：数据库</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:8.0</span>  <span class=\"comment\"># 使用 MySQL 8.0 镜像</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">mysql_db</span>  <span class=\"comment\"># 数据库容器名称</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3306:3306&quot;</span>  <span class=\"comment\"># 映射数据库端口</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=root</span>  <span class=\"comment\"># 设置 root 用户密码</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=demo</span>  <span class=\"comment\"># 设置数据库名称</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_USER=user</span>  <span class=\"comment\"># 设置数据库用户</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_PASSWORD=pass</span>  <span class=\"comment\"># 设置用户密码</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./mysql/data:/var/lib/mysql</span>  <span class=\"comment\"># 持久化数据</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend</span>  <span class=\"comment\"># 使用相同的网络</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">bridge</span>  <span class=\"comment\"># 使用默认的 bridge 网络驱动</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a><code>Dockerfile</code></h2><ul>\n<li>Dockerfile 是一个<strong>构建镜像</strong>的脚本文件, 用命令docker build，创建一个 Dockerfile 文件</li>\n<li>比如你有一个 Spring Boot 项目用 MySQL 和 Redis。<ul>\n<li>用 Dockerfile 构建你自己的 Java 应用镜像。</li>\n<li>用 Docker Compose 启动 Java 应用 + MySQL + Redis 三个容器，它会自动组建成一个小型微服务环境。</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>对比点</th>\n<th>Dockerfile</th>\n<th>Docker Compose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用途</td>\n<td>构建镜像</td>\n<td>一键式启动镜像容器</td>\n</tr>\n<tr>\n<td>文件格式</td>\n<td>name.Dockerfile</td>\n<td>docker-compose.yml</td>\n</tr>\n<tr>\n<td>是否可以独立使用</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>是否构建镜像</td>\n<td>是</td>\n<td>可以（如果用了 <code>build</code>）</td>\n</tr>\n<tr>\n<td>是否启动容器</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>是否支持多个服务</td>\n<td>否</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"如何查看容器错误日志\"><a href=\"#如何查看容器错误日志\" class=\"headerlink\" title=\"如何查看容器错误日志\"></a>如何查看容器错误日志</h2><ul>\n<li>适用于服务没用启动或者服务异常关闭的排错<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：实时查看docker容器名为user-uat的最后10行日志 </span><br><span class=\"line\">docker logs -f -t --<span class=\"built_in\">tail</span> 10 user-uat </span><br><span class=\"line\">例：查看指定时间后的日志，只显示最后100行： docker logs -f -t --since=<span class=\"string\">&quot;2018-02-08&quot;</span> --<span class=\"built_in\">tail</span>=100 user-uat </span><br><span class=\"line\">例：查看最近30分钟的日志: docker logs --since 30m user-uat </span><br><span class=\"line\">例：查看某时间之后的日志： docker logs -t --since=<span class=\"string\">&quot;2018-02-08T13:23:37&quot;</span> user-uat </span><br><span class=\"line\">例：查看某时间段日志： docker logs -t --since=<span class=\"string\">&quot;2018-02-08T13:23:37&quot;</span> --<span class=\"keyword\">until</span> <span class=\"string\">&quot;2018-02-09T12:23:37&quot;</span> user-uat </span><br><span class=\"line\">例：将错误日志写入文件： docker logs -f -t --since=<span class=\"string\">&quot;2018-02-18&quot;</span> user-uat | grep error &gt;&gt; logs_error.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2></li>\n<li>容器想要访问宿主机的端口需要通过DNS<ul>\n<li>Docker专门提供了一个特殊DNS名称 <code>host.docker.internal</code>，这个名称在容器内表示“宿主机地址”</li>\n<li>如果容器想要访问宿主Ollama的服务  可以通过dns映射直接来访问<ul>\n<li><code>http://host.docker.internal:11434</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>docker的作用<ul>\n<li>通过docker我们可以快速打包并一键式部署我们自己的服务在各种环境中, 不管你是在 Windows、Linux、Mac，还是在云服务器、K8s 集群</li>\n</ul>\n</li>\n</ul>\n"},{"title":"加密解密解决方案","date":"2024-12-06T13:43:19.000Z","_content":"\n# Encrypt\n\n## 3种加密类型\n\n### 数字签名\n\n- 不安全,容易被破解, 因为没用采用秘钥的方式, 但是执行效率快\n- 比如: MD5  Sha56  Base64\n\n### 对称加密算法\n\n- 较安全, 因为采用的是单秘钥的方式, 一把秘钥同时支持加密解密, 执行效率中等\n- 比如: AES  DES\n\n### 非对称加密算法\n\n- 很安全, 因为采用的是公私钥结合的方式, 公钥加密, 私钥解密, 执行效率最慢\n- 比如: RSA\n\t- RSA密钥本质上是二进制数据,但二进制数据不方便: Base64编码将二进制数据转换成可打印的可读ASCII字符,便于处理和传输\n\n![17334951657141733495165602.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17334951657141733495165602.png)\n\n## 证书\n- 生成证书的过程，实际上是**创建了一对 RSA 公钥和私钥**，然后把它们存储在**密钥库**（keystore）中，比如：\n- `.jks`（Java Keystore，Java 使用的密钥库）\n- `.p12`（PKCS12 标准密钥库，兼容性更好）\n- `.pem`（开放标准的密钥格式）\n## 例子\n- 采用了AES对称加密(单秘钥)和RSA非对称加密(公私钥)\n\t- 先用AES秘钥加密请求体, 然后用RSA公钥加密AES秘钥, 放入请求头\n- 好处: \n\t- 双重加密, 不易被破解 \n\t- 要解密两次, 性能差\n```java\n// 采用java.util和Hutool工具包\n@Test\npublic void encryptJson() {\n    Log log = LogFactory.get();\n    log.info(\"*******************加密中****************************\");\n\n    // 1. 生成 RSA 公钥和私钥（Base64 编码）\n    RSA rsa = new RSA();\n    String privateKeyBase64 = rsa.getPrivateKeyBase64();\n    String publicKeyBase64 = rsa.getPublicKeyBase64();\n\n    // 将 Base64 字符串还原为 Key 对象 -> 枚举\n    RSA rsaFromBase64 = new RSA(privateKeyBase64, publicKeyBase64);\n\n    // 2. 公钥加密 AES 密钥\n    String aesKey = \"1234567890abcdef\"; // 固定一个 16 字节的字符串作为 AES 密钥\n    byte[] encryptedAesKey = rsaFromBase64.encrypt(aesKey.getBytes(), KeyType.PublicKey);\n\n    // 3. 用 AES 密钥加密 JSON 字符串\n    AES aes = SecureUtil.aes(aesKey.getBytes()); // 使用 AES 密钥初始化 AES 实例\n    String encryptedHex = aes.encryptHex(\"Im JsonString\");\n\n    log.info(\"********************解密中*************************\");\n\n    // 4. 私钥解密 AES 密钥\n    byte[] decryptedAesKeyBytes = rsaFromBase64.decrypt(encryptedAesKey, KeyType.PrivateKey);\n    String decryptedAesKey = new String(decryptedAesKeyBytes);\n\n    // 5. 用解密后的 AES 密钥解密 JSON 数据\n    AES decryptedAes = SecureUtil.aes(decryptedAesKey.getBytes());\n    String decryptedJsonString = decryptedAes.decryptStr(encryptedHex);\n\n    log.info(\"********************测试数据*************************\");\n    log.info(\"Public Key (Base64): {}\", publicKeyBase64);\n    log.info(\"Private Key (Base64): {}\", privateKeyBase64);\n    log.info(\"Encrypted Hex: {}\", encryptedHex);\n    log.info(\"Decrypted JSON String: {}\", decryptedJsonString);\n}\n```\n![17334951277141733495127306.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17334951277141733495127306.png)\n","source":"_posts/encrypt.md","raw":"---\ntitle: 加密解密解决方案\ntags:\n  - encrypt\ncategories: 编程\ndate: 2024-12-06 21:43:19\n---\n\n# Encrypt\n\n## 3种加密类型\n\n### 数字签名\n\n- 不安全,容易被破解, 因为没用采用秘钥的方式, 但是执行效率快\n- 比如: MD5  Sha56  Base64\n\n### 对称加密算法\n\n- 较安全, 因为采用的是单秘钥的方式, 一把秘钥同时支持加密解密, 执行效率中等\n- 比如: AES  DES\n\n### 非对称加密算法\n\n- 很安全, 因为采用的是公私钥结合的方式, 公钥加密, 私钥解密, 执行效率最慢\n- 比如: RSA\n\t- RSA密钥本质上是二进制数据,但二进制数据不方便: Base64编码将二进制数据转换成可打印的可读ASCII字符,便于处理和传输\n\n![17334951657141733495165602.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17334951657141733495165602.png)\n\n## 证书\n- 生成证书的过程，实际上是**创建了一对 RSA 公钥和私钥**，然后把它们存储在**密钥库**（keystore）中，比如：\n- `.jks`（Java Keystore，Java 使用的密钥库）\n- `.p12`（PKCS12 标准密钥库，兼容性更好）\n- `.pem`（开放标准的密钥格式）\n## 例子\n- 采用了AES对称加密(单秘钥)和RSA非对称加密(公私钥)\n\t- 先用AES秘钥加密请求体, 然后用RSA公钥加密AES秘钥, 放入请求头\n- 好处: \n\t- 双重加密, 不易被破解 \n\t- 要解密两次, 性能差\n```java\n// 采用java.util和Hutool工具包\n@Test\npublic void encryptJson() {\n    Log log = LogFactory.get();\n    log.info(\"*******************加密中****************************\");\n\n    // 1. 生成 RSA 公钥和私钥（Base64 编码）\n    RSA rsa = new RSA();\n    String privateKeyBase64 = rsa.getPrivateKeyBase64();\n    String publicKeyBase64 = rsa.getPublicKeyBase64();\n\n    // 将 Base64 字符串还原为 Key 对象 -> 枚举\n    RSA rsaFromBase64 = new RSA(privateKeyBase64, publicKeyBase64);\n\n    // 2. 公钥加密 AES 密钥\n    String aesKey = \"1234567890abcdef\"; // 固定一个 16 字节的字符串作为 AES 密钥\n    byte[] encryptedAesKey = rsaFromBase64.encrypt(aesKey.getBytes(), KeyType.PublicKey);\n\n    // 3. 用 AES 密钥加密 JSON 字符串\n    AES aes = SecureUtil.aes(aesKey.getBytes()); // 使用 AES 密钥初始化 AES 实例\n    String encryptedHex = aes.encryptHex(\"Im JsonString\");\n\n    log.info(\"********************解密中*************************\");\n\n    // 4. 私钥解密 AES 密钥\n    byte[] decryptedAesKeyBytes = rsaFromBase64.decrypt(encryptedAesKey, KeyType.PrivateKey);\n    String decryptedAesKey = new String(decryptedAesKeyBytes);\n\n    // 5. 用解密后的 AES 密钥解密 JSON 数据\n    AES decryptedAes = SecureUtil.aes(decryptedAesKey.getBytes());\n    String decryptedJsonString = decryptedAes.decryptStr(encryptedHex);\n\n    log.info(\"********************测试数据*************************\");\n    log.info(\"Public Key (Base64): {}\", publicKeyBase64);\n    log.info(\"Private Key (Base64): {}\", privateKeyBase64);\n    log.info(\"Encrypted Hex: {}\", encryptedHex);\n    log.info(\"Decrypted JSON String: {}\", decryptedJsonString);\n}\n```\n![17334951277141733495127306.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17334951277141733495127306.png)\n","slug":"encrypt","published":1,"updated":"2025-10-20T08:45:19.827Z","_id":"cmfw4z0a7001fuomw0o9n6s58","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Encrypt\"><a href=\"#Encrypt\" class=\"headerlink\" title=\"Encrypt\"></a>Encrypt</h1><h2 id=\"3种加密类型\"><a href=\"#3种加密类型\" class=\"headerlink\" title=\"3种加密类型\"></a>3种加密类型</h2><h3 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h3><ul>\n<li>不安全,容易被破解, 因为没用采用秘钥的方式, 但是执行效率快</li>\n<li>比如: MD5  Sha56  Base64</li>\n</ul>\n<h3 id=\"对称加密算法\"><a href=\"#对称加密算法\" class=\"headerlink\" title=\"对称加密算法\"></a>对称加密算法</h3><ul>\n<li>较安全, 因为采用的是单秘钥的方式, 一把秘钥同时支持加密解密, 执行效率中等</li>\n<li>比如: AES  DES</li>\n</ul>\n<h3 id=\"非对称加密算法\"><a href=\"#非对称加密算法\" class=\"headerlink\" title=\"非对称加密算法\"></a>非对称加密算法</h3><ul>\n<li>很安全, 因为采用的是公私钥结合的方式, 公钥加密, 私钥解密, 执行效率最慢</li>\n<li>比如: RSA<ul>\n<li>RSA密钥本质上是二进制数据,但二进制数据不方便: Base64编码将二进制数据转换成可打印的可读ASCII字符,便于处理和传输</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17334951657141733495165602.png\" alt=\"17334951657141733495165602.png\"></p>\n<h2 id=\"证书\"><a href=\"#证书\" class=\"headerlink\" title=\"证书\"></a>证书</h2><ul>\n<li>生成证书的过程，实际上是<strong>创建了一对 RSA 公钥和私钥</strong>，然后把它们存储在<strong>密钥库</strong>（keystore）中，比如：</li>\n<li><code>.jks</code>（Java Keystore，Java 使用的密钥库）</li>\n<li><code>.p12</code>（PKCS12 标准密钥库，兼容性更好）</li>\n<li><code>.pem</code>（开放标准的密钥格式）<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2></li>\n<li>采用了AES对称加密(单秘钥)和RSA非对称加密(公私钥)<ul>\n<li>先用AES秘钥加密请求体, 然后用RSA公钥加密AES秘钥, 放入请求头</li>\n</ul>\n</li>\n<li>好处: <ul>\n<li>双重加密, 不易被破解 </li>\n<li>要解密两次, 性能差<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 采用java.util和Hutool工具包</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encryptJson</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Log</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LogFactory.get();</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;*******************加密中****************************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 生成 RSA 公钥和私钥（Base64 编码）</span></span><br><span class=\"line\">    <span class=\"type\">RSA</span> <span class=\"variable\">rsa</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RSA</span>();</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">privateKeyBase64</span> <span class=\"operator\">=</span> rsa.getPrivateKeyBase64();</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">publicKeyBase64</span> <span class=\"operator\">=</span> rsa.getPublicKeyBase64();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 Base64 字符串还原为 Key 对象 -&gt; 枚举</span></span><br><span class=\"line\">    <span class=\"type\">RSA</span> <span class=\"variable\">rsaFromBase64</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RSA</span>(privateKeyBase64, publicKeyBase64);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 公钥加密 AES 密钥</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">aesKey</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;1234567890abcdef&quot;</span>; <span class=\"comment\">// 固定一个 16 字节的字符串作为 AES 密钥</span></span><br><span class=\"line\">    <span class=\"type\">byte</span>[] encryptedAesKey = rsaFromBase64.encrypt(aesKey.getBytes(), KeyType.PublicKey);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 用 AES 密钥加密 JSON 字符串</span></span><br><span class=\"line\">    <span class=\"type\">AES</span> <span class=\"variable\">aes</span> <span class=\"operator\">=</span> SecureUtil.aes(aesKey.getBytes()); <span class=\"comment\">// 使用 AES 密钥初始化 AES 实例</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">encryptedHex</span> <span class=\"operator\">=</span> aes.encryptHex(<span class=\"string\">&quot;Im JsonString&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;********************解密中*************************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. 私钥解密 AES 密钥</span></span><br><span class=\"line\">    <span class=\"type\">byte</span>[] decryptedAesKeyBytes = rsaFromBase64.decrypt(encryptedAesKey, KeyType.PrivateKey);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">decryptedAesKey</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(decryptedAesKeyBytes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 5. 用解密后的 AES 密钥解密 JSON 数据</span></span><br><span class=\"line\">    <span class=\"type\">AES</span> <span class=\"variable\">decryptedAes</span> <span class=\"operator\">=</span> SecureUtil.aes(decryptedAesKey.getBytes());</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">decryptedJsonString</span> <span class=\"operator\">=</span> decryptedAes.decryptStr(encryptedHex);</span><br><span class=\"line\"></span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;********************测试数据*************************&quot;</span>);</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;Public Key (Base64): &#123;&#125;&quot;</span>, publicKeyBase64);</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;Private Key (Base64): &#123;&#125;&quot;</span>, privateKeyBase64);</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;Encrypted Hex: &#123;&#125;&quot;</span>, encryptedHex);</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;Decrypted JSON String: &#123;&#125;&quot;</span>, decryptedJsonString);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17334951277141733495127306.png\" alt=\"17334951277141733495127306.png\"></li>\n</ul>\n</li>\n</ul>\n","cover":"/img/2.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Encrypt\"><a href=\"#Encrypt\" class=\"headerlink\" title=\"Encrypt\"></a>Encrypt</h1><h2 id=\"3种加密类型\"><a href=\"#3种加密类型\" class=\"headerlink\" title=\"3种加密类型\"></a>3种加密类型</h2><h3 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h3><ul>\n<li>不安全,容易被破解, 因为没用采用秘钥的方式, 但是执行效率快</li>\n<li>比如: MD5  Sha56  Base64</li>\n</ul>\n<h3 id=\"对称加密算法\"><a href=\"#对称加密算法\" class=\"headerlink\" title=\"对称加密算法\"></a>对称加密算法</h3><ul>\n<li>较安全, 因为采用的是单秘钥的方式, 一把秘钥同时支持加密解密, 执行效率中等</li>\n<li>比如: AES  DES</li>\n</ul>\n<h3 id=\"非对称加密算法\"><a href=\"#非对称加密算法\" class=\"headerlink\" title=\"非对称加密算法\"></a>非对称加密算法</h3><ul>\n<li>很安全, 因为采用的是公私钥结合的方式, 公钥加密, 私钥解密, 执行效率最慢</li>\n<li>比如: RSA<ul>\n<li>RSA密钥本质上是二进制数据,但二进制数据不方便: Base64编码将二进制数据转换成可打印的可读ASCII字符,便于处理和传输</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17334951657141733495165602.png\" alt=\"17334951657141733495165602.png\"></p>\n<h2 id=\"证书\"><a href=\"#证书\" class=\"headerlink\" title=\"证书\"></a>证书</h2><ul>\n<li>生成证书的过程，实际上是<strong>创建了一对 RSA 公钥和私钥</strong>，然后把它们存储在<strong>密钥库</strong>（keystore）中，比如：</li>\n<li><code>.jks</code>（Java Keystore，Java 使用的密钥库）</li>\n<li><code>.p12</code>（PKCS12 标准密钥库，兼容性更好）</li>\n<li><code>.pem</code>（开放标准的密钥格式）<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2></li>\n<li>采用了AES对称加密(单秘钥)和RSA非对称加密(公私钥)<ul>\n<li>先用AES秘钥加密请求体, 然后用RSA公钥加密AES秘钥, 放入请求头</li>\n</ul>\n</li>\n<li>好处: <ul>\n<li>双重加密, 不易被破解 </li>\n<li>要解密两次, 性能差<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 采用java.util和Hutool工具包</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encryptJson</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Log</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LogFactory.get();</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;*******************加密中****************************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1. 生成 RSA 公钥和私钥（Base64 编码）</span></span><br><span class=\"line\">    <span class=\"type\">RSA</span> <span class=\"variable\">rsa</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RSA</span>();</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">privateKeyBase64</span> <span class=\"operator\">=</span> rsa.getPrivateKeyBase64();</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">publicKeyBase64</span> <span class=\"operator\">=</span> rsa.getPublicKeyBase64();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将 Base64 字符串还原为 Key 对象 -&gt; 枚举</span></span><br><span class=\"line\">    <span class=\"type\">RSA</span> <span class=\"variable\">rsaFromBase64</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RSA</span>(privateKeyBase64, publicKeyBase64);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 公钥加密 AES 密钥</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">aesKey</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;1234567890abcdef&quot;</span>; <span class=\"comment\">// 固定一个 16 字节的字符串作为 AES 密钥</span></span><br><span class=\"line\">    <span class=\"type\">byte</span>[] encryptedAesKey = rsaFromBase64.encrypt(aesKey.getBytes(), KeyType.PublicKey);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 用 AES 密钥加密 JSON 字符串</span></span><br><span class=\"line\">    <span class=\"type\">AES</span> <span class=\"variable\">aes</span> <span class=\"operator\">=</span> SecureUtil.aes(aesKey.getBytes()); <span class=\"comment\">// 使用 AES 密钥初始化 AES 实例</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">encryptedHex</span> <span class=\"operator\">=</span> aes.encryptHex(<span class=\"string\">&quot;Im JsonString&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;********************解密中*************************&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. 私钥解密 AES 密钥</span></span><br><span class=\"line\">    <span class=\"type\">byte</span>[] decryptedAesKeyBytes = rsaFromBase64.decrypt(encryptedAesKey, KeyType.PrivateKey);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">decryptedAesKey</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(decryptedAesKeyBytes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 5. 用解密后的 AES 密钥解密 JSON 数据</span></span><br><span class=\"line\">    <span class=\"type\">AES</span> <span class=\"variable\">decryptedAes</span> <span class=\"operator\">=</span> SecureUtil.aes(decryptedAesKey.getBytes());</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">decryptedJsonString</span> <span class=\"operator\">=</span> decryptedAes.decryptStr(encryptedHex);</span><br><span class=\"line\"></span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;********************测试数据*************************&quot;</span>);</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;Public Key (Base64): &#123;&#125;&quot;</span>, publicKeyBase64);</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;Private Key (Base64): &#123;&#125;&quot;</span>, privateKeyBase64);</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;Encrypted Hex: &#123;&#125;&quot;</span>, encryptedHex);</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;Decrypted JSON String: &#123;&#125;&quot;</span>, decryptedJsonString);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17334951277141733495127306.png\" alt=\"17334951277141733495127306.png\"></li>\n</ul>\n</li>\n</ul>\n"},{"title":"前后端联调","date":"2024-10-30T07:52:02.000Z","_content":"\n> 🥲假如我们分手的话，绝不是出于我的意思，要知道，树是不愿离开花的，是花离开树          —— 大仲马\n\n# 解决联调发生的各种问题\n\n## 联调前的分析\n- 前端给后端的请求数据一般常用的有两种方式: \n\t- form表单: application/x-www-form-urlencoded\n\t- json字符串: application/json\n- 而后端给前端的响应数据, 根据RestFul API风格只有一种: json字符串\n```java\n// 前端实体数据\ncode: 200,\ndata: {\n    tableData: [\n        {\n            date: \"1962-06-22\",\n            name: \"周星驰\",\n            action: \"演员\",\n            address: \"大话西游\",\n        },\n        {\n            date: \"1963-06-23\",\n            name: \"刘慈欣\",\n            action: \"作家\",\n            address: \"三体\",\n        },\n        { \n            date: \"1881-09-25\",\n            name: \"鲁迅\",\n            action: \"作家\",\n            address: \"孔乙己\",\n        },\n        {\n            date: \"1960-04-03\",\n            name: \"余华\",\n            action: \"作家\",\n            address: \"活着\",\n        },\n    ],\n},\n```\n\n### 分析数据组成:\n\n1.是否符合统一响应格式**Result**\n\n```java\npublic class Result {\n    private Integer code;\n    private String message;\n    private Object data;\n}\n```\n\n2.判断是否嵌套:如果有多层嵌套建议先剥橘子(从里到外)\n\n3.判断字段数量和类型(一 一对应,用封装对象来包裹)\n\n```java\nclass tableData {\n    String name;\n    String data;\n    String action;\n    String address;\n}\n```\n\n4.设置响应体类型参数,将对象转化成 Json 字符串\n\n```java\nresponse.setContentType(\"application/json;charset=UTF-8\");\nlist.add(new tableData(\"周润发\", \"2024-10-29\", \"演员\", \"赌场\"));\nlist.add(new tableData(\"周星驰\", \"2024-10-29\", \"演员\", \"大话西游\"));\n\n方式一: 谷歌Gson\nGson gson = new Gson();\ngson.toJson(list);\n\n方式二: jackJson(spring默认)\nObjectMapper jackJson = new ObjectMapper;\njackJson.writeValueAsString(list);\n\n方式三: fastJson\nJSONObject.toJSONString(list);\n```\n\n## HTTP请求的两种方式\n\n### 1.原始Servlet\n\n```xml\n<!--xml配置文件--> \n<servlet>\n    <servlet-name>testServlet</servlet-name>\n    <servlet-class>com.example.demo.testServlet</servlet-class> <!--类路径--> \n</servlet>\n\n<servlet-mapping>\n    <servlet-name>testServlet</servlet-name>\n    <url-pattern>/home/getTableData</url-pattern>\t\t<!--请求参数--> \n</servlet-mapping>\n```\n\n```java\n// 通过继承HttpServlet重写GenericServlet的两方法,最后由Servlet接口实例调用service方法交由Tomcat发起HTTP请求响应\npublic class testServlet extends HttpServlet {\n    @Override\n    void doGet(HttpServletRequest req, HttpServletResponse resp) {\n        // 处理Get请求的逻辑\n    }\n    @Override\n    void doPost(HttpServletRequest req, HttpServletResponse resp) {\n        // 处理Post请求的逻辑\n    }\n}\n```\n\n### 2.springBoot Web容器\n\n- Spring-Boot: 内嵌Tomcat容器 + Servlet\n\n```java\n@CrossOrigin\n@RequestMapping\n@RestController\npublic class testController {\n\n    @GetMapping(\"/home/getTableData\")\n    public Result getTableData() throws Exception {\n        System.out.println(\"testController\");\n\n        List<tableData> list = new ArrayList<>();\n        list.add(new tableData(\"周润发\", \"2024-10-29\", \"演员\", \"赌场\"));\n        list.add(new tableData(\"周星驰\", \"2024-10-29\", \"演员\", \"大话西游\"));\n\n        Gson gson = new Gson();\n        return Result.success(gson.toJson(list));\n    }\n}\t\n```\n\n### 3.解决跨域问题\n- 什么是跨域\n\t- 通俗来说就是端对端访问了不同的 **协议 地址 端口 路径** 的其中一种\n- 解决方式: \n\t- ​对于spring-Boot项目来说,只需要加一个注解 **@CrossOrigin**\n\t- 或者全局加一个过滤器添加请求头参数\n\t- ​如果是部署在Nginx上的话可以添加请求头参数\n  ```nginx\n  add_header Access-Control-Allow-Origin *;  # CORS 设置 跨域问题\n  add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n  add_header Access-Control-Allow-Headers 'Origin, Content-Type, Accept';\n  ```\n## 分析Json\n\n```java\n// 原始的Json格式: 都是字符串 最外层data用的是一个数组   \n{\n    \"code\": 200,\n    \"message\": \"success\",\n    \"data\": \"[{\\\"name\\\":\\\"周润发\\\",\\\"data\\\":\\\"2024-10-29\\\",\\\"action\\\":\\\"演员\\\",\\\"address\\\":\\\"赌场\\\"},{\\\"name\\\":\\\"周星驰\\\",\\\"data\\\":\\\"2024-10-29\\\",\\\"action\\\":\\\"演员\\\",\\\"address\\\":\\\"大话西游\\\"}]\"\n```\n\n- 前端拿到数据应该对数据进行Json解析\n\n- 但是像 Axios 这样的库时，它会自动将返回的 JSON 数据解析为 JavaScript 对象\n\n- 前端内置的fetch就不行,需要手动parse, 但若是axios就不需要手动JSON.parse转换\n\n## 前后端联调会测试1.0\n\n#### 前端\n\n- 创建请求实例:设置默认url和headers\n\n```javascript\n// 创建 axios 实例\nconst axiosInstance = axios.create({\n  baseURL: \"https://localhost:5173\", // 请求的基础URL:不写baseURL默认请求本地\n  timeout: 1000, // 请求超时时间\n  headers: {\n    \"Content-Type\": \"application/json\", // 全局设置请求数据格式JSON\n  },\n});\n```\n\n单独设置实例调用Api方法(区分请求方式) \n\n```javascript\ngetTableData(params) {\n    return request({\n      url: \"/api/home/getTableData/${params.id}\",\n      method: \"get\",\n      params: params,\n    });\n  },\n```\n\n\n\n- 在原本axios实例的基础上, 对受到的数据进行拦截 并进行JSON格式的解析\n\n```javascript\n// 添加响应拦截器\naxiosInstance.interceptors.response.use((response) => {\n  // 像 Axios 这样的库时，它会自动将返回的 JSON 数据解析为 JavaScript 对象\n  const { code, data, msg } = response.data.data; \n  if (response.data.code === 200) {\n    return response.data.data; // 只返回data\n  } else {\n    ElMessage.error(msg || NETWORK_ERROR);\n    return Promise.reject(msg || NETWORK_ERROR);\n  }\n});\n```\n\n- 对拿到的数据进行渲染 \n\n```vue\n<el-card shadow=\"hover\" class=\"userTable\">\n    <el-table :data=\"tableData\" size=\"small\" border>\n        <el-table-column prop=\"date\" label=\"生日\" />\n        <el-table-column prop=\"name\" label=\"名字\" />\n        <el-table-column prop=\"action\" label=\"身份\" />\n        <el-table-column prop=\"address\" label=\"代表作\" />\n    </el-table>\n</el-card>\n```\n\n#### Nginx\n\n```nginx\n// 对前端端口的代理\nworker_processes 1;\n\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/json;\n\n    server {\n        listen 5173;\n        server_name localhost;\n\n        location /api/home/getTableData {\n            proxy_pass http://localhost:8080/home/getTableData;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n\n            # 添加响应头\n            add_header Content-Type application/json;\n            add_header Access-Control-Allow-Origin *;  # CORS 设置 跨域问题\n            add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n            add_header Access-Control-Allow-Headers 'Origin, Content-Type, Accept';\n        }\n    }\n}\n\n\n\n```\n\n#### 后端\n\n```java\n@RequestMapping\n@RestController\n@CrossOrigin(cros = \"前端地址\")\npublic class testController {\n    @GetMapping(\"/home/getTableData\")\n    public Result getTableData() throws Exception {\n        System.out.println(\"testController\");\n\n        List<tableData> list = new ArrayList<>();\n        list.add(new tableData(\"周星驰\", \"1962-06-22\", \"演员\", \"大话西游\"));\n        list.add(new tableData(\"刘慈欣\", \"1963-06-23\", \"作家\", \"三体\"));\n        list.add(new tableData(\"鲁迅\", \"1881-09-25\", \"作家\", \"孔乙己\"));\n        list.add(new tableData(\"余华\", \"1960-04-03\", \"作家\", \"活着\"));\n        Gson gson = new Gson();\n        return Result.success(gson.toJson(list));\n\n    }\n```\n\n## 前后端联调会测试2.0\n\n- 每次要发起请求之前先测试  👍\n\n![好习惯](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17312441657891731244165185.png)\n\n\n\n#### 前端\n\n- **前端会传page为1的原因: 这个1为视图层面上的第一页**\n- **而在数据库层面, 要通过计算得到跳过的条数: (page-1) * pageSize**\n\n```javascript\n// 调用axios方法发起请求\nconst data = await instance.proxy.$api.getUserData(config);\ntableData.value = data.list || [];\nconfig.total = data.count; //总条数\n\n// 请求数据的参数 用对象封装\nconst config = reactive({\n    total: 0, // 总条数  因为不知道会不会走条件查询,所有每次请求都要带上\n    page: 1,  // 当前页码\n    name: \"\", // 查询字段...\n    age ...\n});\n\nconst tableLabel = reactive([\t// 指向性实体类\n    {\n        prop: \"name\",\n        label: \"姓名\",\n    },\n    {\n        prop: \"age\",\n        label: \"年龄\",\n    },\n    {\n        prop: \"sexLabel\",\n        label: \"性别\",\n    },\n    {\n        prop: \"birth\",\n        label: \"出生日期\",\n        width: 200,\n    },\n    {\n        prop: \"addr\",\n        label: \"地址\",\n        width: 200,\n    },\n]);\n<template>\n    <el-table\n:data=\"tableDataObject\"\t// 对象绑定\n>\n    <el-table-column\nv-for=\"item in tableLabel\"\t// 高明手段: 不用逐个 prop=\"name\" \n:key=\"item.prop\"\t// 嵌套循环\n:prop=\"item.prop\"\n:label=\"item.label\"\t // label表头\n/>\n    ...\n```\n\n```javascript\n// 1.为什么要挂载: 不挂载的函数不会执行\n// 2.钩子中执行的代码可以确保组件的 DOM 元素已经可用，从而允许进行数据加载和其他操作。\n// 3.自动挂载：当你在 Vue 组件中定义 setup 函数时，Vue 会自动处理组件的挂载过程。当组件被渲染并添加到 DOM 中时，Vue会自动调用onMounted钩子。\n// 4.在组件挂载后调用 fetchData\nonMounted(() => {\n  getUserDataMethod();  // 每次页面渲染执行第一页数据的查询 默认page=1 pageSize=10\n});\n```\n\n\n\n#### 后端\n\n- Mybatis(pageHelp+xml映射文件)和MybatisPlus(自带插件+warpper)\n\n```java\n@GetMapping(\"/user/getUserData\")\n    public Result getUserData(@RequestParam(defaultValue = \"1\") int page,\t\n                              @RequestParam(defaultValue = \"5\") int limit,\t// 每页展示数,前端没传,默认10\n                              @RequestParam String name...\t\t// 模糊匹配,范围查询,排序字段\n    )\n```\n\n```java\n// 返回VO \npublic class pageVO<T> {\n    private Long Total; // 总条数\n    private Long pages; // 总页数,看前端要求\n    private List<T> list; // 结果列表\n}\n```\n\n```java\n// DTO: 中间数据传递\t这个Page是mp自带的 有排序器 也可作为链式编程的容器 lambdaQuery().Page(page); \npublic class Page<T> implements IPage<T> {\n    private static final long serialVersionUID = 8545996863226528798L;\n    protected List<T> records;\n    protected long total;\n    protected long size;\n    protected long current;\n    protected List<OrderItem> orders;\n    protected boolean optimizeCountSql;\n    protected boolean searchCount;\n    protected boolean optimizeJoinOfCountSql;\n    protected String countId;\n    protected Long maxLimit;\n}\n```\n\n","source":"_posts/frontEnd.md","raw":"---\ntitle: 前后端联调\ndate: 2024-10-30 15:52:02\ntags:\n  - Web\n  - Servlet\n  - CORS\ncategories: 编程\n---\n\n> 🥲假如我们分手的话，绝不是出于我的意思，要知道，树是不愿离开花的，是花离开树          —— 大仲马\n\n# 解决联调发生的各种问题\n\n## 联调前的分析\n- 前端给后端的请求数据一般常用的有两种方式: \n\t- form表单: application/x-www-form-urlencoded\n\t- json字符串: application/json\n- 而后端给前端的响应数据, 根据RestFul API风格只有一种: json字符串\n```java\n// 前端实体数据\ncode: 200,\ndata: {\n    tableData: [\n        {\n            date: \"1962-06-22\",\n            name: \"周星驰\",\n            action: \"演员\",\n            address: \"大话西游\",\n        },\n        {\n            date: \"1963-06-23\",\n            name: \"刘慈欣\",\n            action: \"作家\",\n            address: \"三体\",\n        },\n        { \n            date: \"1881-09-25\",\n            name: \"鲁迅\",\n            action: \"作家\",\n            address: \"孔乙己\",\n        },\n        {\n            date: \"1960-04-03\",\n            name: \"余华\",\n            action: \"作家\",\n            address: \"活着\",\n        },\n    ],\n},\n```\n\n### 分析数据组成:\n\n1.是否符合统一响应格式**Result**\n\n```java\npublic class Result {\n    private Integer code;\n    private String message;\n    private Object data;\n}\n```\n\n2.判断是否嵌套:如果有多层嵌套建议先剥橘子(从里到外)\n\n3.判断字段数量和类型(一 一对应,用封装对象来包裹)\n\n```java\nclass tableData {\n    String name;\n    String data;\n    String action;\n    String address;\n}\n```\n\n4.设置响应体类型参数,将对象转化成 Json 字符串\n\n```java\nresponse.setContentType(\"application/json;charset=UTF-8\");\nlist.add(new tableData(\"周润发\", \"2024-10-29\", \"演员\", \"赌场\"));\nlist.add(new tableData(\"周星驰\", \"2024-10-29\", \"演员\", \"大话西游\"));\n\n方式一: 谷歌Gson\nGson gson = new Gson();\ngson.toJson(list);\n\n方式二: jackJson(spring默认)\nObjectMapper jackJson = new ObjectMapper;\njackJson.writeValueAsString(list);\n\n方式三: fastJson\nJSONObject.toJSONString(list);\n```\n\n## HTTP请求的两种方式\n\n### 1.原始Servlet\n\n```xml\n<!--xml配置文件--> \n<servlet>\n    <servlet-name>testServlet</servlet-name>\n    <servlet-class>com.example.demo.testServlet</servlet-class> <!--类路径--> \n</servlet>\n\n<servlet-mapping>\n    <servlet-name>testServlet</servlet-name>\n    <url-pattern>/home/getTableData</url-pattern>\t\t<!--请求参数--> \n</servlet-mapping>\n```\n\n```java\n// 通过继承HttpServlet重写GenericServlet的两方法,最后由Servlet接口实例调用service方法交由Tomcat发起HTTP请求响应\npublic class testServlet extends HttpServlet {\n    @Override\n    void doGet(HttpServletRequest req, HttpServletResponse resp) {\n        // 处理Get请求的逻辑\n    }\n    @Override\n    void doPost(HttpServletRequest req, HttpServletResponse resp) {\n        // 处理Post请求的逻辑\n    }\n}\n```\n\n### 2.springBoot Web容器\n\n- Spring-Boot: 内嵌Tomcat容器 + Servlet\n\n```java\n@CrossOrigin\n@RequestMapping\n@RestController\npublic class testController {\n\n    @GetMapping(\"/home/getTableData\")\n    public Result getTableData() throws Exception {\n        System.out.println(\"testController\");\n\n        List<tableData> list = new ArrayList<>();\n        list.add(new tableData(\"周润发\", \"2024-10-29\", \"演员\", \"赌场\"));\n        list.add(new tableData(\"周星驰\", \"2024-10-29\", \"演员\", \"大话西游\"));\n\n        Gson gson = new Gson();\n        return Result.success(gson.toJson(list));\n    }\n}\t\n```\n\n### 3.解决跨域问题\n- 什么是跨域\n\t- 通俗来说就是端对端访问了不同的 **协议 地址 端口 路径** 的其中一种\n- 解决方式: \n\t- ​对于spring-Boot项目来说,只需要加一个注解 **@CrossOrigin**\n\t- 或者全局加一个过滤器添加请求头参数\n\t- ​如果是部署在Nginx上的话可以添加请求头参数\n  ```nginx\n  add_header Access-Control-Allow-Origin *;  # CORS 设置 跨域问题\n  add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n  add_header Access-Control-Allow-Headers 'Origin, Content-Type, Accept';\n  ```\n## 分析Json\n\n```java\n// 原始的Json格式: 都是字符串 最外层data用的是一个数组   \n{\n    \"code\": 200,\n    \"message\": \"success\",\n    \"data\": \"[{\\\"name\\\":\\\"周润发\\\",\\\"data\\\":\\\"2024-10-29\\\",\\\"action\\\":\\\"演员\\\",\\\"address\\\":\\\"赌场\\\"},{\\\"name\\\":\\\"周星驰\\\",\\\"data\\\":\\\"2024-10-29\\\",\\\"action\\\":\\\"演员\\\",\\\"address\\\":\\\"大话西游\\\"}]\"\n```\n\n- 前端拿到数据应该对数据进行Json解析\n\n- 但是像 Axios 这样的库时，它会自动将返回的 JSON 数据解析为 JavaScript 对象\n\n- 前端内置的fetch就不行,需要手动parse, 但若是axios就不需要手动JSON.parse转换\n\n## 前后端联调会测试1.0\n\n#### 前端\n\n- 创建请求实例:设置默认url和headers\n\n```javascript\n// 创建 axios 实例\nconst axiosInstance = axios.create({\n  baseURL: \"https://localhost:5173\", // 请求的基础URL:不写baseURL默认请求本地\n  timeout: 1000, // 请求超时时间\n  headers: {\n    \"Content-Type\": \"application/json\", // 全局设置请求数据格式JSON\n  },\n});\n```\n\n单独设置实例调用Api方法(区分请求方式) \n\n```javascript\ngetTableData(params) {\n    return request({\n      url: \"/api/home/getTableData/${params.id}\",\n      method: \"get\",\n      params: params,\n    });\n  },\n```\n\n\n\n- 在原本axios实例的基础上, 对受到的数据进行拦截 并进行JSON格式的解析\n\n```javascript\n// 添加响应拦截器\naxiosInstance.interceptors.response.use((response) => {\n  // 像 Axios 这样的库时，它会自动将返回的 JSON 数据解析为 JavaScript 对象\n  const { code, data, msg } = response.data.data; \n  if (response.data.code === 200) {\n    return response.data.data; // 只返回data\n  } else {\n    ElMessage.error(msg || NETWORK_ERROR);\n    return Promise.reject(msg || NETWORK_ERROR);\n  }\n});\n```\n\n- 对拿到的数据进行渲染 \n\n```vue\n<el-card shadow=\"hover\" class=\"userTable\">\n    <el-table :data=\"tableData\" size=\"small\" border>\n        <el-table-column prop=\"date\" label=\"生日\" />\n        <el-table-column prop=\"name\" label=\"名字\" />\n        <el-table-column prop=\"action\" label=\"身份\" />\n        <el-table-column prop=\"address\" label=\"代表作\" />\n    </el-table>\n</el-card>\n```\n\n#### Nginx\n\n```nginx\n// 对前端端口的代理\nworker_processes 1;\n\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/json;\n\n    server {\n        listen 5173;\n        server_name localhost;\n\n        location /api/home/getTableData {\n            proxy_pass http://localhost:8080/home/getTableData;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n\n            # 添加响应头\n            add_header Content-Type application/json;\n            add_header Access-Control-Allow-Origin *;  # CORS 设置 跨域问题\n            add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n            add_header Access-Control-Allow-Headers 'Origin, Content-Type, Accept';\n        }\n    }\n}\n\n\n\n```\n\n#### 后端\n\n```java\n@RequestMapping\n@RestController\n@CrossOrigin(cros = \"前端地址\")\npublic class testController {\n    @GetMapping(\"/home/getTableData\")\n    public Result getTableData() throws Exception {\n        System.out.println(\"testController\");\n\n        List<tableData> list = new ArrayList<>();\n        list.add(new tableData(\"周星驰\", \"1962-06-22\", \"演员\", \"大话西游\"));\n        list.add(new tableData(\"刘慈欣\", \"1963-06-23\", \"作家\", \"三体\"));\n        list.add(new tableData(\"鲁迅\", \"1881-09-25\", \"作家\", \"孔乙己\"));\n        list.add(new tableData(\"余华\", \"1960-04-03\", \"作家\", \"活着\"));\n        Gson gson = new Gson();\n        return Result.success(gson.toJson(list));\n\n    }\n```\n\n## 前后端联调会测试2.0\n\n- 每次要发起请求之前先测试  👍\n\n![好习惯](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17312441657891731244165185.png)\n\n\n\n#### 前端\n\n- **前端会传page为1的原因: 这个1为视图层面上的第一页**\n- **而在数据库层面, 要通过计算得到跳过的条数: (page-1) * pageSize**\n\n```javascript\n// 调用axios方法发起请求\nconst data = await instance.proxy.$api.getUserData(config);\ntableData.value = data.list || [];\nconfig.total = data.count; //总条数\n\n// 请求数据的参数 用对象封装\nconst config = reactive({\n    total: 0, // 总条数  因为不知道会不会走条件查询,所有每次请求都要带上\n    page: 1,  // 当前页码\n    name: \"\", // 查询字段...\n    age ...\n});\n\nconst tableLabel = reactive([\t// 指向性实体类\n    {\n        prop: \"name\",\n        label: \"姓名\",\n    },\n    {\n        prop: \"age\",\n        label: \"年龄\",\n    },\n    {\n        prop: \"sexLabel\",\n        label: \"性别\",\n    },\n    {\n        prop: \"birth\",\n        label: \"出生日期\",\n        width: 200,\n    },\n    {\n        prop: \"addr\",\n        label: \"地址\",\n        width: 200,\n    },\n]);\n<template>\n    <el-table\n:data=\"tableDataObject\"\t// 对象绑定\n>\n    <el-table-column\nv-for=\"item in tableLabel\"\t// 高明手段: 不用逐个 prop=\"name\" \n:key=\"item.prop\"\t// 嵌套循环\n:prop=\"item.prop\"\n:label=\"item.label\"\t // label表头\n/>\n    ...\n```\n\n```javascript\n// 1.为什么要挂载: 不挂载的函数不会执行\n// 2.钩子中执行的代码可以确保组件的 DOM 元素已经可用，从而允许进行数据加载和其他操作。\n// 3.自动挂载：当你在 Vue 组件中定义 setup 函数时，Vue 会自动处理组件的挂载过程。当组件被渲染并添加到 DOM 中时，Vue会自动调用onMounted钩子。\n// 4.在组件挂载后调用 fetchData\nonMounted(() => {\n  getUserDataMethod();  // 每次页面渲染执行第一页数据的查询 默认page=1 pageSize=10\n});\n```\n\n\n\n#### 后端\n\n- Mybatis(pageHelp+xml映射文件)和MybatisPlus(自带插件+warpper)\n\n```java\n@GetMapping(\"/user/getUserData\")\n    public Result getUserData(@RequestParam(defaultValue = \"1\") int page,\t\n                              @RequestParam(defaultValue = \"5\") int limit,\t// 每页展示数,前端没传,默认10\n                              @RequestParam String name...\t\t// 模糊匹配,范围查询,排序字段\n    )\n```\n\n```java\n// 返回VO \npublic class pageVO<T> {\n    private Long Total; // 总条数\n    private Long pages; // 总页数,看前端要求\n    private List<T> list; // 结果列表\n}\n```\n\n```java\n// DTO: 中间数据传递\t这个Page是mp自带的 有排序器 也可作为链式编程的容器 lambdaQuery().Page(page); \npublic class Page<T> implements IPage<T> {\n    private static final long serialVersionUID = 8545996863226528798L;\n    protected List<T> records;\n    protected long total;\n    protected long size;\n    protected long current;\n    protected List<OrderItem> orders;\n    protected boolean optimizeCountSql;\n    protected boolean searchCount;\n    protected boolean optimizeJoinOfCountSql;\n    protected String countId;\n    protected Long maxLimit;\n}\n```\n\n","slug":"frontEnd","published":1,"updated":"2025-10-14T11:29:04.270Z","_id":"cmfw4z0aa001iuomw0lkgefxm","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>🥲假如我们分手的话，绝不是出于我的意思，要知道，树是不愿离开花的，是花离开树          —— 大仲马</p>\n</blockquote>\n<h1 id=\"解决联调发生的各种问题\"><a href=\"#解决联调发生的各种问题\" class=\"headerlink\" title=\"解决联调发生的各种问题\"></a>解决联调发生的各种问题</h1><h2 id=\"联调前的分析\"><a href=\"#联调前的分析\" class=\"headerlink\" title=\"联调前的分析\"></a>联调前的分析</h2><ul>\n<li>前端给后端的请求数据一般常用的有两种方式: <ul>\n<li>form表单: application/x-www-form-urlencoded</li>\n<li>json字符串: application/json</li>\n</ul>\n</li>\n<li>而后端给前端的响应数据, 根据RestFul API风格只有一种: json字符串<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 前端实体数据</span></span><br><span class=\"line\">code: <span class=\"number\">200</span>,</span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    tableData: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            date: <span class=\"string\">&quot;1962-06-22&quot;</span>,</span><br><span class=\"line\">            name: <span class=\"string\">&quot;周星驰&quot;</span>,</span><br><span class=\"line\">            action: <span class=\"string\">&quot;演员&quot;</span>,</span><br><span class=\"line\">            address: <span class=\"string\">&quot;大话西游&quot;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            date: <span class=\"string\">&quot;1963-06-23&quot;</span>,</span><br><span class=\"line\">            name: <span class=\"string\">&quot;刘慈欣&quot;</span>,</span><br><span class=\"line\">            action: <span class=\"string\">&quot;作家&quot;</span>,</span><br><span class=\"line\">            address: <span class=\"string\">&quot;三体&quot;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            date: <span class=\"string\">&quot;1881-09-25&quot;</span>,</span><br><span class=\"line\">            name: <span class=\"string\">&quot;鲁迅&quot;</span>,</span><br><span class=\"line\">            action: <span class=\"string\">&quot;作家&quot;</span>,</span><br><span class=\"line\">            address: <span class=\"string\">&quot;孔乙己&quot;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            date: <span class=\"string\">&quot;1960-04-03&quot;</span>,</span><br><span class=\"line\">            name: <span class=\"string\">&quot;余华&quot;</span>,</span><br><span class=\"line\">            action: <span class=\"string\">&quot;作家&quot;</span>,</span><br><span class=\"line\">            address: <span class=\"string\">&quot;活着&quot;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"分析数据组成\"><a href=\"#分析数据组成\" class=\"headerlink\" title=\"分析数据组成:\"></a>分析数据组成:</h3><p>1.是否符合统一响应格式<strong>Result</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Result</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer code;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String message;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.判断是否嵌套:如果有多层嵌套建议先剥橘子(从里到外)</p>\n<p>3.判断字段数量和类型(一 一对应,用封装对象来包裹)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">tableData</span> &#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    String data;</span><br><span class=\"line\">    String action;</span><br><span class=\"line\">    String address;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.设置响应体类型参数,将对象转化成 Json 字符串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;周润发&quot;</span>, <span class=\"string\">&quot;2024-10-29&quot;</span>, <span class=\"string\">&quot;演员&quot;</span>, <span class=\"string\">&quot;赌场&quot;</span>));</span><br><span class=\"line\">list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;周星驰&quot;</span>, <span class=\"string\">&quot;2024-10-29&quot;</span>, <span class=\"string\">&quot;演员&quot;</span>, <span class=\"string\">&quot;大话西游&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">方式一: 谷歌Gson</span><br><span class=\"line\"><span class=\"type\">Gson</span> <span class=\"variable\">gson</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>();</span><br><span class=\"line\">gson.toJson(list);</span><br><span class=\"line\"></span><br><span class=\"line\">方式二: jackJson(spring默认)</span><br><span class=\"line\"><span class=\"type\">ObjectMapper</span> <span class=\"variable\">jackJson</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>;</span><br><span class=\"line\">jackJson.writeValueAsString(list);</span><br><span class=\"line\"></span><br><span class=\"line\">方式三: fastJson</span><br><span class=\"line\">JSONObject.toJSONString(list);</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTTP请求的两种方式\"><a href=\"#HTTP请求的两种方式\" class=\"headerlink\" title=\"HTTP请求的两种方式\"></a>HTTP请求的两种方式</h2><h3 id=\"1-原始Servlet\"><a href=\"#1-原始Servlet\" class=\"headerlink\" title=\"1.原始Servlet\"></a>1.原始Servlet</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--xml配置文件--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.example.demo.testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> <span class=\"comment\">&lt;!--类路径--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/home/getTableData<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span>\t\t<span class=\"comment\">&lt;!--请求参数--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过继承HttpServlet重写GenericServlet的两方法,最后由Servlet接口实例调用service方法交由Tomcat发起HTTP请求响应</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理Get请求的逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">doPost</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理Post请求的逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-springBoot-Web容器\"><a href=\"#2-springBoot-Web容器\" class=\"headerlink\" title=\"2.springBoot Web容器\"></a>2.springBoot Web容器</h3><ul>\n<li>Spring-Boot: 内嵌Tomcat容器 + Servlet</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CrossOrigin</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/home/getTableData&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result <span class=\"title function_\">getTableData</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;testController&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;tableData&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;周润发&quot;</span>, <span class=\"string\">&quot;2024-10-29&quot;</span>, <span class=\"string\">&quot;演员&quot;</span>, <span class=\"string\">&quot;赌场&quot;</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;周星驰&quot;</span>, <span class=\"string\">&quot;2024-10-29&quot;</span>, <span class=\"string\">&quot;演员&quot;</span>, <span class=\"string\">&quot;大话西游&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Gson</span> <span class=\"variable\">gson</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.success(gson.toJson(list));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-解决跨域问题\"><a href=\"#3-解决跨域问题\" class=\"headerlink\" title=\"3.解决跨域问题\"></a>3.解决跨域问题</h3><ul>\n<li>什么是跨域<ul>\n<li>通俗来说就是端对端访问了不同的 <strong>协议 地址 端口 路径</strong> 的其中一种</li>\n</ul>\n</li>\n<li>解决方式: <ul>\n<li>​对于spring-Boot项目来说,只需要加一个注解 <strong>@CrossOrigin</strong></li>\n<li>或者全局加一个过滤器添加请求头参数</li>\n<li>​如果是部署在Nginx上的话可以添加请求头参数<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">add_header</span> Access-Control-Allow-Origin *;  <span class=\"comment\"># CORS 设置 跨域问题</span></span><br><span class=\"line\"><span class=\"attribute\">add_header</span> Access-Control-Allow-Methods <span class=\"string\">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class=\"line\"><span class=\"attribute\">add_header</span> Access-Control-Allow-Headers <span class=\"string\">&#x27;Origin, Content-Type, Accept&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分析Json\"><a href=\"#分析Json\" class=\"headerlink\" title=\"分析Json\"></a>分析Json</h2></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原始的Json格式: 都是字符串 最外层data用的是一个数组   </span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;code&quot;</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;success&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;data&quot;</span>: <span class=\"string\">&quot;[&#123;\\&quot;name\\&quot;:\\&quot;周润发\\&quot;,\\&quot;data\\&quot;:\\&quot;2024-10-29\\&quot;,\\&quot;action\\&quot;:\\&quot;演员\\&quot;,\\&quot;address\\&quot;:\\&quot;赌场\\&quot;&#125;,&#123;\\&quot;name\\&quot;:\\&quot;周星驰\\&quot;,\\&quot;data\\&quot;:\\&quot;2024-10-29\\&quot;,\\&quot;action\\&quot;:\\&quot;演员\\&quot;,\\&quot;address\\&quot;:\\&quot;大话西游\\&quot;&#125;]&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>前端拿到数据应该对数据进行Json解析</p>\n</li>\n<li><p>但是像 Axios 这样的库时，它会自动将返回的 JSON 数据解析为 JavaScript 对象</p>\n</li>\n<li><p>前端内置的fetch就不行,需要手动parse, 但若是axios就不需要手动JSON.parse转换</p>\n</li>\n</ul>\n<h2 id=\"前后端联调会测试1-0\"><a href=\"#前后端联调会测试1-0\" class=\"headerlink\" title=\"前后端联调会测试1.0\"></a>前后端联调会测试1.0</h2><h4 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h4><ul>\n<li>创建请求实例:设置默认url和headers</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 axios 实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> axiosInstance = axios.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">baseURL</span>: <span class=\"string\">&quot;https://localhost:5173&quot;</span>, <span class=\"comment\">// 请求的基础URL:不写baseURL默认请求本地</span></span><br><span class=\"line\">  <span class=\"attr\">timeout</span>: <span class=\"number\">1000</span>, <span class=\"comment\">// 请求超时时间</span></span><br><span class=\"line\">  <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Content-Type&quot;</span>: <span class=\"string\">&quot;application/json&quot;</span>, <span class=\"comment\">// 全局设置请求数据格式JSON</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>单独设置实例调用Api方法(区分请求方式) </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">getTableData</span>(<span class=\"params\">params</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">request</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: <span class=\"string\">&quot;/api/home/getTableData/$&#123;params.id&#125;&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">method</span>: <span class=\"string\">&quot;get&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">params</span>: params,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在原本axios实例的基础上, 对受到的数据进行拦截 并进行JSON格式的解析</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加响应拦截器</span></span><br><span class=\"line\">axiosInstance.<span class=\"property\">interceptors</span>.<span class=\"property\">response</span>.<span class=\"title function_\">use</span>(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 像 Axios 这样的库时，它会自动将返回的 JSON 数据解析为 JavaScript 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; code, data, msg &#125; = response.<span class=\"property\">data</span>.<span class=\"property\">data</span>; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (response.<span class=\"property\">data</span>.<span class=\"property\">code</span> === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.<span class=\"property\">data</span>.<span class=\"property\">data</span>; <span class=\"comment\">// 只返回data</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">error</span>(msg || <span class=\"variable constant_\">NETWORK_ERROR</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(msg || <span class=\"variable constant_\">NETWORK_ERROR</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对拿到的数据进行渲染 </li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-card shadow=&quot;hover&quot; class=&quot;userTable&quot;&gt;</span><br><span class=\"line\">    &lt;el-table :data=&quot;tableData&quot; size=&quot;small&quot; border&gt;</span><br><span class=\"line\">        &lt;el-table-column prop=&quot;date&quot; label=&quot;生日&quot; /&gt;</span><br><span class=\"line\">        &lt;el-table-column prop=&quot;name&quot; label=&quot;名字&quot; /&gt;</span><br><span class=\"line\">        &lt;el-table-column prop=&quot;action&quot; label=&quot;身份&quot; /&gt;</span><br><span class=\"line\">        &lt;el-table-column prop=&quot;address&quot; label=&quot;代表作&quot; /&gt;</span><br><span class=\"line\">    &lt;/el-table&gt;</span><br><span class=\"line\">&lt;/el-card&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h4><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对前端端口的代理</span><br><span class=\"line\"><span class=\"attribute\">worker_processes</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">events</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">worker_connections</span> <span class=\"number\">1024</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">http</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">include</span>       mime.types;</span><br><span class=\"line\">    <span class=\"attribute\">default_type</span>  application/json;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">listen</span> <span class=\"number\">5173</span>;</span><br><span class=\"line\">        <span class=\"attribute\">server_name</span> localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"section\">location</span> /api/home/getTableData &#123;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://localhost:8080/home/getTableData;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Proto <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 添加响应头</span></span><br><span class=\"line\">            <span class=\"attribute\">add_header</span> Content-Type application/json;</span><br><span class=\"line\">            <span class=\"attribute\">add_header</span> Access-Control-Allow-Origin *;  <span class=\"comment\"># CORS 设置 跨域问题</span></span><br><span class=\"line\">            <span class=\"attribute\">add_header</span> Access-Control-Allow-Methods <span class=\"string\">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class=\"line\">            <span class=\"attribute\">add_header</span> Access-Control-Allow-Headers <span class=\"string\">&#x27;Origin, Content-Type, Accept&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"后端\"><a href=\"#后端\" class=\"headerlink\" title=\"后端\"></a>后端</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@CrossOrigin(cros = &quot;前端地址&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/home/getTableData&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result <span class=\"title function_\">getTableData</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;testController&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;tableData&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;周星驰&quot;</span>, <span class=\"string\">&quot;1962-06-22&quot;</span>, <span class=\"string\">&quot;演员&quot;</span>, <span class=\"string\">&quot;大话西游&quot;</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;刘慈欣&quot;</span>, <span class=\"string\">&quot;1963-06-23&quot;</span>, <span class=\"string\">&quot;作家&quot;</span>, <span class=\"string\">&quot;三体&quot;</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;鲁迅&quot;</span>, <span class=\"string\">&quot;1881-09-25&quot;</span>, <span class=\"string\">&quot;作家&quot;</span>, <span class=\"string\">&quot;孔乙己&quot;</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;余华&quot;</span>, <span class=\"string\">&quot;1960-04-03&quot;</span>, <span class=\"string\">&quot;作家&quot;</span>, <span class=\"string\">&quot;活着&quot;</span>));</span><br><span class=\"line\">        <span class=\"type\">Gson</span> <span class=\"variable\">gson</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.success(gson.toJson(list));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前后端联调会测试2-0\"><a href=\"#前后端联调会测试2-0\" class=\"headerlink\" title=\"前后端联调会测试2.0\"></a>前后端联调会测试2.0</h2><ul>\n<li>每次要发起请求之前先测试  👍</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17312441657891731244165185.png\" alt=\"好习惯\"></p>\n<h4 id=\"前端-1\"><a href=\"#前端-1\" class=\"headerlink\" title=\"前端\"></a>前端</h4><ul>\n<li><strong>前端会传page为1的原因: 这个1为视图层面上的第一页</strong></li>\n<li><strong>而在数据库层面, 要通过计算得到跳过的条数: (page-1) * pageSize</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用axios方法发起请求</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> instance.<span class=\"property\">proxy</span>.<span class=\"property\">$api</span>.<span class=\"title function_\">getUserData</span>(config);</span><br><span class=\"line\">tableData.<span class=\"property\">value</span> = data.<span class=\"property\">list</span> || [];</span><br><span class=\"line\">config.<span class=\"property\">total</span> = data.<span class=\"property\">count</span>; <span class=\"comment\">//总条数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请求数据的参数 用对象封装</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = <span class=\"title function_\">reactive</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">total</span>: <span class=\"number\">0</span>, <span class=\"comment\">// 总条数  因为不知道会不会走条件查询,所有每次请求都要带上</span></span><br><span class=\"line\">    <span class=\"attr\">page</span>: <span class=\"number\">1</span>,  <span class=\"comment\">// 当前页码</span></span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;&quot;</span>, <span class=\"comment\">// 查询字段...</span></span><br><span class=\"line\">    age ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> tableLabel = <span class=\"title function_\">reactive</span>([\t<span class=\"comment\">// 指向性实体类</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">prop</span>: <span class=\"string\">&quot;name&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">label</span>: <span class=\"string\">&quot;姓名&quot;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">prop</span>: <span class=\"string\">&quot;age&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">label</span>: <span class=\"string\">&quot;年龄&quot;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">prop</span>: <span class=\"string\">&quot;sexLabel&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">label</span>: <span class=\"string\">&quot;性别&quot;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">prop</span>: <span class=\"string\">&quot;birth&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">label</span>: <span class=\"string\">&quot;出生日期&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">width</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">prop</span>: <span class=\"string\">&quot;addr&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">label</span>: <span class=\"string\">&quot;地址&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">width</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">]);</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">el-table</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\"><span class=\"attr\">:data</span>=<span class=\"string\">&quot;tableDataObject&quot;</span>\t// <span class=\"attr\">对象绑定</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">el-table-column</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\"><span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in tableLabel&quot;</span>\t// <span class=\"attr\">高明手段:</span> <span class=\"attr\">不用逐个</span> <span class=\"attr\">prop</span>=<span class=\"string\">&quot;name&quot;</span> </span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\"><span class=\"attr\">:key</span>=<span class=\"string\">&quot;item.prop&quot;</span>\t// <span class=\"attr\">嵌套循环</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\"><span class=\"attr\">:prop</span>=<span class=\"string\">&quot;item.prop&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\"><span class=\"attr\">:label</span>=<span class=\"string\">&quot;item.label&quot;</span>\t // <span class=\"attr\">label表头</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    ...</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.为什么要挂载: 不挂载的函数不会执行</span></span><br><span class=\"line\"><span class=\"comment\">// 2.钩子中执行的代码可以确保组件的 DOM 元素已经可用，从而允许进行数据加载和其他操作。</span></span><br><span class=\"line\"><span class=\"comment\">// 3.自动挂载：当你在 Vue 组件中定义 setup 函数时，Vue 会自动处理组件的挂载过程。当组件被渲染并添加到 DOM 中时，Vue会自动调用onMounted钩子。</span></span><br><span class=\"line\"><span class=\"comment\">// 4.在组件挂载后调用 fetchData</span></span><br><span class=\"line\"><span class=\"title function_\">onMounted</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">getUserDataMethod</span>();  <span class=\"comment\">// 每次页面渲染执行第一页数据的查询 默认page=1 pageSize=10</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"后端-1\"><a href=\"#后端-1\" class=\"headerlink\" title=\"后端\"></a>后端</h4><ul>\n<li>Mybatis(pageHelp+xml映射文件)和MybatisPlus(自带插件+warpper)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/user/getUserData&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result <span class=\"title function_\">getUserData</span><span class=\"params\">(<span class=\"meta\">@RequestParam(defaultValue = &quot;1&quot;)</span> <span class=\"type\">int</span> page,\t</span></span><br><span class=\"line\"><span class=\"params\">                              <span class=\"meta\">@RequestParam(defaultValue = &quot;5&quot;)</span> <span class=\"type\">int</span> limit,\t// 每页展示数,前端没传,默认<span class=\"number\">10</span></span></span><br><span class=\"line\"><span class=\"params\">                              <span class=\"meta\">@RequestParam</span> String name...\t\t// 模糊匹配,范围查询,排序字段</span></span><br><span class=\"line\"><span class=\"params\">    )</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回VO </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">pageVO</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long Total; <span class=\"comment\">// 总条数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long pages; <span class=\"comment\">// 总页数,看前端要求</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;T&gt; list; <span class=\"comment\">// 结果列表</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DTO: 中间数据传递\t这个Page是mp自带的 有排序器 也可作为链式编程的容器 lambdaQuery().Page(page); </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Page</span>&lt;T&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">IPage</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> <span class=\"number\">8545996863226528798L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> List&lt;T&gt; records;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">long</span> total;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">long</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">long</span> current;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> List&lt;OrderItem&gt; orders;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> optimizeCountSql;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> searchCount;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> optimizeJoinOfCountSql;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String countId;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Long maxLimit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","cover":"/img/5.png","cover_type":"img","excerpt":"","more":"<blockquote>\n<p>🥲假如我们分手的话，绝不是出于我的意思，要知道，树是不愿离开花的，是花离开树          —— 大仲马</p>\n</blockquote>\n<h1 id=\"解决联调发生的各种问题\"><a href=\"#解决联调发生的各种问题\" class=\"headerlink\" title=\"解决联调发生的各种问题\"></a>解决联调发生的各种问题</h1><h2 id=\"联调前的分析\"><a href=\"#联调前的分析\" class=\"headerlink\" title=\"联调前的分析\"></a>联调前的分析</h2><ul>\n<li>前端给后端的请求数据一般常用的有两种方式: <ul>\n<li>form表单: application/x-www-form-urlencoded</li>\n<li>json字符串: application/json</li>\n</ul>\n</li>\n<li>而后端给前端的响应数据, 根据RestFul API风格只有一种: json字符串<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 前端实体数据</span></span><br><span class=\"line\">code: <span class=\"number\">200</span>,</span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    tableData: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            date: <span class=\"string\">&quot;1962-06-22&quot;</span>,</span><br><span class=\"line\">            name: <span class=\"string\">&quot;周星驰&quot;</span>,</span><br><span class=\"line\">            action: <span class=\"string\">&quot;演员&quot;</span>,</span><br><span class=\"line\">            address: <span class=\"string\">&quot;大话西游&quot;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            date: <span class=\"string\">&quot;1963-06-23&quot;</span>,</span><br><span class=\"line\">            name: <span class=\"string\">&quot;刘慈欣&quot;</span>,</span><br><span class=\"line\">            action: <span class=\"string\">&quot;作家&quot;</span>,</span><br><span class=\"line\">            address: <span class=\"string\">&quot;三体&quot;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123; </span><br><span class=\"line\">            date: <span class=\"string\">&quot;1881-09-25&quot;</span>,</span><br><span class=\"line\">            name: <span class=\"string\">&quot;鲁迅&quot;</span>,</span><br><span class=\"line\">            action: <span class=\"string\">&quot;作家&quot;</span>,</span><br><span class=\"line\">            address: <span class=\"string\">&quot;孔乙己&quot;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            date: <span class=\"string\">&quot;1960-04-03&quot;</span>,</span><br><span class=\"line\">            name: <span class=\"string\">&quot;余华&quot;</span>,</span><br><span class=\"line\">            action: <span class=\"string\">&quot;作家&quot;</span>,</span><br><span class=\"line\">            address: <span class=\"string\">&quot;活着&quot;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"分析数据组成\"><a href=\"#分析数据组成\" class=\"headerlink\" title=\"分析数据组成:\"></a>分析数据组成:</h3><p>1.是否符合统一响应格式<strong>Result</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Result</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer code;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String message;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.判断是否嵌套:如果有多层嵌套建议先剥橘子(从里到外)</p>\n<p>3.判断字段数量和类型(一 一对应,用封装对象来包裹)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">tableData</span> &#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    String data;</span><br><span class=\"line\">    String action;</span><br><span class=\"line\">    String address;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.设置响应体类型参数,将对象转化成 Json 字符串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;周润发&quot;</span>, <span class=\"string\">&quot;2024-10-29&quot;</span>, <span class=\"string\">&quot;演员&quot;</span>, <span class=\"string\">&quot;赌场&quot;</span>));</span><br><span class=\"line\">list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;周星驰&quot;</span>, <span class=\"string\">&quot;2024-10-29&quot;</span>, <span class=\"string\">&quot;演员&quot;</span>, <span class=\"string\">&quot;大话西游&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">方式一: 谷歌Gson</span><br><span class=\"line\"><span class=\"type\">Gson</span> <span class=\"variable\">gson</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>();</span><br><span class=\"line\">gson.toJson(list);</span><br><span class=\"line\"></span><br><span class=\"line\">方式二: jackJson(spring默认)</span><br><span class=\"line\"><span class=\"type\">ObjectMapper</span> <span class=\"variable\">jackJson</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>;</span><br><span class=\"line\">jackJson.writeValueAsString(list);</span><br><span class=\"line\"></span><br><span class=\"line\">方式三: fastJson</span><br><span class=\"line\">JSONObject.toJSONString(list);</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTTP请求的两种方式\"><a href=\"#HTTP请求的两种方式\" class=\"headerlink\" title=\"HTTP请求的两种方式\"></a>HTTP请求的两种方式</h2><h3 id=\"1-原始Servlet\"><a href=\"#1-原始Servlet\" class=\"headerlink\" title=\"1.原始Servlet\"></a>1.原始Servlet</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--xml配置文件--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.example.demo.testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span> <span class=\"comment\">&lt;!--类路径--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>testServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/home/getTableData<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span>\t\t<span class=\"comment\">&lt;!--请求参数--&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过继承HttpServlet重写GenericServlet的两方法,最后由Servlet接口实例调用service方法交由Tomcat发起HTTP请求响应</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理Get请求的逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">doPost</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理Post请求的逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-springBoot-Web容器\"><a href=\"#2-springBoot-Web容器\" class=\"headerlink\" title=\"2.springBoot Web容器\"></a>2.springBoot Web容器</h3><ul>\n<li>Spring-Boot: 内嵌Tomcat容器 + Servlet</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CrossOrigin</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/home/getTableData&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result <span class=\"title function_\">getTableData</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;testController&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;tableData&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;周润发&quot;</span>, <span class=\"string\">&quot;2024-10-29&quot;</span>, <span class=\"string\">&quot;演员&quot;</span>, <span class=\"string\">&quot;赌场&quot;</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;周星驰&quot;</span>, <span class=\"string\">&quot;2024-10-29&quot;</span>, <span class=\"string\">&quot;演员&quot;</span>, <span class=\"string\">&quot;大话西游&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Gson</span> <span class=\"variable\">gson</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.success(gson.toJson(list));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-解决跨域问题\"><a href=\"#3-解决跨域问题\" class=\"headerlink\" title=\"3.解决跨域问题\"></a>3.解决跨域问题</h3><ul>\n<li>什么是跨域<ul>\n<li>通俗来说就是端对端访问了不同的 <strong>协议 地址 端口 路径</strong> 的其中一种</li>\n</ul>\n</li>\n<li>解决方式: <ul>\n<li>​对于spring-Boot项目来说,只需要加一个注解 <strong>@CrossOrigin</strong></li>\n<li>或者全局加一个过滤器添加请求头参数</li>\n<li>​如果是部署在Nginx上的话可以添加请求头参数<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">add_header</span> Access-Control-Allow-Origin *;  <span class=\"comment\"># CORS 设置 跨域问题</span></span><br><span class=\"line\"><span class=\"attribute\">add_header</span> Access-Control-Allow-Methods <span class=\"string\">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class=\"line\"><span class=\"attribute\">add_header</span> Access-Control-Allow-Headers <span class=\"string\">&#x27;Origin, Content-Type, Accept&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分析Json\"><a href=\"#分析Json\" class=\"headerlink\" title=\"分析Json\"></a>分析Json</h2></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原始的Json格式: 都是字符串 最外层data用的是一个数组   </span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;code&quot;</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;success&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;data&quot;</span>: <span class=\"string\">&quot;[&#123;\\&quot;name\\&quot;:\\&quot;周润发\\&quot;,\\&quot;data\\&quot;:\\&quot;2024-10-29\\&quot;,\\&quot;action\\&quot;:\\&quot;演员\\&quot;,\\&quot;address\\&quot;:\\&quot;赌场\\&quot;&#125;,&#123;\\&quot;name\\&quot;:\\&quot;周星驰\\&quot;,\\&quot;data\\&quot;:\\&quot;2024-10-29\\&quot;,\\&quot;action\\&quot;:\\&quot;演员\\&quot;,\\&quot;address\\&quot;:\\&quot;大话西游\\&quot;&#125;]&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>前端拿到数据应该对数据进行Json解析</p>\n</li>\n<li><p>但是像 Axios 这样的库时，它会自动将返回的 JSON 数据解析为 JavaScript 对象</p>\n</li>\n<li><p>前端内置的fetch就不行,需要手动parse, 但若是axios就不需要手动JSON.parse转换</p>\n</li>\n</ul>\n<h2 id=\"前后端联调会测试1-0\"><a href=\"#前后端联调会测试1-0\" class=\"headerlink\" title=\"前后端联调会测试1.0\"></a>前后端联调会测试1.0</h2><h4 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h4><ul>\n<li>创建请求实例:设置默认url和headers</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 axios 实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> axiosInstance = axios.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">baseURL</span>: <span class=\"string\">&quot;https://localhost:5173&quot;</span>, <span class=\"comment\">// 请求的基础URL:不写baseURL默认请求本地</span></span><br><span class=\"line\">  <span class=\"attr\">timeout</span>: <span class=\"number\">1000</span>, <span class=\"comment\">// 请求超时时间</span></span><br><span class=\"line\">  <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Content-Type&quot;</span>: <span class=\"string\">&quot;application/json&quot;</span>, <span class=\"comment\">// 全局设置请求数据格式JSON</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>单独设置实例调用Api方法(区分请求方式) </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">getTableData</span>(<span class=\"params\">params</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">request</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">url</span>: <span class=\"string\">&quot;/api/home/getTableData/$&#123;params.id&#125;&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">method</span>: <span class=\"string\">&quot;get&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">params</span>: params,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在原本axios实例的基础上, 对受到的数据进行拦截 并进行JSON格式的解析</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加响应拦截器</span></span><br><span class=\"line\">axiosInstance.<span class=\"property\">interceptors</span>.<span class=\"property\">response</span>.<span class=\"title function_\">use</span>(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 像 Axios 这样的库时，它会自动将返回的 JSON 数据解析为 JavaScript 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; code, data, msg &#125; = response.<span class=\"property\">data</span>.<span class=\"property\">data</span>; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (response.<span class=\"property\">data</span>.<span class=\"property\">code</span> === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.<span class=\"property\">data</span>.<span class=\"property\">data</span>; <span class=\"comment\">// 只返回data</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">ElMessage</span>.<span class=\"title function_\">error</span>(msg || <span class=\"variable constant_\">NETWORK_ERROR</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(msg || <span class=\"variable constant_\">NETWORK_ERROR</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对拿到的数据进行渲染 </li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-card shadow=&quot;hover&quot; class=&quot;userTable&quot;&gt;</span><br><span class=\"line\">    &lt;el-table :data=&quot;tableData&quot; size=&quot;small&quot; border&gt;</span><br><span class=\"line\">        &lt;el-table-column prop=&quot;date&quot; label=&quot;生日&quot; /&gt;</span><br><span class=\"line\">        &lt;el-table-column prop=&quot;name&quot; label=&quot;名字&quot; /&gt;</span><br><span class=\"line\">        &lt;el-table-column prop=&quot;action&quot; label=&quot;身份&quot; /&gt;</span><br><span class=\"line\">        &lt;el-table-column prop=&quot;address&quot; label=&quot;代表作&quot; /&gt;</span><br><span class=\"line\">    &lt;/el-table&gt;</span><br><span class=\"line\">&lt;/el-card&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h4><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对前端端口的代理</span><br><span class=\"line\"><span class=\"attribute\">worker_processes</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">events</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">worker_connections</span> <span class=\"number\">1024</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">http</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">include</span>       mime.types;</span><br><span class=\"line\">    <span class=\"attribute\">default_type</span>  application/json;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">listen</span> <span class=\"number\">5173</span>;</span><br><span class=\"line\">        <span class=\"attribute\">server_name</span> localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"section\">location</span> /api/home/getTableData &#123;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://localhost:8080/home/getTableData;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-Proto <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 添加响应头</span></span><br><span class=\"line\">            <span class=\"attribute\">add_header</span> Content-Type application/json;</span><br><span class=\"line\">            <span class=\"attribute\">add_header</span> Access-Control-Allow-Origin *;  <span class=\"comment\"># CORS 设置 跨域问题</span></span><br><span class=\"line\">            <span class=\"attribute\">add_header</span> Access-Control-Allow-Methods <span class=\"string\">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class=\"line\">            <span class=\"attribute\">add_header</span> Access-Control-Allow-Headers <span class=\"string\">&#x27;Origin, Content-Type, Accept&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"后端\"><a href=\"#后端\" class=\"headerlink\" title=\"后端\"></a>后端</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@CrossOrigin(cros = &quot;前端地址&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/home/getTableData&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result <span class=\"title function_\">getTableData</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;testController&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;tableData&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;周星驰&quot;</span>, <span class=\"string\">&quot;1962-06-22&quot;</span>, <span class=\"string\">&quot;演员&quot;</span>, <span class=\"string\">&quot;大话西游&quot;</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;刘慈欣&quot;</span>, <span class=\"string\">&quot;1963-06-23&quot;</span>, <span class=\"string\">&quot;作家&quot;</span>, <span class=\"string\">&quot;三体&quot;</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;鲁迅&quot;</span>, <span class=\"string\">&quot;1881-09-25&quot;</span>, <span class=\"string\">&quot;作家&quot;</span>, <span class=\"string\">&quot;孔乙己&quot;</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">tableData</span>(<span class=\"string\">&quot;余华&quot;</span>, <span class=\"string\">&quot;1960-04-03&quot;</span>, <span class=\"string\">&quot;作家&quot;</span>, <span class=\"string\">&quot;活着&quot;</span>));</span><br><span class=\"line\">        <span class=\"type\">Gson</span> <span class=\"variable\">gson</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.success(gson.toJson(list));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前后端联调会测试2-0\"><a href=\"#前后端联调会测试2-0\" class=\"headerlink\" title=\"前后端联调会测试2.0\"></a>前后端联调会测试2.0</h2><ul>\n<li>每次要发起请求之前先测试  👍</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17312441657891731244165185.png\" alt=\"好习惯\"></p>\n<h4 id=\"前端-1\"><a href=\"#前端-1\" class=\"headerlink\" title=\"前端\"></a>前端</h4><ul>\n<li><strong>前端会传page为1的原因: 这个1为视图层面上的第一页</strong></li>\n<li><strong>而在数据库层面, 要通过计算得到跳过的条数: (page-1) * pageSize</strong></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 调用axios方法发起请求</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> instance.<span class=\"property\">proxy</span>.<span class=\"property\">$api</span>.<span class=\"title function_\">getUserData</span>(config);</span><br><span class=\"line\">tableData.<span class=\"property\">value</span> = data.<span class=\"property\">list</span> || [];</span><br><span class=\"line\">config.<span class=\"property\">total</span> = data.<span class=\"property\">count</span>; <span class=\"comment\">//总条数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请求数据的参数 用对象封装</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = <span class=\"title function_\">reactive</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">total</span>: <span class=\"number\">0</span>, <span class=\"comment\">// 总条数  因为不知道会不会走条件查询,所有每次请求都要带上</span></span><br><span class=\"line\">    <span class=\"attr\">page</span>: <span class=\"number\">1</span>,  <span class=\"comment\">// 当前页码</span></span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;&quot;</span>, <span class=\"comment\">// 查询字段...</span></span><br><span class=\"line\">    age ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> tableLabel = <span class=\"title function_\">reactive</span>([\t<span class=\"comment\">// 指向性实体类</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">prop</span>: <span class=\"string\">&quot;name&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">label</span>: <span class=\"string\">&quot;姓名&quot;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">prop</span>: <span class=\"string\">&quot;age&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">label</span>: <span class=\"string\">&quot;年龄&quot;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">prop</span>: <span class=\"string\">&quot;sexLabel&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">label</span>: <span class=\"string\">&quot;性别&quot;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">prop</span>: <span class=\"string\">&quot;birth&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">label</span>: <span class=\"string\">&quot;出生日期&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">width</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">prop</span>: <span class=\"string\">&quot;addr&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">label</span>: <span class=\"string\">&quot;地址&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">width</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">]);</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">el-table</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\"><span class=\"attr\">:data</span>=<span class=\"string\">&quot;tableDataObject&quot;</span>\t// <span class=\"attr\">对象绑定</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">el-table-column</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\"><span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in tableLabel&quot;</span>\t// <span class=\"attr\">高明手段:</span> <span class=\"attr\">不用逐个</span> <span class=\"attr\">prop</span>=<span class=\"string\">&quot;name&quot;</span> </span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\"><span class=\"attr\">:key</span>=<span class=\"string\">&quot;item.prop&quot;</span>\t// <span class=\"attr\">嵌套循环</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\"><span class=\"attr\">:prop</span>=<span class=\"string\">&quot;item.prop&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\"><span class=\"attr\">:label</span>=<span class=\"string\">&quot;item.label&quot;</span>\t // <span class=\"attr\">label表头</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    ...</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.为什么要挂载: 不挂载的函数不会执行</span></span><br><span class=\"line\"><span class=\"comment\">// 2.钩子中执行的代码可以确保组件的 DOM 元素已经可用，从而允许进行数据加载和其他操作。</span></span><br><span class=\"line\"><span class=\"comment\">// 3.自动挂载：当你在 Vue 组件中定义 setup 函数时，Vue 会自动处理组件的挂载过程。当组件被渲染并添加到 DOM 中时，Vue会自动调用onMounted钩子。</span></span><br><span class=\"line\"><span class=\"comment\">// 4.在组件挂载后调用 fetchData</span></span><br><span class=\"line\"><span class=\"title function_\">onMounted</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">getUserDataMethod</span>();  <span class=\"comment\">// 每次页面渲染执行第一页数据的查询 默认page=1 pageSize=10</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"后端-1\"><a href=\"#后端-1\" class=\"headerlink\" title=\"后端\"></a>后端</h4><ul>\n<li>Mybatis(pageHelp+xml映射文件)和MybatisPlus(自带插件+warpper)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/user/getUserData&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result <span class=\"title function_\">getUserData</span><span class=\"params\">(<span class=\"meta\">@RequestParam(defaultValue = &quot;1&quot;)</span> <span class=\"type\">int</span> page,\t</span></span><br><span class=\"line\"><span class=\"params\">                              <span class=\"meta\">@RequestParam(defaultValue = &quot;5&quot;)</span> <span class=\"type\">int</span> limit,\t// 每页展示数,前端没传,默认<span class=\"number\">10</span></span></span><br><span class=\"line\"><span class=\"params\">                              <span class=\"meta\">@RequestParam</span> String name...\t\t// 模糊匹配,范围查询,排序字段</span></span><br><span class=\"line\"><span class=\"params\">    )</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回VO </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">pageVO</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long Total; <span class=\"comment\">// 总条数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long pages; <span class=\"comment\">// 总页数,看前端要求</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;T&gt; list; <span class=\"comment\">// 结果列表</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DTO: 中间数据传递\t这个Page是mp自带的 有排序器 也可作为链式编程的容器 lambdaQuery().Page(page); </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Page</span>&lt;T&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">IPage</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> <span class=\"number\">8545996863226528798L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> List&lt;T&gt; records;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">long</span> total;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">long</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">long</span> current;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> List&lt;OrderItem&gt; orders;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> optimizeCountSql;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> searchCount;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> optimizeJoinOfCountSql;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String countId;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Long maxLimit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"jdk和cglib代理动态代理","date":"2024-11-29T12:42:55.000Z","_content":"\n# PROXY\n\n## 什么是代理\n\n### 概念\n- 代理分为: **静态代理**和**动态代理**\n- 动态代理细分为2种: **JDK代理和CGLIB代理**\n- 为什么要有代理:  由于某些原因需要给某对象提供一个代理以控制对该对象的访问,访 问对象不适合或者不能直接引用为目标对象, 代理对象作为访问对象和目标对象之间的中介(就像访客 <-> 售票处 <-> 火车站)\n### 静态代理(static proxy)\n- 静态代理是指代理类提前在编译时期就创建好的, 代理类和被代理类的的关系是固定的，**代理类会持有目标类的引用，并通过该引用调用目标类的方法**。\n```java\n// 被代理接口\npublic interface userService {\n    void select();\n}\n\n// 被代理实现类\npublic class userServiceImpl implements userService {\n    @Override\n    public void select() {\n        System.out.println(\"Service is being served.\");\n    }\n}\n\n// 代理类\npublic class userServiceProxy implements Service {\n    private userService userservice;\n\n    public userServiceProxy(userService userservice) {\n        this.userservice = userservice;\n    }\n\n    @Override\n    public void proxyService() {\n        System.out.println(\"Before serving...\");\n        userservice.select();  // 调用目标对象的方法\n        System.out.println(\"After serving...\");\n    }\n}\n\n// 测试\npublic class ProxyTest {\n    public static void main(String[] args) {\n        userService userservice = new userServiceImpl();\n        userService proxy = new userServiceProxy(userservice);\n        proxy.proxyService();\n    }\n}\n```\n### 为什么类可以动态的生成\n- Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中**加载阶段**需要完成以下3件事情：\n  - 通过**一个类的全限定名**来获取定义此类的二进制字节流, **每个类都会有一个对应的 `.class` 文件**,该文件存储了类的字节码, 通过类加载器从类路径中查找并加载这个字节流\n  - .class 文件中的字节码经过**解码**后，JVM 会将这些**字节码转换为方法区的数据结构**，即方法区的运行时数据（运行时常量池、类的字段、**方法**等）。这些数据结构用于后续的类操作。\n  - **每个加载的类都会有一个对应的 `Class` 对象**，它代表了该类的元数据, 通过 `Class` 对象，JVM 可以访问该类的各种信息，如字段、**方法**、构造函数、注解等。这个 `Class` 对象也提供了**反射**机制的入口，可以让你**动态地获取和操作类的信息**（例如获取字段、调用方法、创建对象等)\n  - **反射就是通过 `Class` 对象来动态获取类的信息，甚至在运行时动态生成和操作类**\n### 静态代理和动态代理的区别\n\t静态代理靠手动去创建代理类和被代理类, 代理类和被代理类的对象在编译时就被创建了\n\t动态代理只能由被代理类手动创建对象, 正因如此代理类依托于反射的Constructor.newInstance()才能在运行时动态创建对象\n#### 静态代理\n  - 静态代理是在编译时就已经明确生成的，它是通过直接`new`出目标对象来完成代理操作的。\n  - 在静态代理中，代理类和目标类的关系是硬编码的，代理类必须实现与目标类相同的接口或者直接继承目标类，且代理类的行为在编译时就已经确定。\n  - **关键点**：静态代理确实在编译时就已经生成了代理类，且代理类**不依赖反射**。\n#### 动态代理\n  - 动态代理在运行时**通过反射机制**创建代理对象，并将目标方法的调用交给代理处理器（`InvocationHandler`）。\n  - 它不需要手动写代理类，而是通**过`Proxy.newProxyInstance()`方法动态生成代理类**。这样，你可以通过一个通用的`InvocationHandler`处理不同的目标对象，减少了代码重复和硬编码。\n  - **动态代理则是利用反射**,通过 `Proxy.newProxyInstance()` 方法，动态代理不需要编写代理类并将方法调用委托给 `InvocationHandler` 中的 `invoke()` 方法。虽然最终也会通过 `new` 创建目标对象，但代理类的生成和方法调用的分发机制是完全动态的。\n  - **关键点**：动态代理依赖反射，且代理类是在运行时动态生成的，目标对象的方法调用由`InvocationHandler`来决定。\n![17329446161661732944615286.png|700x342](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17329446161661732944615286.png)\n## 动态代理的运用\n### 代理模式优缺点\n- 优点: \n  1. 代理模式在客户端与目标对象之间起到一个中介作用和**保护目标对象**的作用 -> 隐藏卖家\n  2. 代理对象可以**增强目标对象的功能**，被用来间接访问底层对象，与原始对象具有相同的 hashCode  -> 增强功能\n  3. 代理模式能将客户端与目标对象分离，在一定程度上**降低了系统的耦合度**  -> 降低\n- 缺点：增加了系统的复杂度\n### JDK动态代理\n- **通过代理类实现接口的方式** -> JDK动态代理 -> 反射\n- JDK动态代理主要涉及两个类：**java.lang.reflect.Proxy**和 **java.lang.reflect.InvocationHandler**\n```java\n// 被代理接口\ninterface Service {\n    void serve();\n}\n\n// 被代理实现类\npublic class ServiceImpl implements Service {\n    @Override\n    public void serve() {\n        System.out.println(\"Service is being served.\");\n    }\n}\n\n// 动态代理类的 InvocationHandler\nclass ServiceInvocationHandler implements InvocationHandler {\n    private Object target;\n\n    public ServiceInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"Before serving...\");\n        Object result = method.invoke(target, args);  // 调用目标对象的方法\n        System.out.println(\"After serving...\");\n        return result;\n    }\n}\n\n// 测试\nclass ProxyTest {\n    public static void main(String[] args) {\n        Service service = new ServiceImpl();\n        Service proxy = (Service) Proxy.newProxyInstance(\n                service.getClass().getClassLoader(), // 被代理类的类加载器类型\n                service.getClass().getInterfaces(),  // 被代理类的接口类型\n                new ServiceInvocationHandler(service) // 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用\n        );\n        // \t\ta.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码\n        //      b.然后根据相应的字节码转换成对应的class，\n        //       c.然后调用newInstance()创建代理实例  例如: $proxy0\n        proxy.serve();  // 等价于 handle.invoke()\n    }\n}\n```\n\n```java\n// 代理类内部结构\npublic final class $Proxy0 extends Proxy implements Service {\n    private static Method m1;\n    private static Method m3; // 目标方法server()\n    private static Method m2;\n    private static Method m0;\n\n    public $Proxy0(InvocationHandler var1) throws  {\n        super(var1);\n    }\n\n    public final boolean equals(Object var1) throws  {\n        try {\n            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final void serve() throws  { // 目标方法\n        try {\n            super.h.invoke(this, m3, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final String toString() throws  {\n        try {\n            return (String)super.h.invoke(this, m2, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final int hashCode() throws  {\n        try {\n            return (Integer)super.h.invoke(this, m0, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    static {\n        try {\n            m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\"));\n            m3 = Class.forName(\"proxy.Service\").getMethod(\"serve\"); // 反射加载方法\n            m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\");\n            m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\");\n        } catch (NoSuchMethodException var2) {\n            throw new NoSuchMethodError(var2.getMessage());\n        } catch (ClassNotFoundException var3) {\n            throw new NoClassDefFoundError(var3.getMessage());\n        }\n    }\n}\n```\n\n![17328903987391732890398584.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17328903987391732890398584.png)\n### 调用处理器和反射类\n- **Proxy**\n```java\n// Proxy提供用于创建动态类和实例的静态方法, 创建的所有动态代理类的超类\nProxy::newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h);\n// 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用\nObject invoke(Object proxy, Method method, Object[] args)\n```\n-  **InvocationHandler**\n```java\n// 用于获取指定代理对象所关联的调用处理器\nstatic InvocationHandler getInvocationHandler(Object proxy);\n// 返回指定接口的代理类\nstatic Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces);\n// 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法\nstatic Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h);\n// 返回 cl 是否为一个代理类\nstatic boolean isProxyClass(Class<?> cl);\n```\n- 通过`Proxy` 类的 `newProxyInstance()` 创建的代理对象在调用方法的时候，实际会调用到实现`InvocationHandler` 接口的类的 `invoke()`方法\n### CGLIB代理\n- **通过代理类继承被代理类重写其方法的方式** -> CGLIB代理 -> 字节码\n- 在运行时通过继承的方式为目标类创建代理类。与 JDK 动态代理不同，CGLIB 不要求代理类实现接口，而是**直接对被代理类进行字节码增强**\n```java\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\n// 被代理类\npublic class Service {\n    public void serve() {\n        System.out.println(\"Service is being served.\");\n    }\n}\n\n// 代理类\nclass ServiceInterceptor implements MethodInterceptor {\n    private Object target;\n\n    public ServiceInterceptor(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(\"Before serving...\");\n        Object result = method.invokeSuper(target, args);\n        System.out.println(\"After serving...\");\n        return result;\n    }\n}\n\n// 测试\npublic class ProxyTest {\n    public static void main(String[] args) {\n        Service service = new Service();// 被代理类对象\n       \t// Enhancer：CGLIB 的核心类，用于生成代理类\n        // MethodInterceptor：用于定义方法拦截逻辑\n        Service proxy = (Service) Enhancer.create(Service.class, new ServiceInterceptor(service));\n        // MethodProxy：用于调用父类的方法\n        proxy.intercept();\n    }\n}\n```\n- 在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心\n- 自定义 `MethodInterceptor` 实现类并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法\n- 通过 `Enhancer`类来动态获取被代理类，通过 `Enhancer` 类的 `create()`创建代理类, 当代理类调用方法的时候，实际调用的是 `MethodInterceptor` 中的 `intercept` 方法 这里的 `intercept`类似于 `invoke`方法\n## JDK和CGLIB代理的对比\n\n| 对比         | JDK代理                    | CGLIB代理             |\n| ---------- | ------------------------ | ------------------- |\n| 代理对象生成方式   | **基于反射生成$proxy0代理类**     | **基于字节码生成子类**       |\n| 方法的调用方式    | **基于proxy.方法调用**         | **基于底层子类super()调用** |\n| 初始化效率      | **反射newInstance生成对象效率高** | 直接生成子类对象效率低         |\n| 方法执行效率     | 执行效率低                    | **执行效率高(直接调用父类方法)** |\n| spring默认策略 | 有接口                      | 无接口                 |\n\n- 总结: CGLIB 由于主要基于字节码操作，如果是**只要初始化一次且方法要长期被调用**, 性能通常高于 JDK 动态代理, 适用于不需要频繁修改代理逻辑的场景，因为cglib代理是子类,父类修改了子类也要跟着改, 并且内存占用要高于jdk代理\n## 工厂代理模式\n\n- 工厂代理模式是一种将**工厂模式**与**代理模式**相结合的设计模式。通过工厂方法创建代理对象，从而**简化代理对象的创建流程**，同时增强代理模式的灵活性\n- 工厂方法屏蔽了对象的创建细节，提高了代码的灵活性和扩展性。\n### 动态工厂代理模式\n- 动态工厂代理模式结合了 **动态代理** 和 **工厂模式**，通过工厂方法动态生成代理对象。\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\n// 定义接口\npublic interface Service {\n    void serve();\n}\n\n// 目标类\npublic class RealService implements Service {\n    @Override\n    public void serve() {\n        System.out.println(\"RealService is serving...\");\n    }\n}\n\n// 动态代理处理器\nclass ServiceInvocationHandler implements InvocationHandler {\n    private final Object target;\n\n    public ServiceInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"Before method: \" + method.getName());\n        Object result = method.invoke(target, args); // 调用目标对象的方法\n        System.out.println(\"After method: \" + method.getName());\n        return result;\n    }\n}\n\n// 工厂类\npublic class ServiceFactory {\n    public static Service getProxy() {\n        RealService realService = new RealService();\n\n        return (Service) Proxy.newProxyInstance(\n            realService.getClass().getClassLoader(),\n            realService.getClass().getInterfaces(),\n            new ServiceInvocationHandler(realService) // 传入动态代理处理器\n        );\n    }\n}\n\n// 测试\npublic class Main {\n    public static void main(String[] args) {\n        Service service = ServiceFactory.getProxy(); // 解耦了代理类创建过程\n        service.serve();\n    }\n}\n```\n### 工厂代理模式的优缺点\n**优点：**\n1. **解耦**：将代理对象的创建逻辑封装到工厂类中，客户端代码不需要关心代理对象的实现细节。\n2. **灵活性**：可以动态生成代理对象，支持多种代理模式（如静态代理、动态代理、CGLIB 代理）。\n3. **扩展性**：如果需要更改代理逻辑或代理方式，只需修改工厂类的实现，而无需影响客户端代码。\n**缺点：**\n4. **复杂性**：相比直接使用代理模式，工厂代理模式的实现复杂度更高。\n5. **性能开销**：动态代理可能增加运行时的性能开销（如反射调用）\n## 注意\n### 性能开销\n- **JDK 动态代理的性能**：JDK 动态代理基于反射机制生成代理对象和方法调用，因此**每次方法调用都会涉及到反射**，性能相对较低，尤其是在大量调用的场景中。如果对性能要求非常高的场合，尽量避免过多使用 JDK 动态代理。\n- **CGLIB 代理的性能**：CGLIB 通过字节码技术生成子类代理，因此没有反射带来的性能开销，相对较为高效。不过，CGLIB 的代理对象是通过继承生成的，这可能导致**对目标类的修改（如方法的添加、删除等）对代理类的影响较大**，可能需要重新生成代理类。\n### 代理对象的生命周期\n- 在使用动态代理时，代理对象的生命周期通常由代理工厂管理。确保代理对象在适当的时机销毁，以避免内存泄漏。特别是在使用动态代理时，通过反射和字节码生成代理对象时，代理对象可能会占用更多的内存，因此需要注意对象的销毁和资源回收。\n- 对于 **CGLIB 代理**，需要注意，由于它是通过继承目标类生成的代理对象，所以会增加内存占用。并且，CGLIB 对目标类的生成依赖于字节码操作，因此需要确保代理类在不再使用时被正确清理。\n### 动态代理和AOP的结合\n- **AOP（面向切面编程）**：动态代理常与 AOP 结合使用，尤其是在 Spring 框架中，动态代理用于增强类的方法。通过 AOP，可以在不改变目标类的代码情况下，在方法执行前后执行额外的操作，例如事务管理、权限验证、日志记录等。\n![17601594300691760159429855.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17601594300691760159429855.png)\n- 在 Spring 框架中：\n  - 如果被代理类实现了接口，Spring 会使用 JDK 动态代理(默认方式)\n  - 如果被代理类没有实现接口，Spring 会使用 CGLIB 代理\n- 通过 AOP，可以灵活地为目标对象动态织入切面，增强其功能。\n![17601593600641760159359315.png|700x691](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17601593600641760159359315.png)\n### 获取代理类对象\n##### 具体情况：\n1. **没有AOP代理的情况：** 如果你注入的是一个普通的类，并且没有使用 Spring AOP 的代理机制，那么 `@Autowired` 会注入这个类的实例对象。\n2. **有AOP代理的情况：** 如果你的类上使用了 AOP 功能（比如事务、日志、权限等），Spring 会为这个类创建一个代理对象。这时，`@Autowired` 注入的就是代理类对象，而不是原始类的实例。\n3. 使用 **`@Transactional` 注解**的代理对象, spring 会为你创建一个代理对象来处理事务\n##### 代理类型：\n- **JDK 动态代理**：当你注入的是接口类型的类时，Spring 会通过 JDK 动态代理来创建一个实现了该接口的代理类。\n- **CGLIB 代理**：当你注入的是没有接口的类时，Spring 会使用 CGLIB 生成一个该类的子类作为代理对象。\n##### 如何判断注入的是代理对象：\n可以通过 `getClass().getName()` 来检查实例的类型。如果你看到的是一个类似 `com.sun.proxy.$Proxy` 的类名，那就说明注入的是代理对象。\n##### 获取当前代理对象\n- Spring AOP 提供了 `AopContext`，它允许你在方法调用中访问当前的代理对象:\n```java\n// 获取代理对象的 AopProxy\nAopProxy aopProxy = (AopProxy) AopContext.currentProxy();\n// 获取代理对象\nMyService proxy = (MyService) aopProxy.getProxy();\n```\n-  通过 `ApplicationContext` 获取代理对象: \n```java\nMyService proxy = (MyService) applicationContext.getBean(MyService.class);\n```\n- 如果你想判断某个对象是否为代理对象，可以使用 **AopUtils.isAopProxy()** 方法\n\n","source":"_posts/proxy.md","raw":"---\ntitle: jdk和cglib代理动态代理\ntags:\n  - proxy\n  - AOP\ncategories: 编程\ndate: 2024-11-29 20:42:55\n---\n\n# PROXY\n\n## 什么是代理\n\n### 概念\n- 代理分为: **静态代理**和**动态代理**\n- 动态代理细分为2种: **JDK代理和CGLIB代理**\n- 为什么要有代理:  由于某些原因需要给某对象提供一个代理以控制对该对象的访问,访 问对象不适合或者不能直接引用为目标对象, 代理对象作为访问对象和目标对象之间的中介(就像访客 <-> 售票处 <-> 火车站)\n### 静态代理(static proxy)\n- 静态代理是指代理类提前在编译时期就创建好的, 代理类和被代理类的的关系是固定的，**代理类会持有目标类的引用，并通过该引用调用目标类的方法**。\n```java\n// 被代理接口\npublic interface userService {\n    void select();\n}\n\n// 被代理实现类\npublic class userServiceImpl implements userService {\n    @Override\n    public void select() {\n        System.out.println(\"Service is being served.\");\n    }\n}\n\n// 代理类\npublic class userServiceProxy implements Service {\n    private userService userservice;\n\n    public userServiceProxy(userService userservice) {\n        this.userservice = userservice;\n    }\n\n    @Override\n    public void proxyService() {\n        System.out.println(\"Before serving...\");\n        userservice.select();  // 调用目标对象的方法\n        System.out.println(\"After serving...\");\n    }\n}\n\n// 测试\npublic class ProxyTest {\n    public static void main(String[] args) {\n        userService userservice = new userServiceImpl();\n        userService proxy = new userServiceProxy(userservice);\n        proxy.proxyService();\n    }\n}\n```\n### 为什么类可以动态的生成\n- Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中**加载阶段**需要完成以下3件事情：\n  - 通过**一个类的全限定名**来获取定义此类的二进制字节流, **每个类都会有一个对应的 `.class` 文件**,该文件存储了类的字节码, 通过类加载器从类路径中查找并加载这个字节流\n  - .class 文件中的字节码经过**解码**后，JVM 会将这些**字节码转换为方法区的数据结构**，即方法区的运行时数据（运行时常量池、类的字段、**方法**等）。这些数据结构用于后续的类操作。\n  - **每个加载的类都会有一个对应的 `Class` 对象**，它代表了该类的元数据, 通过 `Class` 对象，JVM 可以访问该类的各种信息，如字段、**方法**、构造函数、注解等。这个 `Class` 对象也提供了**反射**机制的入口，可以让你**动态地获取和操作类的信息**（例如获取字段、调用方法、创建对象等)\n  - **反射就是通过 `Class` 对象来动态获取类的信息，甚至在运行时动态生成和操作类**\n### 静态代理和动态代理的区别\n\t静态代理靠手动去创建代理类和被代理类, 代理类和被代理类的对象在编译时就被创建了\n\t动态代理只能由被代理类手动创建对象, 正因如此代理类依托于反射的Constructor.newInstance()才能在运行时动态创建对象\n#### 静态代理\n  - 静态代理是在编译时就已经明确生成的，它是通过直接`new`出目标对象来完成代理操作的。\n  - 在静态代理中，代理类和目标类的关系是硬编码的，代理类必须实现与目标类相同的接口或者直接继承目标类，且代理类的行为在编译时就已经确定。\n  - **关键点**：静态代理确实在编译时就已经生成了代理类，且代理类**不依赖反射**。\n#### 动态代理\n  - 动态代理在运行时**通过反射机制**创建代理对象，并将目标方法的调用交给代理处理器（`InvocationHandler`）。\n  - 它不需要手动写代理类，而是通**过`Proxy.newProxyInstance()`方法动态生成代理类**。这样，你可以通过一个通用的`InvocationHandler`处理不同的目标对象，减少了代码重复和硬编码。\n  - **动态代理则是利用反射**,通过 `Proxy.newProxyInstance()` 方法，动态代理不需要编写代理类并将方法调用委托给 `InvocationHandler` 中的 `invoke()` 方法。虽然最终也会通过 `new` 创建目标对象，但代理类的生成和方法调用的分发机制是完全动态的。\n  - **关键点**：动态代理依赖反射，且代理类是在运行时动态生成的，目标对象的方法调用由`InvocationHandler`来决定。\n![17329446161661732944615286.png|700x342](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17329446161661732944615286.png)\n## 动态代理的运用\n### 代理模式优缺点\n- 优点: \n  1. 代理模式在客户端与目标对象之间起到一个中介作用和**保护目标对象**的作用 -> 隐藏卖家\n  2. 代理对象可以**增强目标对象的功能**，被用来间接访问底层对象，与原始对象具有相同的 hashCode  -> 增强功能\n  3. 代理模式能将客户端与目标对象分离，在一定程度上**降低了系统的耦合度**  -> 降低\n- 缺点：增加了系统的复杂度\n### JDK动态代理\n- **通过代理类实现接口的方式** -> JDK动态代理 -> 反射\n- JDK动态代理主要涉及两个类：**java.lang.reflect.Proxy**和 **java.lang.reflect.InvocationHandler**\n```java\n// 被代理接口\ninterface Service {\n    void serve();\n}\n\n// 被代理实现类\npublic class ServiceImpl implements Service {\n    @Override\n    public void serve() {\n        System.out.println(\"Service is being served.\");\n    }\n}\n\n// 动态代理类的 InvocationHandler\nclass ServiceInvocationHandler implements InvocationHandler {\n    private Object target;\n\n    public ServiceInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"Before serving...\");\n        Object result = method.invoke(target, args);  // 调用目标对象的方法\n        System.out.println(\"After serving...\");\n        return result;\n    }\n}\n\n// 测试\nclass ProxyTest {\n    public static void main(String[] args) {\n        Service service = new ServiceImpl();\n        Service proxy = (Service) Proxy.newProxyInstance(\n                service.getClass().getClassLoader(), // 被代理类的类加载器类型\n                service.getClass().getInterfaces(),  // 被代理类的接口类型\n                new ServiceInvocationHandler(service) // 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用\n        );\n        // \t\ta.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码\n        //      b.然后根据相应的字节码转换成对应的class，\n        //       c.然后调用newInstance()创建代理实例  例如: $proxy0\n        proxy.serve();  // 等价于 handle.invoke()\n    }\n}\n```\n\n```java\n// 代理类内部结构\npublic final class $Proxy0 extends Proxy implements Service {\n    private static Method m1;\n    private static Method m3; // 目标方法server()\n    private static Method m2;\n    private static Method m0;\n\n    public $Proxy0(InvocationHandler var1) throws  {\n        super(var1);\n    }\n\n    public final boolean equals(Object var1) throws  {\n        try {\n            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final void serve() throws  { // 目标方法\n        try {\n            super.h.invoke(this, m3, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final String toString() throws  {\n        try {\n            return (String)super.h.invoke(this, m2, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final int hashCode() throws  {\n        try {\n            return (Integer)super.h.invoke(this, m0, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    static {\n        try {\n            m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\"));\n            m3 = Class.forName(\"proxy.Service\").getMethod(\"serve\"); // 反射加载方法\n            m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\");\n            m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\");\n        } catch (NoSuchMethodException var2) {\n            throw new NoSuchMethodError(var2.getMessage());\n        } catch (ClassNotFoundException var3) {\n            throw new NoClassDefFoundError(var3.getMessage());\n        }\n    }\n}\n```\n\n![17328903987391732890398584.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17328903987391732890398584.png)\n### 调用处理器和反射类\n- **Proxy**\n```java\n// Proxy提供用于创建动态类和实例的静态方法, 创建的所有动态代理类的超类\nProxy::newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h);\n// 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用\nObject invoke(Object proxy, Method method, Object[] args)\n```\n-  **InvocationHandler**\n```java\n// 用于获取指定代理对象所关联的调用处理器\nstatic InvocationHandler getInvocationHandler(Object proxy);\n// 返回指定接口的代理类\nstatic Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces);\n// 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法\nstatic Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h);\n// 返回 cl 是否为一个代理类\nstatic boolean isProxyClass(Class<?> cl);\n```\n- 通过`Proxy` 类的 `newProxyInstance()` 创建的代理对象在调用方法的时候，实际会调用到实现`InvocationHandler` 接口的类的 `invoke()`方法\n### CGLIB代理\n- **通过代理类继承被代理类重写其方法的方式** -> CGLIB代理 -> 字节码\n- 在运行时通过继承的方式为目标类创建代理类。与 JDK 动态代理不同，CGLIB 不要求代理类实现接口，而是**直接对被代理类进行字节码增强**\n```java\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\n// 被代理类\npublic class Service {\n    public void serve() {\n        System.out.println(\"Service is being served.\");\n    }\n}\n\n// 代理类\nclass ServiceInterceptor implements MethodInterceptor {\n    private Object target;\n\n    public ServiceInterceptor(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        System.out.println(\"Before serving...\");\n        Object result = method.invokeSuper(target, args);\n        System.out.println(\"After serving...\");\n        return result;\n    }\n}\n\n// 测试\npublic class ProxyTest {\n    public static void main(String[] args) {\n        Service service = new Service();// 被代理类对象\n       \t// Enhancer：CGLIB 的核心类，用于生成代理类\n        // MethodInterceptor：用于定义方法拦截逻辑\n        Service proxy = (Service) Enhancer.create(Service.class, new ServiceInterceptor(service));\n        // MethodProxy：用于调用父类的方法\n        proxy.intercept();\n    }\n}\n```\n- 在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心\n- 自定义 `MethodInterceptor` 实现类并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法\n- 通过 `Enhancer`类来动态获取被代理类，通过 `Enhancer` 类的 `create()`创建代理类, 当代理类调用方法的时候，实际调用的是 `MethodInterceptor` 中的 `intercept` 方法 这里的 `intercept`类似于 `invoke`方法\n## JDK和CGLIB代理的对比\n\n| 对比         | JDK代理                    | CGLIB代理             |\n| ---------- | ------------------------ | ------------------- |\n| 代理对象生成方式   | **基于反射生成$proxy0代理类**     | **基于字节码生成子类**       |\n| 方法的调用方式    | **基于proxy.方法调用**         | **基于底层子类super()调用** |\n| 初始化效率      | **反射newInstance生成对象效率高** | 直接生成子类对象效率低         |\n| 方法执行效率     | 执行效率低                    | **执行效率高(直接调用父类方法)** |\n| spring默认策略 | 有接口                      | 无接口                 |\n\n- 总结: CGLIB 由于主要基于字节码操作，如果是**只要初始化一次且方法要长期被调用**, 性能通常高于 JDK 动态代理, 适用于不需要频繁修改代理逻辑的场景，因为cglib代理是子类,父类修改了子类也要跟着改, 并且内存占用要高于jdk代理\n## 工厂代理模式\n\n- 工厂代理模式是一种将**工厂模式**与**代理模式**相结合的设计模式。通过工厂方法创建代理对象，从而**简化代理对象的创建流程**，同时增强代理模式的灵活性\n- 工厂方法屏蔽了对象的创建细节，提高了代码的灵活性和扩展性。\n### 动态工厂代理模式\n- 动态工厂代理模式结合了 **动态代理** 和 **工厂模式**，通过工厂方法动态生成代理对象。\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\n// 定义接口\npublic interface Service {\n    void serve();\n}\n\n// 目标类\npublic class RealService implements Service {\n    @Override\n    public void serve() {\n        System.out.println(\"RealService is serving...\");\n    }\n}\n\n// 动态代理处理器\nclass ServiceInvocationHandler implements InvocationHandler {\n    private final Object target;\n\n    public ServiceInvocationHandler(Object target) {\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"Before method: \" + method.getName());\n        Object result = method.invoke(target, args); // 调用目标对象的方法\n        System.out.println(\"After method: \" + method.getName());\n        return result;\n    }\n}\n\n// 工厂类\npublic class ServiceFactory {\n    public static Service getProxy() {\n        RealService realService = new RealService();\n\n        return (Service) Proxy.newProxyInstance(\n            realService.getClass().getClassLoader(),\n            realService.getClass().getInterfaces(),\n            new ServiceInvocationHandler(realService) // 传入动态代理处理器\n        );\n    }\n}\n\n// 测试\npublic class Main {\n    public static void main(String[] args) {\n        Service service = ServiceFactory.getProxy(); // 解耦了代理类创建过程\n        service.serve();\n    }\n}\n```\n### 工厂代理模式的优缺点\n**优点：**\n1. **解耦**：将代理对象的创建逻辑封装到工厂类中，客户端代码不需要关心代理对象的实现细节。\n2. **灵活性**：可以动态生成代理对象，支持多种代理模式（如静态代理、动态代理、CGLIB 代理）。\n3. **扩展性**：如果需要更改代理逻辑或代理方式，只需修改工厂类的实现，而无需影响客户端代码。\n**缺点：**\n4. **复杂性**：相比直接使用代理模式，工厂代理模式的实现复杂度更高。\n5. **性能开销**：动态代理可能增加运行时的性能开销（如反射调用）\n## 注意\n### 性能开销\n- **JDK 动态代理的性能**：JDK 动态代理基于反射机制生成代理对象和方法调用，因此**每次方法调用都会涉及到反射**，性能相对较低，尤其是在大量调用的场景中。如果对性能要求非常高的场合，尽量避免过多使用 JDK 动态代理。\n- **CGLIB 代理的性能**：CGLIB 通过字节码技术生成子类代理，因此没有反射带来的性能开销，相对较为高效。不过，CGLIB 的代理对象是通过继承生成的，这可能导致**对目标类的修改（如方法的添加、删除等）对代理类的影响较大**，可能需要重新生成代理类。\n### 代理对象的生命周期\n- 在使用动态代理时，代理对象的生命周期通常由代理工厂管理。确保代理对象在适当的时机销毁，以避免内存泄漏。特别是在使用动态代理时，通过反射和字节码生成代理对象时，代理对象可能会占用更多的内存，因此需要注意对象的销毁和资源回收。\n- 对于 **CGLIB 代理**，需要注意，由于它是通过继承目标类生成的代理对象，所以会增加内存占用。并且，CGLIB 对目标类的生成依赖于字节码操作，因此需要确保代理类在不再使用时被正确清理。\n### 动态代理和AOP的结合\n- **AOP（面向切面编程）**：动态代理常与 AOP 结合使用，尤其是在 Spring 框架中，动态代理用于增强类的方法。通过 AOP，可以在不改变目标类的代码情况下，在方法执行前后执行额外的操作，例如事务管理、权限验证、日志记录等。\n![17601594300691760159429855.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17601594300691760159429855.png)\n- 在 Spring 框架中：\n  - 如果被代理类实现了接口，Spring 会使用 JDK 动态代理(默认方式)\n  - 如果被代理类没有实现接口，Spring 会使用 CGLIB 代理\n- 通过 AOP，可以灵活地为目标对象动态织入切面，增强其功能。\n![17601593600641760159359315.png|700x691](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17601593600641760159359315.png)\n### 获取代理类对象\n##### 具体情况：\n1. **没有AOP代理的情况：** 如果你注入的是一个普通的类，并且没有使用 Spring AOP 的代理机制，那么 `@Autowired` 会注入这个类的实例对象。\n2. **有AOP代理的情况：** 如果你的类上使用了 AOP 功能（比如事务、日志、权限等），Spring 会为这个类创建一个代理对象。这时，`@Autowired` 注入的就是代理类对象，而不是原始类的实例。\n3. 使用 **`@Transactional` 注解**的代理对象, spring 会为你创建一个代理对象来处理事务\n##### 代理类型：\n- **JDK 动态代理**：当你注入的是接口类型的类时，Spring 会通过 JDK 动态代理来创建一个实现了该接口的代理类。\n- **CGLIB 代理**：当你注入的是没有接口的类时，Spring 会使用 CGLIB 生成一个该类的子类作为代理对象。\n##### 如何判断注入的是代理对象：\n可以通过 `getClass().getName()` 来检查实例的类型。如果你看到的是一个类似 `com.sun.proxy.$Proxy` 的类名，那就说明注入的是代理对象。\n##### 获取当前代理对象\n- Spring AOP 提供了 `AopContext`，它允许你在方法调用中访问当前的代理对象:\n```java\n// 获取代理对象的 AopProxy\nAopProxy aopProxy = (AopProxy) AopContext.currentProxy();\n// 获取代理对象\nMyService proxy = (MyService) aopProxy.getProxy();\n```\n-  通过 `ApplicationContext` 获取代理对象: \n```java\nMyService proxy = (MyService) applicationContext.getBean(MyService.class);\n```\n- 如果你想判断某个对象是否为代理对象，可以使用 **AopUtils.isAopProxy()** 方法\n\n","slug":"proxy","published":1,"updated":"2025-10-14T07:52:34.112Z","_id":"cmfw4z0ab001kuomw8bewh51p","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"PROXY\"><a href=\"#PROXY\" class=\"headerlink\" title=\"PROXY\"></a>PROXY</h1><h2 id=\"什么是代理\"><a href=\"#什么是代理\" class=\"headerlink\" title=\"什么是代理\"></a>什么是代理</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>代理分为: <strong>静态代理</strong>和<strong>动态代理</strong></li>\n<li>动态代理细分为2种: <strong>JDK代理和CGLIB代理</strong></li>\n<li>为什么要有代理:  由于某些原因需要给某对象提供一个代理以控制对该对象的访问,访 问对象不适合或者不能直接引用为目标对象, 代理对象作为访问对象和目标对象之间的中介(就像访客 &lt;-&gt; 售票处 &lt;-&gt; 火车站)<h3 id=\"静态代理-static-proxy\"><a href=\"#静态代理-static-proxy\" class=\"headerlink\" title=\"静态代理(static proxy)\"></a>静态代理(static proxy)</h3></li>\n<li>静态代理是指代理类提前在编译时期就创建好的, 代理类和被代理类的的关系是固定的，<strong>代理类会持有目标类的引用，并通过该引用调用目标类的方法</strong>。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 被代理接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">userService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">select</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 被代理实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">userServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">userService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">select</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Service is being served.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">userServiceProxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> userService userservice;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">userServiceProxy</span><span class=\"params\">(userService userservice)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userservice = userservice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">proxyService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before serving...&quot;</span>);</span><br><span class=\"line\">        userservice.select();  <span class=\"comment\">// 调用目标对象的方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After serving...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">userService</span> <span class=\"variable\">userservice</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">userServiceImpl</span>();</span><br><span class=\"line\">        <span class=\"type\">userService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">userServiceProxy</span>(userservice);</span><br><span class=\"line\">        proxy.proxyService();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么类可以动态的生成\"><a href=\"#为什么类可以动态的生成\" class=\"headerlink\" title=\"为什么类可以动态的生成\"></a>为什么类可以动态的生成</h3></li>\n<li>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中<strong>加载阶段</strong>需要完成以下3件事情：<ul>\n<li>通过<strong>一个类的全限定名</strong>来获取定义此类的二进制字节流, <strong>每个类都会有一个对应的 <code>.class</code> 文件</strong>,该文件存储了类的字节码, 通过类加载器从类路径中查找并加载这个字节流</li>\n<li>.class 文件中的字节码经过<strong>解码</strong>后，JVM 会将这些<strong>字节码转换为方法区的数据结构</strong>，即方法区的运行时数据（运行时常量池、类的字段、<strong>方法</strong>等）。这些数据结构用于后续的类操作。</li>\n<li><strong>每个加载的类都会有一个对应的 <code>Class</code> 对象</strong>，它代表了该类的元数据, 通过 <code>Class</code> 对象，JVM 可以访问该类的各种信息，如字段、<strong>方法</strong>、构造函数、注解等。这个 <code>Class</code> 对象也提供了<strong>反射</strong>机制的入口，可以让你<strong>动态地获取和操作类的信息</strong>（例如获取字段、调用方法、创建对象等)</li>\n<li><strong>反射就是通过 <code>Class</code> 对象来动态获取类的信息，甚至在运行时动态生成和操作类</strong><h3 id=\"静态代理和动态代理的区别\"><a href=\"#静态代理和动态代理的区别\" class=\"headerlink\" title=\"静态代理和动态代理的区别\"></a>静态代理和动态代理的区别</h3>静态代理靠手动去创建代理类和被代理类, 代理类和被代理类的对象在编译时就被创建了<br>动态代理只能由被代理类手动创建对象, 正因如此代理类依托于反射的Constructor.newInstance()才能在运行时动态创建对象<h4 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h4></li>\n<li>静态代理是在编译时就已经明确生成的，它是通过直接<code>new</code>出目标对象来完成代理操作的。</li>\n<li>在静态代理中，代理类和目标类的关系是硬编码的，代理类必须实现与目标类相同的接口或者直接继承目标类，且代理类的行为在编译时就已经确定。</li>\n<li><strong>关键点</strong>：静态代理确实在编译时就已经生成了代理类，且代理类<strong>不依赖反射</strong>。<h4 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h4></li>\n<li>动态代理在运行时<strong>通过反射机制</strong>创建代理对象，并将目标方法的调用交给代理处理器（<code>InvocationHandler</code>）。</li>\n<li>它不需要手动写代理类，而是通<strong>过<code>Proxy.newProxyInstance()</code>方法动态生成代理类</strong>。这样，你可以通过一个通用的<code>InvocationHandler</code>处理不同的目标对象，减少了代码重复和硬编码。</li>\n<li><strong>动态代理则是利用反射</strong>,通过 <code>Proxy.newProxyInstance()</code> 方法，动态代理不需要编写代理类并将方法调用委托给 <code>InvocationHandler</code> 中的 <code>invoke()</code> 方法。虽然最终也会通过 <code>new</code> 创建目标对象，但代理类的生成和方法调用的分发机制是完全动态的。</li>\n<li><strong>关键点</strong>：动态代理依赖反射，且代理类是在运行时动态生成的，目标对象的方法调用由<code>InvocationHandler</code>来决定。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17329446161661732944615286.png\" alt=\"17329446161661732944615286.png|700x342\"><h2 id=\"动态代理的运用\"><a href=\"#动态代理的运用\" class=\"headerlink\" title=\"动态代理的运用\"></a>动态代理的运用</h2><h3 id=\"代理模式优缺点\"><a href=\"#代理模式优缺点\" class=\"headerlink\" title=\"代理模式优缺点\"></a>代理模式优缺点</h3></li>\n</ul>\n</li>\n<li>优点: <ol>\n<li>代理模式在客户端与目标对象之间起到一个中介作用和<strong>保护目标对象</strong>的作用 -&gt; 隐藏卖家</li>\n<li>代理对象可以<strong>增强目标对象的功能</strong>，被用来间接访问底层对象，与原始对象具有相同的 hashCode  -&gt; 增强功能</li>\n<li>代理模式能将客户端与目标对象分离，在一定程度上<strong>降低了系统的耦合度</strong>  -&gt; 降低</li>\n</ol>\n</li>\n<li>缺点：增加了系统的复杂度<h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3></li>\n<li><strong>通过代理类实现接口的方式</strong> -&gt; JDK动态代理 -&gt; 反射</li>\n<li>JDK动态代理主要涉及两个类：<strong>java.lang.reflect.Proxy</strong>和 <strong>java.lang.reflect.InvocationHandler</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 被代理接口</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">serve</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 被代理实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">serve</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Service is being served.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态代理类的 InvocationHandler</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ServiceInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceInvocationHandler</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before serving...&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args);  <span class=\"comment\">// 调用目标对象的方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After serving...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ProxyTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceImpl</span>();</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (Service) Proxy.newProxyInstance(</span><br><span class=\"line\">                service.getClass().getClassLoader(), <span class=\"comment\">// 被代理类的类加载器类型</span></span><br><span class=\"line\">                service.getClass().getInterfaces(),  <span class=\"comment\">// 被代理类的接口类型</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInvocationHandler</span>(service) <span class=\"comment\">// 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"comment\">// \t\ta.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class=\"line\">        <span class=\"comment\">//      b.然后根据相应的字节码转换成对应的class，</span></span><br><span class=\"line\">        <span class=\"comment\">//       c.然后调用newInstance()创建代理实例  例如: $proxy0</span></span><br><span class=\"line\">        proxy.serve();  <span class=\"comment\">// 等价于 handle.invoke()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代理类内部结构</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">$Proxy0</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m1;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m3; <span class=\"comment\">// 目标方法server()</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m2;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m0;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> $Proxy0(InvocationHandler var1) <span class=\"keyword\">throws</span>  &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object var1)</span> <span class=\"keyword\">throws</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Boolean)<span class=\"built_in\">super</span>.h.invoke(<span class=\"built_in\">this</span>, m1, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;var1&#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> var3;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var4) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UndeclaredThrowableException</span>(var4);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">serve</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  &#123; <span class=\"comment\">// 目标方法</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.h.invoke(<span class=\"built_in\">this</span>, m3, (Object[])<span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> var2;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UndeclaredThrowableException</span>(var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (String)<span class=\"built_in\">super</span>.h.invoke(<span class=\"built_in\">this</span>, m2, (Object[])<span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> var2;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UndeclaredThrowableException</span>(var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Integer)<span class=\"built_in\">super</span>.h.invoke(<span class=\"built_in\">this</span>, m0, (Object[])<span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> var2;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UndeclaredThrowableException</span>(var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            m1 = Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>).getMethod(<span class=\"string\">&quot;equals&quot;</span>, Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>));</span><br><span class=\"line\">            m3 = Class.forName(<span class=\"string\">&quot;proxy.Service&quot;</span>).getMethod(<span class=\"string\">&quot;serve&quot;</span>); <span class=\"comment\">// 反射加载方法</span></span><br><span class=\"line\">            m2 = Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>).getMethod(<span class=\"string\">&quot;toString&quot;</span>);</span><br><span class=\"line\">            m0 = Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>).getMethod(<span class=\"string\">&quot;hashCode&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchMethodError</span>(var2.getMessage());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17328903987391732890398584.png\" alt=\"17328903987391732890398584.png\"></p>\n<h3 id=\"调用处理器和反射类\"><a href=\"#调用处理器和反射类\" class=\"headerlink\" title=\"调用处理器和反射类\"></a>调用处理器和反射类</h3><ul>\n<li><strong>Proxy</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Proxy提供用于创建动态类和实例的静态方法, 创建的所有动态代理类的超类</span></span><br><span class=\"line\">Proxy::newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h);</span><br><span class=\"line\"><span class=\"comment\">// 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</span></span><br><span class=\"line\">Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>InvocationHandler</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于获取指定代理对象所关联的调用处理器</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> InvocationHandler <span class=\"title function_\">getInvocationHandler</span><span class=\"params\">(Object proxy)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 返回指定接口的代理类</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces);</span><br><span class=\"line\"><span class=\"comment\">// 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> Object <span class=\"title function_\">newProxyInstance</span><span class=\"params\">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 返回 cl 是否为一个代理类</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isProxyClass</span><span class=\"params\">(Class&lt;?&gt; cl)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法<h3 id=\"CGLIB代理\"><a href=\"#CGLIB代理\" class=\"headerlink\" title=\"CGLIB代理\"></a>CGLIB代理</h3></li>\n<li><strong>通过代理类继承被代理类重写其方法的方式</strong> -&gt; CGLIB代理 -&gt; 字节码</li>\n<li>在运行时通过继承的方式为目标类创建代理类。与 JDK 动态代理不同，CGLIB 不要求代理类实现接口，而是<strong>直接对被代理类进行字节码增强</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 被代理类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">serve</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Service is being served.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ServiceInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceInterceptor</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before serving...&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invokeSuper(target, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After serving...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Service</span>();<span class=\"comment\">// 被代理类对象</span></span><br><span class=\"line\">       \t<span class=\"comment\">// Enhancer：CGLIB 的核心类，用于生成代理类</span></span><br><span class=\"line\">        <span class=\"comment\">// MethodInterceptor：用于定义方法拦截逻辑</span></span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (Service) Enhancer.create(Service.class, <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInterceptor</span>(service));</span><br><span class=\"line\">        <span class=\"comment\">// MethodProxy：用于调用父类的方法</span></span><br><span class=\"line\">        proxy.intercept();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心</li>\n<li>自定义 <code>MethodInterceptor</code> 实现类并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法</li>\n<li>通过 <code>Enhancer</code>类来动态获取被代理类，通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类, 当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法 这里的 <code>intercept</code>类似于 <code>invoke</code>方法<h2 id=\"JDK和CGLIB代理的对比\"><a href=\"#JDK和CGLIB代理的对比\" class=\"headerlink\" title=\"JDK和CGLIB代理的对比\"></a>JDK和CGLIB代理的对比</h2></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>对比</th>\n<th>JDK代理</th>\n<th>CGLIB代理</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>代理对象生成方式</td>\n<td><strong>基于反射生成$proxy0代理类</strong></td>\n<td><strong>基于字节码生成子类</strong></td>\n</tr>\n<tr>\n<td>方法的调用方式</td>\n<td><strong>基于proxy.方法调用</strong></td>\n<td><strong>基于底层子类super()调用</strong></td>\n</tr>\n<tr>\n<td>初始化效率</td>\n<td><strong>反射newInstance生成对象效率高</strong></td>\n<td>直接生成子类对象效率低</td>\n</tr>\n<tr>\n<td>方法执行效率</td>\n<td>执行效率低</td>\n<td><strong>执行效率高(直接调用父类方法)</strong></td>\n</tr>\n<tr>\n<td>spring默认策略</td>\n<td>有接口</td>\n<td>无接口</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><p>总结: CGLIB 由于主要基于字节码操作，如果是<strong>只要初始化一次且方法要长期被调用</strong>, 性能通常高于 JDK 动态代理, 适用于不需要频繁修改代理逻辑的场景，因为cglib代理是子类,父类修改了子类也要跟着改, 并且内存占用要高于jdk代理</p>\n<h2 id=\"工厂代理模式\"><a href=\"#工厂代理模式\" class=\"headerlink\" title=\"工厂代理模式\"></a>工厂代理模式</h2></li>\n<li><p>工厂代理模式是一种将<strong>工厂模式</strong>与<strong>代理模式</strong>相结合的设计模式。通过工厂方法创建代理对象，从而<strong>简化代理对象的创建流程</strong>，同时增强代理模式的灵活性</p>\n</li>\n<li>工厂方法屏蔽了对象的创建细节，提高了代码的灵活性和扩展性。<h3 id=\"动态工厂代理模式\"><a href=\"#动态工厂代理模式\" class=\"headerlink\" title=\"动态工厂代理模式\"></a>动态工厂代理模式</h3></li>\n<li>动态工厂代理模式结合了 <strong>动态代理</strong> 和 <strong>工厂模式</strong>，通过工厂方法动态生成代理对象。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">serve</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 目标类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RealService</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">serve</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;RealService is serving...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态代理处理器</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ServiceInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceInvocationHandler</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before method: &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args); <span class=\"comment\">// 调用目标对象的方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After method: &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Service <span class=\"title function_\">getProxy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RealService</span> <span class=\"variable\">realService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RealService</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Service) Proxy.newProxyInstance(</span><br><span class=\"line\">            realService.getClass().getClassLoader(),</span><br><span class=\"line\">            realService.getClass().getInterfaces(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInvocationHandler</span>(realService) <span class=\"comment\">// 传入动态代理处理器</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> ServiceFactory.getProxy(); <span class=\"comment\">// 解耦了代理类创建过程</span></span><br><span class=\"line\">        service.serve();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"工厂代理模式的优缺点\"><a href=\"#工厂代理模式的优缺点\" class=\"headerlink\" title=\"工厂代理模式的优缺点\"></a>工厂代理模式的优缺点</h3><strong>优点：</strong></li>\n</ul>\n<ol>\n<li><strong>解耦</strong>：将代理对象的创建逻辑封装到工厂类中，客户端代码不需要关心代理对象的实现细节。</li>\n<li><strong>灵活性</strong>：可以动态生成代理对象，支持多种代理模式（如静态代理、动态代理、CGLIB 代理）。</li>\n<li><strong>扩展性</strong>：如果需要更改代理逻辑或代理方式，只需修改工厂类的实现，而无需影响客户端代码。<br><strong>缺点：</strong></li>\n<li><strong>复杂性</strong>：相比直接使用代理模式，工厂代理模式的实现复杂度更高。</li>\n<li><strong>性能开销</strong>：动态代理可能增加运行时的性能开销（如反射调用）<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><h3 id=\"性能开销\"><a href=\"#性能开销\" class=\"headerlink\" title=\"性能开销\"></a>性能开销</h3></li>\n</ol>\n<ul>\n<li><strong>JDK 动态代理的性能</strong>：JDK 动态代理基于反射机制生成代理对象和方法调用，因此<strong>每次方法调用都会涉及到反射</strong>，性能相对较低，尤其是在大量调用的场景中。如果对性能要求非常高的场合，尽量避免过多使用 JDK 动态代理。</li>\n<li><strong>CGLIB 代理的性能</strong>：CGLIB 通过字节码技术生成子类代理，因此没有反射带来的性能开销，相对较为高效。不过，CGLIB 的代理对象是通过继承生成的，这可能导致<strong>对目标类的修改（如方法的添加、删除等）对代理类的影响较大</strong>，可能需要重新生成代理类。<h3 id=\"代理对象的生命周期\"><a href=\"#代理对象的生命周期\" class=\"headerlink\" title=\"代理对象的生命周期\"></a>代理对象的生命周期</h3></li>\n<li>在使用动态代理时，代理对象的生命周期通常由代理工厂管理。确保代理对象在适当的时机销毁，以避免内存泄漏。特别是在使用动态代理时，通过反射和字节码生成代理对象时，代理对象可能会占用更多的内存，因此需要注意对象的销毁和资源回收。</li>\n<li>对于 <strong>CGLIB 代理</strong>，需要注意，由于它是通过继承目标类生成的代理对象，所以会增加内存占用。并且，CGLIB 对目标类的生成依赖于字节码操作，因此需要确保代理类在不再使用时被正确清理。<h3 id=\"动态代理和AOP的结合\"><a href=\"#动态代理和AOP的结合\" class=\"headerlink\" title=\"动态代理和AOP的结合\"></a>动态代理和AOP的结合</h3></li>\n<li><strong>AOP（面向切面编程）</strong>：动态代理常与 AOP 结合使用，尤其是在 Spring 框架中，动态代理用于增强类的方法。通过 AOP，可以在不改变目标类的代码情况下，在方法执行前后执行额外的操作，例如事务管理、权限验证、日志记录等。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17601594300691760159429855.png\" alt=\"17601594300691760159429855.png\"></li>\n<li>在 Spring 框架中：<ul>\n<li>如果被代理类实现了接口，Spring 会使用 JDK 动态代理(默认方式)</li>\n<li>如果被代理类没有实现接口，Spring 会使用 CGLIB 代理</li>\n</ul>\n</li>\n<li>通过 AOP，可以灵活地为目标对象动态织入切面，增强其功能。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17601593600641760159359315.png\" alt=\"17601593600641760159359315.png|700x691\"><h3 id=\"获取代理类对象\"><a href=\"#获取代理类对象\" class=\"headerlink\" title=\"获取代理类对象\"></a>获取代理类对象</h3><h5 id=\"具体情况：\"><a href=\"#具体情况：\" class=\"headerlink\" title=\"具体情况：\"></a>具体情况：</h5></li>\n</ul>\n<ol>\n<li><strong>没有AOP代理的情况：</strong> 如果你注入的是一个普通的类，并且没有使用 Spring AOP 的代理机制，那么 <code>@Autowired</code> 会注入这个类的实例对象。</li>\n<li><strong>有AOP代理的情况：</strong> 如果你的类上使用了 AOP 功能（比如事务、日志、权限等），Spring 会为这个类创建一个代理对象。这时，<code>@Autowired</code> 注入的就是代理类对象，而不是原始类的实例。</li>\n<li>使用 <strong><code>@Transactional</code> 注解</strong>的代理对象, spring 会为你创建一个代理对象来处理事务<h5 id=\"代理类型：\"><a href=\"#代理类型：\" class=\"headerlink\" title=\"代理类型：\"></a>代理类型：</h5></li>\n</ol>\n<ul>\n<li><strong>JDK 动态代理</strong>：当你注入的是接口类型的类时，Spring 会通过 JDK 动态代理来创建一个实现了该接口的代理类。</li>\n<li><strong>CGLIB 代理</strong>：当你注入的是没有接口的类时，Spring 会使用 CGLIB 生成一个该类的子类作为代理对象。<h5 id=\"如何判断注入的是代理对象：\"><a href=\"#如何判断注入的是代理对象：\" class=\"headerlink\" title=\"如何判断注入的是代理对象：\"></a>如何判断注入的是代理对象：</h5>可以通过 <code>getClass().getName()</code> 来检查实例的类型。如果你看到的是一个类似 <code>com.sun.proxy.$Proxy</code> 的类名，那就说明注入的是代理对象。<h5 id=\"获取当前代理对象\"><a href=\"#获取当前代理对象\" class=\"headerlink\" title=\"获取当前代理对象\"></a>获取当前代理对象</h5></li>\n<li>Spring AOP 提供了 <code>AopContext</code>，它允许你在方法调用中访问当前的代理对象:<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取代理对象的 AopProxy</span></span><br><span class=\"line\"><span class=\"type\">AopProxy</span> <span class=\"variable\">aopProxy</span> <span class=\"operator\">=</span> (AopProxy) AopContext.currentProxy();</span><br><span class=\"line\"><span class=\"comment\">// 获取代理对象</span></span><br><span class=\"line\"><span class=\"type\">MyService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (MyService) aopProxy.getProxy();</span><br></pre></td></tr></table></figure></li>\n<li>通过 <code>ApplicationContext</code> 获取代理对象: <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">MyService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (MyService) applicationContext.getBean(MyService.class);</span><br></pre></td></tr></table></figure></li>\n<li>如果你想判断某个对象是否为代理对象，可以使用 <strong>AopUtils.isAopProxy()</strong> 方法</li>\n</ul>\n","cover":"/img/wallpaper/view13.jpg","cover_type":"img","excerpt":"","more":"<h1 id=\"PROXY\"><a href=\"#PROXY\" class=\"headerlink\" title=\"PROXY\"></a>PROXY</h1><h2 id=\"什么是代理\"><a href=\"#什么是代理\" class=\"headerlink\" title=\"什么是代理\"></a>什么是代理</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li>代理分为: <strong>静态代理</strong>和<strong>动态代理</strong></li>\n<li>动态代理细分为2种: <strong>JDK代理和CGLIB代理</strong></li>\n<li>为什么要有代理:  由于某些原因需要给某对象提供一个代理以控制对该对象的访问,访 问对象不适合或者不能直接引用为目标对象, 代理对象作为访问对象和目标对象之间的中介(就像访客 &lt;-&gt; 售票处 &lt;-&gt; 火车站)<h3 id=\"静态代理-static-proxy\"><a href=\"#静态代理-static-proxy\" class=\"headerlink\" title=\"静态代理(static proxy)\"></a>静态代理(static proxy)</h3></li>\n<li>静态代理是指代理类提前在编译时期就创建好的, 代理类和被代理类的的关系是固定的，<strong>代理类会持有目标类的引用，并通过该引用调用目标类的方法</strong>。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 被代理接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">userService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">select</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 被代理实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">userServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">userService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">select</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Service is being served.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">userServiceProxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> userService userservice;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">userServiceProxy</span><span class=\"params\">(userService userservice)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userservice = userservice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">proxyService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before serving...&quot;</span>);</span><br><span class=\"line\">        userservice.select();  <span class=\"comment\">// 调用目标对象的方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After serving...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">userService</span> <span class=\"variable\">userservice</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">userServiceImpl</span>();</span><br><span class=\"line\">        <span class=\"type\">userService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">userServiceProxy</span>(userservice);</span><br><span class=\"line\">        proxy.proxyService();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么类可以动态的生成\"><a href=\"#为什么类可以动态的生成\" class=\"headerlink\" title=\"为什么类可以动态的生成\"></a>为什么类可以动态的生成</h3></li>\n<li>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中<strong>加载阶段</strong>需要完成以下3件事情：<ul>\n<li>通过<strong>一个类的全限定名</strong>来获取定义此类的二进制字节流, <strong>每个类都会有一个对应的 <code>.class</code> 文件</strong>,该文件存储了类的字节码, 通过类加载器从类路径中查找并加载这个字节流</li>\n<li>.class 文件中的字节码经过<strong>解码</strong>后，JVM 会将这些<strong>字节码转换为方法区的数据结构</strong>，即方法区的运行时数据（运行时常量池、类的字段、<strong>方法</strong>等）。这些数据结构用于后续的类操作。</li>\n<li><strong>每个加载的类都会有一个对应的 <code>Class</code> 对象</strong>，它代表了该类的元数据, 通过 <code>Class</code> 对象，JVM 可以访问该类的各种信息，如字段、<strong>方法</strong>、构造函数、注解等。这个 <code>Class</code> 对象也提供了<strong>反射</strong>机制的入口，可以让你<strong>动态地获取和操作类的信息</strong>（例如获取字段、调用方法、创建对象等)</li>\n<li><strong>反射就是通过 <code>Class</code> 对象来动态获取类的信息，甚至在运行时动态生成和操作类</strong><h3 id=\"静态代理和动态代理的区别\"><a href=\"#静态代理和动态代理的区别\" class=\"headerlink\" title=\"静态代理和动态代理的区别\"></a>静态代理和动态代理的区别</h3>静态代理靠手动去创建代理类和被代理类, 代理类和被代理类的对象在编译时就被创建了<br>动态代理只能由被代理类手动创建对象, 正因如此代理类依托于反射的Constructor.newInstance()才能在运行时动态创建对象<h4 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h4></li>\n<li>静态代理是在编译时就已经明确生成的，它是通过直接<code>new</code>出目标对象来完成代理操作的。</li>\n<li>在静态代理中，代理类和目标类的关系是硬编码的，代理类必须实现与目标类相同的接口或者直接继承目标类，且代理类的行为在编译时就已经确定。</li>\n<li><strong>关键点</strong>：静态代理确实在编译时就已经生成了代理类，且代理类<strong>不依赖反射</strong>。<h4 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h4></li>\n<li>动态代理在运行时<strong>通过反射机制</strong>创建代理对象，并将目标方法的调用交给代理处理器（<code>InvocationHandler</code>）。</li>\n<li>它不需要手动写代理类，而是通<strong>过<code>Proxy.newProxyInstance()</code>方法动态生成代理类</strong>。这样，你可以通过一个通用的<code>InvocationHandler</code>处理不同的目标对象，减少了代码重复和硬编码。</li>\n<li><strong>动态代理则是利用反射</strong>,通过 <code>Proxy.newProxyInstance()</code> 方法，动态代理不需要编写代理类并将方法调用委托给 <code>InvocationHandler</code> 中的 <code>invoke()</code> 方法。虽然最终也会通过 <code>new</code> 创建目标对象，但代理类的生成和方法调用的分发机制是完全动态的。</li>\n<li><strong>关键点</strong>：动态代理依赖反射，且代理类是在运行时动态生成的，目标对象的方法调用由<code>InvocationHandler</code>来决定。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17329446161661732944615286.png\" alt=\"17329446161661732944615286.png|700x342\"><h2 id=\"动态代理的运用\"><a href=\"#动态代理的运用\" class=\"headerlink\" title=\"动态代理的运用\"></a>动态代理的运用</h2><h3 id=\"代理模式优缺点\"><a href=\"#代理模式优缺点\" class=\"headerlink\" title=\"代理模式优缺点\"></a>代理模式优缺点</h3></li>\n</ul>\n</li>\n<li>优点: <ol>\n<li>代理模式在客户端与目标对象之间起到一个中介作用和<strong>保护目标对象</strong>的作用 -&gt; 隐藏卖家</li>\n<li>代理对象可以<strong>增强目标对象的功能</strong>，被用来间接访问底层对象，与原始对象具有相同的 hashCode  -&gt; 增强功能</li>\n<li>代理模式能将客户端与目标对象分离，在一定程度上<strong>降低了系统的耦合度</strong>  -&gt; 降低</li>\n</ol>\n</li>\n<li>缺点：增加了系统的复杂度<h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3></li>\n<li><strong>通过代理类实现接口的方式</strong> -&gt; JDK动态代理 -&gt; 反射</li>\n<li>JDK动态代理主要涉及两个类：<strong>java.lang.reflect.Proxy</strong>和 <strong>java.lang.reflect.InvocationHandler</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 被代理接口</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">serve</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 被代理实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">serve</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Service is being served.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态代理类的 InvocationHandler</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ServiceInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceInvocationHandler</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before serving...&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args);  <span class=\"comment\">// 调用目标对象的方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After serving...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ProxyTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceImpl</span>();</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (Service) Proxy.newProxyInstance(</span><br><span class=\"line\">                service.getClass().getClassLoader(), <span class=\"comment\">// 被代理类的类加载器类型</span></span><br><span class=\"line\">                service.getClass().getInterfaces(),  <span class=\"comment\">// 被代理类的接口类型</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInvocationHandler</span>(service) <span class=\"comment\">// 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"comment\">// \t\ta.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class=\"line\">        <span class=\"comment\">//      b.然后根据相应的字节码转换成对应的class，</span></span><br><span class=\"line\">        <span class=\"comment\">//       c.然后调用newInstance()创建代理实例  例如: $proxy0</span></span><br><span class=\"line\">        proxy.serve();  <span class=\"comment\">// 等价于 handle.invoke()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代理类内部结构</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">$Proxy0</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m1;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m3; <span class=\"comment\">// 目标方法server()</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m2;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m0;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> $Proxy0(InvocationHandler var1) <span class=\"keyword\">throws</span>  &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object var1)</span> <span class=\"keyword\">throws</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Boolean)<span class=\"built_in\">super</span>.h.invoke(<span class=\"built_in\">this</span>, m1, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;var1&#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> var3;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var4) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UndeclaredThrowableException</span>(var4);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">serve</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  &#123; <span class=\"comment\">// 目标方法</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.h.invoke(<span class=\"built_in\">this</span>, m3, (Object[])<span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> var2;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UndeclaredThrowableException</span>(var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (String)<span class=\"built_in\">super</span>.h.invoke(<span class=\"built_in\">this</span>, m2, (Object[])<span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> var2;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UndeclaredThrowableException</span>(var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Integer)<span class=\"built_in\">super</span>.h.invoke(<span class=\"built_in\">this</span>, m0, (Object[])<span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> var2;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UndeclaredThrowableException</span>(var3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            m1 = Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>).getMethod(<span class=\"string\">&quot;equals&quot;</span>, Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>));</span><br><span class=\"line\">            m3 = Class.forName(<span class=\"string\">&quot;proxy.Service&quot;</span>).getMethod(<span class=\"string\">&quot;serve&quot;</span>); <span class=\"comment\">// 反射加载方法</span></span><br><span class=\"line\">            m2 = Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>).getMethod(<span class=\"string\">&quot;toString&quot;</span>);</span><br><span class=\"line\">            m0 = Class.forName(<span class=\"string\">&quot;java.lang.Object&quot;</span>).getMethod(<span class=\"string\">&quot;hashCode&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchMethodError</span>(var2.getMessage());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17328903987391732890398584.png\" alt=\"17328903987391732890398584.png\"></p>\n<h3 id=\"调用处理器和反射类\"><a href=\"#调用处理器和反射类\" class=\"headerlink\" title=\"调用处理器和反射类\"></a>调用处理器和反射类</h3><ul>\n<li><strong>Proxy</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Proxy提供用于创建动态类和实例的静态方法, 创建的所有动态代理类的超类</span></span><br><span class=\"line\">Proxy::newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h);</span><br><span class=\"line\"><span class=\"comment\">// 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用</span></span><br><span class=\"line\">Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>InvocationHandler</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于获取指定代理对象所关联的调用处理器</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> InvocationHandler <span class=\"title function_\">getInvocationHandler</span><span class=\"params\">(Object proxy)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 返回指定接口的代理类</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces);</span><br><span class=\"line\"><span class=\"comment\">// 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> Object <span class=\"title function_\">newProxyInstance</span><span class=\"params\">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 返回 cl 是否为一个代理类</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isProxyClass</span><span class=\"params\">(Class&lt;?&gt; cl)</span>;</span><br></pre></td></tr></table></figure></li>\n<li>通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法<h3 id=\"CGLIB代理\"><a href=\"#CGLIB代理\" class=\"headerlink\" title=\"CGLIB代理\"></a>CGLIB代理</h3></li>\n<li><strong>通过代理类继承被代理类重写其方法的方式</strong> -&gt; CGLIB代理 -&gt; 字节码</li>\n<li>在运行时通过继承的方式为目标类创建代理类。与 JDK 动态代理不同，CGLIB 不要求代理类实现接口，而是<strong>直接对被代理类进行字节码增强</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 被代理类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">serve</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Service is being served.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ServiceInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceInterceptor</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before serving...&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invokeSuper(target, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After serving...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProxyTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Service</span>();<span class=\"comment\">// 被代理类对象</span></span><br><span class=\"line\">       \t<span class=\"comment\">// Enhancer：CGLIB 的核心类，用于生成代理类</span></span><br><span class=\"line\">        <span class=\"comment\">// MethodInterceptor：用于定义方法拦截逻辑</span></span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (Service) Enhancer.create(Service.class, <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInterceptor</span>(service));</span><br><span class=\"line\">        <span class=\"comment\">// MethodProxy：用于调用父类的方法</span></span><br><span class=\"line\">        proxy.intercept();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心</li>\n<li>自定义 <code>MethodInterceptor</code> 实现类并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法</li>\n<li>通过 <code>Enhancer</code>类来动态获取被代理类，通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类, 当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法 这里的 <code>intercept</code>类似于 <code>invoke</code>方法<h2 id=\"JDK和CGLIB代理的对比\"><a href=\"#JDK和CGLIB代理的对比\" class=\"headerlink\" title=\"JDK和CGLIB代理的对比\"></a>JDK和CGLIB代理的对比</h2></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>对比</th>\n<th>JDK代理</th>\n<th>CGLIB代理</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>代理对象生成方式</td>\n<td><strong>基于反射生成$proxy0代理类</strong></td>\n<td><strong>基于字节码生成子类</strong></td>\n</tr>\n<tr>\n<td>方法的调用方式</td>\n<td><strong>基于proxy.方法调用</strong></td>\n<td><strong>基于底层子类super()调用</strong></td>\n</tr>\n<tr>\n<td>初始化效率</td>\n<td><strong>反射newInstance生成对象效率高</strong></td>\n<td>直接生成子类对象效率低</td>\n</tr>\n<tr>\n<td>方法执行效率</td>\n<td>执行效率低</td>\n<td><strong>执行效率高(直接调用父类方法)</strong></td>\n</tr>\n<tr>\n<td>spring默认策略</td>\n<td>有接口</td>\n<td>无接口</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><p>总结: CGLIB 由于主要基于字节码操作，如果是<strong>只要初始化一次且方法要长期被调用</strong>, 性能通常高于 JDK 动态代理, 适用于不需要频繁修改代理逻辑的场景，因为cglib代理是子类,父类修改了子类也要跟着改, 并且内存占用要高于jdk代理</p>\n<h2 id=\"工厂代理模式\"><a href=\"#工厂代理模式\" class=\"headerlink\" title=\"工厂代理模式\"></a>工厂代理模式</h2></li>\n<li><p>工厂代理模式是一种将<strong>工厂模式</strong>与<strong>代理模式</strong>相结合的设计模式。通过工厂方法创建代理对象，从而<strong>简化代理对象的创建流程</strong>，同时增强代理模式的灵活性</p>\n</li>\n<li>工厂方法屏蔽了对象的创建细节，提高了代码的灵活性和扩展性。<h3 id=\"动态工厂代理模式\"><a href=\"#动态工厂代理模式\" class=\"headerlink\" title=\"动态工厂代理模式\"></a>动态工厂代理模式</h3></li>\n<li>动态工厂代理模式结合了 <strong>动态代理</strong> 和 <strong>工厂模式</strong>，通过工厂方法动态生成代理对象。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">serve</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 目标类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RealService</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Service</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">serve</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;RealService is serving...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态代理处理器</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ServiceInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">InvocationHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ServiceInvocationHandler</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Before method: &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> method.invoke(target, args); <span class=\"comment\">// 调用目标对象的方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;After method: &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Service <span class=\"title function_\">getProxy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RealService</span> <span class=\"variable\">realService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RealService</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Service) Proxy.newProxyInstance(</span><br><span class=\"line\">            realService.getClass().getClassLoader(),</span><br><span class=\"line\">            realService.getClass().getInterfaces(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ServiceInvocationHandler</span>(realService) <span class=\"comment\">// 传入动态代理处理器</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Service</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> ServiceFactory.getProxy(); <span class=\"comment\">// 解耦了代理类创建过程</span></span><br><span class=\"line\">        service.serve();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"工厂代理模式的优缺点\"><a href=\"#工厂代理模式的优缺点\" class=\"headerlink\" title=\"工厂代理模式的优缺点\"></a>工厂代理模式的优缺点</h3><strong>优点：</strong></li>\n</ul>\n<ol>\n<li><strong>解耦</strong>：将代理对象的创建逻辑封装到工厂类中，客户端代码不需要关心代理对象的实现细节。</li>\n<li><strong>灵活性</strong>：可以动态生成代理对象，支持多种代理模式（如静态代理、动态代理、CGLIB 代理）。</li>\n<li><strong>扩展性</strong>：如果需要更改代理逻辑或代理方式，只需修改工厂类的实现，而无需影响客户端代码。<br><strong>缺点：</strong></li>\n<li><strong>复杂性</strong>：相比直接使用代理模式，工厂代理模式的实现复杂度更高。</li>\n<li><strong>性能开销</strong>：动态代理可能增加运行时的性能开销（如反射调用）<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><h3 id=\"性能开销\"><a href=\"#性能开销\" class=\"headerlink\" title=\"性能开销\"></a>性能开销</h3></li>\n</ol>\n<ul>\n<li><strong>JDK 动态代理的性能</strong>：JDK 动态代理基于反射机制生成代理对象和方法调用，因此<strong>每次方法调用都会涉及到反射</strong>，性能相对较低，尤其是在大量调用的场景中。如果对性能要求非常高的场合，尽量避免过多使用 JDK 动态代理。</li>\n<li><strong>CGLIB 代理的性能</strong>：CGLIB 通过字节码技术生成子类代理，因此没有反射带来的性能开销，相对较为高效。不过，CGLIB 的代理对象是通过继承生成的，这可能导致<strong>对目标类的修改（如方法的添加、删除等）对代理类的影响较大</strong>，可能需要重新生成代理类。<h3 id=\"代理对象的生命周期\"><a href=\"#代理对象的生命周期\" class=\"headerlink\" title=\"代理对象的生命周期\"></a>代理对象的生命周期</h3></li>\n<li>在使用动态代理时，代理对象的生命周期通常由代理工厂管理。确保代理对象在适当的时机销毁，以避免内存泄漏。特别是在使用动态代理时，通过反射和字节码生成代理对象时，代理对象可能会占用更多的内存，因此需要注意对象的销毁和资源回收。</li>\n<li>对于 <strong>CGLIB 代理</strong>，需要注意，由于它是通过继承目标类生成的代理对象，所以会增加内存占用。并且，CGLIB 对目标类的生成依赖于字节码操作，因此需要确保代理类在不再使用时被正确清理。<h3 id=\"动态代理和AOP的结合\"><a href=\"#动态代理和AOP的结合\" class=\"headerlink\" title=\"动态代理和AOP的结合\"></a>动态代理和AOP的结合</h3></li>\n<li><strong>AOP（面向切面编程）</strong>：动态代理常与 AOP 结合使用，尤其是在 Spring 框架中，动态代理用于增强类的方法。通过 AOP，可以在不改变目标类的代码情况下，在方法执行前后执行额外的操作，例如事务管理、权限验证、日志记录等。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17601594300691760159429855.png\" alt=\"17601594300691760159429855.png\"></li>\n<li>在 Spring 框架中：<ul>\n<li>如果被代理类实现了接口，Spring 会使用 JDK 动态代理(默认方式)</li>\n<li>如果被代理类没有实现接口，Spring 会使用 CGLIB 代理</li>\n</ul>\n</li>\n<li>通过 AOP，可以灵活地为目标对象动态织入切面，增强其功能。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17601593600641760159359315.png\" alt=\"17601593600641760159359315.png|700x691\"><h3 id=\"获取代理类对象\"><a href=\"#获取代理类对象\" class=\"headerlink\" title=\"获取代理类对象\"></a>获取代理类对象</h3><h5 id=\"具体情况：\"><a href=\"#具体情况：\" class=\"headerlink\" title=\"具体情况：\"></a>具体情况：</h5></li>\n</ul>\n<ol>\n<li><strong>没有AOP代理的情况：</strong> 如果你注入的是一个普通的类，并且没有使用 Spring AOP 的代理机制，那么 <code>@Autowired</code> 会注入这个类的实例对象。</li>\n<li><strong>有AOP代理的情况：</strong> 如果你的类上使用了 AOP 功能（比如事务、日志、权限等），Spring 会为这个类创建一个代理对象。这时，<code>@Autowired</code> 注入的就是代理类对象，而不是原始类的实例。</li>\n<li>使用 <strong><code>@Transactional</code> 注解</strong>的代理对象, spring 会为你创建一个代理对象来处理事务<h5 id=\"代理类型：\"><a href=\"#代理类型：\" class=\"headerlink\" title=\"代理类型：\"></a>代理类型：</h5></li>\n</ol>\n<ul>\n<li><strong>JDK 动态代理</strong>：当你注入的是接口类型的类时，Spring 会通过 JDK 动态代理来创建一个实现了该接口的代理类。</li>\n<li><strong>CGLIB 代理</strong>：当你注入的是没有接口的类时，Spring 会使用 CGLIB 生成一个该类的子类作为代理对象。<h5 id=\"如何判断注入的是代理对象：\"><a href=\"#如何判断注入的是代理对象：\" class=\"headerlink\" title=\"如何判断注入的是代理对象：\"></a>如何判断注入的是代理对象：</h5>可以通过 <code>getClass().getName()</code> 来检查实例的类型。如果你看到的是一个类似 <code>com.sun.proxy.$Proxy</code> 的类名，那就说明注入的是代理对象。<h5 id=\"获取当前代理对象\"><a href=\"#获取当前代理对象\" class=\"headerlink\" title=\"获取当前代理对象\"></a>获取当前代理对象</h5></li>\n<li>Spring AOP 提供了 <code>AopContext</code>，它允许你在方法调用中访问当前的代理对象:<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取代理对象的 AopProxy</span></span><br><span class=\"line\"><span class=\"type\">AopProxy</span> <span class=\"variable\">aopProxy</span> <span class=\"operator\">=</span> (AopProxy) AopContext.currentProxy();</span><br><span class=\"line\"><span class=\"comment\">// 获取代理对象</span></span><br><span class=\"line\"><span class=\"type\">MyService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (MyService) aopProxy.getProxy();</span><br></pre></td></tr></table></figure></li>\n<li>通过 <code>ApplicationContext</code> 获取代理对象: <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">MyService</span> <span class=\"variable\">proxy</span> <span class=\"operator\">=</span> (MyService) applicationContext.getBean(MyService.class);</span><br></pre></td></tr></table></figure></li>\n<li>如果你想判断某个对象是否为代理对象，可以使用 <strong>AopUtils.isAopProxy()</strong> 方法</li>\n</ul>\n"},{"title":"深入理解多表关联的数据库设计","date":"2024-11-12T12:07:58.000Z","_content":"\n# 深入理解多表关联的数据库设计\n\n## 一.什么是多表关联查询\n\n- 在mysql中通常对不同表之间设置一个外键(物理和逻辑)  -> 逻辑外键最为适合\n  - 为什么是逻辑外键?\n    - 在数据库设计中，我们经常会用到外键来维护表与表之间的关系。然而，使用外键有时会带来一些性能和维护上的问题，比如在进行大量插入、删除操作时，外键约束可能会引发锁竞争，影响操作速度。为了克服这些问题，逻辑外键应运而生。\n\n- 三种多表关联关系\n  - 一对一 ：例如user和user_detail的关系，每个用户对应一条详情记录。\n  - 一对多：例如user和orders的关系，一个用户可以有多个订单。\n  - 多对多：例如setmeal和dish的关系，一个套餐里边可能包含多个菜品，而这一个菜品也可能在多个套餐里面。\n\n## 二.表设计的关键原则\n\n**清晰的表结构和字段命名**：\n\n- 表名、字段名尽量简洁清晰，例如 `user` 表中的 `id` 字段和 `order` 表中的 `user_id` 字段可以直观表明关系。\n\n**避免数据冗余**：\n\n- 不重复存储已经存在的信息，使用外键代替冗余数据。例如 `order` 表通过 `user_id` 字段关联 `user` 表，而不是重复存储用户的姓名和联系方式。\n\n**保持数据一致性**：\n\n- 通过外键约束和触发器等方式，确保数据在关联表间的一致性。\n\n**合理使用中间表**：\n\n- 在多对多关系中，中间表是必不可少的设计。中间表通常包含两张表的外键。\n\n**逻辑外键的设计:**\n\n- 一张表可以包含多个逻辑外键\n\n**在实际开发环境尽量先使用工具进行SQL预查询, 减少错误**\n\n## 三.实例演示\n\n![17314161787661731416178024.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17314161787661731416178024.png)\n","source":"_posts/doubleTable.md","raw":"---\ntitle: 深入理解多表关联的数据库设计\ntags:\n  - mysql\ncategories: 编程\ndate: 2024-11-12 20:07:58\n---\n\n# 深入理解多表关联的数据库设计\n\n## 一.什么是多表关联查询\n\n- 在mysql中通常对不同表之间设置一个外键(物理和逻辑)  -> 逻辑外键最为适合\n  - 为什么是逻辑外键?\n    - 在数据库设计中，我们经常会用到外键来维护表与表之间的关系。然而，使用外键有时会带来一些性能和维护上的问题，比如在进行大量插入、删除操作时，外键约束可能会引发锁竞争，影响操作速度。为了克服这些问题，逻辑外键应运而生。\n\n- 三种多表关联关系\n  - 一对一 ：例如user和user_detail的关系，每个用户对应一条详情记录。\n  - 一对多：例如user和orders的关系，一个用户可以有多个订单。\n  - 多对多：例如setmeal和dish的关系，一个套餐里边可能包含多个菜品，而这一个菜品也可能在多个套餐里面。\n\n## 二.表设计的关键原则\n\n**清晰的表结构和字段命名**：\n\n- 表名、字段名尽量简洁清晰，例如 `user` 表中的 `id` 字段和 `order` 表中的 `user_id` 字段可以直观表明关系。\n\n**避免数据冗余**：\n\n- 不重复存储已经存在的信息，使用外键代替冗余数据。例如 `order` 表通过 `user_id` 字段关联 `user` 表，而不是重复存储用户的姓名和联系方式。\n\n**保持数据一致性**：\n\n- 通过外键约束和触发器等方式，确保数据在关联表间的一致性。\n\n**合理使用中间表**：\n\n- 在多对多关系中，中间表是必不可少的设计。中间表通常包含两张表的外键。\n\n**逻辑外键的设计:**\n\n- 一张表可以包含多个逻辑外键\n\n**在实际开发环境尽量先使用工具进行SQL预查询, 减少错误**\n\n## 三.实例演示\n\n![17314161787661731416178024.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17314161787661731416178024.png)\n","slug":"doubleTable","published":1,"updated":"2025-09-11T00:39:45.100Z","comments":1,"layout":"post","photos":[],"_id":"cmfw4z0ad001nuomwe1wfd7tq","content":"<h1 id=\"深入理解多表关联的数据库设计\"><a href=\"#深入理解多表关联的数据库设计\" class=\"headerlink\" title=\"深入理解多表关联的数据库设计\"></a>深入理解多表关联的数据库设计</h1><h2 id=\"一-什么是多表关联查询\"><a href=\"#一-什么是多表关联查询\" class=\"headerlink\" title=\"一.什么是多表关联查询\"></a>一.什么是多表关联查询</h2><ul>\n<li><p>在mysql中通常对不同表之间设置一个外键(物理和逻辑)  -&gt; 逻辑外键最为适合</p>\n<ul>\n<li>为什么是逻辑外键?<ul>\n<li>在数据库设计中，我们经常会用到外键来维护表与表之间的关系。然而，使用外键有时会带来一些性能和维护上的问题，比如在进行大量插入、删除操作时，外键约束可能会引发锁竞争，影响操作速度。为了克服这些问题，逻辑外键应运而生。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>三种多表关联关系</p>\n<ul>\n<li>一对一 ：例如user和user_detail的关系，每个用户对应一条详情记录。</li>\n<li>一对多：例如user和orders的关系，一个用户可以有多个订单。</li>\n<li>多对多：例如setmeal和dish的关系，一个套餐里边可能包含多个菜品，而这一个菜品也可能在多个套餐里面。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二-表设计的关键原则\"><a href=\"#二-表设计的关键原则\" class=\"headerlink\" title=\"二.表设计的关键原则\"></a>二.表设计的关键原则</h2><p><strong>清晰的表结构和字段命名</strong>：</p>\n<ul>\n<li>表名、字段名尽量简洁清晰，例如 <code>user</code> 表中的 <code>id</code> 字段和 <code>order</code> 表中的 <code>user_id</code> 字段可以直观表明关系。</li>\n</ul>\n<p><strong>避免数据冗余</strong>：</p>\n<ul>\n<li>不重复存储已经存在的信息，使用外键代替冗余数据。例如 <code>order</code> 表通过 <code>user_id</code> 字段关联 <code>user</code> 表，而不是重复存储用户的姓名和联系方式。</li>\n</ul>\n<p><strong>保持数据一致性</strong>：</p>\n<ul>\n<li>通过外键约束和触发器等方式，确保数据在关联表间的一致性。</li>\n</ul>\n<p><strong>合理使用中间表</strong>：</p>\n<ul>\n<li>在多对多关系中，中间表是必不可少的设计。中间表通常包含两张表的外键。</li>\n</ul>\n<p><strong>逻辑外键的设计:</strong></p>\n<ul>\n<li>一张表可以包含多个逻辑外键</li>\n</ul>\n<p><strong>在实际开发环境尽量先使用工具进行SQL预查询, 减少错误</strong></p>\n<h2 id=\"三-实例演示\"><a href=\"#三-实例演示\" class=\"headerlink\" title=\"三.实例演示\"></a>三.实例演示</h2><p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17314161787661731416178024.png\" alt=\"17314161787661731416178024.png\"></p>\n","cover":"/img/3.png","cover_type":"img","excerpt":"","more":"<h1 id=\"深入理解多表关联的数据库设计\"><a href=\"#深入理解多表关联的数据库设计\" class=\"headerlink\" title=\"深入理解多表关联的数据库设计\"></a>深入理解多表关联的数据库设计</h1><h2 id=\"一-什么是多表关联查询\"><a href=\"#一-什么是多表关联查询\" class=\"headerlink\" title=\"一.什么是多表关联查询\"></a>一.什么是多表关联查询</h2><ul>\n<li><p>在mysql中通常对不同表之间设置一个外键(物理和逻辑)  -&gt; 逻辑外键最为适合</p>\n<ul>\n<li>为什么是逻辑外键?<ul>\n<li>在数据库设计中，我们经常会用到外键来维护表与表之间的关系。然而，使用外键有时会带来一些性能和维护上的问题，比如在进行大量插入、删除操作时，外键约束可能会引发锁竞争，影响操作速度。为了克服这些问题，逻辑外键应运而生。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>三种多表关联关系</p>\n<ul>\n<li>一对一 ：例如user和user_detail的关系，每个用户对应一条详情记录。</li>\n<li>一对多：例如user和orders的关系，一个用户可以有多个订单。</li>\n<li>多对多：例如setmeal和dish的关系，一个套餐里边可能包含多个菜品，而这一个菜品也可能在多个套餐里面。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二-表设计的关键原则\"><a href=\"#二-表设计的关键原则\" class=\"headerlink\" title=\"二.表设计的关键原则\"></a>二.表设计的关键原则</h2><p><strong>清晰的表结构和字段命名</strong>：</p>\n<ul>\n<li>表名、字段名尽量简洁清晰，例如 <code>user</code> 表中的 <code>id</code> 字段和 <code>order</code> 表中的 <code>user_id</code> 字段可以直观表明关系。</li>\n</ul>\n<p><strong>避免数据冗余</strong>：</p>\n<ul>\n<li>不重复存储已经存在的信息，使用外键代替冗余数据。例如 <code>order</code> 表通过 <code>user_id</code> 字段关联 <code>user</code> 表，而不是重复存储用户的姓名和联系方式。</li>\n</ul>\n<p><strong>保持数据一致性</strong>：</p>\n<ul>\n<li>通过外键约束和触发器等方式，确保数据在关联表间的一致性。</li>\n</ul>\n<p><strong>合理使用中间表</strong>：</p>\n<ul>\n<li>在多对多关系中，中间表是必不可少的设计。中间表通常包含两张表的外键。</li>\n</ul>\n<p><strong>逻辑外键的设计:</strong></p>\n<ul>\n<li>一张表可以包含多个逻辑外键</li>\n</ul>\n<p><strong>在实际开发环境尽量先使用工具进行SQL预查询, 减少错误</strong></p>\n<h2 id=\"三-实例演示\"><a href=\"#三-实例演示\" class=\"headerlink\" title=\"三.实例演示\"></a>三.实例演示</h2><p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17314161787661731416178024.png\" alt=\"17314161787661731416178024.png\"></p>\n"},{"title":"Git总结","date":"2024-11-25T07:35:24.000Z","_content":"\n# Git 常用命令总结\n\n## Git 基础概念\n- Git 是一种分布式版本控制系统\n- **工作区** → **暂存区** → **本地仓库** → **本地远程仓库** → **远程仓库**\n\n| 状态               | 所在区域 | 含义                   | 如何产生             | 下一步操作                                   |\n| ---------------- | ---- | -------------------- | ---------------- | --------------------------------------- |\n| Untracked（未跟踪）   | 工作区  | 没提交过, 是新建的未加入暂存区     | 新建文件但没 `git add` | `git add` → Staged；或 `.gitignore` 忽略    |\n| Unstaged（已跟踪未暂存） | 工作区  | 文件曾被提交过，但修改后还没保存到暂存区 | 修改已提交/已跟踪的文件     | `git add` → Staged；或 `git restore` 撤销修改 |\n| Staged（已暂存）      | 暂存区  | 文件的当前修改已被保存到暂存区      | `git add` 已修改文件  | `git commit` → Committed                |\n| Committed（已提交）   | 本地仓库 | 文件已提交至本地             | `git commit`     | `git push` → 远程仓库                       |\n![17443477043361744347703409.png|700x335](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17443477043361744347703409.png)\n\n```sh\ngit init # 将目录变成本地仓库\ngit add .\ngit commit -m 'xxx' # 提交到本地仓库\ngit remote add origin https://github.com/Tyson0314/profile # 关联远程仓库\ngit branch --set-upstream-to=origin/master master  # 本地分支关联远程分支\ngit pull origin master --allow-unrelated-histories # 允许合并不相关的历史\ngit push -u origin master  # 如果当前分支与多个主机存在追踪关系，则-u会指定一个默认主机，这样后面就可以不加任何参数使用git push。\n```\n## Git 基本操作\n\n### 配置信息\n```bash\n#查看当前配置的git用户信息\ngit config –-list    \n\n# 配置git提交用户名\ngit config --global user.name XXX    \n\n# 配置git提交邮箱\ngit config --global user.email XXX            \n```\n### 创建本地仓库\n```bash\n# 创建文件夹\nmkdir repository\n\n# 进入文件夹\ncd repository\n\n# 初始化本地仓库,当前目录为git仓库 也就是repository\ngit init\n\n# 将默认的 master 分支改名为 main\ngit branch -m main\n```\n### 克隆远程仓库\n```bash\n# 查看远程仓库\ngit remote -v\n\n# 克隆远程仓库到本地 若使用http形式的需要配置 github账号密码, 推荐使用ssh\ngit clone https://github.com/cloud3111/cloud3111.git\n\n# 添加远程仓库（若非克隆仓库）\ngit remote add origin https://github.com/cloud3111/cloud3111.git\n```\n---\n## Git 提交与推送\n### 创建提交文件\n```bash\n# 查看仓库状态\ngit status\n\n# 写入并创建文件\necho \"hello world\" >> README.md\n\n# 将文件添加到暂存区,在idea中add操作和commit操作是一起的\ngit add README.md\n\n# 提交到本地仓库\ngit commit -m \"详细信息\"\n```\n### 查看日志\n```bash\n# 查看提交记录的简略信息  ---> 提交树\ngit log --online --graph\n\n# 查看提交信息\ngit show <commit-id>\n\n# 查看分支\ngit show <branch-name>\n\n# 查看某次提交的文件内容\ngit show <commit-id>:<file-path>\n```\n### 删除文件\n```bash\necho \"rm test\" > rm.txt\n\n# 添加文件到暂存区并提交\ngit add rm.txt\ngit commit -m \"version2\"\n\n# 删除文件 \n# 在暂存区（index）中把文件标记为删除 加一个后缀 --cached 逻辑删除 当git push时远程仓库就会真正删除这个文件\n# 同时也会在工作区（working directory）中物理删除文件\n# git rm 是完全删除，加 --cached 就是只删除暂存区，保留本地文件\ngit rm rm.txt\ngit commit -m \"version3\"\n```\n### 推送与拉取\n```bash\n# 推送本地 main 分支到远程仓库 main 分支\ngit push -u origin main:main\n\n# 从远程仓库拉取 main 分支到本地 main 分支\ngit pull origin main:main\n```\n---\n## Git 分支管理\n```bash\n# 列出所有分支（包括远程分支）\ngit branch -a\n\n# 创建并切换到 dev 分支 3种方式\ngit branch dev\ngit switch dev\ngit checkout -b dev\n```\n### 合并分支\n```bash\n# 合并 dev 分支到当前main分支\ngit merge dev\n```\n### 解决冲突\n```bash\n# 查看冲突文件内容 (工作区和暂存区之间的差异)\ngit diff  \n\n# 想看暂存区和最新一次提交（HEAD）之间的差异\ngit diff --cached\n\n# 想看当前工作区和最新一次提交（HEAD）之间的所有差异\ngit diff HEAD\n\n# 编辑冲突文件\nvi dev.txt\n\n# 提交解决后的文件\ngit commit -am \"解决冲突\"\n```\n---\n## 查看日志和分支图\n\n```bash\n# 查看提交历史图并设置别名\nalias graph=\"git log --graph --online --decorate --all\"\ngit graph\n```\n---\n## Git进阶命令\n\n### Git Stash 临时存储\n- **把当前工作区和暂存区的改动临时保存起来**，然后让工作区恢复到**干净**的状态（和最近一次提交一致）-> 临时本地保存\n```bash\n# 保存当前修改(包括工作区和暂存区的修改),然后回到未提交状态(工作区和暂存区全部清空)\ngit stash save \"备注\" \n\n# 查看所有stash记录\ngit stash list\n\n# 应用最近一次 stash，并且删除 stash 记录\ngit stash pop\n\n# 应用最近一次 stash，但不删除 stash 记录\ngit stash apply\n```\n- 案例\n```bash\n# 保存当前改动 当前分支dev\ngit stash -m \"测试\" \n# 切换到别的分支操作\ngit checkout hotfix\n# 切换回来\ngit checkout dev\n# 恢复\ngit stash pop\n```\n### Git Rebase 分支基变\n\n- 基变与合并的区别就是 将提交记录变成直线, 让历史更清晰简洁\n![17443486993261744348698844.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17443486993261744348698844.png)\n- [参考文献](https://blog.csdn.net/weixin_42310154/article/details/119004977)\n### Git Reset 恢复回滚\n- git reset比较常用的用法有两种\n\t- 一种是移动到指定的提交  git reset --soft/mixed/hard <commit_hash>\n\t- 一种是回退到上N个提交  git reset --soft HEAD~N\n```bash\n# 如果是软移动和软回退,不改变当前页面的工作区和暂存区,也就是保留当前的修改\ngit reset --soft abc123\ngit reset --soft HEAD^\n# 如果是混合移动和混合回退,工作区修改保留,暂存区丢弃\ngit reset --mixed abc13\ngit reset --mixed HEAD^\n# 如果是硬移动和硬回退,清空当前修改的暂存区和工作区\ngit reset --hard abc13\ngit reset --hard HEAD^\n```\n### Git Feach 拉取不合并\n- `git fetch` 只是把远程仓库的更新下载到了本地 `.git` 目录中，不会直接影响本地的工作区和当前分支, 需要你**手动merger合并或者rebase基变**\n- git pull则是**会获取所有远程索引并合并到本地分支**\n### Git Reflog 本机历史记录\n- 记录了**本地仓库**中分支的变化记录 和 HEAD的移动历史, `reflog` 是**本地记录**，**远程仓库没有**。\n- 包括了- 提交（`git commit`）合并（`git merge`）变基（`git rebase`）撤销（`git reset`）拉取（`git pull`）checkout（切换分支）甚至删除分支也会有记录\n```bash\n# 通过reflog拿到上一次提交(不只是提交)的哈希值id \ngit reflog\n\n# 然后reset恢复到这次提交记录  \ngit reset --hard 哈希值\n\n# 换一种方式    HEAD@{2}: 根据时间顺序排的第 n 次 HEAD 改变, 来源于历史记录\ngit reset --hard HEAD@{2}\n```\n### Git Cherry Pick 优选\n- 将当前分支的提交复制一份到其他分支\n```bash\n# 比如当前在dev分支,有一个提交adc123,想把提交优选到main分支\ngit branch main \ngit cherry-pick abc123\n```\n## Git 标签管理\n```bash\n# 创建标签\ngit tag v1.0.1\n\n# 推送标签到远程\ngit push origin v1.0.1\n\n# 删除本地标签\ngit tag -d v1.0.1\n\n# 删除远程标签\ngit push origin :refs/tags/v1.0.1\n```\n## Git问答\n- 问: 使用 `git merge` 的时候，Git 报错提示有一些本地的未跟踪（untracked）文件，而这些文件在合并进来的分支中也存在，导致无法完成合并, 如何解决?\t\n- 答: 使用git clean对不重要的本地untracked文件进行删除, 或者先把文件复制到其他地方备份, 或者通过git stash 进行保存, 或者通过git add 把文件交给版本管理\n\n- 问: 如何忽略本地的某些文件? .gitignore 不生效?\n- 答: 只有未被提交的文件才能真正被git忽略, 否则只要提交过一次就有了这个文件的追踪记录, 如果想真正让 Git 忽略已经被跟踪的 log/ 文件夹，需要先把它们从 Git 索引中移除，然后再让 .gitignore 生效\n```java\ngit rm -r --cached logs // --cached:只从 Git 索引记录中删除,不动本地文件(本地文件还在,远程的索引和数据删除)\ngit commit -m // \"把logs文件从版本库中移除\"\ngit push origin main // 执行版本库中的logs文件的删除\n```\n","source":"_posts/git.md","raw":"---\ntitle: Git总结\ntags:\n  - Git\ncategories: 编程\ndate: 2024-11-25 15:35:24\n---\n\n# Git 常用命令总结\n\n## Git 基础概念\n- Git 是一种分布式版本控制系统\n- **工作区** → **暂存区** → **本地仓库** → **本地远程仓库** → **远程仓库**\n\n| 状态               | 所在区域 | 含义                   | 如何产生             | 下一步操作                                   |\n| ---------------- | ---- | -------------------- | ---------------- | --------------------------------------- |\n| Untracked（未跟踪）   | 工作区  | 没提交过, 是新建的未加入暂存区     | 新建文件但没 `git add` | `git add` → Staged；或 `.gitignore` 忽略    |\n| Unstaged（已跟踪未暂存） | 工作区  | 文件曾被提交过，但修改后还没保存到暂存区 | 修改已提交/已跟踪的文件     | `git add` → Staged；或 `git restore` 撤销修改 |\n| Staged（已暂存）      | 暂存区  | 文件的当前修改已被保存到暂存区      | `git add` 已修改文件  | `git commit` → Committed                |\n| Committed（已提交）   | 本地仓库 | 文件已提交至本地             | `git commit`     | `git push` → 远程仓库                       |\n![17443477043361744347703409.png|700x335](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17443477043361744347703409.png)\n\n```sh\ngit init # 将目录变成本地仓库\ngit add .\ngit commit -m 'xxx' # 提交到本地仓库\ngit remote add origin https://github.com/Tyson0314/profile # 关联远程仓库\ngit branch --set-upstream-to=origin/master master  # 本地分支关联远程分支\ngit pull origin master --allow-unrelated-histories # 允许合并不相关的历史\ngit push -u origin master  # 如果当前分支与多个主机存在追踪关系，则-u会指定一个默认主机，这样后面就可以不加任何参数使用git push。\n```\n## Git 基本操作\n\n### 配置信息\n```bash\n#查看当前配置的git用户信息\ngit config –-list    \n\n# 配置git提交用户名\ngit config --global user.name XXX    \n\n# 配置git提交邮箱\ngit config --global user.email XXX            \n```\n### 创建本地仓库\n```bash\n# 创建文件夹\nmkdir repository\n\n# 进入文件夹\ncd repository\n\n# 初始化本地仓库,当前目录为git仓库 也就是repository\ngit init\n\n# 将默认的 master 分支改名为 main\ngit branch -m main\n```\n### 克隆远程仓库\n```bash\n# 查看远程仓库\ngit remote -v\n\n# 克隆远程仓库到本地 若使用http形式的需要配置 github账号密码, 推荐使用ssh\ngit clone https://github.com/cloud3111/cloud3111.git\n\n# 添加远程仓库（若非克隆仓库）\ngit remote add origin https://github.com/cloud3111/cloud3111.git\n```\n---\n## Git 提交与推送\n### 创建提交文件\n```bash\n# 查看仓库状态\ngit status\n\n# 写入并创建文件\necho \"hello world\" >> README.md\n\n# 将文件添加到暂存区,在idea中add操作和commit操作是一起的\ngit add README.md\n\n# 提交到本地仓库\ngit commit -m \"详细信息\"\n```\n### 查看日志\n```bash\n# 查看提交记录的简略信息  ---> 提交树\ngit log --online --graph\n\n# 查看提交信息\ngit show <commit-id>\n\n# 查看分支\ngit show <branch-name>\n\n# 查看某次提交的文件内容\ngit show <commit-id>:<file-path>\n```\n### 删除文件\n```bash\necho \"rm test\" > rm.txt\n\n# 添加文件到暂存区并提交\ngit add rm.txt\ngit commit -m \"version2\"\n\n# 删除文件 \n# 在暂存区（index）中把文件标记为删除 加一个后缀 --cached 逻辑删除 当git push时远程仓库就会真正删除这个文件\n# 同时也会在工作区（working directory）中物理删除文件\n# git rm 是完全删除，加 --cached 就是只删除暂存区，保留本地文件\ngit rm rm.txt\ngit commit -m \"version3\"\n```\n### 推送与拉取\n```bash\n# 推送本地 main 分支到远程仓库 main 分支\ngit push -u origin main:main\n\n# 从远程仓库拉取 main 分支到本地 main 分支\ngit pull origin main:main\n```\n---\n## Git 分支管理\n```bash\n# 列出所有分支（包括远程分支）\ngit branch -a\n\n# 创建并切换到 dev 分支 3种方式\ngit branch dev\ngit switch dev\ngit checkout -b dev\n```\n### 合并分支\n```bash\n# 合并 dev 分支到当前main分支\ngit merge dev\n```\n### 解决冲突\n```bash\n# 查看冲突文件内容 (工作区和暂存区之间的差异)\ngit diff  \n\n# 想看暂存区和最新一次提交（HEAD）之间的差异\ngit diff --cached\n\n# 想看当前工作区和最新一次提交（HEAD）之间的所有差异\ngit diff HEAD\n\n# 编辑冲突文件\nvi dev.txt\n\n# 提交解决后的文件\ngit commit -am \"解决冲突\"\n```\n---\n## 查看日志和分支图\n\n```bash\n# 查看提交历史图并设置别名\nalias graph=\"git log --graph --online --decorate --all\"\ngit graph\n```\n---\n## Git进阶命令\n\n### Git Stash 临时存储\n- **把当前工作区和暂存区的改动临时保存起来**，然后让工作区恢复到**干净**的状态（和最近一次提交一致）-> 临时本地保存\n```bash\n# 保存当前修改(包括工作区和暂存区的修改),然后回到未提交状态(工作区和暂存区全部清空)\ngit stash save \"备注\" \n\n# 查看所有stash记录\ngit stash list\n\n# 应用最近一次 stash，并且删除 stash 记录\ngit stash pop\n\n# 应用最近一次 stash，但不删除 stash 记录\ngit stash apply\n```\n- 案例\n```bash\n# 保存当前改动 当前分支dev\ngit stash -m \"测试\" \n# 切换到别的分支操作\ngit checkout hotfix\n# 切换回来\ngit checkout dev\n# 恢复\ngit stash pop\n```\n### Git Rebase 分支基变\n\n- 基变与合并的区别就是 将提交记录变成直线, 让历史更清晰简洁\n![17443486993261744348698844.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17443486993261744348698844.png)\n- [参考文献](https://blog.csdn.net/weixin_42310154/article/details/119004977)\n### Git Reset 恢复回滚\n- git reset比较常用的用法有两种\n\t- 一种是移动到指定的提交  git reset --soft/mixed/hard <commit_hash>\n\t- 一种是回退到上N个提交  git reset --soft HEAD~N\n```bash\n# 如果是软移动和软回退,不改变当前页面的工作区和暂存区,也就是保留当前的修改\ngit reset --soft abc123\ngit reset --soft HEAD^\n# 如果是混合移动和混合回退,工作区修改保留,暂存区丢弃\ngit reset --mixed abc13\ngit reset --mixed HEAD^\n# 如果是硬移动和硬回退,清空当前修改的暂存区和工作区\ngit reset --hard abc13\ngit reset --hard HEAD^\n```\n### Git Feach 拉取不合并\n- `git fetch` 只是把远程仓库的更新下载到了本地 `.git` 目录中，不会直接影响本地的工作区和当前分支, 需要你**手动merger合并或者rebase基变**\n- git pull则是**会获取所有远程索引并合并到本地分支**\n### Git Reflog 本机历史记录\n- 记录了**本地仓库**中分支的变化记录 和 HEAD的移动历史, `reflog` 是**本地记录**，**远程仓库没有**。\n- 包括了- 提交（`git commit`）合并（`git merge`）变基（`git rebase`）撤销（`git reset`）拉取（`git pull`）checkout（切换分支）甚至删除分支也会有记录\n```bash\n# 通过reflog拿到上一次提交(不只是提交)的哈希值id \ngit reflog\n\n# 然后reset恢复到这次提交记录  \ngit reset --hard 哈希值\n\n# 换一种方式    HEAD@{2}: 根据时间顺序排的第 n 次 HEAD 改变, 来源于历史记录\ngit reset --hard HEAD@{2}\n```\n### Git Cherry Pick 优选\n- 将当前分支的提交复制一份到其他分支\n```bash\n# 比如当前在dev分支,有一个提交adc123,想把提交优选到main分支\ngit branch main \ngit cherry-pick abc123\n```\n## Git 标签管理\n```bash\n# 创建标签\ngit tag v1.0.1\n\n# 推送标签到远程\ngit push origin v1.0.1\n\n# 删除本地标签\ngit tag -d v1.0.1\n\n# 删除远程标签\ngit push origin :refs/tags/v1.0.1\n```\n## Git问答\n- 问: 使用 `git merge` 的时候，Git 报错提示有一些本地的未跟踪（untracked）文件，而这些文件在合并进来的分支中也存在，导致无法完成合并, 如何解决?\t\n- 答: 使用git clean对不重要的本地untracked文件进行删除, 或者先把文件复制到其他地方备份, 或者通过git stash 进行保存, 或者通过git add 把文件交给版本管理\n\n- 问: 如何忽略本地的某些文件? .gitignore 不生效?\n- 答: 只有未被提交的文件才能真正被git忽略, 否则只要提交过一次就有了这个文件的追踪记录, 如果想真正让 Git 忽略已经被跟踪的 log/ 文件夹，需要先把它们从 Git 索引中移除，然后再让 .gitignore 生效\n```java\ngit rm -r --cached logs // --cached:只从 Git 索引记录中删除,不动本地文件(本地文件还在,远程的索引和数据删除)\ngit commit -m // \"把logs文件从版本库中移除\"\ngit push origin main // 执行版本库中的logs文件的删除\n```\n","slug":"git","published":1,"updated":"2025-09-18T11:45:23.479Z","comments":1,"layout":"post","photos":[],"_id":"cmfw4z0ah001xuomw1zce7nd4","content":"<h1 id=\"Git-常用命令总结\"><a href=\"#Git-常用命令总结\" class=\"headerlink\" title=\"Git 常用命令总结\"></a>Git 常用命令总结</h1><h2 id=\"Git-基础概念\"><a href=\"#Git-基础概念\" class=\"headerlink\" title=\"Git 基础概念\"></a>Git 基础概念</h2><ul>\n<li>Git 是一种分布式版本控制系统</li>\n<li><strong>工作区</strong> → <strong>暂存区</strong> → <strong>本地仓库</strong> → <strong>本地远程仓库</strong> → <strong>远程仓库</strong></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>所在区域</th>\n<th>含义</th>\n<th>如何产生</th>\n<th>下一步操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Untracked（未跟踪）</td>\n<td>工作区</td>\n<td>没提交过, 是新建的未加入暂存区</td>\n<td>新建文件但没 <code>git add</code></td>\n<td><code>git add</code> → Staged；或 <code>.gitignore</code> 忽略</td>\n</tr>\n<tr>\n<td>Unstaged（已跟踪未暂存）</td>\n<td>工作区</td>\n<td>文件曾被提交过，但修改后还没保存到暂存区</td>\n<td>修改已提交/已跟踪的文件</td>\n<td><code>git add</code> → Staged；或 <code>git restore</code> 撤销修改</td>\n</tr>\n<tr>\n<td>Staged（已暂存）</td>\n<td>暂存区</td>\n<td>文件的当前修改已被保存到暂存区</td>\n<td><code>git add</code> 已修改文件</td>\n<td><code>git commit</code> → Committed</td>\n</tr>\n<tr>\n<td>Committed（已提交）</td>\n<td>本地仓库</td>\n<td>文件已提交至本地</td>\n<td><code>git commit</code></td>\n<td><code>git push</code> → 远程仓库</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17443477043361744347703409.png\" alt=\"17443477043361744347703409.png|700x335\"></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init <span class=\"comment\"># 将目录变成本地仓库</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&#x27;xxx&#x27;</span> <span class=\"comment\"># 提交到本地仓库</span></span><br><span class=\"line\">git remote add origin https://github.com/Tyson0314/profile <span class=\"comment\"># 关联远程仓库</span></span><br><span class=\"line\">git branch --set-upstream-to=origin/master master  <span class=\"comment\"># 本地分支关联远程分支</span></span><br><span class=\"line\">git pull origin master --allow-unrelated-histories <span class=\"comment\"># 允许合并不相关的历史</span></span><br><span class=\"line\">git push -u origin master  <span class=\"comment\"># 如果当前分支与多个主机存在追踪关系，则-u会指定一个默认主机，这样后面就可以不加任何参数使用git push。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Git-基本操作\"><a href=\"#Git-基本操作\" class=\"headerlink\" title=\"Git 基本操作\"></a>Git 基本操作</h2><h3 id=\"配置信息\"><a href=\"#配置信息\" class=\"headerlink\" title=\"配置信息\"></a>配置信息</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#查看当前配置的git用户信息</span></span><br><span class=\"line\">git config –-list    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置git提交用户名</span></span><br><span class=\"line\">git config --global user.name XXX    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置git提交邮箱</span></span><br><span class=\"line\">git config --global user.email XXX            </span><br></pre></td></tr></table></figure>\n<h3 id=\"创建本地仓库\"><a href=\"#创建本地仓库\" class=\"headerlink\" title=\"创建本地仓库\"></a>创建本地仓库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建文件夹</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> repository</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入文件夹</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> repository</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化本地仓库,当前目录为git仓库 也就是repository</span></span><br><span class=\"line\">git init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将默认的 master 分支改名为 main</span></span><br><span class=\"line\">git branch -m main</span><br></pre></td></tr></table></figure>\n<h3 id=\"克隆远程仓库\"><a href=\"#克隆远程仓库\" class=\"headerlink\" title=\"克隆远程仓库\"></a>克隆远程仓库</h3><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看远程仓库</span></span><br><span class=\"line\">git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 克隆远程仓库到本地 若使用http形式的需要配置 github账号密码, 推荐使用ssh</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/cloud3111/cloud3111.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加远程仓库（若非克隆仓库）</span></span><br><span class=\"line\">git remote add origin https://github.com/cloud3111/cloud3111.git</span><br></pre></td></tr></table></figure></h2><h2 id=\"Git-提交与推送\"><a href=\"#Git-提交与推送\" class=\"headerlink\" title=\"Git 提交与推送\"></a>Git 提交与推送</h2><h3 id=\"创建提交文件\"><a href=\"#创建提交文件\" class=\"headerlink\" title=\"创建提交文件\"></a>创建提交文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看仓库状态</span></span><br><span class=\"line\">git status</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 写入并创建文件</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;hello world&quot;</span> &gt;&gt; README.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将文件添加到暂存区,在idea中add操作和commit操作是一起的</span></span><br><span class=\"line\">git add README.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交到本地仓库</span></span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;详细信息&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看日志\"><a href=\"#查看日志\" class=\"headerlink\" title=\"查看日志\"></a>查看日志</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看提交记录的简略信息  ---&gt; 提交树</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --online --graph</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看提交信息</span></span><br><span class=\"line\">git show &lt;commit-id&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看分支</span></span><br><span class=\"line\">git show &lt;branch-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看某次提交的文件内容</span></span><br><span class=\"line\">git show &lt;commit-id&gt;:&lt;file-path&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;rm test&quot;</span> &gt; rm.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加文件到暂存区并提交</span></span><br><span class=\"line\">git add rm.txt</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;version2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除文件 </span></span><br><span class=\"line\"><span class=\"comment\"># 在暂存区（index）中把文件标记为删除 加一个后缀 --cached 逻辑删除 当git push时远程仓库就会真正删除这个文件</span></span><br><span class=\"line\"><span class=\"comment\"># 同时也会在工作区（working directory）中物理删除文件</span></span><br><span class=\"line\"><span class=\"comment\"># git rm 是完全删除，加 --cached 就是只删除暂存区，保留本地文件</span></span><br><span class=\"line\">git <span class=\"built_in\">rm</span> rm.txt</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;version3&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"推送与拉取\"><a href=\"#推送与拉取\" class=\"headerlink\" title=\"推送与拉取\"></a>推送与拉取</h3><h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 推送本地 main 分支到远程仓库 main 分支</span></span><br><span class=\"line\">git push -u origin main:main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从远程仓库拉取 main 分支到本地 main 分支</span></span><br><span class=\"line\">git pull origin main:main</span><br></pre></td></tr></table></figure></h2><h2 id=\"Git-分支管理\"><a href=\"#Git-分支管理\" class=\"headerlink\" title=\"Git 分支管理\"></a>Git 分支管理</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有分支（包括远程分支）</span></span><br><span class=\"line\">git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并切换到 dev 分支 3种方式</span></span><br><span class=\"line\">git branch dev</span><br><span class=\"line\">git switch dev</span><br><span class=\"line\">git checkout -b dev</span><br></pre></td></tr></table></figure>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 合并 dev 分支到当前main分支</span></span><br><span class=\"line\">git merge dev</span><br></pre></td></tr></table></figure>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看冲突文件内容 (工作区和暂存区之间的差异)</span></span><br><span class=\"line\">git diff  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 想看暂存区和最新一次提交（HEAD）之间的差异</span></span><br><span class=\"line\">git diff --cached</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 想看当前工作区和最新一次提交（HEAD）之间的所有差异</span></span><br><span class=\"line\">git diff HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编辑冲突文件</span></span><br><span class=\"line\">vi dev.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交解决后的文件</span></span><br><span class=\"line\">git commit -am <span class=\"string\">&quot;解决冲突&quot;</span></span><br></pre></td></tr></table></figure></h2><h2 id=\"查看日志和分支图\"><a href=\"#查看日志和分支图\" class=\"headerlink\" title=\"查看日志和分支图\"></a>查看日志和分支图</h2><h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看提交历史图并设置别名</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> graph=<span class=\"string\">&quot;git log --graph --online --decorate --all&quot;</span></span><br><span class=\"line\">git graph</span><br></pre></td></tr></table></figure></h2><h2 id=\"Git进阶命令\"><a href=\"#Git进阶命令\" class=\"headerlink\" title=\"Git进阶命令\"></a>Git进阶命令</h2><h3 id=\"Git-Stash-临时存储\"><a href=\"#Git-Stash-临时存储\" class=\"headerlink\" title=\"Git Stash 临时存储\"></a>Git Stash 临时存储</h3><ul>\n<li><strong>把当前工作区和暂存区的改动临时保存起来</strong>，然后让工作区恢复到<strong>干净</strong>的状态（和最近一次提交一致）-&gt; 临时本地保存<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 保存当前修改(包括工作区和暂存区的修改),然后回到未提交状态(工作区和暂存区全部清空)</span></span><br><span class=\"line\">git stash save <span class=\"string\">&quot;备注&quot;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有stash记录</span></span><br><span class=\"line\">git stash list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 应用最近一次 stash，并且删除 stash 记录</span></span><br><span class=\"line\">git stash pop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 应用最近一次 stash，但不删除 stash 记录</span></span><br><span class=\"line\">git stash apply</span><br></pre></td></tr></table></figure></li>\n<li><p>案例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 保存当前改动 当前分支dev</span></span><br><span class=\"line\">git stash -m <span class=\"string\">&quot;测试&quot;</span> </span><br><span class=\"line\"><span class=\"comment\"># 切换到别的分支操作</span></span><br><span class=\"line\">git checkout hotfix</span><br><span class=\"line\"><span class=\"comment\"># 切换回来</span></span><br><span class=\"line\">git checkout dev</span><br><span class=\"line\"><span class=\"comment\"># 恢复</span></span><br><span class=\"line\">git stash pop</span><br></pre></td></tr></table></figure>\n<h3 id=\"Git-Rebase-分支基变\"><a href=\"#Git-Rebase-分支基变\" class=\"headerlink\" title=\"Git Rebase 分支基变\"></a>Git Rebase 分支基变</h3></li>\n<li><p>基变与合并的区别就是 将提交记录变成直线, 让历史更清晰简洁<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17443486993261744348698844.png\" alt=\"17443486993261744348698844.png\"></p>\n</li>\n<li><a href=\"https://blog.csdn.net/weixin_42310154/article/details/119004977\">参考文献</a><h3 id=\"Git-Reset-恢复回滚\"><a href=\"#Git-Reset-恢复回滚\" class=\"headerlink\" title=\"Git Reset 恢复回滚\"></a>Git Reset 恢复回滚</h3></li>\n<li>git reset比较常用的用法有两种<ul>\n<li>一种是移动到指定的提交  git reset —soft/mixed/hard <commit_hash></li>\n<li>一种是回退到上N个提交  git reset —soft HEAD~N<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果是软移动和软回退,不改变当前页面的工作区和暂存区,也就是保留当前的修改</span></span><br><span class=\"line\">git reset --soft abc123</span><br><span class=\"line\">git reset --soft HEAD^</span><br><span class=\"line\"><span class=\"comment\"># 如果是混合移动和混合回退,工作区修改保留,暂存区丢弃</span></span><br><span class=\"line\">git reset --mixed abc13</span><br><span class=\"line\">git reset --mixed HEAD^</span><br><span class=\"line\"><span class=\"comment\"># 如果是硬移动和硬回退,清空当前修改的暂存区和工作区</span></span><br><span class=\"line\">git reset --hard abc13</span><br><span class=\"line\">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>\n<h3 id=\"Git-Feach-拉取不合并\"><a href=\"#Git-Feach-拉取不合并\" class=\"headerlink\" title=\"Git Feach 拉取不合并\"></a>Git Feach 拉取不合并</h3></li>\n</ul>\n</li>\n<li><code>git fetch</code> 只是把远程仓库的更新下载到了本地 <code>.git</code> 目录中，不会直接影响本地的工作区和当前分支, 需要你<strong>手动merger合并或者rebase基变</strong></li>\n<li>git pull则是<strong>会获取所有远程索引并合并到本地分支</strong><h3 id=\"Git-Reflog-本机历史记录\"><a href=\"#Git-Reflog-本机历史记录\" class=\"headerlink\" title=\"Git Reflog 本机历史记录\"></a>Git Reflog 本机历史记录</h3></li>\n<li>记录了<strong>本地仓库</strong>中分支的变化记录 和 HEAD的移动历史, <code>reflog</code> 是<strong>本地记录</strong>，<strong>远程仓库没有</strong>。</li>\n<li>包括了- 提交（<code>git commit</code>）合并（<code>git merge</code>）变基（<code>git rebase</code>）撤销（<code>git reset</code>）拉取（<code>git pull</code>）checkout（切换分支）甚至删除分支也会有记录<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过reflog拿到上一次提交(不只是提交)的哈希值id </span></span><br><span class=\"line\">git reflog</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 然后reset恢复到这次提交记录  </span></span><br><span class=\"line\">git reset --hard 哈希值</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 换一种方式    HEAD@&#123;2&#125;: 根据时间顺序排的第 n 次 HEAD 改变, 来源于历史记录</span></span><br><span class=\"line\">git reset --hard HEAD@&#123;2&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Git-Cherry-Pick-优选\"><a href=\"#Git-Cherry-Pick-优选\" class=\"headerlink\" title=\"Git Cherry Pick 优选\"></a>Git Cherry Pick 优选</h3></li>\n<li>将当前分支的提交复制一份到其他分支<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 比如当前在dev分支,有一个提交adc123,想把提交优选到main分支</span></span><br><span class=\"line\">git branch main </span><br><span class=\"line\">git cherry-pick abc123</span><br></pre></td></tr></table></figure>\n<h2 id=\"Git-标签管理\"><a href=\"#Git-标签管理\" class=\"headerlink\" title=\"Git 标签管理\"></a>Git 标签管理</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建标签</span></span><br><span class=\"line\">git tag v1.0.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 推送标签到远程</span></span><br><span class=\"line\">git push origin v1.0.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除本地标签</span></span><br><span class=\"line\">git tag -d v1.0.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除远程标签</span></span><br><span class=\"line\">git push origin :refs/tags/v1.0.1</span><br></pre></td></tr></table></figure>\n<h2 id=\"Git问答\"><a href=\"#Git问答\" class=\"headerlink\" title=\"Git问答\"></a>Git问答</h2></li>\n<li>问: 使用 <code>git merge</code> 的时候，Git 报错提示有一些本地的未跟踪（untracked）文件，而这些文件在合并进来的分支中也存在，导致无法完成合并, 如何解决?    </li>\n<li><p>答: 使用git clean对不重要的本地untracked文件进行删除, 或者先把文件复制到其他地方备份, 或者通过git stash 进行保存, 或者通过git add 把文件交给版本管理</p>\n</li>\n<li><p>问: 如何忽略本地的某些文件? .gitignore 不生效?</p>\n</li>\n<li>答: 只有未被提交的文件才能真正被git忽略, 否则只要提交过一次就有了这个文件的追踪记录, 如果想真正让 Git 忽略已经被跟踪的 log/ 文件夹，需要先把它们从 Git 索引中移除，然后再让 .gitignore 生效<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r --cached logs <span class=\"comment\">// --cached:只从 Git 索引记录中删除,不动本地文件(本地文件还在,远程的索引和数据删除)</span></span><br><span class=\"line\">git commit -m <span class=\"comment\">// &quot;把logs文件从版本库中移除&quot;</span></span><br><span class=\"line\">git push origin main <span class=\"comment\">// 执行版本库中的logs文件的删除</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","cover":"/img/2.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Git-常用命令总结\"><a href=\"#Git-常用命令总结\" class=\"headerlink\" title=\"Git 常用命令总结\"></a>Git 常用命令总结</h1><h2 id=\"Git-基础概念\"><a href=\"#Git-基础概念\" class=\"headerlink\" title=\"Git 基础概念\"></a>Git 基础概念</h2><ul>\n<li>Git 是一种分布式版本控制系统</li>\n<li><strong>工作区</strong> → <strong>暂存区</strong> → <strong>本地仓库</strong> → <strong>本地远程仓库</strong> → <strong>远程仓库</strong></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>所在区域</th>\n<th>含义</th>\n<th>如何产生</th>\n<th>下一步操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Untracked（未跟踪）</td>\n<td>工作区</td>\n<td>没提交过, 是新建的未加入暂存区</td>\n<td>新建文件但没 <code>git add</code></td>\n<td><code>git add</code> → Staged；或 <code>.gitignore</code> 忽略</td>\n</tr>\n<tr>\n<td>Unstaged（已跟踪未暂存）</td>\n<td>工作区</td>\n<td>文件曾被提交过，但修改后还没保存到暂存区</td>\n<td>修改已提交/已跟踪的文件</td>\n<td><code>git add</code> → Staged；或 <code>git restore</code> 撤销修改</td>\n</tr>\n<tr>\n<td>Staged（已暂存）</td>\n<td>暂存区</td>\n<td>文件的当前修改已被保存到暂存区</td>\n<td><code>git add</code> 已修改文件</td>\n<td><code>git commit</code> → Committed</td>\n</tr>\n<tr>\n<td>Committed（已提交）</td>\n<td>本地仓库</td>\n<td>文件已提交至本地</td>\n<td><code>git commit</code></td>\n<td><code>git push</code> → 远程仓库</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17443477043361744347703409.png\" alt=\"17443477043361744347703409.png|700x335\"></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init <span class=\"comment\"># 将目录变成本地仓库</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&#x27;xxx&#x27;</span> <span class=\"comment\"># 提交到本地仓库</span></span><br><span class=\"line\">git remote add origin https://github.com/Tyson0314/profile <span class=\"comment\"># 关联远程仓库</span></span><br><span class=\"line\">git branch --set-upstream-to=origin/master master  <span class=\"comment\"># 本地分支关联远程分支</span></span><br><span class=\"line\">git pull origin master --allow-unrelated-histories <span class=\"comment\"># 允许合并不相关的历史</span></span><br><span class=\"line\">git push -u origin master  <span class=\"comment\"># 如果当前分支与多个主机存在追踪关系，则-u会指定一个默认主机，这样后面就可以不加任何参数使用git push。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Git-基本操作\"><a href=\"#Git-基本操作\" class=\"headerlink\" title=\"Git 基本操作\"></a>Git 基本操作</h2><h3 id=\"配置信息\"><a href=\"#配置信息\" class=\"headerlink\" title=\"配置信息\"></a>配置信息</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#查看当前配置的git用户信息</span></span><br><span class=\"line\">git config –-list    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置git提交用户名</span></span><br><span class=\"line\">git config --global user.name XXX    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置git提交邮箱</span></span><br><span class=\"line\">git config --global user.email XXX            </span><br></pre></td></tr></table></figure>\n<h3 id=\"创建本地仓库\"><a href=\"#创建本地仓库\" class=\"headerlink\" title=\"创建本地仓库\"></a>创建本地仓库</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建文件夹</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> repository</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入文件夹</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> repository</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化本地仓库,当前目录为git仓库 也就是repository</span></span><br><span class=\"line\">git init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将默认的 master 分支改名为 main</span></span><br><span class=\"line\">git branch -m main</span><br></pre></td></tr></table></figure>\n<h3 id=\"克隆远程仓库\"><a href=\"#克隆远程仓库\" class=\"headerlink\" title=\"克隆远程仓库\"></a>克隆远程仓库</h3><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看远程仓库</span></span><br><span class=\"line\">git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 克隆远程仓库到本地 若使用http形式的需要配置 github账号密码, 推荐使用ssh</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/cloud3111/cloud3111.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加远程仓库（若非克隆仓库）</span></span><br><span class=\"line\">git remote add origin https://github.com/cloud3111/cloud3111.git</span><br></pre></td></tr></table></figure></h2><h2 id=\"Git-提交与推送\"><a href=\"#Git-提交与推送\" class=\"headerlink\" title=\"Git 提交与推送\"></a>Git 提交与推送</h2><h3 id=\"创建提交文件\"><a href=\"#创建提交文件\" class=\"headerlink\" title=\"创建提交文件\"></a>创建提交文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看仓库状态</span></span><br><span class=\"line\">git status</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 写入并创建文件</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;hello world&quot;</span> &gt;&gt; README.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将文件添加到暂存区,在idea中add操作和commit操作是一起的</span></span><br><span class=\"line\">git add README.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交到本地仓库</span></span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;详细信息&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查看日志\"><a href=\"#查看日志\" class=\"headerlink\" title=\"查看日志\"></a>查看日志</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看提交记录的简略信息  ---&gt; 提交树</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --online --graph</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看提交信息</span></span><br><span class=\"line\">git show &lt;commit-id&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看分支</span></span><br><span class=\"line\">git show &lt;branch-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看某次提交的文件内容</span></span><br><span class=\"line\">git show &lt;commit-id&gt;:&lt;file-path&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;rm test&quot;</span> &gt; rm.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加文件到暂存区并提交</span></span><br><span class=\"line\">git add rm.txt</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;version2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除文件 </span></span><br><span class=\"line\"><span class=\"comment\"># 在暂存区（index）中把文件标记为删除 加一个后缀 --cached 逻辑删除 当git push时远程仓库就会真正删除这个文件</span></span><br><span class=\"line\"><span class=\"comment\"># 同时也会在工作区（working directory）中物理删除文件</span></span><br><span class=\"line\"><span class=\"comment\"># git rm 是完全删除，加 --cached 就是只删除暂存区，保留本地文件</span></span><br><span class=\"line\">git <span class=\"built_in\">rm</span> rm.txt</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;version3&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"推送与拉取\"><a href=\"#推送与拉取\" class=\"headerlink\" title=\"推送与拉取\"></a>推送与拉取</h3><h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 推送本地 main 分支到远程仓库 main 分支</span></span><br><span class=\"line\">git push -u origin main:main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从远程仓库拉取 main 分支到本地 main 分支</span></span><br><span class=\"line\">git pull origin main:main</span><br></pre></td></tr></table></figure></h2><h2 id=\"Git-分支管理\"><a href=\"#Git-分支管理\" class=\"headerlink\" title=\"Git 分支管理\"></a>Git 分支管理</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有分支（包括远程分支）</span></span><br><span class=\"line\">git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并切换到 dev 分支 3种方式</span></span><br><span class=\"line\">git branch dev</span><br><span class=\"line\">git switch dev</span><br><span class=\"line\">git checkout -b dev</span><br></pre></td></tr></table></figure>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 合并 dev 分支到当前main分支</span></span><br><span class=\"line\">git merge dev</span><br></pre></td></tr></table></figure>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><h2 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"\"></a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看冲突文件内容 (工作区和暂存区之间的差异)</span></span><br><span class=\"line\">git diff  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 想看暂存区和最新一次提交（HEAD）之间的差异</span></span><br><span class=\"line\">git diff --cached</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 想看当前工作区和最新一次提交（HEAD）之间的所有差异</span></span><br><span class=\"line\">git diff HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编辑冲突文件</span></span><br><span class=\"line\">vi dev.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交解决后的文件</span></span><br><span class=\"line\">git commit -am <span class=\"string\">&quot;解决冲突&quot;</span></span><br></pre></td></tr></table></figure></h2><h2 id=\"查看日志和分支图\"><a href=\"#查看日志和分支图\" class=\"headerlink\" title=\"查看日志和分支图\"></a>查看日志和分支图</h2><h2 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"\"></a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看提交历史图并设置别名</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> graph=<span class=\"string\">&quot;git log --graph --online --decorate --all&quot;</span></span><br><span class=\"line\">git graph</span><br></pre></td></tr></table></figure></h2><h2 id=\"Git进阶命令\"><a href=\"#Git进阶命令\" class=\"headerlink\" title=\"Git进阶命令\"></a>Git进阶命令</h2><h3 id=\"Git-Stash-临时存储\"><a href=\"#Git-Stash-临时存储\" class=\"headerlink\" title=\"Git Stash 临时存储\"></a>Git Stash 临时存储</h3><ul>\n<li><strong>把当前工作区和暂存区的改动临时保存起来</strong>，然后让工作区恢复到<strong>干净</strong>的状态（和最近一次提交一致）-&gt; 临时本地保存<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 保存当前修改(包括工作区和暂存区的修改),然后回到未提交状态(工作区和暂存区全部清空)</span></span><br><span class=\"line\">git stash save <span class=\"string\">&quot;备注&quot;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有stash记录</span></span><br><span class=\"line\">git stash list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 应用最近一次 stash，并且删除 stash 记录</span></span><br><span class=\"line\">git stash pop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 应用最近一次 stash，但不删除 stash 记录</span></span><br><span class=\"line\">git stash apply</span><br></pre></td></tr></table></figure></li>\n<li><p>案例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 保存当前改动 当前分支dev</span></span><br><span class=\"line\">git stash -m <span class=\"string\">&quot;测试&quot;</span> </span><br><span class=\"line\"><span class=\"comment\"># 切换到别的分支操作</span></span><br><span class=\"line\">git checkout hotfix</span><br><span class=\"line\"><span class=\"comment\"># 切换回来</span></span><br><span class=\"line\">git checkout dev</span><br><span class=\"line\"><span class=\"comment\"># 恢复</span></span><br><span class=\"line\">git stash pop</span><br></pre></td></tr></table></figure>\n<h3 id=\"Git-Rebase-分支基变\"><a href=\"#Git-Rebase-分支基变\" class=\"headerlink\" title=\"Git Rebase 分支基变\"></a>Git Rebase 分支基变</h3></li>\n<li><p>基变与合并的区别就是 将提交记录变成直线, 让历史更清晰简洁<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17443486993261744348698844.png\" alt=\"17443486993261744348698844.png\"></p>\n</li>\n<li><a href=\"https://blog.csdn.net/weixin_42310154/article/details/119004977\">参考文献</a><h3 id=\"Git-Reset-恢复回滚\"><a href=\"#Git-Reset-恢复回滚\" class=\"headerlink\" title=\"Git Reset 恢复回滚\"></a>Git Reset 恢复回滚</h3></li>\n<li>git reset比较常用的用法有两种<ul>\n<li>一种是移动到指定的提交  git reset —soft/mixed/hard <commit_hash></li>\n<li>一种是回退到上N个提交  git reset —soft HEAD~N<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果是软移动和软回退,不改变当前页面的工作区和暂存区,也就是保留当前的修改</span></span><br><span class=\"line\">git reset --soft abc123</span><br><span class=\"line\">git reset --soft HEAD^</span><br><span class=\"line\"><span class=\"comment\"># 如果是混合移动和混合回退,工作区修改保留,暂存区丢弃</span></span><br><span class=\"line\">git reset --mixed abc13</span><br><span class=\"line\">git reset --mixed HEAD^</span><br><span class=\"line\"><span class=\"comment\"># 如果是硬移动和硬回退,清空当前修改的暂存区和工作区</span></span><br><span class=\"line\">git reset --hard abc13</span><br><span class=\"line\">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>\n<h3 id=\"Git-Feach-拉取不合并\"><a href=\"#Git-Feach-拉取不合并\" class=\"headerlink\" title=\"Git Feach 拉取不合并\"></a>Git Feach 拉取不合并</h3></li>\n</ul>\n</li>\n<li><code>git fetch</code> 只是把远程仓库的更新下载到了本地 <code>.git</code> 目录中，不会直接影响本地的工作区和当前分支, 需要你<strong>手动merger合并或者rebase基变</strong></li>\n<li>git pull则是<strong>会获取所有远程索引并合并到本地分支</strong><h3 id=\"Git-Reflog-本机历史记录\"><a href=\"#Git-Reflog-本机历史记录\" class=\"headerlink\" title=\"Git Reflog 本机历史记录\"></a>Git Reflog 本机历史记录</h3></li>\n<li>记录了<strong>本地仓库</strong>中分支的变化记录 和 HEAD的移动历史, <code>reflog</code> 是<strong>本地记录</strong>，<strong>远程仓库没有</strong>。</li>\n<li>包括了- 提交（<code>git commit</code>）合并（<code>git merge</code>）变基（<code>git rebase</code>）撤销（<code>git reset</code>）拉取（<code>git pull</code>）checkout（切换分支）甚至删除分支也会有记录<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过reflog拿到上一次提交(不只是提交)的哈希值id </span></span><br><span class=\"line\">git reflog</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 然后reset恢复到这次提交记录  </span></span><br><span class=\"line\">git reset --hard 哈希值</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 换一种方式    HEAD@&#123;2&#125;: 根据时间顺序排的第 n 次 HEAD 改变, 来源于历史记录</span></span><br><span class=\"line\">git reset --hard HEAD@&#123;2&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Git-Cherry-Pick-优选\"><a href=\"#Git-Cherry-Pick-优选\" class=\"headerlink\" title=\"Git Cherry Pick 优选\"></a>Git Cherry Pick 优选</h3></li>\n<li>将当前分支的提交复制一份到其他分支<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 比如当前在dev分支,有一个提交adc123,想把提交优选到main分支</span></span><br><span class=\"line\">git branch main </span><br><span class=\"line\">git cherry-pick abc123</span><br></pre></td></tr></table></figure>\n<h2 id=\"Git-标签管理\"><a href=\"#Git-标签管理\" class=\"headerlink\" title=\"Git 标签管理\"></a>Git 标签管理</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建标签</span></span><br><span class=\"line\">git tag v1.0.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 推送标签到远程</span></span><br><span class=\"line\">git push origin v1.0.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除本地标签</span></span><br><span class=\"line\">git tag -d v1.0.1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除远程标签</span></span><br><span class=\"line\">git push origin :refs/tags/v1.0.1</span><br></pre></td></tr></table></figure>\n<h2 id=\"Git问答\"><a href=\"#Git问答\" class=\"headerlink\" title=\"Git问答\"></a>Git问答</h2></li>\n<li>问: 使用 <code>git merge</code> 的时候，Git 报错提示有一些本地的未跟踪（untracked）文件，而这些文件在合并进来的分支中也存在，导致无法完成合并, 如何解决?    </li>\n<li><p>答: 使用git clean对不重要的本地untracked文件进行删除, 或者先把文件复制到其他地方备份, 或者通过git stash 进行保存, 或者通过git add 把文件交给版本管理</p>\n</li>\n<li><p>问: 如何忽略本地的某些文件? .gitignore 不生效?</p>\n</li>\n<li>答: 只有未被提交的文件才能真正被git忽略, 否则只要提交过一次就有了这个文件的追踪记录, 如果想真正让 Git 忽略已经被跟踪的 log/ 文件夹，需要先把它们从 Git 索引中移除，然后再让 .gitignore 生效<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r --cached logs <span class=\"comment\">// --cached:只从 Git 索引记录中删除,不动本地文件(本地文件还在,远程的索引和数据删除)</span></span><br><span class=\"line\">git commit -m <span class=\"comment\">// &quot;把logs文件从版本库中移除&quot;</span></span><br><span class=\"line\">git push origin main <span class=\"comment\">// 执行版本库中的logs文件的删除</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"函数式接口和stream流API","date":"2024-11-28T06:48:20.000Z","banner":"[[pixel-banner-image.png]]","_content":"\n# FunctionStream\n## 初识stream流\n### 什么是stream流\n- stream流是`jdk8`引入的一种简化编程效率的工具, 通过stream流API,可以很轻松的把一种形式的对象转换成另一种对象\n- 通过一系列**中间操作**和**最终操作**来进行**功能增强**, 中间操作通常会引用一个函数式接口作为参数, 利用**参数行为化隐式进行方法重写,** 最终操作则会触发流的遍历并执行最终操作(把返回值传给下一个流)\n### 函数式接口(方法重写)\n- 函数式接口是只包含一个方法的接口\n- 通过函数式接口对隐式方法的重写, 可以通过lambda表达式显示进行方法重写, 也可以通过方法引用(引用类的方法来覆盖重写接口方法)\n- 4中基础函数式接口类型: Predicat  Consumer  Supplier  Function  Comparator(int compare(T o1, T o2))\n- lambda表达式: 当在方法内使用lambda其实是对函数接口唯一方法的重写, 通过隐式捕获上下文的变量来操作流中的元素\n![17327779764721732777975546.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17327779764721732777975546.png)\n```java\n1.Predicate\n    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    Predicate<Integer> isEvenPredicate = num -> num % 2 == 0;\n\tnumbers.stream()\n    .filter(isEvenPredicate)\n    .forEach(System.out::println);\n2.Consumer\n    List<String> names = new ArrayList<>();\n    names.add(\"Alice\");\n    names.add(\"Bob\");\n    names.add(\"Charlie\");\n    Consumer<String> printConsumer = System.out::println;\n    在 forEach 方法内部，它会被隐式调用以打印列表中的每个元素。\n    names.forEach(printConsumer);\n3.Function\n    Function<String, Integer> parseIntFunction = Integer::parseInt;\n    int result = parseIntFunction.apply(\"123\");\n    System.out.println(result);\n4.Supplier (重点)\n    Supplier<Double> randomSupplier = Math::random;\n\tSystem.out.println(randomSupplier.get());\n```\n### 自定义函数式接口\n- @FunctionInterface注解只是一个规范性的对象,加了注解在接口上有两个方法编译都过不了\n- 示例:\n```java\n// 接口规范了重写方法的返回值和参数\n@FunctionalInterface\npublic interface returnName<T,V> {\n    V accept(T t);\n}\n```\n\n```java\n// 定义了一个方法: 接收一个函数式接口作为参数\npublic void print(returnName<Person,String> returnName){\n    // 里面又把被告作为参数传了进去\n    returnName.accept(new Person(\"jack\", 18, age.MAN));\n}\n```\n\n```java\n// 这里调用的实例确实是通过上下文拿到的\n@Test\npublic void test() {\n    print(Person::getName); // 结果:jack \n}\n```\n- 重点:\n  - **print方法体里其实才是对方法的重写: 传入了一个Person对象**\n  - **而在Test里面其实是对返回值的一个筛选输出: print(person -> person.getName());**\n  - **反过头来userSet.stream() -> 其实userSet是被当做重写方法的参数放了进去**\n```java\npublic void ext(Function<Person, String> function, Person person){\n    function.apply(person);\n}\n\n@Test\npublic void test1() {\n    ext(person -> person.getName(), new Person(\"jack\", 18, age.MAN));\n}\n```\n- 在stream流中其实对方法参数的传入进行了隐藏,而不是像上面自己传参\n## 深入stream\n### 流程stream\n```java\n@Test\npublic void test() {\n    Set<user> userSet = new HashSet<>();\n    userSet.add(new user());\n    List<userDTO> perfect = userSet.stream()\n        .map(user -> new userDTO())\n        .toList();\n}\n```\n\n![17328538657361732853865377.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17328538657361732853865377.png)\n### 闭包\n-  Lambda 表达式闭包特性，能够捕获外部作用域的局部变量\n- 这是jdk的新特性, 而不是语法糖\n```java\npublic void test3(Consumer<Integer> consumer){\n    Integer inner = 20;\n    consumer.accept(inner); //  <- 重写传参\n}\n\n@Test\npublic void test2(){\n    Integer outer = 19;  <- 闭包\n\t    test3(inner -> System.out.println(inner + \":\" + outer)); // outer闭包读取,因为outer不在作用域之内\n}\n```\n## Lambda语法糖\n```java\n// lambda写法 \nselect(list, (Person) -> Person.getGender() == age.MAN && Person.getName().equals(\"任小粟\"));\n\n// 实际语法糖\nselect(list, new lambda<Person>() {\n    @Override\n    public boolean select(Person Person) {\n        return Person.getGender().equals(age.MAN) && Person.getName().equals(\"任小粟\");\n    }\n});\n```\n## 结论\n- 函数式接口负责中间操作: 传参  返回结果值\n- Stream流负责对结果值的过滤filter, 转换map, 遍历foreach  \n- Lambda其实是在简化对结果值的判断\n- Stream流所有你需要做的事确实是对函数式方法的重写,内部隐藏了传参以及各种逻辑转化\n![17328588597371732858859198.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17328588597371732858859198.png)\n","source":"_posts/stream.md","raw":"---\ntitle: 函数式接口和stream流API\ntags:\n  - stream\ncategories: 编程\ndate: 2024-11-28 14:48:20\nbanner: \"[[pixel-banner-image.png]]\"\n---\n\n# FunctionStream\n## 初识stream流\n### 什么是stream流\n- stream流是`jdk8`引入的一种简化编程效率的工具, 通过stream流API,可以很轻松的把一种形式的对象转换成另一种对象\n- 通过一系列**中间操作**和**最终操作**来进行**功能增强**, 中间操作通常会引用一个函数式接口作为参数, 利用**参数行为化隐式进行方法重写,** 最终操作则会触发流的遍历并执行最终操作(把返回值传给下一个流)\n### 函数式接口(方法重写)\n- 函数式接口是只包含一个方法的接口\n- 通过函数式接口对隐式方法的重写, 可以通过lambda表达式显示进行方法重写, 也可以通过方法引用(引用类的方法来覆盖重写接口方法)\n- 4中基础函数式接口类型: Predicat  Consumer  Supplier  Function  Comparator(int compare(T o1, T o2))\n- lambda表达式: 当在方法内使用lambda其实是对函数接口唯一方法的重写, 通过隐式捕获上下文的变量来操作流中的元素\n![17327779764721732777975546.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17327779764721732777975546.png)\n```java\n1.Predicate\n    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    Predicate<Integer> isEvenPredicate = num -> num % 2 == 0;\n\tnumbers.stream()\n    .filter(isEvenPredicate)\n    .forEach(System.out::println);\n2.Consumer\n    List<String> names = new ArrayList<>();\n    names.add(\"Alice\");\n    names.add(\"Bob\");\n    names.add(\"Charlie\");\n    Consumer<String> printConsumer = System.out::println;\n    在 forEach 方法内部，它会被隐式调用以打印列表中的每个元素。\n    names.forEach(printConsumer);\n3.Function\n    Function<String, Integer> parseIntFunction = Integer::parseInt;\n    int result = parseIntFunction.apply(\"123\");\n    System.out.println(result);\n4.Supplier (重点)\n    Supplier<Double> randomSupplier = Math::random;\n\tSystem.out.println(randomSupplier.get());\n```\n### 自定义函数式接口\n- @FunctionInterface注解只是一个规范性的对象,加了注解在接口上有两个方法编译都过不了\n- 示例:\n```java\n// 接口规范了重写方法的返回值和参数\n@FunctionalInterface\npublic interface returnName<T,V> {\n    V accept(T t);\n}\n```\n\n```java\n// 定义了一个方法: 接收一个函数式接口作为参数\npublic void print(returnName<Person,String> returnName){\n    // 里面又把被告作为参数传了进去\n    returnName.accept(new Person(\"jack\", 18, age.MAN));\n}\n```\n\n```java\n// 这里调用的实例确实是通过上下文拿到的\n@Test\npublic void test() {\n    print(Person::getName); // 结果:jack \n}\n```\n- 重点:\n  - **print方法体里其实才是对方法的重写: 传入了一个Person对象**\n  - **而在Test里面其实是对返回值的一个筛选输出: print(person -> person.getName());**\n  - **反过头来userSet.stream() -> 其实userSet是被当做重写方法的参数放了进去**\n```java\npublic void ext(Function<Person, String> function, Person person){\n    function.apply(person);\n}\n\n@Test\npublic void test1() {\n    ext(person -> person.getName(), new Person(\"jack\", 18, age.MAN));\n}\n```\n- 在stream流中其实对方法参数的传入进行了隐藏,而不是像上面自己传参\n## 深入stream\n### 流程stream\n```java\n@Test\npublic void test() {\n    Set<user> userSet = new HashSet<>();\n    userSet.add(new user());\n    List<userDTO> perfect = userSet.stream()\n        .map(user -> new userDTO())\n        .toList();\n}\n```\n\n![17328538657361732853865377.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17328538657361732853865377.png)\n### 闭包\n-  Lambda 表达式闭包特性，能够捕获外部作用域的局部变量\n- 这是jdk的新特性, 而不是语法糖\n```java\npublic void test3(Consumer<Integer> consumer){\n    Integer inner = 20;\n    consumer.accept(inner); //  <- 重写传参\n}\n\n@Test\npublic void test2(){\n    Integer outer = 19;  <- 闭包\n\t    test3(inner -> System.out.println(inner + \":\" + outer)); // outer闭包读取,因为outer不在作用域之内\n}\n```\n## Lambda语法糖\n```java\n// lambda写法 \nselect(list, (Person) -> Person.getGender() == age.MAN && Person.getName().equals(\"任小粟\"));\n\n// 实际语法糖\nselect(list, new lambda<Person>() {\n    @Override\n    public boolean select(Person Person) {\n        return Person.getGender().equals(age.MAN) && Person.getName().equals(\"任小粟\");\n    }\n});\n```\n## 结论\n- 函数式接口负责中间操作: 传参  返回结果值\n- Stream流负责对结果值的过滤filter, 转换map, 遍历foreach  \n- Lambda其实是在简化对结果值的判断\n- Stream流所有你需要做的事确实是对函数式方法的重写,内部隐藏了传参以及各种逻辑转化\n![17328588597371732858859198.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17328588597371732858859198.png)\n","slug":"stream","published":1,"updated":"2025-10-14T13:06:01.539Z","_id":"cmfw4z0b5003uuomwgz5e7m0d","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"FunctionStream\"><a href=\"#FunctionStream\" class=\"headerlink\" title=\"FunctionStream\"></a>FunctionStream</h1><h2 id=\"初识stream流\"><a href=\"#初识stream流\" class=\"headerlink\" title=\"初识stream流\"></a>初识stream流</h2><h3 id=\"什么是stream流\"><a href=\"#什么是stream流\" class=\"headerlink\" title=\"什么是stream流\"></a>什么是stream流</h3><ul>\n<li>stream流是<code>jdk8</code>引入的一种简化编程效率的工具, 通过stream流API,可以很轻松的把一种形式的对象转换成另一种对象</li>\n<li>通过一系列<strong>中间操作</strong>和<strong>最终操作</strong>来进行<strong>功能增强</strong>, 中间操作通常会引用一个函数式接口作为参数, 利用<strong>参数行为化隐式进行方法重写,</strong> 最终操作则会触发流的遍历并执行最终操作(把返回值传给下一个流)<h3 id=\"函数式接口-方法重写\"><a href=\"#函数式接口-方法重写\" class=\"headerlink\" title=\"函数式接口(方法重写)\"></a>函数式接口(方法重写)</h3></li>\n<li>函数式接口是只包含一个方法的接口</li>\n<li>通过函数式接口对隐式方法的重写, 可以通过lambda表达式显示进行方法重写, 也可以通过方法引用(引用类的方法来覆盖重写接口方法)</li>\n<li>4中基础函数式接口类型: Predicat  Consumer  Supplier  Function  Comparator(int compare(T o1, T o2))</li>\n<li>lambda表达式: 当在方法内使用lambda其实是对函数接口唯一方法的重写, 通过隐式捕获上下文的变量来操作流中的元素<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17327779764721732777975546.png\" alt=\"17327779764721732777975546.png\"><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>Predicate</span><br><span class=\"line\">    List&lt;Integer&gt; numbers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">    Predicate&lt;Integer&gt; isEvenPredicate = num -&gt; num % <span class=\"number\">2</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\">\tnumbers.stream()</span><br><span class=\"line\">    .filter(isEvenPredicate)</span><br><span class=\"line\">    .forEach(System.out::println);</span><br><span class=\"line\"><span class=\"number\">2.</span>Consumer</span><br><span class=\"line\">    List&lt;String&gt; names = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;Alice&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;Charlie&quot;</span>);</span><br><span class=\"line\">    Consumer&lt;String&gt; printConsumer = System.out::println;</span><br><span class=\"line\">    在 forEach 方法内部，它会被隐式调用以打印列表中的每个元素。</span><br><span class=\"line\">    names.forEach(printConsumer);</span><br><span class=\"line\"><span class=\"number\">3.</span>Function</span><br><span class=\"line\">    Function&lt;String, Integer&gt; parseIntFunction = Integer::parseInt;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> parseIntFunction.apply(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\"><span class=\"number\">4.</span>Supplier (重点)</span><br><span class=\"line\">    Supplier&lt;Double&gt; randomSupplier = Math::random;</span><br><span class=\"line\">\tSystem.out.println(randomSupplier.get());</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义函数式接口\"><a href=\"#自定义函数式接口\" class=\"headerlink\" title=\"自定义函数式接口\"></a>自定义函数式接口</h3></li>\n<li>@FunctionInterface注解只是一个规范性的对象,加了注解在接口上有两个方法编译都过不了</li>\n<li>示例:<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接口规范了重写方法的返回值和参数</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">returnName</span>&lt;T,V&gt; &#123;</span><br><span class=\"line\">    V <span class=\"title function_\">accept</span><span class=\"params\">(T t)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义了一个方法: 接收一个函数式接口作为参数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">print</span><span class=\"params\">(returnName&lt;Person,String&gt; returnName)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 里面又把被告作为参数传了进去</span></span><br><span class=\"line\">    returnName.accept(<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;jack&quot;</span>, <span class=\"number\">18</span>, age.MAN));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里调用的实例确实是通过上下文拿到的</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    print(Person::getName); <span class=\"comment\">// 结果:jack </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>重点:<ul>\n<li><strong>print方法体里其实才是对方法的重写: 传入了一个Person对象</strong></li>\n<li><strong>而在Test里面其实是对返回值的一个筛选输出: print(person -&gt; person.getName());</strong></li>\n<li><strong>反过头来userSet.stream() -&gt; 其实userSet是被当做重写方法的参数放了进去</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ext</span><span class=\"params\">(Function&lt;Person, String&gt; function, Person person)</span>&#123;</span><br><span class=\"line\">    function.apply(person);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    ext(person -&gt; person.getName(), <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;jack&quot;</span>, <span class=\"number\">18</span>, age.MAN));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>在stream流中其实对方法参数的传入进行了隐藏,而不是像上面自己传参<h2 id=\"深入stream\"><a href=\"#深入stream\" class=\"headerlink\" title=\"深入stream\"></a>深入stream</h2><h3 id=\"流程stream\"><a href=\"#流程stream\" class=\"headerlink\" title=\"流程stream\"></a>流程stream</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Set&lt;user&gt; userSet = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">    userSet.add(<span class=\"keyword\">new</span> <span class=\"title class_\">user</span>());</span><br><span class=\"line\">    List&lt;userDTO&gt; perfect = userSet.stream()</span><br><span class=\"line\">        .map(user -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">userDTO</span>())</span><br><span class=\"line\">        .toList();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17328538657361732853865377.png\" alt=\"17328538657361732853865377.png\"></p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><ul>\n<li>Lambda 表达式闭包特性，能够捕获外部作用域的局部变量</li>\n<li>这是jdk的新特性, 而不是语法糖<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">(Consumer&lt;Integer&gt; consumer)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">inner</span> <span class=\"operator\">=</span> <span class=\"number\">20</span>;</span><br><span class=\"line\">    consumer.accept(inner); <span class=\"comment\">//  &lt;- 重写传参</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">outer</span> <span class=\"operator\">=</span> <span class=\"number\">19</span>;  &lt;- 闭包</span><br><span class=\"line\">\t    test3(inner -&gt; System.out.println(inner + <span class=\"string\">&quot;:&quot;</span> + outer)); <span class=\"comment\">// outer闭包读取,因为outer不在作用域之内</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Lambda语法糖\"><a href=\"#Lambda语法糖\" class=\"headerlink\" title=\"Lambda语法糖\"></a>Lambda语法糖</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lambda写法 </span></span><br><span class=\"line\">select(list, (Person) -&gt; Person.getGender() == age.MAN &amp;&amp; Person.getName().equals(<span class=\"string\">&quot;任小粟&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实际语法糖</span></span><br><span class=\"line\">select(list, <span class=\"keyword\">new</span> <span class=\"title class_\">lambda</span>&lt;Person&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">select</span><span class=\"params\">(Person Person)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Person.getGender().equals(age.MAN) &amp;&amp; Person.getName().equals(<span class=\"string\">&quot;任小粟&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2></li>\n<li>函数式接口负责中间操作: 传参  返回结果值</li>\n<li>Stream流负责对结果值的过滤filter, 转换map, 遍历foreach  </li>\n<li>Lambda其实是在简化对结果值的判断</li>\n<li>Stream流所有你需要做的事确实是对函数式方法的重写,内部隐藏了传参以及各种逻辑转化<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17328588597371732858859198.png\" alt=\"17328588597371732858859198.png\"></li>\n</ul>\n","cover":"/img/2.png","cover_type":"img","excerpt":"","more":"<h1 id=\"FunctionStream\"><a href=\"#FunctionStream\" class=\"headerlink\" title=\"FunctionStream\"></a>FunctionStream</h1><h2 id=\"初识stream流\"><a href=\"#初识stream流\" class=\"headerlink\" title=\"初识stream流\"></a>初识stream流</h2><h3 id=\"什么是stream流\"><a href=\"#什么是stream流\" class=\"headerlink\" title=\"什么是stream流\"></a>什么是stream流</h3><ul>\n<li>stream流是<code>jdk8</code>引入的一种简化编程效率的工具, 通过stream流API,可以很轻松的把一种形式的对象转换成另一种对象</li>\n<li>通过一系列<strong>中间操作</strong>和<strong>最终操作</strong>来进行<strong>功能增强</strong>, 中间操作通常会引用一个函数式接口作为参数, 利用<strong>参数行为化隐式进行方法重写,</strong> 最终操作则会触发流的遍历并执行最终操作(把返回值传给下一个流)<h3 id=\"函数式接口-方法重写\"><a href=\"#函数式接口-方法重写\" class=\"headerlink\" title=\"函数式接口(方法重写)\"></a>函数式接口(方法重写)</h3></li>\n<li>函数式接口是只包含一个方法的接口</li>\n<li>通过函数式接口对隐式方法的重写, 可以通过lambda表达式显示进行方法重写, 也可以通过方法引用(引用类的方法来覆盖重写接口方法)</li>\n<li>4中基础函数式接口类型: Predicat  Consumer  Supplier  Function  Comparator(int compare(T o1, T o2))</li>\n<li>lambda表达式: 当在方法内使用lambda其实是对函数接口唯一方法的重写, 通过隐式捕获上下文的变量来操作流中的元素<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17327779764721732777975546.png\" alt=\"17327779764721732777975546.png\"><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>Predicate</span><br><span class=\"line\">    List&lt;Integer&gt; numbers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">    Predicate&lt;Integer&gt; isEvenPredicate = num -&gt; num % <span class=\"number\">2</span> == <span class=\"number\">0</span>;</span><br><span class=\"line\">\tnumbers.stream()</span><br><span class=\"line\">    .filter(isEvenPredicate)</span><br><span class=\"line\">    .forEach(System.out::println);</span><br><span class=\"line\"><span class=\"number\">2.</span>Consumer</span><br><span class=\"line\">    List&lt;String&gt; names = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;Alice&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;Charlie&quot;</span>);</span><br><span class=\"line\">    Consumer&lt;String&gt; printConsumer = System.out::println;</span><br><span class=\"line\">    在 forEach 方法内部，它会被隐式调用以打印列表中的每个元素。</span><br><span class=\"line\">    names.forEach(printConsumer);</span><br><span class=\"line\"><span class=\"number\">3.</span>Function</span><br><span class=\"line\">    Function&lt;String, Integer&gt; parseIntFunction = Integer::parseInt;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> parseIntFunction.apply(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\"><span class=\"number\">4.</span>Supplier (重点)</span><br><span class=\"line\">    Supplier&lt;Double&gt; randomSupplier = Math::random;</span><br><span class=\"line\">\tSystem.out.println(randomSupplier.get());</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义函数式接口\"><a href=\"#自定义函数式接口\" class=\"headerlink\" title=\"自定义函数式接口\"></a>自定义函数式接口</h3></li>\n<li>@FunctionInterface注解只是一个规范性的对象,加了注解在接口上有两个方法编译都过不了</li>\n<li>示例:<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接口规范了重写方法的返回值和参数</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">returnName</span>&lt;T,V&gt; &#123;</span><br><span class=\"line\">    V <span class=\"title function_\">accept</span><span class=\"params\">(T t)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义了一个方法: 接收一个函数式接口作为参数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">print</span><span class=\"params\">(returnName&lt;Person,String&gt; returnName)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 里面又把被告作为参数传了进去</span></span><br><span class=\"line\">    returnName.accept(<span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;jack&quot;</span>, <span class=\"number\">18</span>, age.MAN));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里调用的实例确实是通过上下文拿到的</span></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    print(Person::getName); <span class=\"comment\">// 结果:jack </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>重点:<ul>\n<li><strong>print方法体里其实才是对方法的重写: 传入了一个Person对象</strong></li>\n<li><strong>而在Test里面其实是对返回值的一个筛选输出: print(person -&gt; person.getName());</strong></li>\n<li><strong>反过头来userSet.stream() -&gt; 其实userSet是被当做重写方法的参数放了进去</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ext</span><span class=\"params\">(Function&lt;Person, String&gt; function, Person person)</span>&#123;</span><br><span class=\"line\">    function.apply(person);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    ext(person -&gt; person.getName(), <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;jack&quot;</span>, <span class=\"number\">18</span>, age.MAN));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>在stream流中其实对方法参数的传入进行了隐藏,而不是像上面自己传参<h2 id=\"深入stream\"><a href=\"#深入stream\" class=\"headerlink\" title=\"深入stream\"></a>深入stream</h2><h3 id=\"流程stream\"><a href=\"#流程stream\" class=\"headerlink\" title=\"流程stream\"></a>流程stream</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Set&lt;user&gt; userSet = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">    userSet.add(<span class=\"keyword\">new</span> <span class=\"title class_\">user</span>());</span><br><span class=\"line\">    List&lt;userDTO&gt; perfect = userSet.stream()</span><br><span class=\"line\">        .map(user -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">userDTO</span>())</span><br><span class=\"line\">        .toList();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17328538657361732853865377.png\" alt=\"17328538657361732853865377.png\"></p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><ul>\n<li>Lambda 表达式闭包特性，能够捕获外部作用域的局部变量</li>\n<li>这是jdk的新特性, 而不是语法糖<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">(Consumer&lt;Integer&gt; consumer)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">inner</span> <span class=\"operator\">=</span> <span class=\"number\">20</span>;</span><br><span class=\"line\">    consumer.accept(inner); <span class=\"comment\">//  &lt;- 重写传参</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">outer</span> <span class=\"operator\">=</span> <span class=\"number\">19</span>;  &lt;- 闭包</span><br><span class=\"line\">\t    test3(inner -&gt; System.out.println(inner + <span class=\"string\">&quot;:&quot;</span> + outer)); <span class=\"comment\">// outer闭包读取,因为outer不在作用域之内</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Lambda语法糖\"><a href=\"#Lambda语法糖\" class=\"headerlink\" title=\"Lambda语法糖\"></a>Lambda语法糖</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lambda写法 </span></span><br><span class=\"line\">select(list, (Person) -&gt; Person.getGender() == age.MAN &amp;&amp; Person.getName().equals(<span class=\"string\">&quot;任小粟&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实际语法糖</span></span><br><span class=\"line\">select(list, <span class=\"keyword\">new</span> <span class=\"title class_\">lambda</span>&lt;Person&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">select</span><span class=\"params\">(Person Person)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Person.getGender().equals(age.MAN) &amp;&amp; Person.getName().equals(<span class=\"string\">&quot;任小粟&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2></li>\n<li>函数式接口负责中间操作: 传参  返回结果值</li>\n<li>Stream流负责对结果值的过滤filter, 转换map, 遍历foreach  </li>\n<li>Lambda其实是在简化对结果值的判断</li>\n<li>Stream流所有你需要做的事确实是对函数式方法的重写,内部隐藏了传参以及各种逻辑转化<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17328588597371732858859198.png\" alt=\"17328588597371732858859198.png\"></li>\n</ul>\n"},{"title":"理解栈和堆在JVM中作用","date":"2024-12-02T10:22:38.000Z","_content":"\n# stackHeap\n\n- **栈是运行时的单位，而堆是存储的单位**\n- **每个方法调用都会创建一个栈帧，栈帧保存着该方法的局部变量、参数等信息，方法执行完毕后栈帧销毁。**\n## 栈和堆的生命周期\n\n通常情况下，在方法内部定义的引用类型变量只在该方法内部有效。一旦方法执行结束，变量将被销毁\n\n![17331392979641733139297889.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17331392979641733139297889.png)\n\n## 栈和堆的作用\n\n  - **栈内存的特性：**\n    - 每个线程都有独立的栈内存是私有的\n    - 方法调用过程中产生的局部变量（包括基本数据类型和对象引用）\n    - 栈内存随着方法的进栈和出栈自动管理，不需要 GC 来回收\n    - 栈的生命周期与线程一致，线程结束时(方法执行完毕后)栈内存自动销毁，栈中的数据会自动销毁, 不涉及gc\n\n    **堆内存的特性：**\n    - 堆是线程共享的, 所有线程可以访问堆内存中的对象。\n\n    - 堆内存用于存储所有对象实例和数组，生命周期可能超出方法的执行范围。\n    - 这些对象由 GC 管理，确保程序运行过程中不会出现内存泄漏。\n    - GC 通过算法检测堆中哪些对象不再被引用，从而释放它们的内存。\n\n- 栈是用来执行当用户线程执行到某个方法时用来执行出入栈运算操作\n\n- 堆是程序启动初期用来存储所有实例对象,class对象,字符串对象以及常量池的存储空间(通常和方法区共同作用), 当用户线程进来执行到特定方法而new出来的对象不受容器控制时,就需要gc了\n\n## 例子\n\n- **栈中存储引用变量**： 栈中的局部变量可能保存对堆中对象的引用。例如：\n\n```java\nString refer1 = new String(\"Hello\"); // refer1 是存放在栈中的局部变量，指向堆中的 \"Hello\" 对象\nString refer2 = \"Hello\";             // 字符串常量池中存储了 \"Hello\"\n```\n\n当栈帧退出，`name` 变量从栈中销毁。如果没有其他引用指向堆中的 `\"Hello\"` 对象，GC 会回收它。\n\n- **对象在堆上分配内存**： 方法执行时，局部变量指向堆中的对象。只要堆中的对象有引用（强引用、弱引用等），它就不会被回收\n\n```java\npublic void gcExample() {\n    String str1 = new String(\"Hello\"); // str1 存在栈中，\"Hello\" 对象存放在堆中\n    String str2 = str1;               // str2 也指向堆中的 \"Hello\"\n    str1 = null;                      // str1 断开引用\n    // 由于 str2 仍然引用着堆中的 \"Hello\", 只要有一个引用, GC就不会回收该对象\n    str2 = null;                      // str2 也断开引用，此时 \"Hello\" 可被 GC 回收\n}\n```\n\n## 内存泄漏(memoryLeak)\n\n```java\npublic class MemoryLeakExample {\n    // static是常量,无法通过栈自动销毁,也就无法GC(gc需要无指引的对象),当list存储的对象越来越多就会造成内存泄漏\n    private static List<Object> list = new ArrayList<>(); \n\n    public static void createLeak() {\n        for (int i = 0; i < 1000000; i++) {\n            Object obj = new Object(); // 新对象存储在堆中\n            list.add(obj);             // 对象被静态 list 引用\n        }\n    }\n}\n```\n\n- **list的引用不是定义在方法内部(即局部变量),也就导致了变量的reference不能被销毁**\n\n```java\npublic class NormalExample {\n    public static void createObjects() {\n        for (int i = 0; i < 1000000; i++) {\n            Object obj = new Object(); // 局部变量 obj 存储在栈中\n        } // 方法结束后，obj 的作用域结束，堆中的对象无引用，GC 会回收\n    }\n}\n```\n","source":"_posts/stackHeap.md","raw":"---\ntitle: 理解栈和堆在JVM中作用\ntags:\n  - stack\n  - heap\n  - Jvm\ncategories: 编程\ndate: 2024-12-02 18:22:38\n---\n\n# stackHeap\n\n- **栈是运行时的单位，而堆是存储的单位**\n- **每个方法调用都会创建一个栈帧，栈帧保存着该方法的局部变量、参数等信息，方法执行完毕后栈帧销毁。**\n## 栈和堆的生命周期\n\n通常情况下，在方法内部定义的引用类型变量只在该方法内部有效。一旦方法执行结束，变量将被销毁\n\n![17331392979641733139297889.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17331392979641733139297889.png)\n\n## 栈和堆的作用\n\n  - **栈内存的特性：**\n    - 每个线程都有独立的栈内存是私有的\n    - 方法调用过程中产生的局部变量（包括基本数据类型和对象引用）\n    - 栈内存随着方法的进栈和出栈自动管理，不需要 GC 来回收\n    - 栈的生命周期与线程一致，线程结束时(方法执行完毕后)栈内存自动销毁，栈中的数据会自动销毁, 不涉及gc\n\n    **堆内存的特性：**\n    - 堆是线程共享的, 所有线程可以访问堆内存中的对象。\n\n    - 堆内存用于存储所有对象实例和数组，生命周期可能超出方法的执行范围。\n    - 这些对象由 GC 管理，确保程序运行过程中不会出现内存泄漏。\n    - GC 通过算法检测堆中哪些对象不再被引用，从而释放它们的内存。\n\n- 栈是用来执行当用户线程执行到某个方法时用来执行出入栈运算操作\n\n- 堆是程序启动初期用来存储所有实例对象,class对象,字符串对象以及常量池的存储空间(通常和方法区共同作用), 当用户线程进来执行到特定方法而new出来的对象不受容器控制时,就需要gc了\n\n## 例子\n\n- **栈中存储引用变量**： 栈中的局部变量可能保存对堆中对象的引用。例如：\n\n```java\nString refer1 = new String(\"Hello\"); // refer1 是存放在栈中的局部变量，指向堆中的 \"Hello\" 对象\nString refer2 = \"Hello\";             // 字符串常量池中存储了 \"Hello\"\n```\n\n当栈帧退出，`name` 变量从栈中销毁。如果没有其他引用指向堆中的 `\"Hello\"` 对象，GC 会回收它。\n\n- **对象在堆上分配内存**： 方法执行时，局部变量指向堆中的对象。只要堆中的对象有引用（强引用、弱引用等），它就不会被回收\n\n```java\npublic void gcExample() {\n    String str1 = new String(\"Hello\"); // str1 存在栈中，\"Hello\" 对象存放在堆中\n    String str2 = str1;               // str2 也指向堆中的 \"Hello\"\n    str1 = null;                      // str1 断开引用\n    // 由于 str2 仍然引用着堆中的 \"Hello\", 只要有一个引用, GC就不会回收该对象\n    str2 = null;                      // str2 也断开引用，此时 \"Hello\" 可被 GC 回收\n}\n```\n\n## 内存泄漏(memoryLeak)\n\n```java\npublic class MemoryLeakExample {\n    // static是常量,无法通过栈自动销毁,也就无法GC(gc需要无指引的对象),当list存储的对象越来越多就会造成内存泄漏\n    private static List<Object> list = new ArrayList<>(); \n\n    public static void createLeak() {\n        for (int i = 0; i < 1000000; i++) {\n            Object obj = new Object(); // 新对象存储在堆中\n            list.add(obj);             // 对象被静态 list 引用\n        }\n    }\n}\n```\n\n- **list的引用不是定义在方法内部(即局部变量),也就导致了变量的reference不能被销毁**\n\n```java\npublic class NormalExample {\n    public static void createObjects() {\n        for (int i = 0; i < 1000000; i++) {\n            Object obj = new Object(); // 局部变量 obj 存储在栈中\n        } // 方法结束后，obj 的作用域结束，堆中的对象无引用，GC 会回收\n    }\n}\n```\n","slug":"stackHeap","published":1,"updated":"2025-04-27T05:04:21.949Z","comments":1,"layout":"post","photos":[],"_id":"cmfw4z0b7003vuomw9x8gdzid","content":"<h1 id=\"stackHeap\"><a href=\"#stackHeap\" class=\"headerlink\" title=\"stackHeap\"></a>stackHeap</h1><ul>\n<li><strong>栈是运行时的单位，而堆是存储的单位</strong></li>\n<li><strong>每个方法调用都会创建一个栈帧，栈帧保存着该方法的局部变量、参数等信息，方法执行完毕后栈帧销毁。</strong><h2 id=\"栈和堆的生命周期\"><a href=\"#栈和堆的生命周期\" class=\"headerlink\" title=\"栈和堆的生命周期\"></a>栈和堆的生命周期</h2></li>\n</ul>\n<p>通常情况下，在方法内部定义的引用类型变量只在该方法内部有效。一旦方法执行结束，变量将被销毁</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17331392979641733139297889.png\" alt=\"17331392979641733139297889.png\"></p>\n<h2 id=\"栈和堆的作用\"><a href=\"#栈和堆的作用\" class=\"headerlink\" title=\"栈和堆的作用\"></a>栈和堆的作用</h2><ul>\n<li><p><strong>栈内存的特性：</strong></p>\n<ul>\n<li>每个线程都有独立的栈内存是私有的</li>\n<li>方法调用过程中产生的局部变量（包括基本数据类型和对象引用）</li>\n<li>栈内存随着方法的进栈和出栈自动管理，不需要 GC 来回收</li>\n<li>栈的生命周期与线程一致，线程结束时(方法执行完毕后)栈内存自动销毁，栈中的数据会自动销毁, 不涉及gc</li>\n</ul>\n<p><strong>堆内存的特性：</strong></p>\n<ul>\n<li><p>堆是线程共享的, 所有线程可以访问堆内存中的对象。</p>\n</li>\n<li><p>堆内存用于存储所有对象实例和数组，生命周期可能超出方法的执行范围。</p>\n</li>\n<li>这些对象由 GC 管理，确保程序运行过程中不会出现内存泄漏。</li>\n<li>GC 通过算法检测堆中哪些对象不再被引用，从而释放它们的内存。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>栈是用来执行当用户线程执行到某个方法时用来执行出入栈运算操作</p>\n</li>\n<li><p>堆是程序启动初期用来存储所有实例对象,class对象,字符串对象以及常量池的存储空间(通常和方法区共同作用), 当用户线程进来执行到特定方法而new出来的对象不受容器控制时,就需要gc了</p>\n</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><ul>\n<li><strong>栈中存储引用变量</strong>： 栈中的局部变量可能保存对堆中对象的引用。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">refer1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// refer1 是存放在栈中的局部变量，指向堆中的 &quot;Hello&quot; 对象</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">refer2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello&quot;</span>;             <span class=\"comment\">// 字符串常量池中存储了 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>\n<p>当栈帧退出，<code>name</code> 变量从栈中销毁。如果没有其他引用指向堆中的 <code>&quot;Hello&quot;</code> 对象，GC 会回收它。</p>\n<ul>\n<li><strong>对象在堆上分配内存</strong>： 方法执行时，局部变量指向堆中的对象。只要堆中的对象有引用（强引用、弱引用等），它就不会被回收</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">gcExample</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// str1 存在栈中，&quot;Hello&quot; 对象存放在堆中</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> str1;               <span class=\"comment\">// str2 也指向堆中的 &quot;Hello&quot;</span></span><br><span class=\"line\">    str1 = <span class=\"literal\">null</span>;                      <span class=\"comment\">// str1 断开引用</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于 str2 仍然引用着堆中的 &quot;Hello&quot;, 只要有一个引用, GC就不会回收该对象</span></span><br><span class=\"line\">    str2 = <span class=\"literal\">null</span>;                      <span class=\"comment\">// str2 也断开引用，此时 &quot;Hello&quot; 可被 GC 回收</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"内存泄漏-memoryLeak\"><a href=\"#内存泄漏-memoryLeak\" class=\"headerlink\" title=\"内存泄漏(memoryLeak)\"></a>内存泄漏(memoryLeak)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MemoryLeakExample</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// static是常量,无法通过栈自动销毁,也就无法GC(gc需要无指引的对象),当list存储的对象越来越多就会造成内存泄漏</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;Object&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createLeak</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>(); <span class=\"comment\">// 新对象存储在堆中</span></span><br><span class=\"line\">            list.add(obj);             <span class=\"comment\">// 对象被静态 list 引用</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>list的引用不是定义在方法内部(即局部变量),也就导致了变量的reference不能被销毁</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NormalExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createObjects</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>(); <span class=\"comment\">// 局部变量 obj 存储在栈中</span></span><br><span class=\"line\">        &#125; <span class=\"comment\">// 方法结束后，obj 的作用域结束，堆中的对象无引用，GC 会回收</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","cover":"/img/3.png","cover_type":"img","excerpt":"","more":"<h1 id=\"stackHeap\"><a href=\"#stackHeap\" class=\"headerlink\" title=\"stackHeap\"></a>stackHeap</h1><ul>\n<li><strong>栈是运行时的单位，而堆是存储的单位</strong></li>\n<li><strong>每个方法调用都会创建一个栈帧，栈帧保存着该方法的局部变量、参数等信息，方法执行完毕后栈帧销毁。</strong><h2 id=\"栈和堆的生命周期\"><a href=\"#栈和堆的生命周期\" class=\"headerlink\" title=\"栈和堆的生命周期\"></a>栈和堆的生命周期</h2></li>\n</ul>\n<p>通常情况下，在方法内部定义的引用类型变量只在该方法内部有效。一旦方法执行结束，变量将被销毁</p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17331392979641733139297889.png\" alt=\"17331392979641733139297889.png\"></p>\n<h2 id=\"栈和堆的作用\"><a href=\"#栈和堆的作用\" class=\"headerlink\" title=\"栈和堆的作用\"></a>栈和堆的作用</h2><ul>\n<li><p><strong>栈内存的特性：</strong></p>\n<ul>\n<li>每个线程都有独立的栈内存是私有的</li>\n<li>方法调用过程中产生的局部变量（包括基本数据类型和对象引用）</li>\n<li>栈内存随着方法的进栈和出栈自动管理，不需要 GC 来回收</li>\n<li>栈的生命周期与线程一致，线程结束时(方法执行完毕后)栈内存自动销毁，栈中的数据会自动销毁, 不涉及gc</li>\n</ul>\n<p><strong>堆内存的特性：</strong></p>\n<ul>\n<li><p>堆是线程共享的, 所有线程可以访问堆内存中的对象。</p>\n</li>\n<li><p>堆内存用于存储所有对象实例和数组，生命周期可能超出方法的执行范围。</p>\n</li>\n<li>这些对象由 GC 管理，确保程序运行过程中不会出现内存泄漏。</li>\n<li>GC 通过算法检测堆中哪些对象不再被引用，从而释放它们的内存。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>栈是用来执行当用户线程执行到某个方法时用来执行出入栈运算操作</p>\n</li>\n<li><p>堆是程序启动初期用来存储所有实例对象,class对象,字符串对象以及常量池的存储空间(通常和方法区共同作用), 当用户线程进来执行到特定方法而new出来的对象不受容器控制时,就需要gc了</p>\n</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><ul>\n<li><strong>栈中存储引用变量</strong>： 栈中的局部变量可能保存对堆中对象的引用。例如：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">refer1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// refer1 是存放在栈中的局部变量，指向堆中的 &quot;Hello&quot; 对象</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">refer2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello&quot;</span>;             <span class=\"comment\">// 字符串常量池中存储了 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>\n<p>当栈帧退出，<code>name</code> 变量从栈中销毁。如果没有其他引用指向堆中的 <code>&quot;Hello&quot;</code> 对象，GC 会回收它。</p>\n<ul>\n<li><strong>对象在堆上分配内存</strong>： 方法执行时，局部变量指向堆中的对象。只要堆中的对象有引用（强引用、弱引用等），它就不会被回收</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">gcExample</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// str1 存在栈中，&quot;Hello&quot; 对象存放在堆中</span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> str1;               <span class=\"comment\">// str2 也指向堆中的 &quot;Hello&quot;</span></span><br><span class=\"line\">    str1 = <span class=\"literal\">null</span>;                      <span class=\"comment\">// str1 断开引用</span></span><br><span class=\"line\">    <span class=\"comment\">// 由于 str2 仍然引用着堆中的 &quot;Hello&quot;, 只要有一个引用, GC就不会回收该对象</span></span><br><span class=\"line\">    str2 = <span class=\"literal\">null</span>;                      <span class=\"comment\">// str2 也断开引用，此时 &quot;Hello&quot; 可被 GC 回收</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"内存泄漏-memoryLeak\"><a href=\"#内存泄漏-memoryLeak\" class=\"headerlink\" title=\"内存泄漏(memoryLeak)\"></a>内存泄漏(memoryLeak)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MemoryLeakExample</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// static是常量,无法通过栈自动销毁,也就无法GC(gc需要无指引的对象),当list存储的对象越来越多就会造成内存泄漏</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;Object&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createLeak</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>(); <span class=\"comment\">// 新对象存储在堆中</span></span><br><span class=\"line\">            list.add(obj);             <span class=\"comment\">// 对象被静态 list 引用</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>list的引用不是定义在方法内部(即局部变量),也就导致了变量的reference不能被销毁</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NormalExample</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createObjects</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>(); <span class=\"comment\">// 局部变量 obj 存储在栈中</span></span><br><span class=\"line\">        &#125; <span class=\"comment\">// 方法结束后，obj 的作用域结束，堆中的对象无引用，GC 会回收</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"banner":"[[pixel-banner-image.png]]","title":"web开发的踩坑避雷","date":"2025-03-22T07:48:00.000Z","_content":"\n\twe've got you covered there, too.\n# Web开发总结\n## `axios` 详解\n### `axiox` 实例的创建\n```javascript\nimport axios from 'axios'; \n/* 创建 axios 实例的好处：  \n 可以配置默认 baseURL，避免重复写 API 地址\n 可以添加请求/响应拦截器，统一处理 Token、错误消息等\n 便于维护和管理多个 API 端点\n*/\nexport function createAxiosInstance() {\n    const axiosInstance = axios.create({\n        baseURL: process.env.VUE_APP_SERVER, // 替换为你的后端 API 地址\n        timeout: 5000, // 请求超时时间\n        withCredentials: true,  //允许跨域\n        headers: {\n            'Content-Type': 'application/json',\n        },\n    });\n    return axiosInstance;\n}\n// 或者直接修改全局默认配置, 否则需要调用实例 注意: 要定义在mian.js中才生效\naxios.defaults.baseURL = process.env.VUE_APP_SERVER;\naxios.defaults.timeout = 5000;\naxios.defaults.withCredentials = true;\naxios.defaults.headers['Content-Type'] = 'application/json';\n```\n### `axios` 拦截器\n```javascript\n// 请求拦截器\naxios.interceptors.request.use(\n    (config) => {\n        // 打印请求参数\n        console.log(\"请求参数: \" ,config)\n        // 从本地存储或者商店中拿\n        const token = localStorage.getItem('Authorization');\n        config.headers[\"Authorization\"] = `${token}`;\n        config.headers['Content-Encoding'] = \"utf-8\"\n        return config;\n    }\n);\n// 响应拦截器\naxios.interceptors.response.use(\n    (response) => {\n        // 打印响应参数\n        console.log(\"响应参数: \" ,response)\n        // HTTP响应状态码正常 200 OK\n        if (response.status === 200) {\n            const data = response.data;\n            // 自定义统一响应结果的code值: 由后端定义\n            if (data.code === HttpCode.SUCCESS) {\n                message.success(\"响应一切正常:\" , response.statusText);\n                return Promise.resolve(response)\n            } else if (data.code === HttpCode.NOT_FOUND) {\n                    message.error(\"404 Not Fount\")\n                    return Promise.reject(response.data.message);\n                } else if (data.code === HttpCode.UNAUTHORIZED) {\n                        message.error(\"401 未授权 token过期\")\n                        return Promise.reject(response.data.message);\n                    } else if (data.code === HttpCode.SERVER_ERROR) {\n                            message.error(\"500 服务器错误\")\n                            return Promise.reject(response.data.message);\n                        } else {\n                            message.warn(\"未知错误: \" + data.message)\n                            return Promise.reject(response.data.message);\n                        }\n        }\n        // 接口404的情况\n        else if (response.status === 404) {\n            message.warning(\"404访问页面不存在\");\n            return Promise.reject(response.data.message);\n        }\n        // 其他情况\n        else {\n            message.error(\"response.status: \" + response.status)\n            return Promise.reject(response.data.message);\n        }\n    }\n);\n```\n### `axios` 发送请求\n```javascript\n// 发送验证码请求: baseUrl由axios的实例定义了\nexport const sendCodeRequest = async (data) => {\n    const response = await axios.post(\"/member/sendCode\", data);\n    if (response.data.data) {\n        // Axios 默认已经解析 JSON，不需要 `JSON.parse(response.data)`\n        return {\n            mobile: response.data.data.mobile || \"\",\n            verificationCode: response.data.data.verificationCode\n        };\n    }\n    throw new Error(\"返回数据为空\");\n}\n```\n- 一个简单地axios由3部分组成: (url, data, config) 以及一个Promise\n### `Router`守卫\n```javascript\n// 添加一个路由的全局前置守卫\nrouter.beforeEach(async function (to, from, next) {\n  // 判断是否是登录页面\n  if (to.name === \"login\" || to.name === \"NotFound\" || to.name === \"Forbidden\" || to.name === \"Error\") {\n    next();\n    return false;\n  }\n  // 判断本地是否记录token值\n  const memberStore = useMemberStore();\n  const token = memberStore.$state.Authorization;\n  // 如果没有token\n  if (!token) {\n    // next({ name: \"Login\" });\n    notification.error({description: \"在未登录时，禁止访问其他页面！\"});\n    router.push(\"/login\")\n    return false;\n  }\n  next();\n  return true;\n});\n```\n## `Promise` 详解\n### 什么是`Promise`\n- `Promise` 是 **JavaScript 中的一种异步处理机制**，用于解决 **回调地狱（Callback Hell）** 和 **异步操作的可读性问题**。它代表 **一个未来可能会完成或失败的操作**，并允许在操作完成后执行相应的代码\n### `Promise`的三种状态\n1. **`pending`（进行中）：** 初始状态，表示异步操作尚未完成。\n2. **`fulfilled`（已完成）：** 操作成功，`resolve()` 被调用。\n3. **`rejected`（已失败）：** 操作失败，`reject()` 被调用。\n- 一旦 `Promise` 从 `pending` 变为 `fulfilled` 或 `rejected`，就不能再改变状态（不可逆)\n### `Promise` 的基本用法\n```javascript\nconst myPromise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    let success = true;\n    if (success) {\n      resolve(\"操作成功！\"); // 成功调用 resolve\n    } else {\n      reject(\"操作失败！\"); // 失败调用 reject\n    }\n  }, 2000);\n});\n\n```\n在 `Promise` 内部：\n- 创建了一个promise, 函数体是执行内容\n- 根据内容决定  -> 执行哪一个内部函数resolve还是reject\n- `resolve(value)` **表示成功**，会触发 `.then()`\n- `reject(error)` **表示失败**，会触发 `.catch()`\n### `Promise`异步回调处理\n```javascript\nmyPromise\n  .then((result) => {\n    console.log(\"成功:\", result);\n  })\n  .catch((error) => {\n    console.error(\"失败:\", error);\n  })\n  .finally(() => {\n    console.log(\"无论成功还是失败都会执行！\");\n  });\n\n```\n执行流程：\n- 根据内部函数的执行, 从而决定调用then还是catch, 也就是会被捕捉\n1. 如果 `resolve()` 被调用，执行 `.then(result)` ,then()处理异步操作成功后的结果，返回一个新的 `Promise`，可以链式调用。\n2. 如果 `reject()` 被调用, 执行 `.catch(error)`\n3. `.finally()` 一定会执行，无论成功还是失败\n### `async/await`（Promise 的语法糖）\n```javascript\nconst fetchData = async () => {\n  try {\n    const result = await myPromise;\n    console.log(result);\n  } catch (error) {\n    console.error(\"错误:\", error);\n  } finally {\n    console.log(\"执行完成\");\n  }\n};\nfetchData();\n\n```\n`await` 关键字的作用：\n- 暂停代码执行，直到 `Promise` 解决\n- 可以直接获取 `Promise` 结果\n- 比 `.then()` 语法更直观\n### 用async还是then\n- 注意这里的两个return\n\t- 其实没必要用两个异步回调\n```javascript\nexport const batchJobAddOrResRequest = async (url, data) => {\n    return await axios.post(\"/batch/admin/job/\" + url, data).then((response) => {\n        try {\n            const Result = response.data;\n            if (Result.code === HttpStatusCode.Ok) {\n                return true;\n            }\n        } catch (error) {\n            console.error(\"定时任务添加错误\");\n        }\n    });\n}\n```\n## 组件中间值的传递\n- **对参数赋值, 值通过子组件传递进来**\n```javascript\n// 父组件: 定义了一个Switch, 通过子组件双向数据绑定的值进行设置打开状态\n<template>\n  <div>\n    <a-switch v-model:checked=\"switchValue\" />\n  <childComponent v-model=\"switchValue\" messageText=\"我对子盒子说话\" @messageMethod=\"getMessageDetail\"/>\n  </div>\n  <div>\n    {{ detailMessage }}\n  </div>\n</template>\n\n<script setup>\nimport { ref } from \"vue\";\nimport childComponent from \"./childComponent.vue\";\nconst switchValue = ref(false);\nlet detailMessage = ref();\nconst getMessageDetail = (detail) => {\n  detailMessage.value = detail;\n}\n</script>\n```\n\n```javascript\nwatch(\n  () => watchValue,\n  (newVal, oldVal) => {}\n```\n\n```javascript\n//  自定义子组件的属性和方法, 通过父组件传递参数\n<template>\n  <a-button\n    @click=\"handleClick\"\n    :style=\"'messageText: ' + '父组件可以显示设置子组件的style'\"\n  >\n    开关\n  </a-button>\n  <div>\n    {{ props.messageText }}\n  </div>\n</template>\n\n<script setup>\nimport { defineProps, defineEmits, ref, watch, onMounted } from \"vue\";\nonMounted(() => {\n  emits(\"messageMethod\", \"我是通过方法传递给父盒子的信息\")\n})\n// 定义了传递字段\nconst props = defineProps({\n  modelValue: Boolean,\n  messageText: String,\n});\n// 定义了传递函数\nconst emits = defineEmits([\"update:modelValue\", \"messageMethod\"]);\n\nlet switchValue = ref(false);\nconst handleClick = () => {\n  switchValue.value = !switchValue.value;\n  emits(\"update:modelValue\", switchValue.value ? false : true);\n};\n// 也可以通过对props.modelValue值的监听(vue3的watch), 来收到父组件的信息\nwatch(\n  () => props.modelValue,\n  (modelValue) => {\n    console.log(modelValue, \"的值变化了\");\n  }\n);\n</script>\n\n<style scoped>\n</style>\n```\n## 组件小部件\n- 表格数据渲染, row与col 通过v-for进行表格数据渲染, 作用与a-table和el-table一样\n\t- 数据源 - 表头行 - 间隔\n\t- 用v-for渲染: 在每一行数据中可以灵活运用v-if和v-model和差值语法进行处理\n```javascript\n<a-row class=\"order-tickets-header\" v-if=\"tickets.length > 0\">\n      <a-col :span=\"2\">乘客</a-col>\n      <a-col :span=\"6\">身份证</a-col>\n      <a-col :span=\"4\">票种</a-col>\n      <a-col :span=\"4\">座位类型</a-col>\n      <a-col :span=\"6\">乘客详细信息</a-col>\n    </a-row>\n    <a-row\n      class=\"order-tickets-row\"\n      v-for=\"(ticket, i) in tickets\"\n      :key=\"ticket.passengerId\"\n    >\n      <a-col :span=\"2\">{{ ticket.passengerName }}</a-col>\n      <a-col :span=\"6\">{{ ticket.passengerIdCard }}</a-col>\n      <a-col :span=\"4\">\n        <a-select v-model:value=\"ticket.passengerType\" style=\"width: 100%\">\n          <a-select-option\n            v-for=\"item in PASSENGER_TYPE_ARRAY\"\n            :key=\"item.code\"\n            :value=\"item.code\"\n          >\n            {{ item.desc }}\n          </a-select-option>\n        </a-select>\n      </a-col>\n\t  </a-row>\n```\n## Ref变量和reactive变量\n- reactive是响应式的(能自动解包), 就不需要通过 `.value`获取值, 对于对象和数组能快速取值\n- 在 Vue 3 的 Composition API 里，`ref()` 返回的是一个对象，这个对象有一个 `value` 属性，它才是真正存储数据的地方。因此，访问 `ref()` 变量时必须使用 `.value`，否则你拿到的是 `Ref` 对象，而不是它的值, 所以ref还是比较适合基础类型\n```javascript\nconst form = ref({ id: \"\", name: \"\" });\nconsole.log(form); // ->  { form: { id: \"\", name: \"\" } }\n```\n- **`reactive()` 直接返回代理对象，而 `ref()` 返回的是一个 `{ value: 数据 }` 的对象**。\n- `const`和`let`用来定义变量，`{}`是对象，`[]`是数组，`({})`是对象赋值，`([])`是数组赋值, 本质上来说是一样的, 只不过为了区分\n\n## 注意事项\n- vue的if判断不单单能判断boolean类型, 甚至对空对象, 空值, 0 , 正数…都能判断\n- 对象的打印不是用加号而是用逗号, 否则打印出来的是\"Object\"这个字符\n```javascript\nlet obj = { name: \"Alice\" };\nconsole.log(\"obj: \" + obj); \n// 打印结果：obj: [object Object]\nconsole.log(\"obj:\", obj);    \n// 打印结果：obj: { name: \"Alice\" }\n```\n- computed属性函数: 有使用内置缓存的特性 \n- vue3新语法: `<script setup>`, 不用手动return, 让代码更简洁\n- vue3新功能: watch监听器\n- history: createWebHistory(),  启用 vue3的History 路由模式: \n\t- `http://example.com/about` -> vue3新模式: 真实路径\n\t- `http://example.com/#/about`  -> 而不是 Vue 2 时代 `hash` 模式的\n- 状态码code和统一响应结果code不一样\n- vue的打包dist要指定mode(dev, prod)\n- 一个按钮内有点击事件, 内容是一个路由跳转函数, 那么只会执行一个\n- 前端对JSON的处理: JSON.stringify(object)和JSON.parse(jsonObject)\n- Axios 默认已经解析 JSON，不需要 JSON.parse(response.data.data)\n- localStorage永久保存在本地, 而sessionStorage会话存储, 值的有效期只在当前浏览器会话\n- 对如何类的调用都应该创建实例, 只有实例才能取属性调用函数\n- `Uncaught (in promise)` 错误通常意味着你没有处理 `Promise` 被拒绝的情况。需要进行请求的捕获tryCatch\n- 设置为一个 URL 字符串时，浏览器会自动发出一个 HTTP 请求去获取这个 URL 对应的资源\n![17452385641011745238563053.png|700x196](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17452385641011745238563053.png)\n- 响应拦截器获得的响应数据其实是被3层包裹 \n![17426307478001742630746874.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17426307478001742630746874.png)\n- 后端定义的首字母大写字段有时候会被Lombok变成小写, 例如: Authorization -> authorization, 可以添加@JsonProperty(\"Authorization\") 或者全局修改规则\n- 解决前后端交互Long类型精度丢失的问题: 1.加一个jackson序列化器 2.每一个响应类加一个注解:@JsonSerialize(using = ToStringSerializer.class)\n- 在使用 `map` 前，务必确保你操作的变量是 **数组**, 因为JS的赋值类型是多变得,所有必须多加一层判断语句\n- 其实anDesignVue的东西都是在原始html的基础上添加了一些属性和方法, 过程跟我们使用父子组件的方法一样, 所以我们也可以自定义自己的组件库","source":"_posts/webDev.md","raw":"---\nbanner: \"[[pixel-banner-image.png]]\"\ntitle: web开发的踩坑避雷\ntags:\n  - Web\ncategories: 编程\ndate: 2025-03-22T15:48:00\n---\n\n\twe've got you covered there, too.\n# Web开发总结\n## `axios` 详解\n### `axiox` 实例的创建\n```javascript\nimport axios from 'axios'; \n/* 创建 axios 实例的好处：  \n 可以配置默认 baseURL，避免重复写 API 地址\n 可以添加请求/响应拦截器，统一处理 Token、错误消息等\n 便于维护和管理多个 API 端点\n*/\nexport function createAxiosInstance() {\n    const axiosInstance = axios.create({\n        baseURL: process.env.VUE_APP_SERVER, // 替换为你的后端 API 地址\n        timeout: 5000, // 请求超时时间\n        withCredentials: true,  //允许跨域\n        headers: {\n            'Content-Type': 'application/json',\n        },\n    });\n    return axiosInstance;\n}\n// 或者直接修改全局默认配置, 否则需要调用实例 注意: 要定义在mian.js中才生效\naxios.defaults.baseURL = process.env.VUE_APP_SERVER;\naxios.defaults.timeout = 5000;\naxios.defaults.withCredentials = true;\naxios.defaults.headers['Content-Type'] = 'application/json';\n```\n### `axios` 拦截器\n```javascript\n// 请求拦截器\naxios.interceptors.request.use(\n    (config) => {\n        // 打印请求参数\n        console.log(\"请求参数: \" ,config)\n        // 从本地存储或者商店中拿\n        const token = localStorage.getItem('Authorization');\n        config.headers[\"Authorization\"] = `${token}`;\n        config.headers['Content-Encoding'] = \"utf-8\"\n        return config;\n    }\n);\n// 响应拦截器\naxios.interceptors.response.use(\n    (response) => {\n        // 打印响应参数\n        console.log(\"响应参数: \" ,response)\n        // HTTP响应状态码正常 200 OK\n        if (response.status === 200) {\n            const data = response.data;\n            // 自定义统一响应结果的code值: 由后端定义\n            if (data.code === HttpCode.SUCCESS) {\n                message.success(\"响应一切正常:\" , response.statusText);\n                return Promise.resolve(response)\n            } else if (data.code === HttpCode.NOT_FOUND) {\n                    message.error(\"404 Not Fount\")\n                    return Promise.reject(response.data.message);\n                } else if (data.code === HttpCode.UNAUTHORIZED) {\n                        message.error(\"401 未授权 token过期\")\n                        return Promise.reject(response.data.message);\n                    } else if (data.code === HttpCode.SERVER_ERROR) {\n                            message.error(\"500 服务器错误\")\n                            return Promise.reject(response.data.message);\n                        } else {\n                            message.warn(\"未知错误: \" + data.message)\n                            return Promise.reject(response.data.message);\n                        }\n        }\n        // 接口404的情况\n        else if (response.status === 404) {\n            message.warning(\"404访问页面不存在\");\n            return Promise.reject(response.data.message);\n        }\n        // 其他情况\n        else {\n            message.error(\"response.status: \" + response.status)\n            return Promise.reject(response.data.message);\n        }\n    }\n);\n```\n### `axios` 发送请求\n```javascript\n// 发送验证码请求: baseUrl由axios的实例定义了\nexport const sendCodeRequest = async (data) => {\n    const response = await axios.post(\"/member/sendCode\", data);\n    if (response.data.data) {\n        // Axios 默认已经解析 JSON，不需要 `JSON.parse(response.data)`\n        return {\n            mobile: response.data.data.mobile || \"\",\n            verificationCode: response.data.data.verificationCode\n        };\n    }\n    throw new Error(\"返回数据为空\");\n}\n```\n- 一个简单地axios由3部分组成: (url, data, config) 以及一个Promise\n### `Router`守卫\n```javascript\n// 添加一个路由的全局前置守卫\nrouter.beforeEach(async function (to, from, next) {\n  // 判断是否是登录页面\n  if (to.name === \"login\" || to.name === \"NotFound\" || to.name === \"Forbidden\" || to.name === \"Error\") {\n    next();\n    return false;\n  }\n  // 判断本地是否记录token值\n  const memberStore = useMemberStore();\n  const token = memberStore.$state.Authorization;\n  // 如果没有token\n  if (!token) {\n    // next({ name: \"Login\" });\n    notification.error({description: \"在未登录时，禁止访问其他页面！\"});\n    router.push(\"/login\")\n    return false;\n  }\n  next();\n  return true;\n});\n```\n## `Promise` 详解\n### 什么是`Promise`\n- `Promise` 是 **JavaScript 中的一种异步处理机制**，用于解决 **回调地狱（Callback Hell）** 和 **异步操作的可读性问题**。它代表 **一个未来可能会完成或失败的操作**，并允许在操作完成后执行相应的代码\n### `Promise`的三种状态\n1. **`pending`（进行中）：** 初始状态，表示异步操作尚未完成。\n2. **`fulfilled`（已完成）：** 操作成功，`resolve()` 被调用。\n3. **`rejected`（已失败）：** 操作失败，`reject()` 被调用。\n- 一旦 `Promise` 从 `pending` 变为 `fulfilled` 或 `rejected`，就不能再改变状态（不可逆)\n### `Promise` 的基本用法\n```javascript\nconst myPromise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    let success = true;\n    if (success) {\n      resolve(\"操作成功！\"); // 成功调用 resolve\n    } else {\n      reject(\"操作失败！\"); // 失败调用 reject\n    }\n  }, 2000);\n});\n\n```\n在 `Promise` 内部：\n- 创建了一个promise, 函数体是执行内容\n- 根据内容决定  -> 执行哪一个内部函数resolve还是reject\n- `resolve(value)` **表示成功**，会触发 `.then()`\n- `reject(error)` **表示失败**，会触发 `.catch()`\n### `Promise`异步回调处理\n```javascript\nmyPromise\n  .then((result) => {\n    console.log(\"成功:\", result);\n  })\n  .catch((error) => {\n    console.error(\"失败:\", error);\n  })\n  .finally(() => {\n    console.log(\"无论成功还是失败都会执行！\");\n  });\n\n```\n执行流程：\n- 根据内部函数的执行, 从而决定调用then还是catch, 也就是会被捕捉\n1. 如果 `resolve()` 被调用，执行 `.then(result)` ,then()处理异步操作成功后的结果，返回一个新的 `Promise`，可以链式调用。\n2. 如果 `reject()` 被调用, 执行 `.catch(error)`\n3. `.finally()` 一定会执行，无论成功还是失败\n### `async/await`（Promise 的语法糖）\n```javascript\nconst fetchData = async () => {\n  try {\n    const result = await myPromise;\n    console.log(result);\n  } catch (error) {\n    console.error(\"错误:\", error);\n  } finally {\n    console.log(\"执行完成\");\n  }\n};\nfetchData();\n\n```\n`await` 关键字的作用：\n- 暂停代码执行，直到 `Promise` 解决\n- 可以直接获取 `Promise` 结果\n- 比 `.then()` 语法更直观\n### 用async还是then\n- 注意这里的两个return\n\t- 其实没必要用两个异步回调\n```javascript\nexport const batchJobAddOrResRequest = async (url, data) => {\n    return await axios.post(\"/batch/admin/job/\" + url, data).then((response) => {\n        try {\n            const Result = response.data;\n            if (Result.code === HttpStatusCode.Ok) {\n                return true;\n            }\n        } catch (error) {\n            console.error(\"定时任务添加错误\");\n        }\n    });\n}\n```\n## 组件中间值的传递\n- **对参数赋值, 值通过子组件传递进来**\n```javascript\n// 父组件: 定义了一个Switch, 通过子组件双向数据绑定的值进行设置打开状态\n<template>\n  <div>\n    <a-switch v-model:checked=\"switchValue\" />\n  <childComponent v-model=\"switchValue\" messageText=\"我对子盒子说话\" @messageMethod=\"getMessageDetail\"/>\n  </div>\n  <div>\n    {{ detailMessage }}\n  </div>\n</template>\n\n<script setup>\nimport { ref } from \"vue\";\nimport childComponent from \"./childComponent.vue\";\nconst switchValue = ref(false);\nlet detailMessage = ref();\nconst getMessageDetail = (detail) => {\n  detailMessage.value = detail;\n}\n</script>\n```\n\n```javascript\nwatch(\n  () => watchValue,\n  (newVal, oldVal) => {}\n```\n\n```javascript\n//  自定义子组件的属性和方法, 通过父组件传递参数\n<template>\n  <a-button\n    @click=\"handleClick\"\n    :style=\"'messageText: ' + '父组件可以显示设置子组件的style'\"\n  >\n    开关\n  </a-button>\n  <div>\n    {{ props.messageText }}\n  </div>\n</template>\n\n<script setup>\nimport { defineProps, defineEmits, ref, watch, onMounted } from \"vue\";\nonMounted(() => {\n  emits(\"messageMethod\", \"我是通过方法传递给父盒子的信息\")\n})\n// 定义了传递字段\nconst props = defineProps({\n  modelValue: Boolean,\n  messageText: String,\n});\n// 定义了传递函数\nconst emits = defineEmits([\"update:modelValue\", \"messageMethod\"]);\n\nlet switchValue = ref(false);\nconst handleClick = () => {\n  switchValue.value = !switchValue.value;\n  emits(\"update:modelValue\", switchValue.value ? false : true);\n};\n// 也可以通过对props.modelValue值的监听(vue3的watch), 来收到父组件的信息\nwatch(\n  () => props.modelValue,\n  (modelValue) => {\n    console.log(modelValue, \"的值变化了\");\n  }\n);\n</script>\n\n<style scoped>\n</style>\n```\n## 组件小部件\n- 表格数据渲染, row与col 通过v-for进行表格数据渲染, 作用与a-table和el-table一样\n\t- 数据源 - 表头行 - 间隔\n\t- 用v-for渲染: 在每一行数据中可以灵活运用v-if和v-model和差值语法进行处理\n```javascript\n<a-row class=\"order-tickets-header\" v-if=\"tickets.length > 0\">\n      <a-col :span=\"2\">乘客</a-col>\n      <a-col :span=\"6\">身份证</a-col>\n      <a-col :span=\"4\">票种</a-col>\n      <a-col :span=\"4\">座位类型</a-col>\n      <a-col :span=\"6\">乘客详细信息</a-col>\n    </a-row>\n    <a-row\n      class=\"order-tickets-row\"\n      v-for=\"(ticket, i) in tickets\"\n      :key=\"ticket.passengerId\"\n    >\n      <a-col :span=\"2\">{{ ticket.passengerName }}</a-col>\n      <a-col :span=\"6\">{{ ticket.passengerIdCard }}</a-col>\n      <a-col :span=\"4\">\n        <a-select v-model:value=\"ticket.passengerType\" style=\"width: 100%\">\n          <a-select-option\n            v-for=\"item in PASSENGER_TYPE_ARRAY\"\n            :key=\"item.code\"\n            :value=\"item.code\"\n          >\n            {{ item.desc }}\n          </a-select-option>\n        </a-select>\n      </a-col>\n\t  </a-row>\n```\n## Ref变量和reactive变量\n- reactive是响应式的(能自动解包), 就不需要通过 `.value`获取值, 对于对象和数组能快速取值\n- 在 Vue 3 的 Composition API 里，`ref()` 返回的是一个对象，这个对象有一个 `value` 属性，它才是真正存储数据的地方。因此，访问 `ref()` 变量时必须使用 `.value`，否则你拿到的是 `Ref` 对象，而不是它的值, 所以ref还是比较适合基础类型\n```javascript\nconst form = ref({ id: \"\", name: \"\" });\nconsole.log(form); // ->  { form: { id: \"\", name: \"\" } }\n```\n- **`reactive()` 直接返回代理对象，而 `ref()` 返回的是一个 `{ value: 数据 }` 的对象**。\n- `const`和`let`用来定义变量，`{}`是对象，`[]`是数组，`({})`是对象赋值，`([])`是数组赋值, 本质上来说是一样的, 只不过为了区分\n\n## 注意事项\n- vue的if判断不单单能判断boolean类型, 甚至对空对象, 空值, 0 , 正数…都能判断\n- 对象的打印不是用加号而是用逗号, 否则打印出来的是\"Object\"这个字符\n```javascript\nlet obj = { name: \"Alice\" };\nconsole.log(\"obj: \" + obj); \n// 打印结果：obj: [object Object]\nconsole.log(\"obj:\", obj);    \n// 打印结果：obj: { name: \"Alice\" }\n```\n- computed属性函数: 有使用内置缓存的特性 \n- vue3新语法: `<script setup>`, 不用手动return, 让代码更简洁\n- vue3新功能: watch监听器\n- history: createWebHistory(),  启用 vue3的History 路由模式: \n\t- `http://example.com/about` -> vue3新模式: 真实路径\n\t- `http://example.com/#/about`  -> 而不是 Vue 2 时代 `hash` 模式的\n- 状态码code和统一响应结果code不一样\n- vue的打包dist要指定mode(dev, prod)\n- 一个按钮内有点击事件, 内容是一个路由跳转函数, 那么只会执行一个\n- 前端对JSON的处理: JSON.stringify(object)和JSON.parse(jsonObject)\n- Axios 默认已经解析 JSON，不需要 JSON.parse(response.data.data)\n- localStorage永久保存在本地, 而sessionStorage会话存储, 值的有效期只在当前浏览器会话\n- 对如何类的调用都应该创建实例, 只有实例才能取属性调用函数\n- `Uncaught (in promise)` 错误通常意味着你没有处理 `Promise` 被拒绝的情况。需要进行请求的捕获tryCatch\n- 设置为一个 URL 字符串时，浏览器会自动发出一个 HTTP 请求去获取这个 URL 对应的资源\n![17452385641011745238563053.png|700x196](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17452385641011745238563053.png)\n- 响应拦截器获得的响应数据其实是被3层包裹 \n![17426307478001742630746874.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17426307478001742630746874.png)\n- 后端定义的首字母大写字段有时候会被Lombok变成小写, 例如: Authorization -> authorization, 可以添加@JsonProperty(\"Authorization\") 或者全局修改规则\n- 解决前后端交互Long类型精度丢失的问题: 1.加一个jackson序列化器 2.每一个响应类加一个注解:@JsonSerialize(using = ToStringSerializer.class)\n- 在使用 `map` 前，务必确保你操作的变量是 **数组**, 因为JS的赋值类型是多变得,所有必须多加一层判断语句\n- 其实anDesignVue的东西都是在原始html的基础上添加了一些属性和方法, 过程跟我们使用父子组件的方法一样, 所以我们也可以自定义自己的组件库","slug":"webDev","published":1,"updated":"2025-04-27T04:32:01.111Z","comments":1,"layout":"post","photos":[],"_id":"cmfw4z0b8003xuomwgc3yevhj","content":"<pre><code>we&#39;ve got you covered there, too.\n</code></pre><h1 id=\"Web开发总结\"><a href=\"#Web开发总结\" class=\"headerlink\" title=\"Web开发总结\"></a>Web开发总结</h1><h2 id=\"axios-详解\"><a href=\"#axios-详解\" class=\"headerlink\" title=\"axios 详解\"></a><code>axios</code> 详解</h2><h3 id=\"axiox-实例的创建\"><a href=\"#axiox-实例的创建\" class=\"headerlink\" title=\"axiox 实例的创建\"></a><code>axiox</code> 实例的创建</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">&#x27;axios&#x27;</span>; </span><br><span class=\"line\"><span class=\"comment\">/* 创建 axios 实例的好处：  </span></span><br><span class=\"line\"><span class=\"comment\"> 可以配置默认 baseURL，避免重复写 API 地址</span></span><br><span class=\"line\"><span class=\"comment\"> 可以添加请求/响应拦截器，统一处理 Token、错误消息等</span></span><br><span class=\"line\"><span class=\"comment\"> 便于维护和管理多个 API 端点</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createAxiosInstance</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> axiosInstance = axios.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">baseURL</span>: process.<span class=\"property\">env</span>.<span class=\"property\">VUE_APP_SERVER</span>, <span class=\"comment\">// 替换为你的后端 API 地址</span></span><br><span class=\"line\">        <span class=\"attr\">timeout</span>: <span class=\"number\">5000</span>, <span class=\"comment\">// 请求超时时间</span></span><br><span class=\"line\">        <span class=\"attr\">withCredentials</span>: <span class=\"literal\">true</span>,  <span class=\"comment\">//允许跨域</span></span><br><span class=\"line\">        <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> axiosInstance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 或者直接修改全局默认配置, 否则需要调用实例 注意: 要定义在mian.js中才生效</span></span><br><span class=\"line\">axios.<span class=\"property\">defaults</span>.<span class=\"property\">baseURL</span> = process.<span class=\"property\">env</span>.<span class=\"property\">VUE_APP_SERVER</span>;</span><br><span class=\"line\">axios.<span class=\"property\">defaults</span>.<span class=\"property\">timeout</span> = <span class=\"number\">5000</span>;</span><br><span class=\"line\">axios.<span class=\"property\">defaults</span>.<span class=\"property\">withCredentials</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">axios.<span class=\"property\">defaults</span>.<span class=\"property\">headers</span>[<span class=\"string\">&#x27;Content-Type&#x27;</span>] = <span class=\"string\">&#x27;application/json&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"axios-拦截器\"><a href=\"#axios-拦截器\" class=\"headerlink\" title=\"axios 拦截器\"></a><code>axios</code> 拦截器</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 请求拦截器</span></span><br><span class=\"line\">axios.<span class=\"property\">interceptors</span>.<span class=\"property\">request</span>.<span class=\"title function_\">use</span>(</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">config</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 打印请求参数</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;请求参数: &quot;</span> ,config)</span><br><span class=\"line\">        <span class=\"comment\">// 从本地存储或者商店中拿</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> token = <span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">getItem</span>(<span class=\"string\">&#x27;Authorization&#x27;</span>);</span><br><span class=\"line\">        config.<span class=\"property\">headers</span>[<span class=\"string\">&quot;Authorization&quot;</span>] = <span class=\"string\">`<span class=\"subst\">$&#123;token&#125;</span>`</span>;</span><br><span class=\"line\">        config.<span class=\"property\">headers</span>[<span class=\"string\">&#x27;Content-Encoding&#x27;</span>] = <span class=\"string\">&quot;utf-8&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// 响应拦截器</span></span><br><span class=\"line\">axios.<span class=\"property\">interceptors</span>.<span class=\"property\">response</span>.<span class=\"title function_\">use</span>(</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 打印响应参数</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;响应参数: &quot;</span> ,response)</span><br><span class=\"line\">        <span class=\"comment\">// HTTP响应状态码正常 200 OK</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (response.<span class=\"property\">status</span> === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> data = response.<span class=\"property\">data</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 自定义统一响应结果的code值: 由后端定义</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data.<span class=\"property\">code</span> === <span class=\"title class_\">HttpCode</span>.<span class=\"property\">SUCCESS</span>) &#123;</span><br><span class=\"line\">                message.<span class=\"title function_\">success</span>(<span class=\"string\">&quot;响应一切正常:&quot;</span> , response.<span class=\"property\">statusText</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(response)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data.<span class=\"property\">code</span> === <span class=\"title class_\">HttpCode</span>.<span class=\"property\">NOT_FOUND</span>) &#123;</span><br><span class=\"line\">                    message.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;404 Not Fount&quot;</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(response.<span class=\"property\">data</span>.<span class=\"property\">message</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data.<span class=\"property\">code</span> === <span class=\"title class_\">HttpCode</span>.<span class=\"property\">UNAUTHORIZED</span>) &#123;</span><br><span class=\"line\">                        message.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;401 未授权 token过期&quot;</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(response.<span class=\"property\">data</span>.<span class=\"property\">message</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data.<span class=\"property\">code</span> === <span class=\"title class_\">HttpCode</span>.<span class=\"property\">SERVER_ERROR</span>) &#123;</span><br><span class=\"line\">                            message.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;500 服务器错误&quot;</span>)</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(response.<span class=\"property\">data</span>.<span class=\"property\">message</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            message.<span class=\"title function_\">warn</span>(<span class=\"string\">&quot;未知错误: &quot;</span> + data.<span class=\"property\">message</span>)</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(response.<span class=\"property\">data</span>.<span class=\"property\">message</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 接口404的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (response.<span class=\"property\">status</span> === <span class=\"number\">404</span>) &#123;</span><br><span class=\"line\">            message.<span class=\"title function_\">warning</span>(<span class=\"string\">&quot;404访问页面不存在&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(response.<span class=\"property\">data</span>.<span class=\"property\">message</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 其他情况</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            message.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;response.status: &quot;</span> + response.<span class=\"property\">status</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(response.<span class=\"property\">data</span>.<span class=\"property\">message</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"axios-发送请求\"><a href=\"#axios-发送请求\" class=\"headerlink\" title=\"axios 发送请求\"></a><code>axios</code> 发送请求</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送验证码请求: baseUrl由axios的实例定义了</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">sendCodeRequest</span> = <span class=\"keyword\">async</span> (<span class=\"params\">data</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> axios.<span class=\"title function_\">post</span>(<span class=\"string\">&quot;/member/sendCode&quot;</span>, data);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response.<span class=\"property\">data</span>.<span class=\"property\">data</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Axios 默认已经解析 JSON，不需要 `JSON.parse(response.data)`</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">mobile</span>: response.<span class=\"property\">data</span>.<span class=\"property\">data</span>.<span class=\"property\">mobile</span> || <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">verificationCode</span>: response.<span class=\"property\">data</span>.<span class=\"property\">data</span>.<span class=\"property\">verificationCode</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;返回数据为空&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>一个简单地axios由3部分组成: (url, data, config) 以及一个Promise<h3 id=\"Router守卫\"><a href=\"#Router守卫\" class=\"headerlink\" title=\"Router守卫\"></a><code>Router</code>守卫</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加一个路由的全局前置守卫</span></span><br><span class=\"line\">router.<span class=\"title function_\">beforeEach</span>(<span class=\"keyword\">async</span> <span class=\"keyword\">function</span> (<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 判断是否是登录页面</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (to.<span class=\"property\">name</span> === <span class=\"string\">&quot;login&quot;</span> || to.<span class=\"property\">name</span> === <span class=\"string\">&quot;NotFound&quot;</span> || to.<span class=\"property\">name</span> === <span class=\"string\">&quot;Forbidden&quot;</span> || to.<span class=\"property\">name</span> === <span class=\"string\">&quot;Error&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">next</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断本地是否记录token值</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> memberStore = <span class=\"title function_\">useMemberStore</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> token = memberStore.<span class=\"property\">$state</span>.<span class=\"property\">Authorization</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有token</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!token) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// next(&#123; name: &quot;Login&quot; &#125;);</span></span><br><span class=\"line\">    notification.<span class=\"title function_\">error</span>(&#123;<span class=\"attr\">description</span>: <span class=\"string\">&quot;在未登录时，禁止访问其他页面！&quot;</span>&#125;);</span><br><span class=\"line\">    router.<span class=\"title function_\">push</span>(<span class=\"string\">&quot;/login&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">next</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise-详解\"><a href=\"#Promise-详解\" class=\"headerlink\" title=\"Promise 详解\"></a><code>Promise</code> 详解</h2><h3 id=\"什么是Promise\"><a href=\"#什么是Promise\" class=\"headerlink\" title=\"什么是Promise\"></a>什么是<code>Promise</code></h3></li>\n<li><code>Promise</code> 是 <strong>JavaScript 中的一种异步处理机制</strong>，用于解决 <strong>回调地狱（Callback Hell）</strong> 和 <strong>异步操作的可读性问题</strong>。它代表 <strong>一个未来可能会完成或失败的操作</strong>，并允许在操作完成后执行相应的代码<h3 id=\"Promise的三种状态\"><a href=\"#Promise的三种状态\" class=\"headerlink\" title=\"Promise的三种状态\"></a><code>Promise</code>的三种状态</h3></li>\n</ul>\n<ol>\n<li><strong><code>pending</code>（进行中）：</strong> 初始状态，表示异步操作尚未完成。</li>\n<li><strong><code>fulfilled</code>（已完成）：</strong> 操作成功，<code>resolve()</code> 被调用。</li>\n<li><strong><code>rejected</code>（已失败）：</strong> 操作失败，<code>reject()</code> 被调用。</li>\n</ol>\n<ul>\n<li>一旦 <code>Promise</code> 从 <code>pending</code> 变为 <code>fulfilled</code> 或 <code>rejected</code>，就不能再改变状态（不可逆)<h3 id=\"Promise-的基本用法\"><a href=\"#Promise-的基本用法\" class=\"headerlink\" title=\"Promise 的基本用法\"></a><code>Promise</code> 的基本用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;操作成功！&quot;</span>); <span class=\"comment\">// 成功调用 resolve</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">reject</span>(<span class=\"string\">&quot;操作失败！&quot;</span>); <span class=\"comment\">// 失败调用 reject</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n在 <code>Promise</code> 内部：</li>\n<li>创建了一个promise, 函数体是执行内容</li>\n<li>根据内容决定  -&gt; 执行哪一个内部函数resolve还是reject</li>\n<li><code>resolve(value)</code> <strong>表示成功</strong>，会触发 <code>.then()</code></li>\n<li><code>reject(error)</code> <strong>表示失败</strong>，会触发 <code>.catch()</code><h3 id=\"Promise异步回调处理\"><a href=\"#Promise异步回调处理\" class=\"headerlink\" title=\"Promise异步回调处理\"></a><code>Promise</code>异步回调处理</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myPromise</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;成功:&quot;</span>, result);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;失败:&quot;</span>, error);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">finally</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;无论成功还是失败都会执行！&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n执行流程：</li>\n<li>根据内部函数的执行, 从而决定调用then还是catch, 也就是会被捕捉</li>\n</ul>\n<ol>\n<li>如果 <code>resolve()</code> 被调用，执行 <code>.then(result)</code> ,then()处理异步操作成功后的结果，返回一个新的 <code>Promise</code>，可以链式调用。</li>\n<li>如果 <code>reject()</code> 被调用, 执行 <code>.catch(error)</code></li>\n<li><code>.finally()</code> 一定会执行，无论成功还是失败<h3 id=\"async-await（Promise-的语法糖）\"><a href=\"#async-await（Promise-的语法糖）\" class=\"headerlink\" title=\"async/await（Promise 的语法糖）\"></a><code>async/await</code>（Promise 的语法糖）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">fetchData</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> myPromise;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;错误:&quot;</span>, error);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;执行完成&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title function_\">fetchData</span>();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<code>await</code> 关键字的作用：</li>\n</ol>\n<ul>\n<li>暂停代码执行，直到 <code>Promise</code> 解决</li>\n<li>可以直接获取 <code>Promise</code> 结果</li>\n<li>比 <code>.then()</code> 语法更直观<h3 id=\"用async还是then\"><a href=\"#用async还是then\" class=\"headerlink\" title=\"用async还是then\"></a>用async还是then</h3></li>\n<li>注意这里的两个return<ul>\n<li>其实没必要用两个异步回调<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">batchJobAddOrResRequest</span> = <span class=\"keyword\">async</span> (<span class=\"params\">url, data</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> axios.<span class=\"title function_\">post</span>(<span class=\"string\">&quot;/batch/admin/job/&quot;</span> + url, data).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"title class_\">Result</span> = response.<span class=\"property\">data</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"title class_\">Result</span>.<span class=\"property\">code</span> === <span class=\"title class_\">HttpStatusCode</span>.<span class=\"property\">Ok</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;定时任务添加错误&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"组件中间值的传递\"><a href=\"#组件中间值的传递\" class=\"headerlink\" title=\"组件中间值的传递\"></a>组件中间值的传递</h2></li>\n</ul>\n</li>\n<li><strong>对参数赋值, 值通过子组件传递进来</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父组件: 定义了一个Switch, 通过子组件双向数据绑定的值进行设置打开状态</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">a-switch</span> <span class=\"attr\">v-model:checked</span>=<span class=\"string\">&quot;switchValue&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">childComponent</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;switchValue&quot;</span> <span class=\"attr\">messageText</span>=<span class=\"string\">&quot;我对子盒子说话&quot;</span> @<span class=\"attr\">messageMethod</span>=<span class=\"string\">&quot;getMessageDetail&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    &#123;&#123; detailMessage &#125;&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> &#123; ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> childComponent <span class=\"keyword\">from</span> <span class=\"string\">&quot;./childComponent.vue&quot;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> switchValue = <span class=\"title function_\">ref</span>(<span class=\"literal\">false</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">let</span> detailMessage = <span class=\"title function_\">ref</span>();</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> <span class=\"title function_\">getMessageDetail</span> = (<span class=\"params\">detail</span>) =&gt; &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  detailMessage.<span class=\"property\">value</span> = detail;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">watch</span>(</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span> watchValue,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">newVal, oldVal</span>) =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  自定义子组件的属性和方法, 通过父组件传递参数</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    @<span class=\"attr\">click</span>=<span class=\"string\">&quot;handleClick&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">:style</span>=<span class=\"string\">&quot;&#x27;messageText: &#x27; + &#x27;父组件可以显示设置子组件的style&#x27;&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">  &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    开关</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">a-button</span>&gt;</span></span></span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    &#123;&#123; props.messageText &#125;&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> &#123; defineProps, defineEmits, ref, watch, onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"title function_\">onMounted</span>(<span class=\"function\">() =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"title function_\">emits</span>(<span class=\"string\">&quot;messageMethod&quot;</span>, <span class=\"string\">&quot;我是通过方法传递给父盒子的信息&quot;</span>)</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;)</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"comment\">// 定义了传递字段</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> props = <span class=\"title function_\">defineProps</span>(&#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"attr\">modelValue</span>: <span class=\"title class_\">Boolean</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"attr\">messageText</span>: <span class=\"title class_\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"comment\">// 定义了传递函数</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> emits = <span class=\"title function_\">defineEmits</span>([<span class=\"string\">&quot;update:modelValue&quot;</span>, <span class=\"string\">&quot;messageMethod&quot;</span>]);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">let</span> switchValue = <span class=\"title function_\">ref</span>(<span class=\"literal\">false</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleClick</span> = (<span class=\"params\"></span>) =&gt; &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  switchValue.<span class=\"property\">value</span> = !switchValue.<span class=\"property\">value</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"title function_\">emits</span>(<span class=\"string\">&quot;update:modelValue&quot;</span>, switchValue.<span class=\"property\">value</span> ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"comment\">// 也可以通过对props.modelValue值的监听(vue3的watch), 来收到父组件的信息</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"title function_\">watch</span>(</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"function\">() =&gt;</span> props.<span class=\"property\">modelValue</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"function\">(<span class=\"params\">modelValue</span>) =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(modelValue, <span class=\"string\">&quot;的值变化了&quot;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"组件小部件\"><a href=\"#组件小部件\" class=\"headerlink\" title=\"组件小部件\"></a>组件小部件</h2><ul>\n<li>表格数据渲染, row与col 通过v-for进行表格数据渲染, 作用与a-table和el-table一样<ul>\n<li>数据源 - 表头行 - 间隔</li>\n<li>用v-for渲染: 在每一行数据中可以灵活运用v-if和v-model和差值语法进行处理<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a-row <span class=\"keyword\">class</span>=<span class=\"string\">&quot;order-tickets-header&quot;</span> v-<span class=\"keyword\">if</span>=<span class=\"string\">&quot;tickets.length &gt; 0&quot;</span>&gt;</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;2&quot;</span>&gt;</span>乘客<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;6&quot;</span>&gt;</span>身份证<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;4&quot;</span>&gt;</span>票种<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;4&quot;</span>&gt;</span>座位类型<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;6&quot;</span>&gt;</span>乘客详细信息<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\">    &lt;/a-row&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-row</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;order-tickets-row&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(ticket, i) in tickets&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      <span class=\"attr\">:key</span>=<span class=\"string\">&quot;ticket.passengerId&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;2&quot;</span>&gt;</span>&#123;&#123; ticket.passengerName &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;6&quot;</span>&gt;</span>&#123;&#123; ticket.passengerIdCard &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;4&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">a-select</span> <span class=\"attr\">v-model:value</span>=<span class=\"string\">&quot;ticket.passengerType&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width: 100%&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">a-select-option</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in PASSENGER_TYPE_ARRAY&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">:key</span>=<span class=\"string\">&quot;item.code&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">:value</span>=<span class=\"string\">&quot;item.code&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;&#123; item.desc &#125;&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;/<span class=\"name\">a-select-option</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">a-select</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t  <span class=\"tag\">&lt;/<span class=\"name\">a-row</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Ref变量和reactive变量\"><a href=\"#Ref变量和reactive变量\" class=\"headerlink\" title=\"Ref变量和reactive变量\"></a>Ref变量和reactive变量</h2></li>\n</ul>\n</li>\n<li>reactive是响应式的(能自动解包), 就不需要通过 <code>.value</code>获取值, 对于对象和数组能快速取值</li>\n<li>在 Vue 3 的 Composition API 里，<code>ref()</code> 返回的是一个对象，这个对象有一个 <code>value</code> 属性，它才是真正存储数据的地方。因此，访问 <code>ref()</code> 变量时必须使用 <code>.value</code>，否则你拿到的是 <code>Ref</code> 对象，而不是它的值, 所以ref还是比较适合基础类型<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> form = <span class=\"title function_\">ref</span>(&#123; <span class=\"attr\">id</span>: <span class=\"string\">&quot;&quot;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&quot;&quot;</span> &#125;);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(form); <span class=\"comment\">// -&gt;  &#123; form: &#123; id: &quot;&quot;, name: &quot;&quot; &#125; &#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><strong><code>reactive()</code> 直接返回代理对象，而 <code>ref()</code> 返回的是一个 <code>&#123; value: 数据 &#125;</code> 的对象</strong>。</li>\n<li><code>const</code>和<code>let</code>用来定义变量，<code>&#123;&#125;</code>是对象，<code>[]</code>是数组，<code>(&#123;&#125;)</code>是对象赋值，<code>([])</code>是数组赋值, 本质上来说是一样的, 只不过为了区分</li>\n</ul>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ul>\n<li>vue的if判断不单单能判断boolean类型, 甚至对空对象, 空值, 0 , 正数…都能判断</li>\n<li>对象的打印不是用加号而是用逗号, 否则打印出来的是”Object”这个字符<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;obj: &quot;</span> + obj); </span><br><span class=\"line\"><span class=\"comment\">// 打印结果：obj: [object Object]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;obj:&quot;</span>, obj);    </span><br><span class=\"line\"><span class=\"comment\">// 打印结果：obj: &#123; name: &quot;Alice&quot; &#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>computed属性函数: 有使用内置缓存的特性 </li>\n<li>vue3新语法: <code>&lt;script setup&gt;</code>, 不用手动return, 让代码更简洁</li>\n<li>vue3新功能: watch监听器</li>\n<li>history: createWebHistory(),  启用 vue3的History 路由模式: <ul>\n<li><code>http://example.com/about</code> -&gt; vue3新模式: 真实路径</li>\n<li><code>http://example.com/#/about</code>  -&gt; 而不是 Vue 2 时代 <code>hash</code> 模式的</li>\n</ul>\n</li>\n<li>状态码code和统一响应结果code不一样</li>\n<li>vue的打包dist要指定mode(dev, prod)</li>\n<li>一个按钮内有点击事件, 内容是一个路由跳转函数, 那么只会执行一个</li>\n<li>前端对JSON的处理: JSON.stringify(object)和JSON.parse(jsonObject)</li>\n<li>Axios 默认已经解析 JSON，不需要 JSON.parse(response.data.data)</li>\n<li>localStorage永久保存在本地, 而sessionStorage会话存储, 值的有效期只在当前浏览器会话</li>\n<li>对如何类的调用都应该创建实例, 只有实例才能取属性调用函数</li>\n<li><code>Uncaught (in promise)</code> 错误通常意味着你没有处理 <code>Promise</code> 被拒绝的情况。需要进行请求的捕获tryCatch</li>\n<li>设置为一个 URL 字符串时，浏览器会自动发出一个 HTTP 请求去获取这个 URL 对应的资源<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17452385641011745238563053.png\" alt=\"17452385641011745238563053.png|700x196\"></li>\n<li>响应拦截器获得的响应数据其实是被3层包裹<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17426307478001742630746874.png\" alt=\"17426307478001742630746874.png\"></li>\n<li>后端定义的首字母大写字段有时候会被Lombok变成小写, 例如: Authorization -&gt; authorization, 可以添加@JsonProperty(“Authorization”) 或者全局修改规则</li>\n<li>解决前后端交互Long类型精度丢失的问题: 1.加一个jackson序列化器 2.每一个响应类加一个注解:@JsonSerialize(using = ToStringSerializer.class)</li>\n<li>在使用 <code>map</code> 前，务必确保你操作的变量是 <strong>数组</strong>, 因为JS的赋值类型是多变得,所有必须多加一层判断语句</li>\n<li>其实anDesignVue的东西都是在原始html的基础上添加了一些属性和方法, 过程跟我们使用父子组件的方法一样, 所以我们也可以自定义自己的组件库</li>\n</ul>\n","cover":"/img/3.png","cover_type":"img","excerpt":"","more":"<pre><code>we&#39;ve got you covered there, too.\n</code></pre><h1 id=\"Web开发总结\"><a href=\"#Web开发总结\" class=\"headerlink\" title=\"Web开发总结\"></a>Web开发总结</h1><h2 id=\"axios-详解\"><a href=\"#axios-详解\" class=\"headerlink\" title=\"axios 详解\"></a><code>axios</code> 详解</h2><h3 id=\"axiox-实例的创建\"><a href=\"#axiox-实例的创建\" class=\"headerlink\" title=\"axiox 实例的创建\"></a><code>axiox</code> 实例的创建</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">&#x27;axios&#x27;</span>; </span><br><span class=\"line\"><span class=\"comment\">/* 创建 axios 实例的好处：  </span></span><br><span class=\"line\"><span class=\"comment\"> 可以配置默认 baseURL，避免重复写 API 地址</span></span><br><span class=\"line\"><span class=\"comment\"> 可以添加请求/响应拦截器，统一处理 Token、错误消息等</span></span><br><span class=\"line\"><span class=\"comment\"> 便于维护和管理多个 API 端点</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createAxiosInstance</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> axiosInstance = axios.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">baseURL</span>: process.<span class=\"property\">env</span>.<span class=\"property\">VUE_APP_SERVER</span>, <span class=\"comment\">// 替换为你的后端 API 地址</span></span><br><span class=\"line\">        <span class=\"attr\">timeout</span>: <span class=\"number\">5000</span>, <span class=\"comment\">// 请求超时时间</span></span><br><span class=\"line\">        <span class=\"attr\">withCredentials</span>: <span class=\"literal\">true</span>,  <span class=\"comment\">//允许跨域</span></span><br><span class=\"line\">        <span class=\"attr\">headers</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> axiosInstance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 或者直接修改全局默认配置, 否则需要调用实例 注意: 要定义在mian.js中才生效</span></span><br><span class=\"line\">axios.<span class=\"property\">defaults</span>.<span class=\"property\">baseURL</span> = process.<span class=\"property\">env</span>.<span class=\"property\">VUE_APP_SERVER</span>;</span><br><span class=\"line\">axios.<span class=\"property\">defaults</span>.<span class=\"property\">timeout</span> = <span class=\"number\">5000</span>;</span><br><span class=\"line\">axios.<span class=\"property\">defaults</span>.<span class=\"property\">withCredentials</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">axios.<span class=\"property\">defaults</span>.<span class=\"property\">headers</span>[<span class=\"string\">&#x27;Content-Type&#x27;</span>] = <span class=\"string\">&#x27;application/json&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"axios-拦截器\"><a href=\"#axios-拦截器\" class=\"headerlink\" title=\"axios 拦截器\"></a><code>axios</code> 拦截器</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 请求拦截器</span></span><br><span class=\"line\">axios.<span class=\"property\">interceptors</span>.<span class=\"property\">request</span>.<span class=\"title function_\">use</span>(</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">config</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 打印请求参数</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;请求参数: &quot;</span> ,config)</span><br><span class=\"line\">        <span class=\"comment\">// 从本地存储或者商店中拿</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> token = <span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">getItem</span>(<span class=\"string\">&#x27;Authorization&#x27;</span>);</span><br><span class=\"line\">        config.<span class=\"property\">headers</span>[<span class=\"string\">&quot;Authorization&quot;</span>] = <span class=\"string\">`<span class=\"subst\">$&#123;token&#125;</span>`</span>;</span><br><span class=\"line\">        config.<span class=\"property\">headers</span>[<span class=\"string\">&#x27;Content-Encoding&#x27;</span>] = <span class=\"string\">&quot;utf-8&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// 响应拦截器</span></span><br><span class=\"line\">axios.<span class=\"property\">interceptors</span>.<span class=\"property\">response</span>.<span class=\"title function_\">use</span>(</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 打印响应参数</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;响应参数: &quot;</span> ,response)</span><br><span class=\"line\">        <span class=\"comment\">// HTTP响应状态码正常 200 OK</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (response.<span class=\"property\">status</span> === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> data = response.<span class=\"property\">data</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 自定义统一响应结果的code值: 由后端定义</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data.<span class=\"property\">code</span> === <span class=\"title class_\">HttpCode</span>.<span class=\"property\">SUCCESS</span>) &#123;</span><br><span class=\"line\">                message.<span class=\"title function_\">success</span>(<span class=\"string\">&quot;响应一切正常:&quot;</span> , response.<span class=\"property\">statusText</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(response)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data.<span class=\"property\">code</span> === <span class=\"title class_\">HttpCode</span>.<span class=\"property\">NOT_FOUND</span>) &#123;</span><br><span class=\"line\">                    message.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;404 Not Fount&quot;</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(response.<span class=\"property\">data</span>.<span class=\"property\">message</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data.<span class=\"property\">code</span> === <span class=\"title class_\">HttpCode</span>.<span class=\"property\">UNAUTHORIZED</span>) &#123;</span><br><span class=\"line\">                        message.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;401 未授权 token过期&quot;</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(response.<span class=\"property\">data</span>.<span class=\"property\">message</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data.<span class=\"property\">code</span> === <span class=\"title class_\">HttpCode</span>.<span class=\"property\">SERVER_ERROR</span>) &#123;</span><br><span class=\"line\">                            message.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;500 服务器错误&quot;</span>)</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(response.<span class=\"property\">data</span>.<span class=\"property\">message</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            message.<span class=\"title function_\">warn</span>(<span class=\"string\">&quot;未知错误: &quot;</span> + data.<span class=\"property\">message</span>)</span><br><span class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(response.<span class=\"property\">data</span>.<span class=\"property\">message</span>);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 接口404的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (response.<span class=\"property\">status</span> === <span class=\"number\">404</span>) &#123;</span><br><span class=\"line\">            message.<span class=\"title function_\">warning</span>(<span class=\"string\">&quot;404访问页面不存在&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(response.<span class=\"property\">data</span>.<span class=\"property\">message</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 其他情况</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            message.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;response.status: &quot;</span> + response.<span class=\"property\">status</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(response.<span class=\"property\">data</span>.<span class=\"property\">message</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"axios-发送请求\"><a href=\"#axios-发送请求\" class=\"headerlink\" title=\"axios 发送请求\"></a><code>axios</code> 发送请求</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发送验证码请求: baseUrl由axios的实例定义了</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">sendCodeRequest</span> = <span class=\"keyword\">async</span> (<span class=\"params\">data</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> axios.<span class=\"title function_\">post</span>(<span class=\"string\">&quot;/member/sendCode&quot;</span>, data);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response.<span class=\"property\">data</span>.<span class=\"property\">data</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Axios 默认已经解析 JSON，不需要 `JSON.parse(response.data)`</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">mobile</span>: response.<span class=\"property\">data</span>.<span class=\"property\">data</span>.<span class=\"property\">mobile</span> || <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">            <span class=\"attr\">verificationCode</span>: response.<span class=\"property\">data</span>.<span class=\"property\">data</span>.<span class=\"property\">verificationCode</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;返回数据为空&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>一个简单地axios由3部分组成: (url, data, config) 以及一个Promise<h3 id=\"Router守卫\"><a href=\"#Router守卫\" class=\"headerlink\" title=\"Router守卫\"></a><code>Router</code>守卫</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加一个路由的全局前置守卫</span></span><br><span class=\"line\">router.<span class=\"title function_\">beforeEach</span>(<span class=\"keyword\">async</span> <span class=\"keyword\">function</span> (<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 判断是否是登录页面</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (to.<span class=\"property\">name</span> === <span class=\"string\">&quot;login&quot;</span> || to.<span class=\"property\">name</span> === <span class=\"string\">&quot;NotFound&quot;</span> || to.<span class=\"property\">name</span> === <span class=\"string\">&quot;Forbidden&quot;</span> || to.<span class=\"property\">name</span> === <span class=\"string\">&quot;Error&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">next</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断本地是否记录token值</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> memberStore = <span class=\"title function_\">useMemberStore</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> token = memberStore.<span class=\"property\">$state</span>.<span class=\"property\">Authorization</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 如果没有token</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!token) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// next(&#123; name: &quot;Login&quot; &#125;);</span></span><br><span class=\"line\">    notification.<span class=\"title function_\">error</span>(&#123;<span class=\"attr\">description</span>: <span class=\"string\">&quot;在未登录时，禁止访问其他页面！&quot;</span>&#125;);</span><br><span class=\"line\">    router.<span class=\"title function_\">push</span>(<span class=\"string\">&quot;/login&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">next</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise-详解\"><a href=\"#Promise-详解\" class=\"headerlink\" title=\"Promise 详解\"></a><code>Promise</code> 详解</h2><h3 id=\"什么是Promise\"><a href=\"#什么是Promise\" class=\"headerlink\" title=\"什么是Promise\"></a>什么是<code>Promise</code></h3></li>\n<li><code>Promise</code> 是 <strong>JavaScript 中的一种异步处理机制</strong>，用于解决 <strong>回调地狱（Callback Hell）</strong> 和 <strong>异步操作的可读性问题</strong>。它代表 <strong>一个未来可能会完成或失败的操作</strong>，并允许在操作完成后执行相应的代码<h3 id=\"Promise的三种状态\"><a href=\"#Promise的三种状态\" class=\"headerlink\" title=\"Promise的三种状态\"></a><code>Promise</code>的三种状态</h3></li>\n</ul>\n<ol>\n<li><strong><code>pending</code>（进行中）：</strong> 初始状态，表示异步操作尚未完成。</li>\n<li><strong><code>fulfilled</code>（已完成）：</strong> 操作成功，<code>resolve()</code> 被调用。</li>\n<li><strong><code>rejected</code>（已失败）：</strong> 操作失败，<code>reject()</code> 被调用。</li>\n</ol>\n<ul>\n<li>一旦 <code>Promise</code> 从 <code>pending</code> 变为 <code>fulfilled</code> 或 <code>rejected</code>，就不能再改变状态（不可逆)<h3 id=\"Promise-的基本用法\"><a href=\"#Promise-的基本用法\" class=\"headerlink\" title=\"Promise 的基本用法\"></a><code>Promise</code> 的基本用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;操作成功！&quot;</span>); <span class=\"comment\">// 成功调用 resolve</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">reject</span>(<span class=\"string\">&quot;操作失败！&quot;</span>); <span class=\"comment\">// 失败调用 reject</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n在 <code>Promise</code> 内部：</li>\n<li>创建了一个promise, 函数体是执行内容</li>\n<li>根据内容决定  -&gt; 执行哪一个内部函数resolve还是reject</li>\n<li><code>resolve(value)</code> <strong>表示成功</strong>，会触发 <code>.then()</code></li>\n<li><code>reject(error)</code> <strong>表示失败</strong>，会触发 <code>.catch()</code><h3 id=\"Promise异步回调处理\"><a href=\"#Promise异步回调处理\" class=\"headerlink\" title=\"Promise异步回调处理\"></a><code>Promise</code>异步回调处理</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myPromise</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;成功:&quot;</span>, result);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;失败:&quot;</span>, error);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">finally</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;无论成功还是失败都会执行！&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n执行流程：</li>\n<li>根据内部函数的执行, 从而决定调用then还是catch, 也就是会被捕捉</li>\n</ul>\n<ol>\n<li>如果 <code>resolve()</code> 被调用，执行 <code>.then(result)</code> ,then()处理异步操作成功后的结果，返回一个新的 <code>Promise</code>，可以链式调用。</li>\n<li>如果 <code>reject()</code> 被调用, 执行 <code>.catch(error)</code></li>\n<li><code>.finally()</code> 一定会执行，无论成功还是失败<h3 id=\"async-await（Promise-的语法糖）\"><a href=\"#async-await（Promise-的语法糖）\" class=\"headerlink\" title=\"async/await（Promise 的语法糖）\"></a><code>async/await</code>（Promise 的语法糖）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">fetchData</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> myPromise;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;错误:&quot;</span>, error);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;执行完成&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title function_\">fetchData</span>();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<code>await</code> 关键字的作用：</li>\n</ol>\n<ul>\n<li>暂停代码执行，直到 <code>Promise</code> 解决</li>\n<li>可以直接获取 <code>Promise</code> 结果</li>\n<li>比 <code>.then()</code> 语法更直观<h3 id=\"用async还是then\"><a href=\"#用async还是then\" class=\"headerlink\" title=\"用async还是then\"></a>用async还是then</h3></li>\n<li>注意这里的两个return<ul>\n<li>其实没必要用两个异步回调<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">batchJobAddOrResRequest</span> = <span class=\"keyword\">async</span> (<span class=\"params\">url, data</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> axios.<span class=\"title function_\">post</span>(<span class=\"string\">&quot;/batch/admin/job/&quot;</span> + url, data).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"title class_\">Result</span> = response.<span class=\"property\">data</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"title class_\">Result</span>.<span class=\"property\">code</span> === <span class=\"title class_\">HttpStatusCode</span>.<span class=\"property\">Ok</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;定时任务添加错误&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"组件中间值的传递\"><a href=\"#组件中间值的传递\" class=\"headerlink\" title=\"组件中间值的传递\"></a>组件中间值的传递</h2></li>\n</ul>\n</li>\n<li><strong>对参数赋值, 值通过子组件传递进来</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父组件: 定义了一个Switch, 通过子组件双向数据绑定的值进行设置打开状态</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">a-switch</span> <span class=\"attr\">v-model:checked</span>=<span class=\"string\">&quot;switchValue&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">childComponent</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;switchValue&quot;</span> <span class=\"attr\">messageText</span>=<span class=\"string\">&quot;我对子盒子说话&quot;</span> @<span class=\"attr\">messageMethod</span>=<span class=\"string\">&quot;getMessageDetail&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    &#123;&#123; detailMessage &#125;&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> &#123; ref &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> childComponent <span class=\"keyword\">from</span> <span class=\"string\">&quot;./childComponent.vue&quot;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> switchValue = <span class=\"title function_\">ref</span>(<span class=\"literal\">false</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">let</span> detailMessage = <span class=\"title function_\">ref</span>();</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> <span class=\"title function_\">getMessageDetail</span> = (<span class=\"params\">detail</span>) =&gt; &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  detailMessage.<span class=\"property\">value</span> = detail;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">watch</span>(</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span> watchValue,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">newVal, oldVal</span>) =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  自定义子组件的属性和方法, 通过父组件传递参数</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    @<span class=\"attr\">click</span>=<span class=\"string\">&quot;handleClick&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">:style</span>=<span class=\"string\">&quot;&#x27;messageText: &#x27; + &#x27;父组件可以显示设置子组件的style&#x27;&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">  &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    开关</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">a-button</span>&gt;</span></span></span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    &#123;&#123; props.messageText &#125;&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">import</span> &#123; defineProps, defineEmits, ref, watch, onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"title function_\">onMounted</span>(<span class=\"function\">() =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"title function_\">emits</span>(<span class=\"string\">&quot;messageMethod&quot;</span>, <span class=\"string\">&quot;我是通过方法传递给父盒子的信息&quot;</span>)</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;)</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"comment\">// 定义了传递字段</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> props = <span class=\"title function_\">defineProps</span>(&#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"attr\">modelValue</span>: <span class=\"title class_\">Boolean</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"attr\">messageText</span>: <span class=\"title class_\">String</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"comment\">// 定义了传递函数</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> emits = <span class=\"title function_\">defineEmits</span>([<span class=\"string\">&quot;update:modelValue&quot;</span>, <span class=\"string\">&quot;messageMethod&quot;</span>]);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">let</span> switchValue = <span class=\"title function_\">ref</span>(<span class=\"literal\">false</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleClick</span> = (<span class=\"params\"></span>) =&gt; &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  switchValue.<span class=\"property\">value</span> = !switchValue.<span class=\"property\">value</span>;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"title function_\">emits</span>(<span class=\"string\">&quot;update:modelValue&quot;</span>, switchValue.<span class=\"property\">value</span> ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"comment\">// 也可以通过对props.modelValue值的监听(vue3的watch), 来收到父组件的信息</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"><span class=\"title function_\">watch</span>(</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"function\">() =&gt;</span> props.<span class=\"property\">modelValue</span>,</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"function\">(<span class=\"params\">modelValue</span>) =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(modelValue, <span class=\"string\">&quot;的值变化了&quot;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">scoped</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"组件小部件\"><a href=\"#组件小部件\" class=\"headerlink\" title=\"组件小部件\"></a>组件小部件</h2><ul>\n<li>表格数据渲染, row与col 通过v-for进行表格数据渲染, 作用与a-table和el-table一样<ul>\n<li>数据源 - 表头行 - 间隔</li>\n<li>用v-for渲染: 在每一行数据中可以灵活运用v-if和v-model和差值语法进行处理<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a-row <span class=\"keyword\">class</span>=<span class=\"string\">&quot;order-tickets-header&quot;</span> v-<span class=\"keyword\">if</span>=<span class=\"string\">&quot;tickets.length &gt; 0&quot;</span>&gt;</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;2&quot;</span>&gt;</span>乘客<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;6&quot;</span>&gt;</span>身份证<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;4&quot;</span>&gt;</span>票种<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;4&quot;</span>&gt;</span>座位类型<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;6&quot;</span>&gt;</span>乘客详细信息<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\">    &lt;/a-row&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">a-row</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      <span class=\"attr\">class</span>=<span class=\"string\">&quot;order-tickets-row&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(ticket, i) in tickets&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      <span class=\"attr\">:key</span>=<span class=\"string\">&quot;ticket.passengerId&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;2&quot;</span>&gt;</span>&#123;&#123; ticket.passengerName &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;6&quot;</span>&gt;</span>&#123;&#123; ticket.passengerIdCard &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">a-col</span> <span class=\"attr\">:span</span>=<span class=\"string\">&quot;4&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">a-select</span> <span class=\"attr\">v-model:value</span>=<span class=\"string\">&quot;ticket.passengerType&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;width: 100%&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">a-select-option</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in PASSENGER_TYPE_ARRAY&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">:key</span>=<span class=\"string\">&quot;item.code&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            <span class=\"attr\">:value</span>=<span class=\"string\">&quot;item.code&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;&#123; item.desc &#125;&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;/<span class=\"name\">a-select-option</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">a-select</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">a-col</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">\t  <span class=\"tag\">&lt;/<span class=\"name\">a-row</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Ref变量和reactive变量\"><a href=\"#Ref变量和reactive变量\" class=\"headerlink\" title=\"Ref变量和reactive变量\"></a>Ref变量和reactive变量</h2></li>\n</ul>\n</li>\n<li>reactive是响应式的(能自动解包), 就不需要通过 <code>.value</code>获取值, 对于对象和数组能快速取值</li>\n<li>在 Vue 3 的 Composition API 里，<code>ref()</code> 返回的是一个对象，这个对象有一个 <code>value</code> 属性，它才是真正存储数据的地方。因此，访问 <code>ref()</code> 变量时必须使用 <code>.value</code>，否则你拿到的是 <code>Ref</code> 对象，而不是它的值, 所以ref还是比较适合基础类型<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> form = <span class=\"title function_\">ref</span>(&#123; <span class=\"attr\">id</span>: <span class=\"string\">&quot;&quot;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&quot;&quot;</span> &#125;);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(form); <span class=\"comment\">// -&gt;  &#123; form: &#123; id: &quot;&quot;, name: &quot;&quot; &#125; &#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><strong><code>reactive()</code> 直接返回代理对象，而 <code>ref()</code> 返回的是一个 <code>&#123; value: 数据 &#125;</code> 的对象</strong>。</li>\n<li><code>const</code>和<code>let</code>用来定义变量，<code>&#123;&#125;</code>是对象，<code>[]</code>是数组，<code>(&#123;&#125;)</code>是对象赋值，<code>([])</code>是数组赋值, 本质上来说是一样的, 只不过为了区分</li>\n</ul>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ul>\n<li>vue的if判断不单单能判断boolean类型, 甚至对空对象, 空值, 0 , 正数…都能判断</li>\n<li>对象的打印不是用加号而是用逗号, 否则打印出来的是”Object”这个字符<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;obj: &quot;</span> + obj); </span><br><span class=\"line\"><span class=\"comment\">// 打印结果：obj: [object Object]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;obj:&quot;</span>, obj);    </span><br><span class=\"line\"><span class=\"comment\">// 打印结果：obj: &#123; name: &quot;Alice&quot; &#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>computed属性函数: 有使用内置缓存的特性 </li>\n<li>vue3新语法: <code>&lt;script setup&gt;</code>, 不用手动return, 让代码更简洁</li>\n<li>vue3新功能: watch监听器</li>\n<li>history: createWebHistory(),  启用 vue3的History 路由模式: <ul>\n<li><code>http://example.com/about</code> -&gt; vue3新模式: 真实路径</li>\n<li><code>http://example.com/#/about</code>  -&gt; 而不是 Vue 2 时代 <code>hash</code> 模式的</li>\n</ul>\n</li>\n<li>状态码code和统一响应结果code不一样</li>\n<li>vue的打包dist要指定mode(dev, prod)</li>\n<li>一个按钮内有点击事件, 内容是一个路由跳转函数, 那么只会执行一个</li>\n<li>前端对JSON的处理: JSON.stringify(object)和JSON.parse(jsonObject)</li>\n<li>Axios 默认已经解析 JSON，不需要 JSON.parse(response.data.data)</li>\n<li>localStorage永久保存在本地, 而sessionStorage会话存储, 值的有效期只在当前浏览器会话</li>\n<li>对如何类的调用都应该创建实例, 只有实例才能取属性调用函数</li>\n<li><code>Uncaught (in promise)</code> 错误通常意味着你没有处理 <code>Promise</code> 被拒绝的情况。需要进行请求的捕获tryCatch</li>\n<li>设置为一个 URL 字符串时，浏览器会自动发出一个 HTTP 请求去获取这个 URL 对应的资源<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17452385641011745238563053.png\" alt=\"17452385641011745238563053.png|700x196\"></li>\n<li>响应拦截器获得的响应数据其实是被3层包裹<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17426307478001742630746874.png\" alt=\"17426307478001742630746874.png\"></li>\n<li>后端定义的首字母大写字段有时候会被Lombok变成小写, 例如: Authorization -&gt; authorization, 可以添加@JsonProperty(“Authorization”) 或者全局修改规则</li>\n<li>解决前后端交互Long类型精度丢失的问题: 1.加一个jackson序列化器 2.每一个响应类加一个注解:@JsonSerialize(using = ToStringSerializer.class)</li>\n<li>在使用 <code>map</code> 前，务必确保你操作的变量是 <strong>数组</strong>, 因为JS的赋值类型是多变得,所有必须多加一层判断语句</li>\n<li>其实anDesignVue的东西都是在原始html的基础上添加了一些属性和方法, 过程跟我们使用父子组件的方法一样, 所以我们也可以自定义自己的组件库</li>\n</ul>\n"},{"title":"深入理解Mybatis","date":"2024-12-18T11:04:25.000Z","_content":"\n# 深入理解Mybatis(常见属性)\n\n- 序言: 本文是对mybatis中的字段回显到实体类(属性, 数组, 哈希表)的方法总结\n\n## 类映射resultType\n\n- 最常见的JavaBean映射, 就是通过类型别名`typeAliases`来处理, 需要在配置文件中指定实体类路径\n\n```java\ntype-aliases-package: com.core.entity # 别名扫描包\n// 然后再xml文件中就可以省略具体路径\n<select id=\"getAdmin\" resultType=\"umsAdmin\">\n```\n\n- 特点: **返回的结果自动映射到实体类Type上, 要求字段要完全一致, 不支持修改字段名**\n\n## 字段映射resultMap\n\n```xml\n<resultMap id=\"adminMap\" type=\"custmeAdmin\">\n        <result column=\"id\" property=\"custmeId\"></result>\n</resultMap>\n```\n\n```xml\n// 使用方法\n<select id=\"getAdmin\" resultMap=\"adminMap\">\n```\n\n- 这里面`column`对应的是数据库的列名或别名；`property`对应的是结果集的字段或属性\n- **特点: 自定义映射字段灵活性较高, 但是实现复杂(需要自己手写字段对应关系)**\n\n## 联合association\n\n- 当resultMap中有字段是bean类嵌套时, 需要通过association去嵌套编写对应关系  **private Role role;**\n\n```xml\n<resultMap id=\"userMap\" type=\"umsAdmin\">\n\t<id property=\"id\" column=\"id\"></id>\n\t<result property=\"username\" column=\"username\"></result>\n\t<result property=\"password\" column=\"password\"></result>\n\t<result property=\"address\" column=\"address\"></result>\n\t<result property=\"email\" column=\"email\"></result>\n\t\n\t<association property=\"role\" javaType=\"Role\">  \n\t\t<id property=\"id\" column=\"role_id\"></id>\n\t\t<result property=\"name\" column=\"role_name\"></result>\n\t</association>\n</resultMap>\n{\n    \"id\": \"1001\",\n    \"username\": \"后羿\",\n    \"password\": \"123456\",\n    \"address\": \"北京市海淀区\",\n    \"email\": \"510273027@qq.com\",\n    \"role\": {\n        \"id\": \"3\",\n        \"name\": \"射手\"\n    }\n}\n```\n\n- **特点: 在resultMap中嵌套实体类, 不支持再嵌套实体类数组**\n\n## 集合collection\n\n- 当resultMap中属性为数组形式时, 可拓展…  **private List< Role > roleList;**\n- **主要的属性: property(实体类数组名)  ofType(实体类数组类型名,一定要写)**\n\n```xml\n<resultMap id=\"userMap\" type=\"User\">\n\t<id property=\"id\" column=\"id\"></id>\n\t<result property=\"username\" column=\"username\"></result>\n\t<result property=\"password\" column=\"password\"></result>\n\t<result property=\"address\" column=\"address\"></result>\n\t<result property=\"email\" column=\"email\"></result>\n\t\n\t<collection property=\"roles\" ofType=\"Role\">\n\t\t<id property=\"id\" column=\"role_id\"></id>\n\t\t<result property=\"name\" column=\"role_name\"></result>\n\t</collection>\n</resultMap>\n{\n    \"id\": \"1003\",\n    \"username\": \"貂蝉\",\n    \"password\": \"123456\",\n    \"address\": \"北京市东城区\",\n    \"email\": \"510273027@qq.com\",\n    \"roles\": [\n        {\n            \"id\": \"1\",\n            \"name\": \"中单\"\n        },\n        {\n            \"id\": \"2\",\n            \"name\": \"打野\"\n        }\n    ]\n}\n```\n\n- **特点: 支持在resultMap中嵌套数组遍历映射, 是association的高级版**\n\n## 例子\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.admin.mapper.productMapper\">\n\t<!--左连接查询 分主表和次表 通过自定义resultMap对结果集进行映射-->  <----------\n    <select id=\"updateInfo\" resultMap=\"productMap\">\n        SELECT p.*,\n               pc.parent_id as        cate_parent_id,\n               l.id                   ladder_id,\n               l.product_id           ladder_product_id,\n               l.discount             ladder_discount,\n               l.count                ladder_count,\n               l.price                ladder_price,\n               pf.id                  full_id,\n               pf.product_id          full_product_id,\n               pf.full_price          full_full_price,\n               pf.reduce_price        full_reduce_price,\n               m.id                   member_id,\n               m.product_id           member_product_id,\n               m.member_level_id      member_member_level_id,\n               m.member_price         member_member_price,\n               m.member_level_name    member_member_level_name,\n               s.id                   sku_id,\n               s.product_id           sku_product_id,\n               s.price                sku_price,\n               s.promotion_price      sku_promotion_price,\n               s.low_stock            sku_low_stock,\n               s.pic                  sku_pic,\n               s.sale                 sku_sale,\n               s.sku_code             sku_sku_code,\n               s.stock                sku_stock,\n               s.sp_data              sku_sp_data,\n               a.id                   attribute_id,\n               a.product_id           attribute_product_id,\n               a.product_attribute_id attribute_product_attribute_id,\n               a.value                attribute_value\n        FROM pms_product p\n                 LEFT JOIN pms_product_category pc on pc.id = p.product_category_id\n                 LEFT JOIN pms_product_ladder l ON p.id = l.product_id\n                 LEFT JOIN pms_product_full_reduction pf ON pf.product_id = p.id\n                 LEFT JOIN pms_member_price m ON m.product_id = p.id\n                 LEFT JOIN pms_sku_stock s ON s.product_id = p.id\n                 LEFT JOIN pms_product_attribute_value a ON a.product_id = p.id\n        WHERE p.id = #{id};\n    </select>\n\t<!--最大的结果集类叫productVO 包含了主表product全部属性和cateParentId-->  <----------\n    <resultMap id=\"productMap\" type=\"com.admin.pojo.vo.productVO\">\n\t\t<!--额外属性-->\n        <result property=\"cateParentId\" column=\"cate_parent_id\"/>\n\t\t<!--主表属性-->\n        <result property=\"brandId\" column=\"brand_id\"/>\n        <result property=\"productCategoryId\" column=\"product_category_id\"/>\n        <result property=\"feightTemplateId\" column=\"feight_template_id\"/>\n        <result property=\"productAttributeCategoryId\" column=\"product_attribute_category_id\"/>\n        <result property=\"name\" column=\"name\"/>\n        <result property=\"pic\" column=\"pic\"/>\n        <result property=\"productSn\" column=\"product_sn\"/>\n        <result property=\"deleted\" column=\"deleted\"/>\n        <result property=\"publishStatus\" column=\"publish_status\"/>\n        <result property=\"newStatus\" column=\"new_status\"/>\n        <result property=\"recommandStatus\" column=\"recommand_status\"/>\n        <result property=\"verifyStatus\" column=\"verify_status\"/>\n        <result property=\"sort\" column=\"sort\"/>\n        <result property=\"sale\" column=\"sale\"/>\n        <result property=\"price\" column=\"price\"/>\n        <result property=\"promotionPrice\" column=\"promotion_price\"/>\n        <result property=\"giftGrowth\" column=\"gift_growth\"/>\n        <result property=\"giftPoint\" column=\"gift_point\"/>\n        <result property=\"usePointLimit\" column=\"use_point_limit\"/>\n        <result property=\"subTitle\" column=\"sub_title\"/>\n        <result property=\"originalPrice\" column=\"original_price\"/>\n        <result property=\"stock\" column=\"stock\"/>\n        <result property=\"lowStock\" column=\"low_stock\"/>\n        <result property=\"unit\" column=\"unit\"/>\n        <result property=\"weight\" column=\"weight\"/>\n        <result property=\"previewStatus\" column=\"preview_status\"/>\n        <result property=\"serviceIds\" column=\"service_ids\"/>\n        <result property=\"keywords\" column=\"keywords\"/>\n        <result property=\"note\" column=\"note\"/>\n        <result property=\"albumPics\" column=\"album_pics\"/>\n        <result property=\"detailTitle\" column=\"detail_title\"/>\n        <result property=\"promotionStartTime\" column=\"promotion_start_time\"/>\n        <result property=\"promotionEndTime\" column=\"promotion_end_time\"/>\n        <result property=\"promotionPerLimit\" column=\"promotion_per_limit\"/>\n        <result property=\"promotionType\" column=\"promotion_type\"/>\n        <result property=\"brandName\" column=\"brand_name\"/>\n        <result property=\"productCategoryName\" column=\"product_category_name\"/>\n        <result property=\"description\" column=\"description\"/>\n        <result property=\"detailDesc\" column=\"detail_desc\"/>\n        <result property=\"detailHtml\" column=\"detail_html\"/>\n        <result property=\"detailMobileHtml\" column=\"detail_mobile_html\"/>\n\t\t<!--次表数组  List<PmsProductLadder> productLadderList;-->\n        <collection property=\"productLadderList\" columnPrefix=\"ladder_\" ofType=\"pmsProductLadder\">\n            <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\"/>\n            <result column=\"product_id\" jdbcType=\"BIGINT\" property=\"productId\"/>\n            <result column=\"count\" jdbcType=\"INTEGER\" property=\"count\"/>\n            <result column=\"discount\" jdbcType=\"DECIMAL\" property=\"discount\"/>\n            <result column=\"price\" jdbcType=\"DECIMAL\" property=\"price\"/>\n        </collection>\n        <collection property=\"memberPriceList\" ofType=\"pmsMemberPrice\">\n            <id column=\"member_id\" jdbcType=\"BIGINT\" property=\"id\"/>\n            <result column=\"member_product_id\" property=\"productId\"/>\n            <result column=\"member_member_level_id\" property=\"memberLevelId\"/>\n            <result column=\"member_member_price\" property=\"memberPrice\"/>\n            <result column=\"member_member_level_name\" property=\"memberLevelName\"/>\n        </collection>\n        <collection property=\"productAttributeValueList\" columnPrefix=\"attribute_\" ofType=\"pmsProductAttributeValue\">\n            <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\"/>\n            <result column=\"product_attribute_id\" property=\"productAttributeId\"/>\n            <result column=\"product_id\" property=\"productId\"/>\n        </collection>\n        <collection property=\"skuStockList\" columnPrefix=\"sku_\" ofType=\"pmsSkuStock\">\n            <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\"/>\n            <result column=\"product_id\" jdbcType=\"BIGINT\" property=\"productId\"/>\n            <result column=\"sku_code\" jdbcType=\"VARCHAR\" property=\"skuCode\"/>\n            <result column=\"price\" jdbcType=\"DECIMAL\" property=\"price\"/>\n            <result column=\"stock\" jdbcType=\"INTEGER\" property=\"stock\"/>\n            <result column=\"low_stock\" jdbcType=\"INTEGER\" property=\"lowStock\"/>\n            <result column=\"pic\" jdbcType=\"VARCHAR\" property=\"pic\"/>\n            <result column=\"sale\" jdbcType=\"INTEGER\" property=\"sale\"/>\n            <result column=\"promotion_price\" jdbcType=\"DECIMAL\" property=\"promotionPrice\"/>\n            <result column=\"lock_stock\" jdbcType=\"INTEGER\" property=\"lockStock\"/>\n            <result column=\"sp_data\" jdbcType=\"VARCHAR\" property=\"spData\"/>\n        </collection>\n        <collection property=\"productFullReductionList\" columnPrefix=\"full_\" ofType=\"pmsProductFullReduction\">\n            <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\"/>\n            <result column=\"product_id\" jdbcType=\"BIGINT\" property=\"productId\"/>\n            <result column=\"full_price\" jdbcType=\"DECIMAL\" property=\"fullPrice\"/>\n            <result column=\"reduce_price\" jdbcType=\"DECIMAL\" property=\"reducePrice\"/>\n        </collection>\n\t\t<!--这两条是相关子查询 根据父查询的结果条件来查询-->\n        <collection property=\"subjectProductRelationList\" column=\"{productId=id}\"\n                    select=\"selectSubjectProductRelationByProductId\" ofType=\"cmsSubjectProductRelation\"/>\n        <collection property=\"prefrenceAreaProductRelationList\" column=\"{productId=id}\"\n                    select=\"selectPrefrenceAreaProductRelationByProductId\" ofType=\"cmsPrefrenceAreaProductRelation\"/>\n    </resultMap>\n\n\t<!--子查询的语句-->\n    <select id=\"selectSubjectProductRelationByProductId\"\n            resultMap=\"SubjectProductRelationByProductIdMap\">\n        select *\n        from cms_subject_product_relation\n        where product_id = #{productId}\n    </select>\n    <select id=\"selectPrefrenceAreaProductRelationByProductId\"\n            resultMap=\"PrefrenceAreaProductRelationByProductIdMap\">\n        select *\n        from cms_prefrence_area_product_relation\n        where product_id = #{productId}\n    </select>\n\t<!--子查询的resultMap结果容器  List<CmsSubjectProductRelation> subjectProductRelationList -->\n    <resultMap id=\"SubjectProductRelationByProductIdMap\" type=\"CmsSubjectProductRelation\">\n        <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\"/>\n        <result column=\"subject_id\" jdbcType=\"BIGINT\" property=\"subjectId\"/>\n        <result column=\"product_id\" jdbcType=\"BIGINT\" property=\"productId\"/>\n    </resultMap>\n    <resultMap id=\"PrefrenceAreaProductRelationByProductIdMap\" type=\"CmsPrefrenceAreaProductRelation\">\n        <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\"/>\n        <result column=\"prefrence_area_id\" jdbcType=\"BIGINT\" property=\"prefrenceAreaId\"/>\n        <result column=\"product_id\" jdbcType=\"BIGINT\" property=\"productId\"/>\n    </resultMap>\n</mapper>\n```\n\n## 为什么使用雪花算法生成id\n- id生成类型:\n\t- 自增: 适用于单体架构单一数据库, 如果使用分库会出现id重复\n\t- UUID: 本身是无序的, 又可能出现重复, 从来一角度来说不断增长的id更适和创建索引\n\t- 雪花id构成((bit)): 1位不用 + 41位时间戳(依据本身特性->自增的) + 10位机器位(分库, 不同机器从同一个Redis中拿到一个机器码) + 12位保障位(同一毫秒内有4096个id)\n- 雪花优点: 全局唯一, 有序增长, 生成效率高","source":"_posts/Mybatis.md","raw":"---\ntitle: 深入理解Mybatis\ntags:\n  - mybatis\n  - mysql\ncategories: 编程\ndate: 2024-12-18 19:04:25\n---\n\n# 深入理解Mybatis(常见属性)\n\n- 序言: 本文是对mybatis中的字段回显到实体类(属性, 数组, 哈希表)的方法总结\n\n## 类映射resultType\n\n- 最常见的JavaBean映射, 就是通过类型别名`typeAliases`来处理, 需要在配置文件中指定实体类路径\n\n```java\ntype-aliases-package: com.core.entity # 别名扫描包\n// 然后再xml文件中就可以省略具体路径\n<select id=\"getAdmin\" resultType=\"umsAdmin\">\n```\n\n- 特点: **返回的结果自动映射到实体类Type上, 要求字段要完全一致, 不支持修改字段名**\n\n## 字段映射resultMap\n\n```xml\n<resultMap id=\"adminMap\" type=\"custmeAdmin\">\n        <result column=\"id\" property=\"custmeId\"></result>\n</resultMap>\n```\n\n```xml\n// 使用方法\n<select id=\"getAdmin\" resultMap=\"adminMap\">\n```\n\n- 这里面`column`对应的是数据库的列名或别名；`property`对应的是结果集的字段或属性\n- **特点: 自定义映射字段灵活性较高, 但是实现复杂(需要自己手写字段对应关系)**\n\n## 联合association\n\n- 当resultMap中有字段是bean类嵌套时, 需要通过association去嵌套编写对应关系  **private Role role;**\n\n```xml\n<resultMap id=\"userMap\" type=\"umsAdmin\">\n\t<id property=\"id\" column=\"id\"></id>\n\t<result property=\"username\" column=\"username\"></result>\n\t<result property=\"password\" column=\"password\"></result>\n\t<result property=\"address\" column=\"address\"></result>\n\t<result property=\"email\" column=\"email\"></result>\n\t\n\t<association property=\"role\" javaType=\"Role\">  \n\t\t<id property=\"id\" column=\"role_id\"></id>\n\t\t<result property=\"name\" column=\"role_name\"></result>\n\t</association>\n</resultMap>\n{\n    \"id\": \"1001\",\n    \"username\": \"后羿\",\n    \"password\": \"123456\",\n    \"address\": \"北京市海淀区\",\n    \"email\": \"510273027@qq.com\",\n    \"role\": {\n        \"id\": \"3\",\n        \"name\": \"射手\"\n    }\n}\n```\n\n- **特点: 在resultMap中嵌套实体类, 不支持再嵌套实体类数组**\n\n## 集合collection\n\n- 当resultMap中属性为数组形式时, 可拓展…  **private List< Role > roleList;**\n- **主要的属性: property(实体类数组名)  ofType(实体类数组类型名,一定要写)**\n\n```xml\n<resultMap id=\"userMap\" type=\"User\">\n\t<id property=\"id\" column=\"id\"></id>\n\t<result property=\"username\" column=\"username\"></result>\n\t<result property=\"password\" column=\"password\"></result>\n\t<result property=\"address\" column=\"address\"></result>\n\t<result property=\"email\" column=\"email\"></result>\n\t\n\t<collection property=\"roles\" ofType=\"Role\">\n\t\t<id property=\"id\" column=\"role_id\"></id>\n\t\t<result property=\"name\" column=\"role_name\"></result>\n\t</collection>\n</resultMap>\n{\n    \"id\": \"1003\",\n    \"username\": \"貂蝉\",\n    \"password\": \"123456\",\n    \"address\": \"北京市东城区\",\n    \"email\": \"510273027@qq.com\",\n    \"roles\": [\n        {\n            \"id\": \"1\",\n            \"name\": \"中单\"\n        },\n        {\n            \"id\": \"2\",\n            \"name\": \"打野\"\n        }\n    ]\n}\n```\n\n- **特点: 支持在resultMap中嵌套数组遍历映射, 是association的高级版**\n\n## 例子\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.admin.mapper.productMapper\">\n\t<!--左连接查询 分主表和次表 通过自定义resultMap对结果集进行映射-->  <----------\n    <select id=\"updateInfo\" resultMap=\"productMap\">\n        SELECT p.*,\n               pc.parent_id as        cate_parent_id,\n               l.id                   ladder_id,\n               l.product_id           ladder_product_id,\n               l.discount             ladder_discount,\n               l.count                ladder_count,\n               l.price                ladder_price,\n               pf.id                  full_id,\n               pf.product_id          full_product_id,\n               pf.full_price          full_full_price,\n               pf.reduce_price        full_reduce_price,\n               m.id                   member_id,\n               m.product_id           member_product_id,\n               m.member_level_id      member_member_level_id,\n               m.member_price         member_member_price,\n               m.member_level_name    member_member_level_name,\n               s.id                   sku_id,\n               s.product_id           sku_product_id,\n               s.price                sku_price,\n               s.promotion_price      sku_promotion_price,\n               s.low_stock            sku_low_stock,\n               s.pic                  sku_pic,\n               s.sale                 sku_sale,\n               s.sku_code             sku_sku_code,\n               s.stock                sku_stock,\n               s.sp_data              sku_sp_data,\n               a.id                   attribute_id,\n               a.product_id           attribute_product_id,\n               a.product_attribute_id attribute_product_attribute_id,\n               a.value                attribute_value\n        FROM pms_product p\n                 LEFT JOIN pms_product_category pc on pc.id = p.product_category_id\n                 LEFT JOIN pms_product_ladder l ON p.id = l.product_id\n                 LEFT JOIN pms_product_full_reduction pf ON pf.product_id = p.id\n                 LEFT JOIN pms_member_price m ON m.product_id = p.id\n                 LEFT JOIN pms_sku_stock s ON s.product_id = p.id\n                 LEFT JOIN pms_product_attribute_value a ON a.product_id = p.id\n        WHERE p.id = #{id};\n    </select>\n\t<!--最大的结果集类叫productVO 包含了主表product全部属性和cateParentId-->  <----------\n    <resultMap id=\"productMap\" type=\"com.admin.pojo.vo.productVO\">\n\t\t<!--额外属性-->\n        <result property=\"cateParentId\" column=\"cate_parent_id\"/>\n\t\t<!--主表属性-->\n        <result property=\"brandId\" column=\"brand_id\"/>\n        <result property=\"productCategoryId\" column=\"product_category_id\"/>\n        <result property=\"feightTemplateId\" column=\"feight_template_id\"/>\n        <result property=\"productAttributeCategoryId\" column=\"product_attribute_category_id\"/>\n        <result property=\"name\" column=\"name\"/>\n        <result property=\"pic\" column=\"pic\"/>\n        <result property=\"productSn\" column=\"product_sn\"/>\n        <result property=\"deleted\" column=\"deleted\"/>\n        <result property=\"publishStatus\" column=\"publish_status\"/>\n        <result property=\"newStatus\" column=\"new_status\"/>\n        <result property=\"recommandStatus\" column=\"recommand_status\"/>\n        <result property=\"verifyStatus\" column=\"verify_status\"/>\n        <result property=\"sort\" column=\"sort\"/>\n        <result property=\"sale\" column=\"sale\"/>\n        <result property=\"price\" column=\"price\"/>\n        <result property=\"promotionPrice\" column=\"promotion_price\"/>\n        <result property=\"giftGrowth\" column=\"gift_growth\"/>\n        <result property=\"giftPoint\" column=\"gift_point\"/>\n        <result property=\"usePointLimit\" column=\"use_point_limit\"/>\n        <result property=\"subTitle\" column=\"sub_title\"/>\n        <result property=\"originalPrice\" column=\"original_price\"/>\n        <result property=\"stock\" column=\"stock\"/>\n        <result property=\"lowStock\" column=\"low_stock\"/>\n        <result property=\"unit\" column=\"unit\"/>\n        <result property=\"weight\" column=\"weight\"/>\n        <result property=\"previewStatus\" column=\"preview_status\"/>\n        <result property=\"serviceIds\" column=\"service_ids\"/>\n        <result property=\"keywords\" column=\"keywords\"/>\n        <result property=\"note\" column=\"note\"/>\n        <result property=\"albumPics\" column=\"album_pics\"/>\n        <result property=\"detailTitle\" column=\"detail_title\"/>\n        <result property=\"promotionStartTime\" column=\"promotion_start_time\"/>\n        <result property=\"promotionEndTime\" column=\"promotion_end_time\"/>\n        <result property=\"promotionPerLimit\" column=\"promotion_per_limit\"/>\n        <result property=\"promotionType\" column=\"promotion_type\"/>\n        <result property=\"brandName\" column=\"brand_name\"/>\n        <result property=\"productCategoryName\" column=\"product_category_name\"/>\n        <result property=\"description\" column=\"description\"/>\n        <result property=\"detailDesc\" column=\"detail_desc\"/>\n        <result property=\"detailHtml\" column=\"detail_html\"/>\n        <result property=\"detailMobileHtml\" column=\"detail_mobile_html\"/>\n\t\t<!--次表数组  List<PmsProductLadder> productLadderList;-->\n        <collection property=\"productLadderList\" columnPrefix=\"ladder_\" ofType=\"pmsProductLadder\">\n            <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\"/>\n            <result column=\"product_id\" jdbcType=\"BIGINT\" property=\"productId\"/>\n            <result column=\"count\" jdbcType=\"INTEGER\" property=\"count\"/>\n            <result column=\"discount\" jdbcType=\"DECIMAL\" property=\"discount\"/>\n            <result column=\"price\" jdbcType=\"DECIMAL\" property=\"price\"/>\n        </collection>\n        <collection property=\"memberPriceList\" ofType=\"pmsMemberPrice\">\n            <id column=\"member_id\" jdbcType=\"BIGINT\" property=\"id\"/>\n            <result column=\"member_product_id\" property=\"productId\"/>\n            <result column=\"member_member_level_id\" property=\"memberLevelId\"/>\n            <result column=\"member_member_price\" property=\"memberPrice\"/>\n            <result column=\"member_member_level_name\" property=\"memberLevelName\"/>\n        </collection>\n        <collection property=\"productAttributeValueList\" columnPrefix=\"attribute_\" ofType=\"pmsProductAttributeValue\">\n            <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\"/>\n            <result column=\"product_attribute_id\" property=\"productAttributeId\"/>\n            <result column=\"product_id\" property=\"productId\"/>\n        </collection>\n        <collection property=\"skuStockList\" columnPrefix=\"sku_\" ofType=\"pmsSkuStock\">\n            <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\"/>\n            <result column=\"product_id\" jdbcType=\"BIGINT\" property=\"productId\"/>\n            <result column=\"sku_code\" jdbcType=\"VARCHAR\" property=\"skuCode\"/>\n            <result column=\"price\" jdbcType=\"DECIMAL\" property=\"price\"/>\n            <result column=\"stock\" jdbcType=\"INTEGER\" property=\"stock\"/>\n            <result column=\"low_stock\" jdbcType=\"INTEGER\" property=\"lowStock\"/>\n            <result column=\"pic\" jdbcType=\"VARCHAR\" property=\"pic\"/>\n            <result column=\"sale\" jdbcType=\"INTEGER\" property=\"sale\"/>\n            <result column=\"promotion_price\" jdbcType=\"DECIMAL\" property=\"promotionPrice\"/>\n            <result column=\"lock_stock\" jdbcType=\"INTEGER\" property=\"lockStock\"/>\n            <result column=\"sp_data\" jdbcType=\"VARCHAR\" property=\"spData\"/>\n        </collection>\n        <collection property=\"productFullReductionList\" columnPrefix=\"full_\" ofType=\"pmsProductFullReduction\">\n            <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\"/>\n            <result column=\"product_id\" jdbcType=\"BIGINT\" property=\"productId\"/>\n            <result column=\"full_price\" jdbcType=\"DECIMAL\" property=\"fullPrice\"/>\n            <result column=\"reduce_price\" jdbcType=\"DECIMAL\" property=\"reducePrice\"/>\n        </collection>\n\t\t<!--这两条是相关子查询 根据父查询的结果条件来查询-->\n        <collection property=\"subjectProductRelationList\" column=\"{productId=id}\"\n                    select=\"selectSubjectProductRelationByProductId\" ofType=\"cmsSubjectProductRelation\"/>\n        <collection property=\"prefrenceAreaProductRelationList\" column=\"{productId=id}\"\n                    select=\"selectPrefrenceAreaProductRelationByProductId\" ofType=\"cmsPrefrenceAreaProductRelation\"/>\n    </resultMap>\n\n\t<!--子查询的语句-->\n    <select id=\"selectSubjectProductRelationByProductId\"\n            resultMap=\"SubjectProductRelationByProductIdMap\">\n        select *\n        from cms_subject_product_relation\n        where product_id = #{productId}\n    </select>\n    <select id=\"selectPrefrenceAreaProductRelationByProductId\"\n            resultMap=\"PrefrenceAreaProductRelationByProductIdMap\">\n        select *\n        from cms_prefrence_area_product_relation\n        where product_id = #{productId}\n    </select>\n\t<!--子查询的resultMap结果容器  List<CmsSubjectProductRelation> subjectProductRelationList -->\n    <resultMap id=\"SubjectProductRelationByProductIdMap\" type=\"CmsSubjectProductRelation\">\n        <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\"/>\n        <result column=\"subject_id\" jdbcType=\"BIGINT\" property=\"subjectId\"/>\n        <result column=\"product_id\" jdbcType=\"BIGINT\" property=\"productId\"/>\n    </resultMap>\n    <resultMap id=\"PrefrenceAreaProductRelationByProductIdMap\" type=\"CmsPrefrenceAreaProductRelation\">\n        <id column=\"id\" jdbcType=\"BIGINT\" property=\"id\"/>\n        <result column=\"prefrence_area_id\" jdbcType=\"BIGINT\" property=\"prefrenceAreaId\"/>\n        <result column=\"product_id\" jdbcType=\"BIGINT\" property=\"productId\"/>\n    </resultMap>\n</mapper>\n```\n\n## 为什么使用雪花算法生成id\n- id生成类型:\n\t- 自增: 适用于单体架构单一数据库, 如果使用分库会出现id重复\n\t- UUID: 本身是无序的, 又可能出现重复, 从来一角度来说不断增长的id更适和创建索引\n\t- 雪花id构成((bit)): 1位不用 + 41位时间戳(依据本身特性->自增的) + 10位机器位(分库, 不同机器从同一个Redis中拿到一个机器码) + 12位保障位(同一毫秒内有4096个id)\n- 雪花优点: 全局唯一, 有序增长, 生成效率高","slug":"Mybatis","published":1,"updated":"2025-09-11T00:40:51.364Z","comments":1,"layout":"post","photos":[],"_id":"cmik3ww9j0000homwgbvse639","content":"<h1 id=\"深入理解Mybatis-常见属性\"><a href=\"#深入理解Mybatis-常见属性\" class=\"headerlink\" title=\"深入理解Mybatis(常见属性)\"></a>深入理解Mybatis(常见属性)</h1><ul>\n<li>序言: 本文是对mybatis中的字段回显到实体类(属性, 数组, 哈希表)的方法总结</li>\n</ul>\n<h2 id=\"类映射resultType\"><a href=\"#类映射resultType\" class=\"headerlink\" title=\"类映射resultType\"></a>类映射resultType</h2><ul>\n<li>最常见的JavaBean映射, 就是通过类型别名<code>typeAliases</code>来处理, 需要在配置文件中指定实体类路径</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type-aliases-<span class=\"keyword\">package</span>: com.core.entity # 别名扫描包</span><br><span class=\"line\"><span class=\"comment\">// 然后再xml文件中就可以省略具体路径</span></span><br><span class=\"line\">&lt;select id=<span class=\"string\">&quot;getAdmin&quot;</span> resultType=<span class=\"string\">&quot;umsAdmin&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特点: <strong>返回的结果自动映射到实体类Type上, 要求字段要完全一致, 不支持修改字段名</strong></li>\n</ul>\n<h2 id=\"字段映射resultMap\"><a href=\"#字段映射resultMap\" class=\"headerlink\" title=\"字段映射resultMap\"></a>字段映射resultMap</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;adminMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;custmeAdmin&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;custmeId&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用方法</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;getAdmin&quot;</span> <span class=\"attr\">resultMap</span>=<span class=\"string\">&quot;adminMap&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>这里面<code>column</code>对应的是数据库的列名或别名；<code>property</code>对应的是结果集的字段或属性</li>\n<li><strong>特点: 自定义映射字段灵活性较高, 但是实现复杂(需要自己手写字段对应关系)</strong></li>\n</ul>\n<h2 id=\"联合association\"><a href=\"#联合association\" class=\"headerlink\" title=\"联合association\"></a>联合association</h2><ul>\n<li>当resultMap中有字段是bean类嵌套时, 需要通过association去嵌套编写对应关系  <strong>private Role role;</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;umsAdmin&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;username&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;address&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;address&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;email&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;email&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">association</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;role&quot;</span> <span class=\"attr\">javaType</span>=<span class=\"string\">&quot;Role&quot;</span>&gt;</span>  </span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;role_id&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;name&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;role_name&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">association</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;id&quot;: &quot;1001&quot;,</span><br><span class=\"line\">    &quot;username&quot;: &quot;后羿&quot;,</span><br><span class=\"line\">    &quot;password&quot;: &quot;123456&quot;,</span><br><span class=\"line\">    &quot;address&quot;: &quot;北京市海淀区&quot;,</span><br><span class=\"line\">    &quot;email&quot;: &quot;510273027@qq.com&quot;,</span><br><span class=\"line\">    &quot;role&quot;: &#123;</span><br><span class=\"line\">        &quot;id&quot;: &quot;3&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;射手&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>特点: 在resultMap中嵌套实体类, 不支持再嵌套实体类数组</strong></li>\n</ul>\n<h2 id=\"集合collection\"><a href=\"#集合collection\" class=\"headerlink\" title=\"集合collection\"></a>集合collection</h2><ul>\n<li>当resultMap中属性为数组形式时, 可拓展…  <strong>private List&lt; Role &gt; roleList;</strong></li>\n<li><strong>主要的属性: property(实体类数组名)  ofType(实体类数组类型名,一定要写)</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;User&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;username&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;address&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;address&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;email&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;email&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;roles&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;Role&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;role_id&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;name&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;role_name&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">collection</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;id&quot;: &quot;1003&quot;,</span><br><span class=\"line\">    &quot;username&quot;: &quot;貂蝉&quot;,</span><br><span class=\"line\">    &quot;password&quot;: &quot;123456&quot;,</span><br><span class=\"line\">    &quot;address&quot;: &quot;北京市东城区&quot;,</span><br><span class=\"line\">    &quot;email&quot;: &quot;510273027@qq.com&quot;,</span><br><span class=\"line\">    &quot;roles&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;id&quot;: &quot;1&quot;,</span><br><span class=\"line\">            &quot;name&quot;: &quot;中单&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;id&quot;: &quot;2&quot;,</span><br><span class=\"line\">            &quot;name&quot;: &quot;打野&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>特点: 支持在resultMap中嵌套数组遍历映射, 是association的高级版</strong></li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">mapper</span> <span class=\"keyword\">PUBLIC</span> <span class=\"string\">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class=\"string\">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">&quot;com.admin.mapper.productMapper&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--左连接查询 分主表和次表 通过自定义resultMap对结果集进行映射--&gt;</span>  &lt;----------</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;updateInfo&quot;</span> <span class=\"attr\">resultMap</span>=<span class=\"string\">&quot;productMap&quot;</span>&gt;</span></span><br><span class=\"line\">        SELECT p.*,</span><br><span class=\"line\">               pc.parent_id as        cate_parent_id,</span><br><span class=\"line\">               l.id                   ladder_id,</span><br><span class=\"line\">               l.product_id           ladder_product_id,</span><br><span class=\"line\">               l.discount             ladder_discount,</span><br><span class=\"line\">               l.count                ladder_count,</span><br><span class=\"line\">               l.price                ladder_price,</span><br><span class=\"line\">               pf.id                  full_id,</span><br><span class=\"line\">               pf.product_id          full_product_id,</span><br><span class=\"line\">               pf.full_price          full_full_price,</span><br><span class=\"line\">               pf.reduce_price        full_reduce_price,</span><br><span class=\"line\">               m.id                   member_id,</span><br><span class=\"line\">               m.product_id           member_product_id,</span><br><span class=\"line\">               m.member_level_id      member_member_level_id,</span><br><span class=\"line\">               m.member_price         member_member_price,</span><br><span class=\"line\">               m.member_level_name    member_member_level_name,</span><br><span class=\"line\">               s.id                   sku_id,</span><br><span class=\"line\">               s.product_id           sku_product_id,</span><br><span class=\"line\">               s.price                sku_price,</span><br><span class=\"line\">               s.promotion_price      sku_promotion_price,</span><br><span class=\"line\">               s.low_stock            sku_low_stock,</span><br><span class=\"line\">               s.pic                  sku_pic,</span><br><span class=\"line\">               s.sale                 sku_sale,</span><br><span class=\"line\">               s.sku_code             sku_sku_code,</span><br><span class=\"line\">               s.stock                sku_stock,</span><br><span class=\"line\">               s.sp_data              sku_sp_data,</span><br><span class=\"line\">               a.id                   attribute_id,</span><br><span class=\"line\">               a.product_id           attribute_product_id,</span><br><span class=\"line\">               a.product_attribute_id attribute_product_attribute_id,</span><br><span class=\"line\">               a.value                attribute_value</span><br><span class=\"line\">        FROM pms_product p</span><br><span class=\"line\">                 LEFT JOIN pms_product_category pc on pc.id = p.product_category_id</span><br><span class=\"line\">                 LEFT JOIN pms_product_ladder l ON p.id = l.product_id</span><br><span class=\"line\">                 LEFT JOIN pms_product_full_reduction pf ON pf.product_id = p.id</span><br><span class=\"line\">                 LEFT JOIN pms_member_price m ON m.product_id = p.id</span><br><span class=\"line\">                 LEFT JOIN pms_sku_stock s ON s.product_id = p.id</span><br><span class=\"line\">                 LEFT JOIN pms_product_attribute_value a ON a.product_id = p.id</span><br><span class=\"line\">        WHERE p.id = #&#123;id&#125;;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--最大的结果集类叫productVO 包含了主表product全部属性和cateParentId--&gt;</span>  &lt;----------</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;productMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;com.admin.pojo.vo.productVO&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--额外属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;cateParentId&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;cate_parent_id&quot;</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--主表属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;brandId&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;brand_id&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productCategoryId&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_category_id&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;feightTemplateId&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;feight_template_id&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productAttributeCategoryId&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_attribute_category_id&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;name&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;name&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;pic&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;pic&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productSn&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_sn&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;deleted&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;deleted&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;publishStatus&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;publish_status&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;newStatus&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;new_status&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;recommandStatus&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;recommand_status&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;verifyStatus&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;verify_status&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;sort&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;sort&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;sale&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;sale&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;price&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;price&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;promotionPrice&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;promotion_price&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;giftGrowth&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;gift_growth&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;giftPoint&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;gift_point&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;usePointLimit&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;use_point_limit&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;subTitle&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;sub_title&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;originalPrice&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;original_price&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;stock&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;stock&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;lowStock&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;low_stock&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;unit&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;unit&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;weight&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;weight&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;previewStatus&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;preview_status&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;serviceIds&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;service_ids&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;keywords&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;keywords&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;note&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;note&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;albumPics&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;album_pics&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;detailTitle&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;detail_title&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;promotionStartTime&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;promotion_start_time&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;promotionEndTime&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;promotion_end_time&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;promotionPerLimit&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;promotion_per_limit&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;promotionType&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;promotion_type&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;brandName&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;brand_name&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productCategoryName&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_category_name&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;description&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;description&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;detailDesc&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;detail_desc&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;detailHtml&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;detail_html&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;detailMobileHtml&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;detail_mobile_html&quot;</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--次表数组  List&lt;PmsProductLadder&gt; productLadderList;--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productLadderList&quot;</span> <span class=\"attr\">columnPrefix</span>=<span class=\"string\">&quot;ladder_&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;pmsProductLadder&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;count&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;INTEGER&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;count&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;discount&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;DECIMAL&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;discount&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;price&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;DECIMAL&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;price&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">collection</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;memberPriceList&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;pmsMemberPrice&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;member_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;member_product_id&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;member_member_level_id&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;memberLevelId&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;member_member_price&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;memberPrice&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;member_member_level_name&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;memberLevelName&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">collection</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productAttributeValueList&quot;</span> <span class=\"attr\">columnPrefix</span>=<span class=\"string\">&quot;attribute_&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;pmsProductAttributeValue&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_attribute_id&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productAttributeId&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_id&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">collection</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;skuStockList&quot;</span> <span class=\"attr\">columnPrefix</span>=<span class=\"string\">&quot;sku_&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;pmsSkuStock&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;sku_code&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;VARCHAR&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;skuCode&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;price&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;DECIMAL&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;price&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;stock&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;INTEGER&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;stock&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;low_stock&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;INTEGER&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;lowStock&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;pic&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;VARCHAR&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;pic&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;sale&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;INTEGER&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;sale&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;promotion_price&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;DECIMAL&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;promotionPrice&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;lock_stock&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;INTEGER&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;lockStock&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;sp_data&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;VARCHAR&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;spData&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">collection</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productFullReductionList&quot;</span> <span class=\"attr\">columnPrefix</span>=<span class=\"string\">&quot;full_&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;pmsProductFullReduction&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;full_price&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;DECIMAL&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;fullPrice&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;reduce_price&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;DECIMAL&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;reducePrice&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">collection</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--这两条是相关子查询 根据父查询的结果条件来查询--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;subjectProductRelationList&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;&#123;productId=id&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">select</span>=<span class=\"string\">&quot;selectSubjectProductRelationByProductId&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;cmsSubjectProductRelation&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;prefrenceAreaProductRelationList&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;&#123;productId=id&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">select</span>=<span class=\"string\">&quot;selectPrefrenceAreaProductRelationByProductId&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;cmsPrefrenceAreaProductRelation&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--子查询的语句--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;selectSubjectProductRelationByProductId&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">resultMap</span>=<span class=\"string\">&quot;SubjectProductRelationByProductIdMap&quot;</span>&gt;</span></span><br><span class=\"line\">        select *</span><br><span class=\"line\">        from cms_subject_product_relation</span><br><span class=\"line\">        where product_id = #&#123;productId&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;selectPrefrenceAreaProductRelationByProductId&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">resultMap</span>=<span class=\"string\">&quot;PrefrenceAreaProductRelationByProductIdMap&quot;</span>&gt;</span></span><br><span class=\"line\">        select *</span><br><span class=\"line\">        from cms_prefrence_area_product_relation</span><br><span class=\"line\">        where product_id = #&#123;productId&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--子查询的resultMap结果容器  List&lt;CmsSubjectProductRelation&gt; subjectProductRelationList --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;SubjectProductRelationByProductIdMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;CmsSubjectProductRelation&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;subject_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;subjectId&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;PrefrenceAreaProductRelationByProductIdMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;CmsPrefrenceAreaProductRelation&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;prefrence_area_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;prefrenceAreaId&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"为什么使用雪花算法生成id\"><a href=\"#为什么使用雪花算法生成id\" class=\"headerlink\" title=\"为什么使用雪花算法生成id\"></a>为什么使用雪花算法生成id</h2><ul>\n<li>id生成类型:<ul>\n<li>自增: 适用于单体架构单一数据库, 如果使用分库会出现id重复</li>\n<li>UUID: 本身是无序的, 又可能出现重复, 从来一角度来说不断增长的id更适和创建索引</li>\n<li>雪花id构成((bit)): 1位不用 + 41位时间戳(依据本身特性-&gt;自增的) + 10位机器位(分库, 不同机器从同一个Redis中拿到一个机器码) + 12位保障位(同一毫秒内有4096个id)</li>\n</ul>\n</li>\n<li>雪花优点: 全局唯一, 有序增长, 生成效率高</li>\n</ul>\n","cover":"/img/5.png","cover_type":"img","excerpt":"","more":"<h1 id=\"深入理解Mybatis-常见属性\"><a href=\"#深入理解Mybatis-常见属性\" class=\"headerlink\" title=\"深入理解Mybatis(常见属性)\"></a>深入理解Mybatis(常见属性)</h1><ul>\n<li>序言: 本文是对mybatis中的字段回显到实体类(属性, 数组, 哈希表)的方法总结</li>\n</ul>\n<h2 id=\"类映射resultType\"><a href=\"#类映射resultType\" class=\"headerlink\" title=\"类映射resultType\"></a>类映射resultType</h2><ul>\n<li>最常见的JavaBean映射, 就是通过类型别名<code>typeAliases</code>来处理, 需要在配置文件中指定实体类路径</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type-aliases-<span class=\"keyword\">package</span>: com.core.entity # 别名扫描包</span><br><span class=\"line\"><span class=\"comment\">// 然后再xml文件中就可以省略具体路径</span></span><br><span class=\"line\">&lt;select id=<span class=\"string\">&quot;getAdmin&quot;</span> resultType=<span class=\"string\">&quot;umsAdmin&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>特点: <strong>返回的结果自动映射到实体类Type上, 要求字段要完全一致, 不支持修改字段名</strong></li>\n</ul>\n<h2 id=\"字段映射resultMap\"><a href=\"#字段映射resultMap\" class=\"headerlink\" title=\"字段映射resultMap\"></a>字段映射resultMap</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;adminMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;custmeAdmin&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;custmeId&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用方法</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;getAdmin&quot;</span> <span class=\"attr\">resultMap</span>=<span class=\"string\">&quot;adminMap&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>这里面<code>column</code>对应的是数据库的列名或别名；<code>property</code>对应的是结果集的字段或属性</li>\n<li><strong>特点: 自定义映射字段灵活性较高, 但是实现复杂(需要自己手写字段对应关系)</strong></li>\n</ul>\n<h2 id=\"联合association\"><a href=\"#联合association\" class=\"headerlink\" title=\"联合association\"></a>联合association</h2><ul>\n<li>当resultMap中有字段是bean类嵌套时, 需要通过association去嵌套编写对应关系  <strong>private Role role;</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;umsAdmin&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;username&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;address&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;address&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;email&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;email&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">association</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;role&quot;</span> <span class=\"attr\">javaType</span>=<span class=\"string\">&quot;Role&quot;</span>&gt;</span>  </span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;role_id&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;name&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;role_name&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">association</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;id&quot;: &quot;1001&quot;,</span><br><span class=\"line\">    &quot;username&quot;: &quot;后羿&quot;,</span><br><span class=\"line\">    &quot;password&quot;: &quot;123456&quot;,</span><br><span class=\"line\">    &quot;address&quot;: &quot;北京市海淀区&quot;,</span><br><span class=\"line\">    &quot;email&quot;: &quot;510273027@qq.com&quot;,</span><br><span class=\"line\">    &quot;role&quot;: &#123;</span><br><span class=\"line\">        &quot;id&quot;: &quot;3&quot;,</span><br><span class=\"line\">        &quot;name&quot;: &quot;射手&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>特点: 在resultMap中嵌套实体类, 不支持再嵌套实体类数组</strong></li>\n</ul>\n<h2 id=\"集合collection\"><a href=\"#集合collection\" class=\"headerlink\" title=\"集合collection\"></a>集合collection</h2><ul>\n<li>当resultMap中属性为数组形式时, 可拓展…  <strong>private List&lt; Role &gt; roleList;</strong></li>\n<li><strong>主要的属性: property(实体类数组名)  ofType(实体类数组类型名,一定要写)</strong></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;User&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;username&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;address&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;address&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;email&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;email&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;roles&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;Role&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;role_id&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;name&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;role_name&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">result</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">collection</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;id&quot;: &quot;1003&quot;,</span><br><span class=\"line\">    &quot;username&quot;: &quot;貂蝉&quot;,</span><br><span class=\"line\">    &quot;password&quot;: &quot;123456&quot;,</span><br><span class=\"line\">    &quot;address&quot;: &quot;北京市东城区&quot;,</span><br><span class=\"line\">    &quot;email&quot;: &quot;510273027@qq.com&quot;,</span><br><span class=\"line\">    &quot;roles&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;id&quot;: &quot;1&quot;,</span><br><span class=\"line\">            &quot;name&quot;: &quot;中单&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;id&quot;: &quot;2&quot;,</span><br><span class=\"line\">            &quot;name&quot;: &quot;打野&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>特点: 支持在resultMap中嵌套数组遍历映射, 是association的高级版</strong></li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">mapper</span> <span class=\"keyword\">PUBLIC</span> <span class=\"string\">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class=\"string\">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">&quot;com.admin.mapper.productMapper&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--左连接查询 分主表和次表 通过自定义resultMap对结果集进行映射--&gt;</span>  &lt;----------</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;updateInfo&quot;</span> <span class=\"attr\">resultMap</span>=<span class=\"string\">&quot;productMap&quot;</span>&gt;</span></span><br><span class=\"line\">        SELECT p.*,</span><br><span class=\"line\">               pc.parent_id as        cate_parent_id,</span><br><span class=\"line\">               l.id                   ladder_id,</span><br><span class=\"line\">               l.product_id           ladder_product_id,</span><br><span class=\"line\">               l.discount             ladder_discount,</span><br><span class=\"line\">               l.count                ladder_count,</span><br><span class=\"line\">               l.price                ladder_price,</span><br><span class=\"line\">               pf.id                  full_id,</span><br><span class=\"line\">               pf.product_id          full_product_id,</span><br><span class=\"line\">               pf.full_price          full_full_price,</span><br><span class=\"line\">               pf.reduce_price        full_reduce_price,</span><br><span class=\"line\">               m.id                   member_id,</span><br><span class=\"line\">               m.product_id           member_product_id,</span><br><span class=\"line\">               m.member_level_id      member_member_level_id,</span><br><span class=\"line\">               m.member_price         member_member_price,</span><br><span class=\"line\">               m.member_level_name    member_member_level_name,</span><br><span class=\"line\">               s.id                   sku_id,</span><br><span class=\"line\">               s.product_id           sku_product_id,</span><br><span class=\"line\">               s.price                sku_price,</span><br><span class=\"line\">               s.promotion_price      sku_promotion_price,</span><br><span class=\"line\">               s.low_stock            sku_low_stock,</span><br><span class=\"line\">               s.pic                  sku_pic,</span><br><span class=\"line\">               s.sale                 sku_sale,</span><br><span class=\"line\">               s.sku_code             sku_sku_code,</span><br><span class=\"line\">               s.stock                sku_stock,</span><br><span class=\"line\">               s.sp_data              sku_sp_data,</span><br><span class=\"line\">               a.id                   attribute_id,</span><br><span class=\"line\">               a.product_id           attribute_product_id,</span><br><span class=\"line\">               a.product_attribute_id attribute_product_attribute_id,</span><br><span class=\"line\">               a.value                attribute_value</span><br><span class=\"line\">        FROM pms_product p</span><br><span class=\"line\">                 LEFT JOIN pms_product_category pc on pc.id = p.product_category_id</span><br><span class=\"line\">                 LEFT JOIN pms_product_ladder l ON p.id = l.product_id</span><br><span class=\"line\">                 LEFT JOIN pms_product_full_reduction pf ON pf.product_id = p.id</span><br><span class=\"line\">                 LEFT JOIN pms_member_price m ON m.product_id = p.id</span><br><span class=\"line\">                 LEFT JOIN pms_sku_stock s ON s.product_id = p.id</span><br><span class=\"line\">                 LEFT JOIN pms_product_attribute_value a ON a.product_id = p.id</span><br><span class=\"line\">        WHERE p.id = #&#123;id&#125;;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--最大的结果集类叫productVO 包含了主表product全部属性和cateParentId--&gt;</span>  &lt;----------</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;productMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;com.admin.pojo.vo.productVO&quot;</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--额外属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;cateParentId&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;cate_parent_id&quot;</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--主表属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;brandId&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;brand_id&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productCategoryId&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_category_id&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;feightTemplateId&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;feight_template_id&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productAttributeCategoryId&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_attribute_category_id&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;name&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;name&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;pic&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;pic&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productSn&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_sn&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;deleted&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;deleted&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;publishStatus&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;publish_status&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;newStatus&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;new_status&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;recommandStatus&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;recommand_status&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;verifyStatus&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;verify_status&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;sort&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;sort&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;sale&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;sale&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;price&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;price&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;promotionPrice&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;promotion_price&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;giftGrowth&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;gift_growth&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;giftPoint&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;gift_point&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;usePointLimit&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;use_point_limit&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;subTitle&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;sub_title&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;originalPrice&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;original_price&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;stock&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;stock&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;lowStock&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;low_stock&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;unit&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;unit&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;weight&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;weight&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;previewStatus&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;preview_status&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;serviceIds&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;service_ids&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;keywords&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;keywords&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;note&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;note&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;albumPics&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;album_pics&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;detailTitle&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;detail_title&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;promotionStartTime&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;promotion_start_time&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;promotionEndTime&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;promotion_end_time&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;promotionPerLimit&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;promotion_per_limit&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;promotionType&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;promotion_type&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;brandName&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;brand_name&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productCategoryName&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_category_name&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;description&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;description&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;detailDesc&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;detail_desc&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;detailHtml&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;detail_html&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;detailMobileHtml&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;detail_mobile_html&quot;</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--次表数组  List&lt;PmsProductLadder&gt; productLadderList;--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productLadderList&quot;</span> <span class=\"attr\">columnPrefix</span>=<span class=\"string\">&quot;ladder_&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;pmsProductLadder&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;count&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;INTEGER&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;count&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;discount&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;DECIMAL&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;discount&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;price&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;DECIMAL&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;price&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">collection</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;memberPriceList&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;pmsMemberPrice&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;member_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;member_product_id&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;member_member_level_id&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;memberLevelId&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;member_member_price&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;memberPrice&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;member_member_level_name&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;memberLevelName&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">collection</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productAttributeValueList&quot;</span> <span class=\"attr\">columnPrefix</span>=<span class=\"string\">&quot;attribute_&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;pmsProductAttributeValue&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_attribute_id&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productAttributeId&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_id&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">collection</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;skuStockList&quot;</span> <span class=\"attr\">columnPrefix</span>=<span class=\"string\">&quot;sku_&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;pmsSkuStock&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;sku_code&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;VARCHAR&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;skuCode&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;price&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;DECIMAL&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;price&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;stock&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;INTEGER&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;stock&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;low_stock&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;INTEGER&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;lowStock&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;pic&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;VARCHAR&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;pic&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;sale&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;INTEGER&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;sale&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;promotion_price&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;DECIMAL&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;promotionPrice&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;lock_stock&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;INTEGER&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;lockStock&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;sp_data&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;VARCHAR&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;spData&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">collection</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productFullReductionList&quot;</span> <span class=\"attr\">columnPrefix</span>=<span class=\"string\">&quot;full_&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;pmsProductFullReduction&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;full_price&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;DECIMAL&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;fullPrice&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;reduce_price&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;DECIMAL&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;reducePrice&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">collection</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">&lt;!--这两条是相关子查询 根据父查询的结果条件来查询--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;subjectProductRelationList&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;&#123;productId=id&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">select</span>=<span class=\"string\">&quot;selectSubjectProductRelationByProductId&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;cmsSubjectProductRelation&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">collection</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;prefrenceAreaProductRelationList&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;&#123;productId=id&#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">select</span>=<span class=\"string\">&quot;selectPrefrenceAreaProductRelationByProductId&quot;</span> <span class=\"attr\">ofType</span>=<span class=\"string\">&quot;cmsPrefrenceAreaProductRelation&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--子查询的语句--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;selectSubjectProductRelationByProductId&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">resultMap</span>=<span class=\"string\">&quot;SubjectProductRelationByProductIdMap&quot;</span>&gt;</span></span><br><span class=\"line\">        select *</span><br><span class=\"line\">        from cms_subject_product_relation</span><br><span class=\"line\">        where product_id = #&#123;productId&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;selectPrefrenceAreaProductRelationByProductId&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">resultMap</span>=<span class=\"string\">&quot;PrefrenceAreaProductRelationByProductIdMap&quot;</span>&gt;</span></span><br><span class=\"line\">        select *</span><br><span class=\"line\">        from cms_prefrence_area_product_relation</span><br><span class=\"line\">        where product_id = #&#123;productId&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!--子查询的resultMap结果容器  List&lt;CmsSubjectProductRelation&gt; subjectProductRelationList --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;SubjectProductRelationByProductIdMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;CmsSubjectProductRelation&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;subject_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;subjectId&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;PrefrenceAreaProductRelationByProductIdMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;CmsPrefrenceAreaProductRelation&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;prefrence_area_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;prefrenceAreaId&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;product_id&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;productId&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"为什么使用雪花算法生成id\"><a href=\"#为什么使用雪花算法生成id\" class=\"headerlink\" title=\"为什么使用雪花算法生成id\"></a>为什么使用雪花算法生成id</h2><ul>\n<li>id生成类型:<ul>\n<li>自增: 适用于单体架构单一数据库, 如果使用分库会出现id重复</li>\n<li>UUID: 本身是无序的, 又可能出现重复, 从来一角度来说不断增长的id更适和创建索引</li>\n<li>雪花id构成((bit)): 1位不用 + 41位时间戳(依据本身特性-&gt;自增的) + 10位机器位(分库, 不同机器从同一个Redis中拿到一个机器码) + 12位保障位(同一毫秒内有4096个id)</li>\n</ul>\n</li>\n<li>雪花优点: 全局唯一, 有序增长, 生成效率高</li>\n</ul>\n"},{"banner":"[[pixel-banner-image.png]]","title":"理解服务器和网络IO模型概念","date":"2025-09-25T13:15:00.000Z","_content":"\n\t当野花盛开的时候,即使是最灿烂的阳光,也会显得谦逊，只愿静静照耀~\n# 理解服务器和网络模型概念\n## 服务器\n### 按部署方式分\n- 物理服务器: 由独立硬件组成, 裸机服务器全年无休\n- 虚拟服务器: 在类似于VM虚拟机上部署\n- 云服务器: 一种运行在云计算平台上的虚拟服务器, 由物理服务器隔离出来的一个小房间, 如阿里云(ECS)按需付费\n- 容器化服务器: 基于Docker部署的隔离式服务器, 轻量启动快\n### 按用途分\n- Web服务器: 提供网页访问服务\n- 应用服务器: 执行实际逻辑, 如Tomcat\n- 数据库服务器: 提供存储和数据管理, 如MYSQL, Redis, MongoDB\n- 文件服务器: FTP服务器, NAS(网盘)\n- 代理服务器: 转发客户端和服务器之间的请求, 如Nginx\n- 域名服务器: DNS服务器\n### 按协议分\n- 在运输层上分为TCP服务器和UDP服务器\n- 在应用层分HTTP服务器, 所有的 HTTP 服务器，本质上都是跑在 TCP 服务器之上的\n### 服务器的关键指标\n- CPU性能：服务器的CPU性能直接影响其计算能力。\n- 内存容量：内存容量决定了服务器能够同时处理的任务数量。\n- 存储容量：存储容量决定了服务器能够存储的数据量。\n- 网络带宽：网络带宽决定了服务器的数据传输速度。\n## Socket网络编程\n![17588726665161758872665563.png|700x417](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17588726665161758872665563.png)\n### 概念理解\n- 文件描述符(**fd: File Description**): Socket 本质上是文件，代表一个进程能打开的最大连接数受操作系统最大打开文件数的限制\n- 网络套接字(socket): 由IP和端口构成, 操作系统实现网络通讯\n- 一个连接 ≈ 一个 socket ≈ 一个 fd\n- 服务器监听`listen()`, 客户端发起`connect()` 共同组成一对Socket对象组\n### 一台服务器最大能支持多少连接\n- 操作系统会为每个 TCP 连接维护一个 Socket 结构体\n\t- 本地 IP、端口\n\t- 对方 IP、端口\n\t- 协议\n- 在操作系统层面, Socket也是文件, 所以连接受最大文件数限制\n- 每个 TCP 连接会消耗内核内存, 所以受内存大小限制\n- 一个 IP 的端口号范围是 0~65535, 端口占用也有限, 所以受端口限制\n## 网络IO模型\n- I/O操作都是纯CPU操作, 线程只需要等待或者返回\n- IO 操作涉及 用户态/内核态切换，这也是阻塞和非阻塞效率差异的关键\n- 传统阻塞 IO 模式每个 TCP 连接都需要一个线程去调用 `read()` 或 `write()`, 线程阻塞在 IO 上，资源消耗大，高并发时线程数爆炸。\n- 典型高性能服务器实现方式，如 Netty  -> 单线程可以管理上千个 TCP 连接\n\t网络 I/O 的处理方式直接影响服务器在高并发下的性能。I/O 操作可分为两个阶段：等待就绪和实际读写。当数据未准备好时，等待阶段不消耗 CPU（内核会挂起线程）；真正的数据读写则需要 CPU 执行，速度非常快。根据是否阻塞以及 I/O 调用方式，可以将 I/O 模型分为以下几类：\n- 但是首先要理清一个概念: 连接 -> 线程 -> CPU\n![17588783225181758878322314.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17588783225181758878322314.png)\n### **BIO**同步阻塞\n- 这是最传统的模型，每个连接由一个线程负责。当线程调用 `read()` 或 `write()` 时，如果数据尚未就绪，线程会被阻塞挂起\n- 例子: Java的传统的Socket连接/TCP连接(一请求一线程)  `InputStream` / `OutputStream`  \n### **NIO**同步非阻塞 -> IO多路复用\n- 概念\n\t- 利用**单个线程监听多个TCP连接**,  客户端发起请求, 服务器用户线程负责执行`read()`和`write()`函数, 如果数据未就绪, 不阻塞线程, 连接直接返回错误, 此时的单线程可以去先去做别的操作, 当某个连接的 `IO` 交互完成, 内核通过 `epoll` 机制唤醒 `Selector`, `Selector` 再把事件分发给其他空闲线程执行回调\n- 例子: Redis的单线程IO多路复用\n### **AIO**异步非阻塞\n- 客户端发起请求, 服务器用户线程调用异步线程由异步线程再去调用CPU执行`read()`和`write()`函数, 然后立即返回结果, 等IO交互完成, 调用回调函数通知\n## IO的三种监听方式\n### `select`\n- 原理：  \n    使用 `fd_set`（位图结构，`bit` 数组）保存所有需要监听的 `fd` 可以是已经返回状态的连接, 只需要保存信息, 后续就可以执行回调。调用 `select()` 后，内核会扫描整个 `fd_set`，看哪些 `fd` 就绪，然后返回。\n- 特点：\n    - 最大 `fd` 数量有限（通常是 1024）。\n    - 每次调用 `select` 都要把整个 `fd_set` 从用户态拷贝到内核态，效率低。\n- 适用场景：  \n    早期跨平台网络编程，但不适合高并发。\n![17589568440181758956843173.png|700x295](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17589568440181758956843173.png)\n### `poll`\n- 原理：  \n    使用 `pollfd` 数组来保存所有`fd`，不再用位图，解决了 `select` 的 1024 限制\n- 特点：\n    - 理论上可以监听无限多个 `fd`。\n    - 但内核依旧要遍历整个数组，效率仍然是 `O(n)`。\n    - 每次调用也需要在用户态和内核态之间传递整个数组。\n- 适用场景：  \n    相比 `select` 更灵活，但在高并发场景依旧不够高效。\n![17589582399371758958239061.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17589582399371758958239061.png)\n### `epoll`\n- 原理：  \n    Linux 2.6 引入的高性能 IO 多路复用机制。提供三个核心函数：\n    - `epoll_create()`：创建 epoll 实例（红黑树结构存 fd）。\n    - `epoll_ctl()`：增删改要监听的 fd。\n    - `epoll_wait()`：等待就绪事件，返回已就绪 fd 列表。\n- 特点：\n    - O(1) 效率：只返回有事件发生的 `fd`，而不是扫描整个集合。\n    - 事件驱动：内核用事件回调机制通知，支持 边缘触发（ET） 和 水平触发（LT）。\n    - 高并发利器：单机支持百万连接（`Redis`、`Nginx`、`Netty` 等核心依赖 `epoll`）。\n- 适用场景：  \n    高并发服务器、事件驱动框架\n![17589583049381758958304150.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17589583049381758958304150.png)\n### 区别\n| 特性      | select     | poll       | epoll            |\n| ------- | ---------- | ---------- | ---------------- |\n| 数据结构    | 位图（fd_set） | 数组（pollfd） | 红黑树 + 就绪链表       |\n| fd 限制   | 1024       | 无          | 无                |\n| 用户/内核拷贝 | 每次全量拷贝     | 每次全量拷贝     | 只拷贝就绪的 fd        |\n| 使用场景    | 早期，小规模并发   | 中等并发       | 高并发（Redis、Nginx） |\n","source":"_posts/ServerModels.md","raw":"---\nbanner: \"[[pixel-banner-image.png]]\"\ntitle: 理解服务器和网络IO模型概念\ntags:\n  - Server\n  - NetworkModels\ncategories: 编程\ndate: 2025-09-25T21:15:00\n---\n\n\t当野花盛开的时候,即使是最灿烂的阳光,也会显得谦逊，只愿静静照耀~\n# 理解服务器和网络模型概念\n## 服务器\n### 按部署方式分\n- 物理服务器: 由独立硬件组成, 裸机服务器全年无休\n- 虚拟服务器: 在类似于VM虚拟机上部署\n- 云服务器: 一种运行在云计算平台上的虚拟服务器, 由物理服务器隔离出来的一个小房间, 如阿里云(ECS)按需付费\n- 容器化服务器: 基于Docker部署的隔离式服务器, 轻量启动快\n### 按用途分\n- Web服务器: 提供网页访问服务\n- 应用服务器: 执行实际逻辑, 如Tomcat\n- 数据库服务器: 提供存储和数据管理, 如MYSQL, Redis, MongoDB\n- 文件服务器: FTP服务器, NAS(网盘)\n- 代理服务器: 转发客户端和服务器之间的请求, 如Nginx\n- 域名服务器: DNS服务器\n### 按协议分\n- 在运输层上分为TCP服务器和UDP服务器\n- 在应用层分HTTP服务器, 所有的 HTTP 服务器，本质上都是跑在 TCP 服务器之上的\n### 服务器的关键指标\n- CPU性能：服务器的CPU性能直接影响其计算能力。\n- 内存容量：内存容量决定了服务器能够同时处理的任务数量。\n- 存储容量：存储容量决定了服务器能够存储的数据量。\n- 网络带宽：网络带宽决定了服务器的数据传输速度。\n## Socket网络编程\n![17588726665161758872665563.png|700x417](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17588726665161758872665563.png)\n### 概念理解\n- 文件描述符(**fd: File Description**): Socket 本质上是文件，代表一个进程能打开的最大连接数受操作系统最大打开文件数的限制\n- 网络套接字(socket): 由IP和端口构成, 操作系统实现网络通讯\n- 一个连接 ≈ 一个 socket ≈ 一个 fd\n- 服务器监听`listen()`, 客户端发起`connect()` 共同组成一对Socket对象组\n### 一台服务器最大能支持多少连接\n- 操作系统会为每个 TCP 连接维护一个 Socket 结构体\n\t- 本地 IP、端口\n\t- 对方 IP、端口\n\t- 协议\n- 在操作系统层面, Socket也是文件, 所以连接受最大文件数限制\n- 每个 TCP 连接会消耗内核内存, 所以受内存大小限制\n- 一个 IP 的端口号范围是 0~65535, 端口占用也有限, 所以受端口限制\n## 网络IO模型\n- I/O操作都是纯CPU操作, 线程只需要等待或者返回\n- IO 操作涉及 用户态/内核态切换，这也是阻塞和非阻塞效率差异的关键\n- 传统阻塞 IO 模式每个 TCP 连接都需要一个线程去调用 `read()` 或 `write()`, 线程阻塞在 IO 上，资源消耗大，高并发时线程数爆炸。\n- 典型高性能服务器实现方式，如 Netty  -> 单线程可以管理上千个 TCP 连接\n\t网络 I/O 的处理方式直接影响服务器在高并发下的性能。I/O 操作可分为两个阶段：等待就绪和实际读写。当数据未准备好时，等待阶段不消耗 CPU（内核会挂起线程）；真正的数据读写则需要 CPU 执行，速度非常快。根据是否阻塞以及 I/O 调用方式，可以将 I/O 模型分为以下几类：\n- 但是首先要理清一个概念: 连接 -> 线程 -> CPU\n![17588783225181758878322314.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17588783225181758878322314.png)\n### **BIO**同步阻塞\n- 这是最传统的模型，每个连接由一个线程负责。当线程调用 `read()` 或 `write()` 时，如果数据尚未就绪，线程会被阻塞挂起\n- 例子: Java的传统的Socket连接/TCP连接(一请求一线程)  `InputStream` / `OutputStream`  \n### **NIO**同步非阻塞 -> IO多路复用\n- 概念\n\t- 利用**单个线程监听多个TCP连接**,  客户端发起请求, 服务器用户线程负责执行`read()`和`write()`函数, 如果数据未就绪, 不阻塞线程, 连接直接返回错误, 此时的单线程可以去先去做别的操作, 当某个连接的 `IO` 交互完成, 内核通过 `epoll` 机制唤醒 `Selector`, `Selector` 再把事件分发给其他空闲线程执行回调\n- 例子: Redis的单线程IO多路复用\n### **AIO**异步非阻塞\n- 客户端发起请求, 服务器用户线程调用异步线程由异步线程再去调用CPU执行`read()`和`write()`函数, 然后立即返回结果, 等IO交互完成, 调用回调函数通知\n## IO的三种监听方式\n### `select`\n- 原理：  \n    使用 `fd_set`（位图结构，`bit` 数组）保存所有需要监听的 `fd` 可以是已经返回状态的连接, 只需要保存信息, 后续就可以执行回调。调用 `select()` 后，内核会扫描整个 `fd_set`，看哪些 `fd` 就绪，然后返回。\n- 特点：\n    - 最大 `fd` 数量有限（通常是 1024）。\n    - 每次调用 `select` 都要把整个 `fd_set` 从用户态拷贝到内核态，效率低。\n- 适用场景：  \n    早期跨平台网络编程，但不适合高并发。\n![17589568440181758956843173.png|700x295](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17589568440181758956843173.png)\n### `poll`\n- 原理：  \n    使用 `pollfd` 数组来保存所有`fd`，不再用位图，解决了 `select` 的 1024 限制\n- 特点：\n    - 理论上可以监听无限多个 `fd`。\n    - 但内核依旧要遍历整个数组，效率仍然是 `O(n)`。\n    - 每次调用也需要在用户态和内核态之间传递整个数组。\n- 适用场景：  \n    相比 `select` 更灵活，但在高并发场景依旧不够高效。\n![17589582399371758958239061.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17589582399371758958239061.png)\n### `epoll`\n- 原理：  \n    Linux 2.6 引入的高性能 IO 多路复用机制。提供三个核心函数：\n    - `epoll_create()`：创建 epoll 实例（红黑树结构存 fd）。\n    - `epoll_ctl()`：增删改要监听的 fd。\n    - `epoll_wait()`：等待就绪事件，返回已就绪 fd 列表。\n- 特点：\n    - O(1) 效率：只返回有事件发生的 `fd`，而不是扫描整个集合。\n    - 事件驱动：内核用事件回调机制通知，支持 边缘触发（ET） 和 水平触发（LT）。\n    - 高并发利器：单机支持百万连接（`Redis`、`Nginx`、`Netty` 等核心依赖 `epoll`）。\n- 适用场景：  \n    高并发服务器、事件驱动框架\n![17589583049381758958304150.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17589583049381758958304150.png)\n### 区别\n| 特性      | select     | poll       | epoll            |\n| ------- | ---------- | ---------- | ---------------- |\n| 数据结构    | 位图（fd_set） | 数组（pollfd） | 红黑树 + 就绪链表       |\n| fd 限制   | 1024       | 无          | 无                |\n| 用户/内核拷贝 | 每次全量拷贝     | 每次全量拷贝     | 只拷贝就绪的 fd        |\n| 使用场景    | 早期，小规模并发   | 中等并发       | 高并发（Redis、Nginx） |\n","slug":"ServerModels","published":1,"updated":"2025-10-14T11:38:47.141Z","comments":1,"layout":"post","photos":[],"_id":"cmik3ww9o0004homwc2e90gki","content":"<pre><code>当野花盛开的时候,即使是最灿烂的阳光,也会显得谦逊，只愿静静照耀~\n</code></pre><h1 id=\"理解服务器和网络模型概念\"><a href=\"#理解服务器和网络模型概念\" class=\"headerlink\" title=\"理解服务器和网络模型概念\"></a>理解服务器和网络模型概念</h1><h2 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h2><h3 id=\"按部署方式分\"><a href=\"#按部署方式分\" class=\"headerlink\" title=\"按部署方式分\"></a>按部署方式分</h3><ul>\n<li>物理服务器: 由独立硬件组成, 裸机服务器全年无休</li>\n<li>虚拟服务器: 在类似于VM虚拟机上部署</li>\n<li>云服务器: 一种运行在云计算平台上的虚拟服务器, 由物理服务器隔离出来的一个小房间, 如阿里云(ECS)按需付费</li>\n<li>容器化服务器: 基于Docker部署的隔离式服务器, 轻量启动快<h3 id=\"按用途分\"><a href=\"#按用途分\" class=\"headerlink\" title=\"按用途分\"></a>按用途分</h3></li>\n<li>Web服务器: 提供网页访问服务</li>\n<li>应用服务器: 执行实际逻辑, 如Tomcat</li>\n<li>数据库服务器: 提供存储和数据管理, 如MYSQL, Redis, MongoDB</li>\n<li>文件服务器: FTP服务器, NAS(网盘)</li>\n<li>代理服务器: 转发客户端和服务器之间的请求, 如Nginx</li>\n<li>域名服务器: DNS服务器<h3 id=\"按协议分\"><a href=\"#按协议分\" class=\"headerlink\" title=\"按协议分\"></a>按协议分</h3></li>\n<li>在运输层上分为TCP服务器和UDP服务器</li>\n<li>在应用层分HTTP服务器, 所有的 HTTP 服务器，本质上都是跑在 TCP 服务器之上的<h3 id=\"服务器的关键指标\"><a href=\"#服务器的关键指标\" class=\"headerlink\" title=\"服务器的关键指标\"></a>服务器的关键指标</h3></li>\n<li>CPU性能：服务器的CPU性能直接影响其计算能力。</li>\n<li>内存容量：内存容量决定了服务器能够同时处理的任务数量。</li>\n<li>存储容量：存储容量决定了服务器能够存储的数据量。</li>\n<li>网络带宽：网络带宽决定了服务器的数据传输速度。<h2 id=\"Socket网络编程\"><a href=\"#Socket网络编程\" class=\"headerlink\" title=\"Socket网络编程\"></a>Socket网络编程</h2><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17588726665161758872665563.png\" alt=\"17588726665161758872665563.png|700x417\"><h3 id=\"概念理解\"><a href=\"#概念理解\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h3></li>\n<li>文件描述符(<strong>fd: File Description</strong>): Socket 本质上是文件，代表一个进程能打开的最大连接数受操作系统最大打开文件数的限制</li>\n<li>网络套接字(socket): 由IP和端口构成, 操作系统实现网络通讯</li>\n<li>一个连接 ≈ 一个 socket ≈ 一个 fd</li>\n<li>服务器监听<code>listen()</code>, 客户端发起<code>connect()</code> 共同组成一对Socket对象组<h3 id=\"一台服务器最大能支持多少连接\"><a href=\"#一台服务器最大能支持多少连接\" class=\"headerlink\" title=\"一台服务器最大能支持多少连接\"></a>一台服务器最大能支持多少连接</h3></li>\n<li>操作系统会为每个 TCP 连接维护一个 Socket 结构体<ul>\n<li>本地 IP、端口</li>\n<li>对方 IP、端口</li>\n<li>协议</li>\n</ul>\n</li>\n<li>在操作系统层面, Socket也是文件, 所以连接受最大文件数限制</li>\n<li>每个 TCP 连接会消耗内核内存, 所以受内存大小限制</li>\n<li>一个 IP 的端口号范围是 0~65535, 端口占用也有限, 所以受端口限制<h2 id=\"网络IO模型\"><a href=\"#网络IO模型\" class=\"headerlink\" title=\"网络IO模型\"></a>网络IO模型</h2></li>\n<li>I/O操作都是纯CPU操作, 线程只需要等待或者返回</li>\n<li>IO 操作涉及 用户态/内核态切换，这也是阻塞和非阻塞效率差异的关键</li>\n<li>传统阻塞 IO 模式每个 TCP 连接都需要一个线程去调用 <code>read()</code> 或 <code>write()</code>, 线程阻塞在 IO 上，资源消耗大，高并发时线程数爆炸。</li>\n<li>典型高性能服务器实现方式，如 Netty  -&gt; 单线程可以管理上千个 TCP 连接<br>  网络 I/O 的处理方式直接影响服务器在高并发下的性能。I/O 操作可分为两个阶段：等待就绪和实际读写。当数据未准备好时，等待阶段不消耗 CPU（内核会挂起线程）；真正的数据读写则需要 CPU 执行，速度非常快。根据是否阻塞以及 I/O 调用方式，可以将 I/O 模型分为以下几类：</li>\n<li>但是首先要理清一个概念: 连接 -&gt; 线程 -&gt; CPU<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17588783225181758878322314.png\" alt=\"17588783225181758878322314.png\"><h3 id=\"BIO同步阻塞\"><a href=\"#BIO同步阻塞\" class=\"headerlink\" title=\"BIO同步阻塞\"></a><strong>BIO</strong>同步阻塞</h3></li>\n<li>这是最传统的模型，每个连接由一个线程负责。当线程调用 <code>read()</code> 或 <code>write()</code> 时，如果数据尚未就绪，线程会被阻塞挂起</li>\n<li>例子: Java的传统的Socket连接/TCP连接(一请求一线程)  <code>InputStream</code> / <code>OutputStream</code>  <h3 id=\"NIO同步非阻塞-gt-IO多路复用\"><a href=\"#NIO同步非阻塞-gt-IO多路复用\" class=\"headerlink\" title=\"NIO同步非阻塞 -&gt; IO多路复用\"></a><strong>NIO</strong>同步非阻塞 -&gt; IO多路复用</h3></li>\n<li>概念<ul>\n<li>利用<strong>单个线程监听多个TCP连接</strong>,  客户端发起请求, 服务器用户线程负责执行<code>read()</code>和<code>write()</code>函数, 如果数据未就绪, 不阻塞线程, 连接直接返回错误, 此时的单线程可以去先去做别的操作, 当某个连接的 <code>IO</code> 交互完成, 内核通过 <code>epoll</code> 机制唤醒 <code>Selector</code>, <code>Selector</code> 再把事件分发给其他空闲线程执行回调</li>\n</ul>\n</li>\n<li>例子: Redis的单线程IO多路复用<h3 id=\"AIO异步非阻塞\"><a href=\"#AIO异步非阻塞\" class=\"headerlink\" title=\"AIO异步非阻塞\"></a><strong>AIO</strong>异步非阻塞</h3></li>\n<li>客户端发起请求, 服务器用户线程调用异步线程由异步线程再去调用CPU执行<code>read()</code>和<code>write()</code>函数, 然后立即返回结果, 等IO交互完成, 调用回调函数通知<h2 id=\"IO的三种监听方式\"><a href=\"#IO的三种监听方式\" class=\"headerlink\" title=\"IO的三种监听方式\"></a>IO的三种监听方式</h2><h3 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a><code>select</code></h3></li>\n<li>原理：<br>  使用 <code>fd_set</code>（位图结构，<code>bit</code> 数组）保存所有需要监听的 <code>fd</code> 可以是已经返回状态的连接, 只需要保存信息, 后续就可以执行回调。调用 <code>select()</code> 后，内核会扫描整个 <code>fd_set</code>，看哪些 <code>fd</code> 就绪，然后返回。</li>\n<li>特点：<ul>\n<li>最大 <code>fd</code> 数量有限（通常是 1024）。</li>\n<li>每次调用 <code>select</code> 都要把整个 <code>fd_set</code> 从用户态拷贝到内核态，效率低。</li>\n</ul>\n</li>\n<li>适用场景：<br>  早期跨平台网络编程，但不适合高并发。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17589568440181758956843173.png\" alt=\"17589568440181758956843173.png|700x295\"><h3 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a><code>poll</code></h3></li>\n<li>原理：<br>  使用 <code>pollfd</code> 数组来保存所有<code>fd</code>，不再用位图，解决了 <code>select</code> 的 1024 限制</li>\n<li>特点：<ul>\n<li>理论上可以监听无限多个 <code>fd</code>。</li>\n<li>但内核依旧要遍历整个数组，效率仍然是 <code>O(n)</code>。</li>\n<li>每次调用也需要在用户态和内核态之间传递整个数组。</li>\n</ul>\n</li>\n<li>适用场景：<br>  相比 <code>select</code> 更灵活，但在高并发场景依旧不够高效。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17589582399371758958239061.png\" alt=\"17589582399371758958239061.png\"><h3 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a><code>epoll</code></h3></li>\n<li>原理：<br>  Linux 2.6 引入的高性能 IO 多路复用机制。提供三个核心函数：<ul>\n<li><code>epoll_create()</code>：创建 epoll 实例（红黑树结构存 fd）。</li>\n<li><code>epoll_ctl()</code>：增删改要监听的 fd。</li>\n<li><code>epoll_wait()</code>：等待就绪事件，返回已就绪 fd 列表。</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>O(1) 效率：只返回有事件发生的 <code>fd</code>，而不是扫描整个集合。</li>\n<li>事件驱动：内核用事件回调机制通知，支持 边缘触发（ET） 和 水平触发（LT）。</li>\n<li>高并发利器：单机支持百万连接（<code>Redis</code>、<code>Nginx</code>、<code>Netty</code> 等核心依赖 <code>epoll</code>）。</li>\n</ul>\n</li>\n<li>适用场景：<br>  高并发服务器、事件驱动框架<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17589583049381758958304150.png\" alt=\"17589583049381758958304150.png\"><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3>| 特性      | select     | poll       | epoll            |<br>| ———- | ————— | ————— | ———————— |<br>| 数据结构    | 位图（fd_set） | 数组（pollfd） | 红黑树 + 就绪链表       |<br>| fd 限制   | 1024       | 无          | 无                |<br>| 用户/内核拷贝 | 每次全量拷贝     | 每次全量拷贝     | 只拷贝就绪的 fd        |<br>| 使用场景    | 早期，小规模并发   | 中等并发       | 高并发（Redis、Nginx） |</li>\n</ul>\n","cover":"/img/wallpaper/view13.jpg","cover_type":"img","excerpt":"","more":"<pre><code>当野花盛开的时候,即使是最灿烂的阳光,也会显得谦逊，只愿静静照耀~\n</code></pre><h1 id=\"理解服务器和网络模型概念\"><a href=\"#理解服务器和网络模型概念\" class=\"headerlink\" title=\"理解服务器和网络模型概念\"></a>理解服务器和网络模型概念</h1><h2 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h2><h3 id=\"按部署方式分\"><a href=\"#按部署方式分\" class=\"headerlink\" title=\"按部署方式分\"></a>按部署方式分</h3><ul>\n<li>物理服务器: 由独立硬件组成, 裸机服务器全年无休</li>\n<li>虚拟服务器: 在类似于VM虚拟机上部署</li>\n<li>云服务器: 一种运行在云计算平台上的虚拟服务器, 由物理服务器隔离出来的一个小房间, 如阿里云(ECS)按需付费</li>\n<li>容器化服务器: 基于Docker部署的隔离式服务器, 轻量启动快<h3 id=\"按用途分\"><a href=\"#按用途分\" class=\"headerlink\" title=\"按用途分\"></a>按用途分</h3></li>\n<li>Web服务器: 提供网页访问服务</li>\n<li>应用服务器: 执行实际逻辑, 如Tomcat</li>\n<li>数据库服务器: 提供存储和数据管理, 如MYSQL, Redis, MongoDB</li>\n<li>文件服务器: FTP服务器, NAS(网盘)</li>\n<li>代理服务器: 转发客户端和服务器之间的请求, 如Nginx</li>\n<li>域名服务器: DNS服务器<h3 id=\"按协议分\"><a href=\"#按协议分\" class=\"headerlink\" title=\"按协议分\"></a>按协议分</h3></li>\n<li>在运输层上分为TCP服务器和UDP服务器</li>\n<li>在应用层分HTTP服务器, 所有的 HTTP 服务器，本质上都是跑在 TCP 服务器之上的<h3 id=\"服务器的关键指标\"><a href=\"#服务器的关键指标\" class=\"headerlink\" title=\"服务器的关键指标\"></a>服务器的关键指标</h3></li>\n<li>CPU性能：服务器的CPU性能直接影响其计算能力。</li>\n<li>内存容量：内存容量决定了服务器能够同时处理的任务数量。</li>\n<li>存储容量：存储容量决定了服务器能够存储的数据量。</li>\n<li>网络带宽：网络带宽决定了服务器的数据传输速度。<h2 id=\"Socket网络编程\"><a href=\"#Socket网络编程\" class=\"headerlink\" title=\"Socket网络编程\"></a>Socket网络编程</h2><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17588726665161758872665563.png\" alt=\"17588726665161758872665563.png|700x417\"><h3 id=\"概念理解\"><a href=\"#概念理解\" class=\"headerlink\" title=\"概念理解\"></a>概念理解</h3></li>\n<li>文件描述符(<strong>fd: File Description</strong>): Socket 本质上是文件，代表一个进程能打开的最大连接数受操作系统最大打开文件数的限制</li>\n<li>网络套接字(socket): 由IP和端口构成, 操作系统实现网络通讯</li>\n<li>一个连接 ≈ 一个 socket ≈ 一个 fd</li>\n<li>服务器监听<code>listen()</code>, 客户端发起<code>connect()</code> 共同组成一对Socket对象组<h3 id=\"一台服务器最大能支持多少连接\"><a href=\"#一台服务器最大能支持多少连接\" class=\"headerlink\" title=\"一台服务器最大能支持多少连接\"></a>一台服务器最大能支持多少连接</h3></li>\n<li>操作系统会为每个 TCP 连接维护一个 Socket 结构体<ul>\n<li>本地 IP、端口</li>\n<li>对方 IP、端口</li>\n<li>协议</li>\n</ul>\n</li>\n<li>在操作系统层面, Socket也是文件, 所以连接受最大文件数限制</li>\n<li>每个 TCP 连接会消耗内核内存, 所以受内存大小限制</li>\n<li>一个 IP 的端口号范围是 0~65535, 端口占用也有限, 所以受端口限制<h2 id=\"网络IO模型\"><a href=\"#网络IO模型\" class=\"headerlink\" title=\"网络IO模型\"></a>网络IO模型</h2></li>\n<li>I/O操作都是纯CPU操作, 线程只需要等待或者返回</li>\n<li>IO 操作涉及 用户态/内核态切换，这也是阻塞和非阻塞效率差异的关键</li>\n<li>传统阻塞 IO 模式每个 TCP 连接都需要一个线程去调用 <code>read()</code> 或 <code>write()</code>, 线程阻塞在 IO 上，资源消耗大，高并发时线程数爆炸。</li>\n<li>典型高性能服务器实现方式，如 Netty  -&gt; 单线程可以管理上千个 TCP 连接<br>  网络 I/O 的处理方式直接影响服务器在高并发下的性能。I/O 操作可分为两个阶段：等待就绪和实际读写。当数据未准备好时，等待阶段不消耗 CPU（内核会挂起线程）；真正的数据读写则需要 CPU 执行，速度非常快。根据是否阻塞以及 I/O 调用方式，可以将 I/O 模型分为以下几类：</li>\n<li>但是首先要理清一个概念: 连接 -&gt; 线程 -&gt; CPU<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17588783225181758878322314.png\" alt=\"17588783225181758878322314.png\"><h3 id=\"BIO同步阻塞\"><a href=\"#BIO同步阻塞\" class=\"headerlink\" title=\"BIO同步阻塞\"></a><strong>BIO</strong>同步阻塞</h3></li>\n<li>这是最传统的模型，每个连接由一个线程负责。当线程调用 <code>read()</code> 或 <code>write()</code> 时，如果数据尚未就绪，线程会被阻塞挂起</li>\n<li>例子: Java的传统的Socket连接/TCP连接(一请求一线程)  <code>InputStream</code> / <code>OutputStream</code>  <h3 id=\"NIO同步非阻塞-gt-IO多路复用\"><a href=\"#NIO同步非阻塞-gt-IO多路复用\" class=\"headerlink\" title=\"NIO同步非阻塞 -&gt; IO多路复用\"></a><strong>NIO</strong>同步非阻塞 -&gt; IO多路复用</h3></li>\n<li>概念<ul>\n<li>利用<strong>单个线程监听多个TCP连接</strong>,  客户端发起请求, 服务器用户线程负责执行<code>read()</code>和<code>write()</code>函数, 如果数据未就绪, 不阻塞线程, 连接直接返回错误, 此时的单线程可以去先去做别的操作, 当某个连接的 <code>IO</code> 交互完成, 内核通过 <code>epoll</code> 机制唤醒 <code>Selector</code>, <code>Selector</code> 再把事件分发给其他空闲线程执行回调</li>\n</ul>\n</li>\n<li>例子: Redis的单线程IO多路复用<h3 id=\"AIO异步非阻塞\"><a href=\"#AIO异步非阻塞\" class=\"headerlink\" title=\"AIO异步非阻塞\"></a><strong>AIO</strong>异步非阻塞</h3></li>\n<li>客户端发起请求, 服务器用户线程调用异步线程由异步线程再去调用CPU执行<code>read()</code>和<code>write()</code>函数, 然后立即返回结果, 等IO交互完成, 调用回调函数通知<h2 id=\"IO的三种监听方式\"><a href=\"#IO的三种监听方式\" class=\"headerlink\" title=\"IO的三种监听方式\"></a>IO的三种监听方式</h2><h3 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a><code>select</code></h3></li>\n<li>原理：<br>  使用 <code>fd_set</code>（位图结构，<code>bit</code> 数组）保存所有需要监听的 <code>fd</code> 可以是已经返回状态的连接, 只需要保存信息, 后续就可以执行回调。调用 <code>select()</code> 后，内核会扫描整个 <code>fd_set</code>，看哪些 <code>fd</code> 就绪，然后返回。</li>\n<li>特点：<ul>\n<li>最大 <code>fd</code> 数量有限（通常是 1024）。</li>\n<li>每次调用 <code>select</code> 都要把整个 <code>fd_set</code> 从用户态拷贝到内核态，效率低。</li>\n</ul>\n</li>\n<li>适用场景：<br>  早期跨平台网络编程，但不适合高并发。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17589568440181758956843173.png\" alt=\"17589568440181758956843173.png|700x295\"><h3 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a><code>poll</code></h3></li>\n<li>原理：<br>  使用 <code>pollfd</code> 数组来保存所有<code>fd</code>，不再用位图，解决了 <code>select</code> 的 1024 限制</li>\n<li>特点：<ul>\n<li>理论上可以监听无限多个 <code>fd</code>。</li>\n<li>但内核依旧要遍历整个数组，效率仍然是 <code>O(n)</code>。</li>\n<li>每次调用也需要在用户态和内核态之间传递整个数组。</li>\n</ul>\n</li>\n<li>适用场景：<br>  相比 <code>select</code> 更灵活，但在高并发场景依旧不够高效。<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17589582399371758958239061.png\" alt=\"17589582399371758958239061.png\"><h3 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a><code>epoll</code></h3></li>\n<li>原理：<br>  Linux 2.6 引入的高性能 IO 多路复用机制。提供三个核心函数：<ul>\n<li><code>epoll_create()</code>：创建 epoll 实例（红黑树结构存 fd）。</li>\n<li><code>epoll_ctl()</code>：增删改要监听的 fd。</li>\n<li><code>epoll_wait()</code>：等待就绪事件，返回已就绪 fd 列表。</li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>O(1) 效率：只返回有事件发生的 <code>fd</code>，而不是扫描整个集合。</li>\n<li>事件驱动：内核用事件回调机制通知，支持 边缘触发（ET） 和 水平触发（LT）。</li>\n<li>高并发利器：单机支持百万连接（<code>Redis</code>、<code>Nginx</code>、<code>Netty</code> 等核心依赖 <code>epoll</code>）。</li>\n</ul>\n</li>\n<li>适用场景：<br>  高并发服务器、事件驱动框架<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17589583049381758958304150.png\" alt=\"17589583049381758958304150.png\"><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3>| 特性      | select     | poll       | epoll            |<br>| ———- | ————— | ————— | ———————— |<br>| 数据结构    | 位图（fd_set） | 数组（pollfd） | 红黑树 + 就绪链表       |<br>| fd 限制   | 1024       | 无          | 无                |<br>| 用户/内核拷贝 | 每次全量拷贝     | 每次全量拷贝     | 只拷贝就绪的 fd        |<br>| 使用场景    | 早期，小规模并发   | 中等并发       | 高并发（Redis、Nginx） |</li>\n</ul>\n"},{"title":"深入了解SpringBoot自动装配原理","date":"2024-11-04T01:25:48.000Z","_content":"\n# Spring And SpringBoot\n## 序言\n\n> - 本文梳理了 `SpringApplication` 启动流程的原理，并分析了入口类返回的 IOC 容器的作用，特别是自动装配的过程。通过对关键组件如 `@Import` 注解、`BeanFactory` 和调试流程的理解，能够更加深入地了解 Spring Boot 应用的启动过程及其背后的工作机制。\n> - `SpringApplication` 返回容器的过程中，自动装配(读取加载注入刷新)是关键的工作，只有在所有工作都完成后，容器才会最终返回\n## Spring启动预览\n- 模拟SpringApplication主类: 通过下面的例子让你快速理解Spring启动加载原理\n```java\n@SpringBootApplication\n@EnableConfigurationProperties\npublic class testSpringApplicant {\n    public static void main(String[] args) {\n        // 1.启动Spring应用\n        SpringApplication app = new SpringApplication(bootClass.class);\n        app.run(args);  // 启动 Spring Boot 应用并初始化容器\n\n        // 2.使用 AnnotationConfigApplicationContext 初始化 IOC 容器\n        ApplicationContext context = new AnnotationConfigApplicationContext();\n\n        // 3.手动注册一个 Bean 示例\n        ConfigurableListableBeanFactory beanFactory = new DefaultListableBeanFactory();         // 工作bean工厂: 不需要IOC容器来做事  注册单例 \n        beanFactory.registerSingleton(\"bean\", new Bean()); \n\n        // 4.刷新容器\n        ((AnnotationConfigApplicationContext) context).refresh(); \n        \n        // 5.等所有准备工作都做完了,可以拿到run方法返回的一个IOC容器\n        ConfigurableApplicationContext returnValue = app.run(args);\n//returnValue应该是ConfigurableApplicationContext的实现AnnotationConfigApplicationContext\n    }\n}\n```\n### SpringApplication类解析\n- 把所有的组件、环境配置、初始化逻辑整合起来，确保应用程序顺利启动。\n- 这个类既是入口类,又是结束类,关系到IOC容器的生命周期,也关系到整个程序的启动与停止\n```java\n// 最外层\npublic static void main(String[] args) {\n        SpringApplication.run(ProjectTestApplication.class, args);\n    } \n```\n\n```java\n// 第二层\npublic static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {\n        return run(new Class[]{primarySource}, args);\n    }\n```\n\n```java\n// 第三层: 实例化一个SpringApplication实例,执行run方法(不是静态的run方法)\npublic static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {\n        return (new SpringApplication(primarySources)).run(args);\n    }\n```\n\n```java\n// 最里层: 逻辑层->程序的启动流程\npublic ConfigurableApplicationContext run(String... args) {\n\t\t//创建 DefaultBootstrapContext 对象，它代表了应用程序的引导上下文。引导上下文通常是 Spring Boot 启动时的早期阶段，用于初始化一些关键组件。\n        DefaultBootstrapContext bootstrapContext = this.createBootstrapContext();\n    \t// 初始化容器对象\n        ConfigurableApplicationContext context = null;\n        this.configureHeadlessProperty();\n    \t// 监听 Spring Boot 应用程序启动生命周期的监听器。\n        SpringApplicationRunListeners listeners = this.getRunListeners(args);\n    \t// 开启监听器\n        listeners.starting(bootstrapContext, this.mainApplicationClass);\n        try {\n            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n            // 准备应用程序的环境配置\n            ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);\n            // 打印横幅\n            Banner printedBanner = this.printBanner(environment);\n            // AnnotationConfigApplicationContext IOC容器\n            context = this.createApplicationContext();\n            // 开启监听器\n            context.setApplicationStartup(this.applicationStartup);\n            // 准备应用程序的上下文（context),并执行一些初始化任务\n            this.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\n            // 刷新 Spring 上下文  触发 BeanFactory 的加载和初始化，容器会开始准备好为应用程序提供服务。\n            this.refreshContext(context);\n            // 刷新后的一些后处理逻辑，通常用于执行一些应用程序启动后的任务。\n            this.afterRefresh(context, applicationArguments);\n            // 标记应用程序的启动过程已经完成。\n            startup.started();\n            // 返回配置好的 ConfigurableApplicationContext 实例。该上下文是整个应用程序的核心容器，所有的 Spring Beans 都会在其中管理。\n            return context;\n        }\n```\n## IOC容器\n- IOC容器的实现类`AnnotationConfigApplicationContext` 实现了`AnnotationConfigRegistry` 继承了`GenericApplicationContext`\n```java\n  public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry\n\n  // 获取Bean名单的方式: 通过register和scan\n  void scan(String… basePackages); // 加载需要扫描的包路径@Compoent\n  void register(Class<?>… componentClasses); // 加载手动注册的注解配置类@Configuration\n```\n### IOC容器实现类有两个方法专门用来扫描Bean\n- **void scan  -> 扫描组件**\n\t- 所有方法自动添加@bean\n\t- 通过@ComponentScan扫描带有注解@Component @Controller @Service @Repository(dao层专用,spring框架下) @Mapper(Mybatis专用)  的类\n- **void register -> 扫描配置类**\n\t- 需手动添加@bean\n\t- @Configuration 下带有@Bean注解的方法\n### IOC容器执行Refresh方法加载注册Bean流程\n  - 加载bean到上下文中(包括解析Bean定义、创建Bean实例、解决依赖关系、初始化Bean以及销毁Bean)\n  - 执行依赖注入\n  - 标注已刷新,完成工作\n### 了解@Import注解: 加载Bean名单(自动装配)\n- @Import注解是spring第三种定义bean的方法, **支持对第三方包的导入**\n- 共有三种实现方法:\n  1. 基础数组: 注解形式通过反射`Class.forName()`把bean交给IOC容器\n    ```java\n    // 这些在容器中bean名称是该类的全类名 ，比如com.spring.ImBean\n    @Import({ 类名.class , 类名.class... })\n    public class TestDemo {\n    }\n    ```\n  2. 实现`ImportSelect`接口:这种方式也是Spring的用法, 返回值就是我们实际上要导入到容器中的组件全限定类名(Bean名单)【**重点** 】\n    ```java\n    public class Myclass implements ImportSelector {\n    // 重写导入Bean名单方法\n        @Override\n        public String[] selectImports(AnnotationMetadata annotationMetadata) {\n            return new String[]{\"com.spring.ImBean\", \"com.spring.ImBean2\"};\n        }\n    }\n    ```\n  3. 实现`ImportBeanDefinitionRegister`接口: 跟上面的实现方法接近, 区别在于能修改bean名\n    ```java\n    public class Myclass2 implements ImportBeanDefinitionRegistrar {\n        @Override\n        public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) {\n            //指定bean定义信息（包括bean的类型、作用域...）\n            RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(ImBean.class);\n            //注册一个bean指定bean名字（id）\n        beanDefinitionRegistry.registerBeanDefinition(\"reNameBean\",rootBeanDefinition);\n        }\n    }\n    ```\n## 自动装配分析(重点)\n- 首先`@SpringBootApplication`启动类注解带有3个关键注解\n\t- 一个就是下文提到的`@EnableAutoConfiguration`, 用于自动装配第三方Bean依赖\n\t- `@ComponentScan`用于扫描`ClassPath`下的本地Bean\n\t- `@SpringBootConfiguration`注解嵌套了一个`@Configuration`, 实际上它也是一个配置类\n- **@EnableAutoConfiguration**启用Spring Boot的自动配置机制，将第三方依赖bean注入IOC容器\n- 通过`SpringFactoriesLoader`从类路径下去读取`META-INF/spring.factories`文件信息，此文件中有一个key为`org.springframework.boot.autoconfigure.EnableAutoConfiguration`，定义了一组需要自动配置的bean名单 如下:\n- [x] ConfigurationPropertiesAutoConfiguration \n- [x] AOPAutoConfiguration\n- [x] DataSourceAutoConfiguration\n- [x] ElasticsearchAutoConfiguration\n- [x] RedisAutoConfiguration\n- [x] GsonAutoConfiguration\n- [x] HttpMessageConvertersAutoConfiguration\n- [x] JacksonAutoConfiguration\n- [x] DispathcherAutoConfiguration\n- [x] WebMvcAutoConfiguration\n### 具体的实现流程\n- `@EnableAutoConfiguration`只是一个引导注解, 真正实现加载bena名单功能的是实现类**AutoConfigurationImportSelector**\n- import注解将`AutoConfigurationImportSelector`这个伪配置类交给IOC\n```java\n@AutoConfigurationPackage\n@Import({AutoConfigurationImportSelector.class})  // 先是通过import第一种用法:基础数组\npublic @interface EnableAutoConfiguration {\n    String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n\n    Class<?>[] exclude() default {};\n\n    String[] excludeName() default {};\n}\n```\n1. 通过`getCandidateConfigurations`去加载配置文件的bean全类名名单, \n2. 由`getAutoConfigurationEntry`做名单过滤, 比如像判断自动转配开关是否打开, 是否设置了排除项, 然后把名单设置到类的成员变量中, \n3. 由`selectImports`方法去拿到成员变量名单去执行加载Bean的操作, 加载Bean是通过实现import接口重写`selectImports`方法实现的\n- 其中加载的配置文件地址  采取逐行读取的方式`readline()`\n\t- 旧地址: META-INF/spring.factories(兼容旧版本) \n\t- 新地址: META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. \n```java\n// DeferredImportSelector实现了了ImportSelect, AutoConfigurationImportSelector实现了DeferredImportSelector\npublic class AutoConfigurationImportSelector implements DeferredImportSelector{\n\n    // 用于返回空bean名单的空数组\n    private static final String[] NO_IMPORTS = new String[0]; \n\n    // 这个才是存储Bean数组和排除的Bean数组的底层对象,里面是List和Set\n    private static final AutoConfigurationEntry EMPTY_ENTRY = new AutoConfigurationEntry();\n\n    // 关于底层对象的定义\n    protected static class AutoConfigurationEntry {\n        private final List<String> configurations;  // 存储bean名单的底层容器\n        private final Set<String> exclusions;       // 排除项名单\n    }\n    \n    // 作用: 得到bean名单 全类名 \n    protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n    // 要加载的接口类型  类加载器类型\n        List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); \n        Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\");\n        // 返回bean名单\n        return configurations;\n    }\n}\n    \n    // 作用: 将得到的bean名单进一步啥筛选\n    protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {\n        // 判断自动装配开关是否打开: 默认spring.boot.enableautoconfiguration=true\n        if (!this.isEnabled(annotationMetadata)) {\n            return EMPTY_ENTRY;\n        } else {\n            AnnotationAttributes attributes = this.getAttributes(annotationMetadata);\n            // 返回bean名单\n            List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes); \n            // 去重操作: 一般为0\n            configurations = this.removeDuplicates(configurations);\n            Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);\n            // 检查排除项\n            this.checkExcludedClasses(configurations, exclusions); \n            // 去除排除项\n            configurations.removeAll(exclusions);\n            // 过滤器过滤bean 逐个检查每个配置类的条件（如@ConditionalOnClass, @ConditionalOnMissingClass)\n            configurations = this.getConfigurationClassFilter().filter(configurations);\n            // 监听器用在自动配置类被导入到 ApplicationContext 之前，执行一些自定义的处理逻辑\n            this.fireAutoConfigurationImportEvents(configurations, exclusions);\n            // 返回底层对象\n            return new AutoConfigurationEntry(configurations, exclusions); \n        }\n    }\n\n    // 作用:获取所有符合条件的类[]的全限定类名,判断和准备要导入的自动配置类,交给IOC刷新\n    @Override\n    public String[] selectImports(AnnotationMetadata annotationMetadata) { \n        if (!this.isEnabled(annotationMetadata)) {  \n\t        // 再次判断自动装配开关是否打开 如果关 则返回空数组\n            return NO_IMPORTS;  \n        } else {\n            AutoConfigurationEntry autoConfigurationEntry = \t\t\t\t this.getAutoConfigurationEntry(annotationMetadata);\t\n            return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); \n        }\n    }\n```\n- 注意\n\t- 调用`getCandidateConfigurations()`方法读取外部文件这个操作是**在IOC容器的Refresh()方法中触发的**\n\t- 也就是说，在IOC容器启动的时候通过调用`getCandidateConfigurations()`方法把外部文件中指定的类读取进来，然后再使用反射机制(CGLIB或者JDK代理)将它们实例化成为Bean对象载入到IOC容器中\n![17307293786901730729377814.png|700x440](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307293786901730729377814.png)\n## Bean的生命周期\n### Bean的执行流程\n**核心金句: 在refresh方法内完成 -> *读取加载注入刷新*** \n- 获取bean名单      包括本地bean和第三方依赖bean\n- 加载类                  CGLIB代理或者是反射Instance\n- 注入类                  依赖注入一般在所有bean都加载完成以后\n- 初始化和销毁       调用@PostConstruct、InitializingBean的afterPropertiesSet方法等，以保证Bean的状态正常\n`这四个阶段并非严格独立，但可以理解为顺序执行的一个过程。每个阶段都会依次触发特定的操作，以确保Bean的正确注册、加载和注入，从而构建一个完整的IOC容器\n### BeanFactory\n-  自定义Bean工厂的核心: **继承了一个抽象模板类, 实现了基础性接口**\n- 使用到了**工厂设计模式**\n    ```java\n    public class testBeanFactory extends AbstractApplicationContext implements BeanFactory {\n        private ConfigurableListableBeanFactory beanFactory; \n        @Override\n        protected void refreshBeanFactory() {  // IOC核心核心方法,读取加载注入刷新\n            // 继承自AbstractBeanFactory的实现类\n            beanFactory = new DefaultListableBeanFactory(); \n            // 调用BeanFactory的注册单例bean方法\n            beanFactory.registerSingleton(\"ImBean\", new ImBean());\n            System.out.println(beanFactory.containsBean(\"ImBean\"));\n        }\n    }\n    ```\n  - `ApplicationContext`:是 `BeanFactory` 的一个子接口，扩展了其功能,项目启动就加载bean,是提前加载\n![17307676058781730767605785.png|700x600](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307676058781730767605785.png)\n\n![17307841307381730784130182.png|700x180](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307841307381730784130182.png)\n\n![17321672134681732167213381.png|700x259](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17321672134681732167213381.png)\n### BeanPostProcessor\n- Bean后置处理器, 用来做bean加载完成后的增强操作: 如转换bean\n- 利用后置处理器(实例化, 初始化): 记录日志, 修改bean的属性方法, 返回另一个bean\n```java\n@Component\npublic class beanUtil implements ApplicationContextAware, BeanPostProcessor {\n\n    @Autowired\n    private ApplicationContext applicationContext;\n\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\n        if (bean instanceof interface2Abstract) {\n            ((interface2Abstract) bean).setMessage(\"bean被拦截了\");\n        }\n        return bean;\n    }\n\n    public Object getBean(String beanName) {\n        return applicationContext.getBean(beanName);\n    }\n\n    public boolean ContainsBean(String beanName) {\n        return applicationContext.containsBean(beanName);\n    }\n}\n```\n## Aware接口\n- 例如ApplicationContextAware: 允许通过setter方法注入了ApplicationContext实例\n- Spring 会在容器初始化该 bean 的时候调用 `setApplicationContext(ApplicationContext context)` 方法，并将当前的 `ApplicationContext` 实例传递给该 bean。因此，`ApplicationContext` 会自动注入到实现了 `ApplicationContextAware` 的类中，而无需显式使用 `@Autowired` 注解。\n```java\npublic interface ApplicationContextAware extends Aware {\n    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;\n}\n```\n## SpringMVC执行流程\n![17601617070631760161706121.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17601617070631760161706121.png)\n## 思考\n- 为什么能在主类底下创建Bean:?\n\t- 因为有@SpringBootConfiguration注解 里层又嵌套了一个@Configuration, 表明主类也是一个配置类, 程序会在启动时自动加载配置类的bean\n- 如何保证Bean线程安全\n\t- 不使用无状态的成员变量\n\t- 加锁: 利用 `synchronized` 或 `ReentrantLock`\n\t- 使用`ThreadLocal`替代\n- 为什么一个程序中只需要一个bean工厂?\n\t1. 便于对bean进行统一管理,而且ApplicationContext相比较底层的BeanFactory有更多的拓展功能: 支持事件发布与监听(记录日志), 而且是BeanFactory的子接口,具有BeanFactory的所有功能\n\t2. 保持单例, 避免重复bean的载入\n\t3. 内存占用和性能的角度\n\t4. Spring 的设计理念是通过简化配置来减少开发者的负担。通过一个统一的 `ApplicationContext`，Spring 实现了自动化和集中化管理，使得开发者无需手动管理多个工厂实例\n- @Bean是怎么实现注入且单例的?\n\t- `@Configuration` 注解的类在 Spring 容器启动时会被 CGLIB 代理，目的是确保每个 `@Bean` 方法在被调用时，返回的是同一个 Bean 实例，而不是每次都创建新的实例\n- 如果一个 Bean 被标记为懒加载，那么它不会在 Spring IoC 容器启动时立即实例化?\n\t- 首先 Spring 会去创建 A 的 Bean，创建时需要注入 B 的属性；\n\t- 由于在 A 上的 B 属性标注了 `@Lazy` 注解，因此 Spring 会去创建一个 B 的代理对象，将这个代理对象注入到 A 中的 B 属性；\n\t- 之后开始执行 B 的实例化、初始化，在注入 B 中的 A 属性时，此时 A 已经创建完毕了，就可以将 A 给注入进去。\n\n- `spring.factories`中这么多配置，每次启动都要全部加载么？\n\t- 不会, 有过滤器进行@Condition注解的判断: 只有存在某些特定的类才能实现加载\n  ```java\n    @ConditionalOnClass({ RabbitTemplate.class, Channel.class })\n    @EnableConfigurationProperties(RabbitProperties.class)\n    @Import(RabbitAnnotationDrivenConfiguration.class)\n    public class RabbitAutoConfiguration {\n    }\n    ```\n  - 补充:`SpringCloud`这类注解要常用到条件型注解\n    - `@ConditionalOnBean`：当容器里有指定 Bean 的条件下\n    - `@ConditionalOnMissingBean`：当容器里没有指定 Bean 的情况下\n    - `@ConditionalOnSingleCandidate`：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean\n    - `@ConditionalOnClass`：当类路径下有指定类的条件下\n    - `@ConditionalOnMissingClass`：当类路径下没有指定类的条件下  \n    - `@ConditionalOnProperty`：指定的属性是否有指定的值\n    - `@ConditionalOnResource`：类路径是否有指定的值\n    - `@ConditionalOnExpression`：基于 `SpEL` 表达式作为判断条件\n    - `@ConditionalOnJava`：基于 `Java` 版本作为判断条件\n    - `@ConditionalOnJndi`：在 `JNDI` 存在的条件下差在指定的位置\n    - `@ConditionalOnNotWebApplication`：当前项目不是 `Web` 项目的条件下\n    - `@ConditionalOnWebApplication`：当前项目是 `Web` 项 目的条件下\n## Debug\n`annotationMetaData`存储的是注解的信息\n![注解信息.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307755237431730775521453.png)\nlocation标注的是配置文件所在地  url是对location做了字符处理得来的\n![17307755677371730775567276.png|700x159](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307755677371730775567276.png)\n\n![17307762407371730776239863.png|700x230](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307762407371730776239863.png)\n\n![17307769407391730776940482.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307769407391730776940482.png)\n\n![17307779357381730777935451.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307779357381730777935451.png)\n\n![17307780087391730778008460.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307780087391730778008460.png)\n\n![17307782007431730778199872.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307782007431730778199872.png)\n\n![17307788857381730778885604.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307788857381730778885604.png)\n\n![17307834977441730783497666.png|700x362](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307834977441730783497666.png)\n\n","source":"_posts/Spring.md","raw":"---\ntitle: 深入了解SpringBoot自动装配原理\ndate: 2024-11-04 09:25:48\ntags:\n  - spring\n  - Annotation\n  - springBoot\n  - BeanFactory\ncategories: 编程\n---\n\n# Spring And SpringBoot\n## 序言\n\n> - 本文梳理了 `SpringApplication` 启动流程的原理，并分析了入口类返回的 IOC 容器的作用，特别是自动装配的过程。通过对关键组件如 `@Import` 注解、`BeanFactory` 和调试流程的理解，能够更加深入地了解 Spring Boot 应用的启动过程及其背后的工作机制。\n> - `SpringApplication` 返回容器的过程中，自动装配(读取加载注入刷新)是关键的工作，只有在所有工作都完成后，容器才会最终返回\n## Spring启动预览\n- 模拟SpringApplication主类: 通过下面的例子让你快速理解Spring启动加载原理\n```java\n@SpringBootApplication\n@EnableConfigurationProperties\npublic class testSpringApplicant {\n    public static void main(String[] args) {\n        // 1.启动Spring应用\n        SpringApplication app = new SpringApplication(bootClass.class);\n        app.run(args);  // 启动 Spring Boot 应用并初始化容器\n\n        // 2.使用 AnnotationConfigApplicationContext 初始化 IOC 容器\n        ApplicationContext context = new AnnotationConfigApplicationContext();\n\n        // 3.手动注册一个 Bean 示例\n        ConfigurableListableBeanFactory beanFactory = new DefaultListableBeanFactory();         // 工作bean工厂: 不需要IOC容器来做事  注册单例 \n        beanFactory.registerSingleton(\"bean\", new Bean()); \n\n        // 4.刷新容器\n        ((AnnotationConfigApplicationContext) context).refresh(); \n        \n        // 5.等所有准备工作都做完了,可以拿到run方法返回的一个IOC容器\n        ConfigurableApplicationContext returnValue = app.run(args);\n//returnValue应该是ConfigurableApplicationContext的实现AnnotationConfigApplicationContext\n    }\n}\n```\n### SpringApplication类解析\n- 把所有的组件、环境配置、初始化逻辑整合起来，确保应用程序顺利启动。\n- 这个类既是入口类,又是结束类,关系到IOC容器的生命周期,也关系到整个程序的启动与停止\n```java\n// 最外层\npublic static void main(String[] args) {\n        SpringApplication.run(ProjectTestApplication.class, args);\n    } \n```\n\n```java\n// 第二层\npublic static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {\n        return run(new Class[]{primarySource}, args);\n    }\n```\n\n```java\n// 第三层: 实例化一个SpringApplication实例,执行run方法(不是静态的run方法)\npublic static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {\n        return (new SpringApplication(primarySources)).run(args);\n    }\n```\n\n```java\n// 最里层: 逻辑层->程序的启动流程\npublic ConfigurableApplicationContext run(String... args) {\n\t\t//创建 DefaultBootstrapContext 对象，它代表了应用程序的引导上下文。引导上下文通常是 Spring Boot 启动时的早期阶段，用于初始化一些关键组件。\n        DefaultBootstrapContext bootstrapContext = this.createBootstrapContext();\n    \t// 初始化容器对象\n        ConfigurableApplicationContext context = null;\n        this.configureHeadlessProperty();\n    \t// 监听 Spring Boot 应用程序启动生命周期的监听器。\n        SpringApplicationRunListeners listeners = this.getRunListeners(args);\n    \t// 开启监听器\n        listeners.starting(bootstrapContext, this.mainApplicationClass);\n        try {\n            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n            // 准备应用程序的环境配置\n            ConfigurableEnvironment environment = this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);\n            // 打印横幅\n            Banner printedBanner = this.printBanner(environment);\n            // AnnotationConfigApplicationContext IOC容器\n            context = this.createApplicationContext();\n            // 开启监听器\n            context.setApplicationStartup(this.applicationStartup);\n            // 准备应用程序的上下文（context),并执行一些初始化任务\n            this.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);\n            // 刷新 Spring 上下文  触发 BeanFactory 的加载和初始化，容器会开始准备好为应用程序提供服务。\n            this.refreshContext(context);\n            // 刷新后的一些后处理逻辑，通常用于执行一些应用程序启动后的任务。\n            this.afterRefresh(context, applicationArguments);\n            // 标记应用程序的启动过程已经完成。\n            startup.started();\n            // 返回配置好的 ConfigurableApplicationContext 实例。该上下文是整个应用程序的核心容器，所有的 Spring Beans 都会在其中管理。\n            return context;\n        }\n```\n## IOC容器\n- IOC容器的实现类`AnnotationConfigApplicationContext` 实现了`AnnotationConfigRegistry` 继承了`GenericApplicationContext`\n```java\n  public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry\n\n  // 获取Bean名单的方式: 通过register和scan\n  void scan(String… basePackages); // 加载需要扫描的包路径@Compoent\n  void register(Class<?>… componentClasses); // 加载手动注册的注解配置类@Configuration\n```\n### IOC容器实现类有两个方法专门用来扫描Bean\n- **void scan  -> 扫描组件**\n\t- 所有方法自动添加@bean\n\t- 通过@ComponentScan扫描带有注解@Component @Controller @Service @Repository(dao层专用,spring框架下) @Mapper(Mybatis专用)  的类\n- **void register -> 扫描配置类**\n\t- 需手动添加@bean\n\t- @Configuration 下带有@Bean注解的方法\n### IOC容器执行Refresh方法加载注册Bean流程\n  - 加载bean到上下文中(包括解析Bean定义、创建Bean实例、解决依赖关系、初始化Bean以及销毁Bean)\n  - 执行依赖注入\n  - 标注已刷新,完成工作\n### 了解@Import注解: 加载Bean名单(自动装配)\n- @Import注解是spring第三种定义bean的方法, **支持对第三方包的导入**\n- 共有三种实现方法:\n  1. 基础数组: 注解形式通过反射`Class.forName()`把bean交给IOC容器\n    ```java\n    // 这些在容器中bean名称是该类的全类名 ，比如com.spring.ImBean\n    @Import({ 类名.class , 类名.class... })\n    public class TestDemo {\n    }\n    ```\n  2. 实现`ImportSelect`接口:这种方式也是Spring的用法, 返回值就是我们实际上要导入到容器中的组件全限定类名(Bean名单)【**重点** 】\n    ```java\n    public class Myclass implements ImportSelector {\n    // 重写导入Bean名单方法\n        @Override\n        public String[] selectImports(AnnotationMetadata annotationMetadata) {\n            return new String[]{\"com.spring.ImBean\", \"com.spring.ImBean2\"};\n        }\n    }\n    ```\n  3. 实现`ImportBeanDefinitionRegister`接口: 跟上面的实现方法接近, 区别在于能修改bean名\n    ```java\n    public class Myclass2 implements ImportBeanDefinitionRegistrar {\n        @Override\n        public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) {\n            //指定bean定义信息（包括bean的类型、作用域...）\n            RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(ImBean.class);\n            //注册一个bean指定bean名字（id）\n        beanDefinitionRegistry.registerBeanDefinition(\"reNameBean\",rootBeanDefinition);\n        }\n    }\n    ```\n## 自动装配分析(重点)\n- 首先`@SpringBootApplication`启动类注解带有3个关键注解\n\t- 一个就是下文提到的`@EnableAutoConfiguration`, 用于自动装配第三方Bean依赖\n\t- `@ComponentScan`用于扫描`ClassPath`下的本地Bean\n\t- `@SpringBootConfiguration`注解嵌套了一个`@Configuration`, 实际上它也是一个配置类\n- **@EnableAutoConfiguration**启用Spring Boot的自动配置机制，将第三方依赖bean注入IOC容器\n- 通过`SpringFactoriesLoader`从类路径下去读取`META-INF/spring.factories`文件信息，此文件中有一个key为`org.springframework.boot.autoconfigure.EnableAutoConfiguration`，定义了一组需要自动配置的bean名单 如下:\n- [x] ConfigurationPropertiesAutoConfiguration \n- [x] AOPAutoConfiguration\n- [x] DataSourceAutoConfiguration\n- [x] ElasticsearchAutoConfiguration\n- [x] RedisAutoConfiguration\n- [x] GsonAutoConfiguration\n- [x] HttpMessageConvertersAutoConfiguration\n- [x] JacksonAutoConfiguration\n- [x] DispathcherAutoConfiguration\n- [x] WebMvcAutoConfiguration\n### 具体的实现流程\n- `@EnableAutoConfiguration`只是一个引导注解, 真正实现加载bena名单功能的是实现类**AutoConfigurationImportSelector**\n- import注解将`AutoConfigurationImportSelector`这个伪配置类交给IOC\n```java\n@AutoConfigurationPackage\n@Import({AutoConfigurationImportSelector.class})  // 先是通过import第一种用法:基础数组\npublic @interface EnableAutoConfiguration {\n    String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n\n    Class<?>[] exclude() default {};\n\n    String[] excludeName() default {};\n}\n```\n1. 通过`getCandidateConfigurations`去加载配置文件的bean全类名名单, \n2. 由`getAutoConfigurationEntry`做名单过滤, 比如像判断自动转配开关是否打开, 是否设置了排除项, 然后把名单设置到类的成员变量中, \n3. 由`selectImports`方法去拿到成员变量名单去执行加载Bean的操作, 加载Bean是通过实现import接口重写`selectImports`方法实现的\n- 其中加载的配置文件地址  采取逐行读取的方式`readline()`\n\t- 旧地址: META-INF/spring.factories(兼容旧版本) \n\t- 新地址: META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. \n```java\n// DeferredImportSelector实现了了ImportSelect, AutoConfigurationImportSelector实现了DeferredImportSelector\npublic class AutoConfigurationImportSelector implements DeferredImportSelector{\n\n    // 用于返回空bean名单的空数组\n    private static final String[] NO_IMPORTS = new String[0]; \n\n    // 这个才是存储Bean数组和排除的Bean数组的底层对象,里面是List和Set\n    private static final AutoConfigurationEntry EMPTY_ENTRY = new AutoConfigurationEntry();\n\n    // 关于底层对象的定义\n    protected static class AutoConfigurationEntry {\n        private final List<String> configurations;  // 存储bean名单的底层容器\n        private final Set<String> exclusions;       // 排除项名单\n    }\n    \n    // 作用: 得到bean名单 全类名 \n    protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n    // 要加载的接口类型  类加载器类型\n        List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); \n        Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\");\n        // 返回bean名单\n        return configurations;\n    }\n}\n    \n    // 作用: 将得到的bean名单进一步啥筛选\n    protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {\n        // 判断自动装配开关是否打开: 默认spring.boot.enableautoconfiguration=true\n        if (!this.isEnabled(annotationMetadata)) {\n            return EMPTY_ENTRY;\n        } else {\n            AnnotationAttributes attributes = this.getAttributes(annotationMetadata);\n            // 返回bean名单\n            List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes); \n            // 去重操作: 一般为0\n            configurations = this.removeDuplicates(configurations);\n            Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);\n            // 检查排除项\n            this.checkExcludedClasses(configurations, exclusions); \n            // 去除排除项\n            configurations.removeAll(exclusions);\n            // 过滤器过滤bean 逐个检查每个配置类的条件（如@ConditionalOnClass, @ConditionalOnMissingClass)\n            configurations = this.getConfigurationClassFilter().filter(configurations);\n            // 监听器用在自动配置类被导入到 ApplicationContext 之前，执行一些自定义的处理逻辑\n            this.fireAutoConfigurationImportEvents(configurations, exclusions);\n            // 返回底层对象\n            return new AutoConfigurationEntry(configurations, exclusions); \n        }\n    }\n\n    // 作用:获取所有符合条件的类[]的全限定类名,判断和准备要导入的自动配置类,交给IOC刷新\n    @Override\n    public String[] selectImports(AnnotationMetadata annotationMetadata) { \n        if (!this.isEnabled(annotationMetadata)) {  \n\t        // 再次判断自动装配开关是否打开 如果关 则返回空数组\n            return NO_IMPORTS;  \n        } else {\n            AutoConfigurationEntry autoConfigurationEntry = \t\t\t\t this.getAutoConfigurationEntry(annotationMetadata);\t\n            return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); \n        }\n    }\n```\n- 注意\n\t- 调用`getCandidateConfigurations()`方法读取外部文件这个操作是**在IOC容器的Refresh()方法中触发的**\n\t- 也就是说，在IOC容器启动的时候通过调用`getCandidateConfigurations()`方法把外部文件中指定的类读取进来，然后再使用反射机制(CGLIB或者JDK代理)将它们实例化成为Bean对象载入到IOC容器中\n![17307293786901730729377814.png|700x440](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307293786901730729377814.png)\n## Bean的生命周期\n### Bean的执行流程\n**核心金句: 在refresh方法内完成 -> *读取加载注入刷新*** \n- 获取bean名单      包括本地bean和第三方依赖bean\n- 加载类                  CGLIB代理或者是反射Instance\n- 注入类                  依赖注入一般在所有bean都加载完成以后\n- 初始化和销毁       调用@PostConstruct、InitializingBean的afterPropertiesSet方法等，以保证Bean的状态正常\n`这四个阶段并非严格独立，但可以理解为顺序执行的一个过程。每个阶段都会依次触发特定的操作，以确保Bean的正确注册、加载和注入，从而构建一个完整的IOC容器\n### BeanFactory\n-  自定义Bean工厂的核心: **继承了一个抽象模板类, 实现了基础性接口**\n- 使用到了**工厂设计模式**\n    ```java\n    public class testBeanFactory extends AbstractApplicationContext implements BeanFactory {\n        private ConfigurableListableBeanFactory beanFactory; \n        @Override\n        protected void refreshBeanFactory() {  // IOC核心核心方法,读取加载注入刷新\n            // 继承自AbstractBeanFactory的实现类\n            beanFactory = new DefaultListableBeanFactory(); \n            // 调用BeanFactory的注册单例bean方法\n            beanFactory.registerSingleton(\"ImBean\", new ImBean());\n            System.out.println(beanFactory.containsBean(\"ImBean\"));\n        }\n    }\n    ```\n  - `ApplicationContext`:是 `BeanFactory` 的一个子接口，扩展了其功能,项目启动就加载bean,是提前加载\n![17307676058781730767605785.png|700x600](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307676058781730767605785.png)\n\n![17307841307381730784130182.png|700x180](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307841307381730784130182.png)\n\n![17321672134681732167213381.png|700x259](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17321672134681732167213381.png)\n### BeanPostProcessor\n- Bean后置处理器, 用来做bean加载完成后的增强操作: 如转换bean\n- 利用后置处理器(实例化, 初始化): 记录日志, 修改bean的属性方法, 返回另一个bean\n```java\n@Component\npublic class beanUtil implements ApplicationContextAware, BeanPostProcessor {\n\n    @Autowired\n    private ApplicationContext applicationContext;\n\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n\n        if (bean instanceof interface2Abstract) {\n            ((interface2Abstract) bean).setMessage(\"bean被拦截了\");\n        }\n        return bean;\n    }\n\n    public Object getBean(String beanName) {\n        return applicationContext.getBean(beanName);\n    }\n\n    public boolean ContainsBean(String beanName) {\n        return applicationContext.containsBean(beanName);\n    }\n}\n```\n## Aware接口\n- 例如ApplicationContextAware: 允许通过setter方法注入了ApplicationContext实例\n- Spring 会在容器初始化该 bean 的时候调用 `setApplicationContext(ApplicationContext context)` 方法，并将当前的 `ApplicationContext` 实例传递给该 bean。因此，`ApplicationContext` 会自动注入到实现了 `ApplicationContextAware` 的类中，而无需显式使用 `@Autowired` 注解。\n```java\npublic interface ApplicationContextAware extends Aware {\n    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;\n}\n```\n## SpringMVC执行流程\n![17601617070631760161706121.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17601617070631760161706121.png)\n## 思考\n- 为什么能在主类底下创建Bean:?\n\t- 因为有@SpringBootConfiguration注解 里层又嵌套了一个@Configuration, 表明主类也是一个配置类, 程序会在启动时自动加载配置类的bean\n- 如何保证Bean线程安全\n\t- 不使用无状态的成员变量\n\t- 加锁: 利用 `synchronized` 或 `ReentrantLock`\n\t- 使用`ThreadLocal`替代\n- 为什么一个程序中只需要一个bean工厂?\n\t1. 便于对bean进行统一管理,而且ApplicationContext相比较底层的BeanFactory有更多的拓展功能: 支持事件发布与监听(记录日志), 而且是BeanFactory的子接口,具有BeanFactory的所有功能\n\t2. 保持单例, 避免重复bean的载入\n\t3. 内存占用和性能的角度\n\t4. Spring 的设计理念是通过简化配置来减少开发者的负担。通过一个统一的 `ApplicationContext`，Spring 实现了自动化和集中化管理，使得开发者无需手动管理多个工厂实例\n- @Bean是怎么实现注入且单例的?\n\t- `@Configuration` 注解的类在 Spring 容器启动时会被 CGLIB 代理，目的是确保每个 `@Bean` 方法在被调用时，返回的是同一个 Bean 实例，而不是每次都创建新的实例\n- 如果一个 Bean 被标记为懒加载，那么它不会在 Spring IoC 容器启动时立即实例化?\n\t- 首先 Spring 会去创建 A 的 Bean，创建时需要注入 B 的属性；\n\t- 由于在 A 上的 B 属性标注了 `@Lazy` 注解，因此 Spring 会去创建一个 B 的代理对象，将这个代理对象注入到 A 中的 B 属性；\n\t- 之后开始执行 B 的实例化、初始化，在注入 B 中的 A 属性时，此时 A 已经创建完毕了，就可以将 A 给注入进去。\n\n- `spring.factories`中这么多配置，每次启动都要全部加载么？\n\t- 不会, 有过滤器进行@Condition注解的判断: 只有存在某些特定的类才能实现加载\n  ```java\n    @ConditionalOnClass({ RabbitTemplate.class, Channel.class })\n    @EnableConfigurationProperties(RabbitProperties.class)\n    @Import(RabbitAnnotationDrivenConfiguration.class)\n    public class RabbitAutoConfiguration {\n    }\n    ```\n  - 补充:`SpringCloud`这类注解要常用到条件型注解\n    - `@ConditionalOnBean`：当容器里有指定 Bean 的条件下\n    - `@ConditionalOnMissingBean`：当容器里没有指定 Bean 的情况下\n    - `@ConditionalOnSingleCandidate`：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean\n    - `@ConditionalOnClass`：当类路径下有指定类的条件下\n    - `@ConditionalOnMissingClass`：当类路径下没有指定类的条件下  \n    - `@ConditionalOnProperty`：指定的属性是否有指定的值\n    - `@ConditionalOnResource`：类路径是否有指定的值\n    - `@ConditionalOnExpression`：基于 `SpEL` 表达式作为判断条件\n    - `@ConditionalOnJava`：基于 `Java` 版本作为判断条件\n    - `@ConditionalOnJndi`：在 `JNDI` 存在的条件下差在指定的位置\n    - `@ConditionalOnNotWebApplication`：当前项目不是 `Web` 项目的条件下\n    - `@ConditionalOnWebApplication`：当前项目是 `Web` 项 目的条件下\n## Debug\n`annotationMetaData`存储的是注解的信息\n![注解信息.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307755237431730775521453.png)\nlocation标注的是配置文件所在地  url是对location做了字符处理得来的\n![17307755677371730775567276.png|700x159](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307755677371730775567276.png)\n\n![17307762407371730776239863.png|700x230](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307762407371730776239863.png)\n\n![17307769407391730776940482.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307769407391730776940482.png)\n\n![17307779357381730777935451.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307779357381730777935451.png)\n\n![17307780087391730778008460.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307780087391730778008460.png)\n\n![17307782007431730778199872.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307782007431730778199872.png)\n\n![17307788857381730778885604.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307788857381730778885604.png)\n\n![17307834977441730783497666.png|700x362](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307834977441730783497666.png)\n\n","slug":"Spring","published":1,"updated":"2025-10-13T03:57:12.023Z","comments":1,"layout":"post","photos":[],"_id":"cmik3ww9u0006homwew6jemkn","content":"<h1 id=\"Spring-And-SpringBoot\"><a href=\"#Spring-And-SpringBoot\" class=\"headerlink\" title=\"Spring And SpringBoot\"></a>Spring And SpringBoot</h1><h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><blockquote>\n<ul>\n<li>本文梳理了 <code>SpringApplication</code> 启动流程的原理，并分析了入口类返回的 IOC 容器的作用，特别是自动装配的过程。通过对关键组件如 <code>@Import</code> 注解、<code>BeanFactory</code> 和调试流程的理解，能够更加深入地了解 Spring Boot 应用的启动过程及其背后的工作机制。</li>\n<li><code>SpringApplication</code> 返回容器的过程中，自动装配(读取加载注入刷新)是关键的工作，只有在所有工作都完成后，容器才会最终返回<h2 id=\"Spring启动预览\"><a href=\"#Spring启动预览\" class=\"headerlink\" title=\"Spring启动预览\"></a>Spring启动预览</h2></li>\n<li>模拟SpringApplication主类: 通过下面的例子让你快速理解Spring启动加载原理<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testSpringApplicant</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.启动Spring应用</span></span><br><span class=\"line\">        <span class=\"type\">SpringApplication</span> <span class=\"variable\">app</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SpringApplication</span>(bootClass.class);</span><br><span class=\"line\">        app.run(args);  <span class=\"comment\">// 启动 Spring Boot 应用并初始化容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2.使用 AnnotationConfigApplicationContext 初始化 IOC 容器</span></span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3.手动注册一个 Bean 示例</span></span><br><span class=\"line\">        <span class=\"type\">ConfigurableListableBeanFactory</span> <span class=\"variable\">beanFactory</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultListableBeanFactory</span>();         <span class=\"comment\">// 工作bean工厂: 不需要IOC容器来做事  注册单例 </span></span><br><span class=\"line\">        beanFactory.registerSingleton(<span class=\"string\">&quot;bean&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Bean</span>()); </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4.刷新容器</span></span><br><span class=\"line\">        ((AnnotationConfigApplicationContext) context).refresh(); </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 5.等所有准备工作都做完了,可以拿到run方法返回的一个IOC容器</span></span><br><span class=\"line\">        <span class=\"type\">ConfigurableApplicationContext</span> <span class=\"variable\">returnValue</span> <span class=\"operator\">=</span> app.run(args);</span><br><span class=\"line\"><span class=\"comment\">//returnValue应该是ConfigurableApplicationContext的实现AnnotationConfigApplicationContext</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"SpringApplication类解析\"><a href=\"#SpringApplication类解析\" class=\"headerlink\" title=\"SpringApplication类解析\"></a>SpringApplication类解析</h3></li>\n<li>把所有的组件、环境配置、初始化逻辑整合起来，确保应用程序顺利启动。</li>\n<li>这个类既是入口类,又是结束类,关系到IOC容器的生命周期,也关系到整个程序的启动与停止<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最外层</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ProjectTestApplication.class, args);</span><br><span class=\"line\">    &#125; </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第二层</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> run(<span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;primarySource&#125;, args);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第三层: 实例化一个SpringApplication实例,执行run方法(不是静态的run方法)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> <span class=\"title class_\">SpringApplication</span>(primarySources)).run(args);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最里层: 逻辑层-&gt;程序的启动流程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//创建 DefaultBootstrapContext 对象，它代表了应用程序的引导上下文。引导上下文通常是 Spring Boot 启动时的早期阶段，用于初始化一些关键组件。</span></span><br><span class=\"line\">        <span class=\"type\">DefaultBootstrapContext</span> <span class=\"variable\">bootstrapContext</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.createBootstrapContext();</span><br><span class=\"line\">    \t<span class=\"comment\">// 初始化容器对象</span></span><br><span class=\"line\">        <span class=\"type\">ConfigurableApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.configureHeadlessProperty();</span><br><span class=\"line\">    \t<span class=\"comment\">// 监听 Spring Boot 应用程序启动生命周期的监听器。</span></span><br><span class=\"line\">        <span class=\"type\">SpringApplicationRunListeners</span> <span class=\"variable\">listeners</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.getRunListeners(args);</span><br><span class=\"line\">    \t<span class=\"comment\">// 开启监听器</span></span><br><span class=\"line\">        listeners.starting(bootstrapContext, <span class=\"built_in\">this</span>.mainApplicationClass);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ApplicationArguments</span> <span class=\"variable\">applicationArguments</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultApplicationArguments</span>(args);</span><br><span class=\"line\">            <span class=\"comment\">// 准备应用程序的环境配置</span></span><br><span class=\"line\">            <span class=\"type\">ConfigurableEnvironment</span> <span class=\"variable\">environment</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class=\"line\">            <span class=\"comment\">// 打印横幅</span></span><br><span class=\"line\">            <span class=\"type\">Banner</span> <span class=\"variable\">printedBanner</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.printBanner(environment);</span><br><span class=\"line\">            <span class=\"comment\">// AnnotationConfigApplicationContext IOC容器</span></span><br><span class=\"line\">            context = <span class=\"built_in\">this</span>.createApplicationContext();</span><br><span class=\"line\">            <span class=\"comment\">// 开启监听器</span></span><br><span class=\"line\">            context.setApplicationStartup(<span class=\"built_in\">this</span>.applicationStartup);</span><br><span class=\"line\">            <span class=\"comment\">// 准备应用程序的上下文（context),并执行一些初始化任务</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class=\"line\">            <span class=\"comment\">// 刷新 Spring 上下文  触发 BeanFactory 的加载和初始化，容器会开始准备好为应用程序提供服务。</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.refreshContext(context);</span><br><span class=\"line\">            <span class=\"comment\">// 刷新后的一些后处理逻辑，通常用于执行一些应用程序启动后的任务。</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.afterRefresh(context, applicationArguments);</span><br><span class=\"line\">            <span class=\"comment\">// 标记应用程序的启动过程已经完成。</span></span><br><span class=\"line\">            startup.started();</span><br><span class=\"line\">            <span class=\"comment\">// 返回配置好的 ConfigurableApplicationContext 实例。该上下文是整个应用程序的核心容器，所有的 Spring Beans 都会在其中管理。</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"IOC容器\"><a href=\"#IOC容器\" class=\"headerlink\" title=\"IOC容器\"></a>IOC容器</h2><ul>\n<li>IOC容器的实现类<code>AnnotationConfigApplicationContext</code> 实现了<code>AnnotationConfigRegistry</code> 继承了<code>GenericApplicationContext</code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">GenericApplicationContext</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AnnotationConfigRegistry</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取Bean名单的方式: 通过register和scan</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">scan</span><span class=\"params\">(String… basePackages)</span>; <span class=\"comment\">// 加载需要扫描的包路径@Compoent</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(Class&lt;?&gt;… componentClasses)</span>; <span class=\"comment\">// 加载手动注册的注解配置类@Configuration</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"IOC容器实现类有两个方法专门用来扫描Bean\"><a href=\"#IOC容器实现类有两个方法专门用来扫描Bean\" class=\"headerlink\" title=\"IOC容器实现类有两个方法专门用来扫描Bean\"></a>IOC容器实现类有两个方法专门用来扫描Bean</h3></li>\n<li><strong>void scan  -&gt; 扫描组件</strong><ul>\n<li>所有方法自动添加@bean</li>\n<li>通过@ComponentScan扫描带有注解@Component @Controller @Service @Repository(dao层专用,spring框架下) @Mapper(Mybatis专用)  的类</li>\n</ul>\n</li>\n<li><strong>void register -&gt; 扫描配置类</strong><ul>\n<li>需手动添加@bean</li>\n<li>@Configuration 下带有@Bean注解的方法<h3 id=\"IOC容器执行Refresh方法加载注册Bean流程\"><a href=\"#IOC容器执行Refresh方法加载注册Bean流程\" class=\"headerlink\" title=\"IOC容器执行Refresh方法加载注册Bean流程\"></a>IOC容器执行Refresh方法加载注册Bean流程</h3><ul>\n<li>加载bean到上下文中(包括解析Bean定义、创建Bean实例、解决依赖关系、初始化Bean以及销毁Bean)</li>\n<li>执行依赖注入</li>\n<li>标注已刷新,完成工作<h3 id=\"了解-Import注解-加载Bean名单-自动装配\"><a href=\"#了解-Import注解-加载Bean名单-自动装配\" class=\"headerlink\" title=\"了解@Import注解: 加载Bean名单(自动装配)\"></a>了解@Import注解: 加载Bean名单(自动装配)</h3></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>@Import注解是spring第三种定义bean的方法, <strong>支持对第三方包的导入</strong></li>\n<li>共有三种实现方法:<ol>\n<li>基础数组: 注解形式通过反射<code>Class.forName()</code>把bean交给IOC容器<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这些在容器中bean名称是该类的全类名 ，比如com.spring.ImBean</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123; 类名.class , 类名.class... &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestDemo</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>实现<code>ImportSelect</code>接口:这种方式也是Spring的用法, 返回值就是我们实际上要导入到容器中的组件全限定类名(Bean名单)【<strong>重点</strong> 】<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Myclass</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImportSelector</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 重写导入Bean名单方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;com.spring.ImBean&quot;</span>, <span class=\"string\">&quot;com.spring.ImBean2&quot;</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>实现<code>ImportBeanDefinitionRegister</code>接口: 跟上面的实现方法接近, 区别在于能修改bean名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Myclass2</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//指定bean定义信息（包括bean的类型、作用域...）</span></span><br><span class=\"line\">        <span class=\"type\">RootBeanDefinition</span> <span class=\"variable\">rootBeanDefinition</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RootBeanDefinition</span>(ImBean.class);</span><br><span class=\"line\">        <span class=\"comment\">//注册一个bean指定bean名字（id）</span></span><br><span class=\"line\">    beanDefinitionRegistry.registerBeanDefinition(<span class=\"string\">&quot;reNameBean&quot;</span>,rootBeanDefinition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"自动装配分析-重点\"><a href=\"#自动装配分析-重点\" class=\"headerlink\" title=\"自动装配分析(重点)\"></a>自动装配分析(重点)</h2></li>\n</ol>\n</li>\n<li>首先<code>@SpringBootApplication</code>启动类注解带有3个关键注解<ul>\n<li>一个就是下文提到的<code>@EnableAutoConfiguration</code>, 用于自动装配第三方Bean依赖</li>\n<li><code>@ComponentScan</code>用于扫描<code>ClassPath</code>下的本地Bean</li>\n<li><code>@SpringBootConfiguration</code>注解嵌套了一个<code>@Configuration</code>, 实际上它也是一个配置类</li>\n</ul>\n</li>\n<li><strong>@EnableAutoConfiguration</strong>启用Spring Boot的自动配置机制，将第三方依赖bean注入IOC容器</li>\n<li>通过<code>SpringFactoriesLoader</code>从类路径下去读取<code>META-INF/spring.factories</code>文件信息，此文件中有一个key为<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>，定义了一组需要自动配置的bean名单 如下:</li>\n<li>[x] ConfigurationPropertiesAutoConfiguration </li>\n<li>[x] AOPAutoConfiguration</li>\n<li>[x] DataSourceAutoConfiguration</li>\n<li>[x] ElasticsearchAutoConfiguration</li>\n<li>[x] RedisAutoConfiguration</li>\n<li>[x] GsonAutoConfiguration</li>\n<li>[x] HttpMessageConvertersAutoConfiguration</li>\n<li>[x] JacksonAutoConfiguration</li>\n<li>[x] DispathcherAutoConfiguration</li>\n<li>[x] WebMvcAutoConfiguration<h3 id=\"具体的实现流程\"><a href=\"#具体的实现流程\" class=\"headerlink\" title=\"具体的实现流程\"></a>具体的实现流程</h3></li>\n<li><code>@EnableAutoConfiguration</code>只是一个引导注解, 真正实现加载bena名单功能的是实现类<strong>AutoConfigurationImportSelector</strong></li>\n<li>import注解将<code>AutoConfigurationImportSelector</code>这个伪配置类交给IOC<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span>  <span class=\"comment\">// 先是通过import第一种用法:基础数组</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ENABLED_OVERRIDE_PROPERTY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol>\n<li>通过<code>getCandidateConfigurations</code>去加载配置文件的bean全类名名单, </li>\n<li>由<code>getAutoConfigurationEntry</code>做名单过滤, 比如像判断自动转配开关是否打开, 是否设置了排除项, 然后把名单设置到类的成员变量中, </li>\n<li>由<code>selectImports</code>方法去拿到成员变量名单去执行加载Bean的操作, 加载Bean是通过实现import接口重写<code>selectImports</code>方法实现的</li>\n</ol>\n<ul>\n<li>其中加载的配置文件地址  采取逐行读取的方式<code>readline()</code><ul>\n<li>旧地址: META-INF/spring.factories(兼容旧版本) </li>\n<li>新地址: META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DeferredImportSelector实现了了ImportSelect, AutoConfigurationImportSelector实现了DeferredImportSelector</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AutoConfigurationImportSelector</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DeferredImportSelector</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 用于返回空bean名单的空数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] NO_IMPORTS = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">0</span>]; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这个才是存储Bean数组和排除的Bean数组的底层对象,里面是List和Set</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">AutoConfigurationEntry</span> <span class=\"variable\">EMPTY_ENTRY</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AutoConfigurationEntry</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关于底层对象的定义</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AutoConfigurationEntry</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; configurations;  <span class=\"comment\">// 存储bean名单的底层容器</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;String&gt; exclusions;       <span class=\"comment\">// 排除项名单</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 作用: 得到bean名单 全类名 </span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> List&lt;String&gt; <span class=\"title function_\">getCandidateConfigurations</span><span class=\"params\">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 要加载的接口类型  类加载器类型</span></span><br><span class=\"line\">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class=\"built_in\">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class=\"built_in\">this</span>.getBeanClassLoader()); </span><br><span class=\"line\">        Assert.notEmpty(configurations, <span class=\"string\">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 返回bean名单</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> configurations;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 作用: 将得到的bean名单进一步啥筛选</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AutoConfigurationEntry <span class=\"title function_\">getAutoConfigurationEntry</span><span class=\"params\">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断自动装配开关是否打开: 默认spring.boot.enableautoconfiguration=true</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> EMPTY_ENTRY;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">AnnotationAttributes</span> <span class=\"variable\">attributes</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.getAttributes(annotationMetadata);</span><br><span class=\"line\">            <span class=\"comment\">// 返回bean名单</span></span><br><span class=\"line\">            List&lt;String&gt; configurations = <span class=\"built_in\">this</span>.getCandidateConfigurations(annotationMetadata, attributes); </span><br><span class=\"line\">            <span class=\"comment\">// 去重操作: 一般为0</span></span><br><span class=\"line\">            configurations = <span class=\"built_in\">this</span>.removeDuplicates(configurations);</span><br><span class=\"line\">            Set&lt;String&gt; exclusions = <span class=\"built_in\">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class=\"line\">            <span class=\"comment\">// 检查排除项</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.checkExcludedClasses(configurations, exclusions); </span><br><span class=\"line\">            <span class=\"comment\">// 去除排除项</span></span><br><span class=\"line\">            configurations.removeAll(exclusions);</span><br><span class=\"line\">            <span class=\"comment\">// 过滤器过滤bean 逐个检查每个配置类的条件（如@ConditionalOnClass, @ConditionalOnMissingClass)</span></span><br><span class=\"line\">            configurations = <span class=\"built_in\">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class=\"line\">            <span class=\"comment\">// 监听器用在自动配置类被导入到 ApplicationContext 之前，执行一些自定义的处理逻辑</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class=\"line\">            <span class=\"comment\">// 返回底层对象</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AutoConfigurationEntry</span>(configurations, exclusions); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 作用:获取所有符合条件的类[]的全限定类名,判断和准备要导入的自动配置类,交给IOC刷新</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.isEnabled(annotationMetadata)) &#123;  </span><br><span class=\"line\">\t        <span class=\"comment\">// 再次判断自动装配开关是否打开 如果关 则返回空数组</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> NO_IMPORTS;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">AutoConfigurationEntry</span> <span class=\"variable\">autoConfigurationEntry</span> <span class=\"operator\">=</span> \t\t\t\t <span class=\"built_in\">this</span>.getAutoConfigurationEntry(annotationMetadata);\t</span><br><span class=\"line\">            <span class=\"keyword\">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>注意<ul>\n<li>调用<code>getCandidateConfigurations()</code>方法读取外部文件这个操作是<strong>在IOC容器的Refresh()方法中触发的</strong></li>\n<li>也就是说，在IOC容器启动的时候通过调用<code>getCandidateConfigurations()</code>方法把外部文件中指定的类读取进来，然后再使用反射机制(CGLIB或者JDK代理)将它们实例化成为Bean对象载入到IOC容器中<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307293786901730729377814.png\" alt=\"17307293786901730729377814.png|700x440\"><h2 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h2><h3 id=\"Bean的执行流程\"><a href=\"#Bean的执行流程\" class=\"headerlink\" title=\"Bean的执行流程\"></a>Bean的执行流程</h3><strong>核心金句: 在refresh方法内完成 -&gt; <em>读取加载注入刷新</em></strong> </li>\n</ul>\n</li>\n<li>获取bean名单      包括本地bean和第三方依赖bean</li>\n<li>加载类                  CGLIB代理或者是反射Instance</li>\n<li>注入类                  依赖注入一般在所有bean都加载完成以后</li>\n<li>初始化和销毁       调用@PostConstruct、InitializingBean的afterPropertiesSet方法等，以保证Bean的状态正常<br>`这四个阶段并非严格独立，但可以理解为顺序执行的一个过程。每个阶段都会依次触发特定的操作，以确保Bean的正确注册、加载和注入，从而构建一个完整的IOC容器<h3 id=\"BeanFactory\"><a href=\"#BeanFactory\" class=\"headerlink\" title=\"BeanFactory\"></a>BeanFactory</h3></li>\n<li>自定义Bean工厂的核心: <strong>继承了一个抽象模板类, 实现了基础性接口</strong></li>\n<li>使用到了<strong>工厂设计模式</strong>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testBeanFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractApplicationContext</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BeanFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ConfigurableListableBeanFactory beanFactory; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refreshBeanFactory</span><span class=\"params\">()</span> &#123;  <span class=\"comment\">// IOC核心核心方法,读取加载注入刷新</span></span><br><span class=\"line\">        <span class=\"comment\">// 继承自AbstractBeanFactory的实现类</span></span><br><span class=\"line\">        beanFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultListableBeanFactory</span>(); </span><br><span class=\"line\">        <span class=\"comment\">// 调用BeanFactory的注册单例bean方法</span></span><br><span class=\"line\">        beanFactory.registerSingleton(<span class=\"string\">&quot;ImBean&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ImBean</span>());</span><br><span class=\"line\">        System.out.println(beanFactory.containsBean(<span class=\"string\">&quot;ImBean&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>ApplicationContext</code>:是 <code>BeanFactory</code> 的一个子接口，扩展了其功能,项目启动就加载bean,是提前加载<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307676058781730767605785.png\" alt=\"17307676058781730767605785.png|700x600\"></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307841307381730784130182.png\" alt=\"17307841307381730784130182.png|700x180\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17321672134681732167213381.png\" alt=\"17321672134681732167213381.png|700x259\"></p>\n<h3 id=\"BeanPostProcessor\"><a href=\"#BeanPostProcessor\" class=\"headerlink\" title=\"BeanPostProcessor\"></a>BeanPostProcessor</h3><ul>\n<li>Bean后置处理器, 用来做bean加载完成后的增强操作: 如转换bean</li>\n<li>利用后置处理器(实例化, 初始化): 记录日志, 修改bean的属性方法, 返回另一个bean<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">beanUtil</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationContextAware</span>, BeanPostProcessor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApplicationContext applicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.applicationContext = applicationContext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">postProcessBeforeInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bean <span class=\"keyword\">instanceof</span> interface2Abstract) &#123;</span><br><span class=\"line\">            ((interface2Abstract) bean).setMessage(<span class=\"string\">&quot;bean被拦截了&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanName)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> applicationContext.getBean(beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">ContainsBean</span><span class=\"params\">(String beanName)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> applicationContext.containsBean(beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Aware接口\"><a href=\"#Aware接口\" class=\"headerlink\" title=\"Aware接口\"></a>Aware接口</h2></li>\n<li>例如ApplicationContextAware: 允许通过setter方法注入了ApplicationContext实例</li>\n<li>Spring 会在容器初始化该 bean 的时候调用 <code>setApplicationContext(ApplicationContext context)</code> 方法，并将当前的 <code>ApplicationContext</code> 实例传递给该 bean。因此，<code>ApplicationContext</code> 会自动注入到实现了 <code>ApplicationContextAware</code> 的类中，而无需显式使用 <code>@Autowired</code> 注解。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ApplicationContextAware</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Aware</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"SpringMVC执行流程\"><a href=\"#SpringMVC执行流程\" class=\"headerlink\" title=\"SpringMVC执行流程\"></a>SpringMVC执行流程</h2><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17601617070631760161706121.png\" alt=\"17601617070631760161706121.png\"><h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2></li>\n<li>为什么能在主类底下创建Bean:?<ul>\n<li>因为有@SpringBootConfiguration注解 里层又嵌套了一个@Configuration, 表明主类也是一个配置类, 程序会在启动时自动加载配置类的bean</li>\n</ul>\n</li>\n<li>如何保证Bean线程安全<ul>\n<li>不使用无状态的成员变量</li>\n<li>加锁: 利用 <code>synchronized</code> 或 <code>ReentrantLock</code></li>\n<li>使用<code>ThreadLocal</code>替代</li>\n</ul>\n</li>\n<li>为什么一个程序中只需要一个bean工厂?<ol>\n<li>便于对bean进行统一管理,而且ApplicationContext相比较底层的BeanFactory有更多的拓展功能: 支持事件发布与监听(记录日志), 而且是BeanFactory的子接口,具有BeanFactory的所有功能</li>\n<li>保持单例, 避免重复bean的载入</li>\n<li>内存占用和性能的角度</li>\n<li>Spring 的设计理念是通过简化配置来减少开发者的负担。通过一个统一的 <code>ApplicationContext</code>，Spring 实现了自动化和集中化管理，使得开发者无需手动管理多个工厂实例</li>\n</ol>\n</li>\n<li>@Bean是怎么实现注入且单例的?<ul>\n<li><code>@Configuration</code> 注解的类在 Spring 容器启动时会被 CGLIB 代理，目的是确保每个 <code>@Bean</code> 方法在被调用时，返回的是同一个 Bean 实例，而不是每次都创建新的实例</li>\n</ul>\n</li>\n<li><p>如果一个 Bean 被标记为懒加载，那么它不会在 Spring IoC 容器启动时立即实例化?</p>\n<ul>\n<li>首先 Spring 会去创建 A 的 Bean，创建时需要注入 B 的属性；</li>\n<li>由于在 A 上的 B 属性标注了 <code>@Lazy</code> 注解，因此 Spring 会去创建一个 B 的代理对象，将这个代理对象注入到 A 中的 B 属性；</li>\n<li>之后开始执行 B 的实例化、初始化，在注入 B 中的 A 属性时，此时 A 已经创建完毕了，就可以将 A 给注入进去。</li>\n</ul>\n</li>\n<li><p><code>spring.factories</code>中这么多配置，每次启动都要全部加载么？</p>\n<ul>\n<li>不会, 有过滤器进行@Condition注解的判断: 只有存在某些特定的类才能实现加载<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(&#123; RabbitTemplate.class, Channel.class &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(RabbitProperties.class)</span></span><br><span class=\"line\"><span class=\"meta\">@Import(RabbitAnnotationDrivenConfiguration.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitAutoConfiguration</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>补充:<code>SpringCloud</code>这类注解要常用到条件型注解</li>\n</ul>\n</li>\n<li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li>\n<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean 的情况下</li>\n<li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</li>\n<li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li>\n<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下  </li>\n<li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li>\n<li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li>\n<li><code>@ConditionalOnExpression</code>：基于 <code>SpEL</code> 表达式作为判断条件</li>\n<li><code>@ConditionalOnJava</code>：基于 <code>Java</code> 版本作为判断条件</li>\n<li><code>@ConditionalOnJndi</code>：在 <code>JNDI</code> 存在的条件下差在指定的位置</li>\n<li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 <code>Web</code> 项目的条件下</li>\n<li><code>@ConditionalOnWebApplication</code>：当前项目是 <code>Web</code> 项 目的条件下<h2 id=\"Debug\"><a href=\"#Debug\" class=\"headerlink\" title=\"Debug\"></a>Debug</h2><code>annotationMetaData</code>存储的是注解的信息<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307755237431730775521453.png\" alt=\"注解信息.png\"><br>location标注的是配置文件所在地  url是对location做了字符处理得来的<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307755677371730775567276.png\" alt=\"17307755677371730775567276.png|700x159\"></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307762407371730776239863.png\" alt=\"17307762407371730776239863.png|700x230\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307769407391730776940482.png\" alt=\"17307769407391730776940482.png\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307779357381730777935451.png\" alt=\"17307779357381730777935451.png\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307780087391730778008460.png\" alt=\"17307780087391730778008460.png\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307782007431730778199872.png\" alt=\"17307782007431730778199872.png\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307788857381730778885604.png\" alt=\"17307788857381730778885604.png\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307834977441730783497666.png\" alt=\"17307834977441730783497666.png|700x362\"></p>\n","cover":"/img/4.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Spring-And-SpringBoot\"><a href=\"#Spring-And-SpringBoot\" class=\"headerlink\" title=\"Spring And SpringBoot\"></a>Spring And SpringBoot</h1><h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><blockquote>\n<ul>\n<li>本文梳理了 <code>SpringApplication</code> 启动流程的原理，并分析了入口类返回的 IOC 容器的作用，特别是自动装配的过程。通过对关键组件如 <code>@Import</code> 注解、<code>BeanFactory</code> 和调试流程的理解，能够更加深入地了解 Spring Boot 应用的启动过程及其背后的工作机制。</li>\n<li><code>SpringApplication</code> 返回容器的过程中，自动装配(读取加载注入刷新)是关键的工作，只有在所有工作都完成后，容器才会最终返回<h2 id=\"Spring启动预览\"><a href=\"#Spring启动预览\" class=\"headerlink\" title=\"Spring启动预览\"></a>Spring启动预览</h2></li>\n<li>模拟SpringApplication主类: 通过下面的例子让你快速理解Spring启动加载原理<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testSpringApplicant</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.启动Spring应用</span></span><br><span class=\"line\">        <span class=\"type\">SpringApplication</span> <span class=\"variable\">app</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SpringApplication</span>(bootClass.class);</span><br><span class=\"line\">        app.run(args);  <span class=\"comment\">// 启动 Spring Boot 应用并初始化容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2.使用 AnnotationConfigApplicationContext 初始化 IOC 容器</span></span><br><span class=\"line\">        <span class=\"type\">ApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3.手动注册一个 Bean 示例</span></span><br><span class=\"line\">        <span class=\"type\">ConfigurableListableBeanFactory</span> <span class=\"variable\">beanFactory</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultListableBeanFactory</span>();         <span class=\"comment\">// 工作bean工厂: 不需要IOC容器来做事  注册单例 </span></span><br><span class=\"line\">        beanFactory.registerSingleton(<span class=\"string\">&quot;bean&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Bean</span>()); </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 4.刷新容器</span></span><br><span class=\"line\">        ((AnnotationConfigApplicationContext) context).refresh(); </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 5.等所有准备工作都做完了,可以拿到run方法返回的一个IOC容器</span></span><br><span class=\"line\">        <span class=\"type\">ConfigurableApplicationContext</span> <span class=\"variable\">returnValue</span> <span class=\"operator\">=</span> app.run(args);</span><br><span class=\"line\"><span class=\"comment\">//returnValue应该是ConfigurableApplicationContext的实现AnnotationConfigApplicationContext</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"SpringApplication类解析\"><a href=\"#SpringApplication类解析\" class=\"headerlink\" title=\"SpringApplication类解析\"></a>SpringApplication类解析</h3></li>\n<li>把所有的组件、环境配置、初始化逻辑整合起来，确保应用程序顺利启动。</li>\n<li>这个类既是入口类,又是结束类,关系到IOC容器的生命周期,也关系到整个程序的启动与停止<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最外层</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ProjectTestApplication.class, args);</span><br><span class=\"line\">    &#125; </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第二层</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> run(<span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;primarySource&#125;, args);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第三层: 实例化一个SpringApplication实例,执行run方法(不是静态的run方法)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> <span class=\"title class_\">SpringApplication</span>(primarySources)).run(args);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最里层: 逻辑层-&gt;程序的启动流程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ConfigurableApplicationContext <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//创建 DefaultBootstrapContext 对象，它代表了应用程序的引导上下文。引导上下文通常是 Spring Boot 启动时的早期阶段，用于初始化一些关键组件。</span></span><br><span class=\"line\">        <span class=\"type\">DefaultBootstrapContext</span> <span class=\"variable\">bootstrapContext</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.createBootstrapContext();</span><br><span class=\"line\">    \t<span class=\"comment\">// 初始化容器对象</span></span><br><span class=\"line\">        <span class=\"type\">ConfigurableApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.configureHeadlessProperty();</span><br><span class=\"line\">    \t<span class=\"comment\">// 监听 Spring Boot 应用程序启动生命周期的监听器。</span></span><br><span class=\"line\">        <span class=\"type\">SpringApplicationRunListeners</span> <span class=\"variable\">listeners</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.getRunListeners(args);</span><br><span class=\"line\">    \t<span class=\"comment\">// 开启监听器</span></span><br><span class=\"line\">        listeners.starting(bootstrapContext, <span class=\"built_in\">this</span>.mainApplicationClass);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ApplicationArguments</span> <span class=\"variable\">applicationArguments</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultApplicationArguments</span>(args);</span><br><span class=\"line\">            <span class=\"comment\">// 准备应用程序的环境配置</span></span><br><span class=\"line\">            <span class=\"type\">ConfigurableEnvironment</span> <span class=\"variable\">environment</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class=\"line\">            <span class=\"comment\">// 打印横幅</span></span><br><span class=\"line\">            <span class=\"type\">Banner</span> <span class=\"variable\">printedBanner</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.printBanner(environment);</span><br><span class=\"line\">            <span class=\"comment\">// AnnotationConfigApplicationContext IOC容器</span></span><br><span class=\"line\">            context = <span class=\"built_in\">this</span>.createApplicationContext();</span><br><span class=\"line\">            <span class=\"comment\">// 开启监听器</span></span><br><span class=\"line\">            context.setApplicationStartup(<span class=\"built_in\">this</span>.applicationStartup);</span><br><span class=\"line\">            <span class=\"comment\">// 准备应用程序的上下文（context),并执行一些初始化任务</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class=\"line\">            <span class=\"comment\">// 刷新 Spring 上下文  触发 BeanFactory 的加载和初始化，容器会开始准备好为应用程序提供服务。</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.refreshContext(context);</span><br><span class=\"line\">            <span class=\"comment\">// 刷新后的一些后处理逻辑，通常用于执行一些应用程序启动后的任务。</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.afterRefresh(context, applicationArguments);</span><br><span class=\"line\">            <span class=\"comment\">// 标记应用程序的启动过程已经完成。</span></span><br><span class=\"line\">            startup.started();</span><br><span class=\"line\">            <span class=\"comment\">// 返回配置好的 ConfigurableApplicationContext 实例。该上下文是整个应用程序的核心容器，所有的 Spring Beans 都会在其中管理。</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"IOC容器\"><a href=\"#IOC容器\" class=\"headerlink\" title=\"IOC容器\"></a>IOC容器</h2><ul>\n<li>IOC容器的实现类<code>AnnotationConfigApplicationContext</code> 实现了<code>AnnotationConfigRegistry</code> 继承了<code>GenericApplicationContext</code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">GenericApplicationContext</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">AnnotationConfigRegistry</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取Bean名单的方式: 通过register和scan</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">scan</span><span class=\"params\">(String… basePackages)</span>; <span class=\"comment\">// 加载需要扫描的包路径@Compoent</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(Class&lt;?&gt;… componentClasses)</span>; <span class=\"comment\">// 加载手动注册的注解配置类@Configuration</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"IOC容器实现类有两个方法专门用来扫描Bean\"><a href=\"#IOC容器实现类有两个方法专门用来扫描Bean\" class=\"headerlink\" title=\"IOC容器实现类有两个方法专门用来扫描Bean\"></a>IOC容器实现类有两个方法专门用来扫描Bean</h3></li>\n<li><strong>void scan  -&gt; 扫描组件</strong><ul>\n<li>所有方法自动添加@bean</li>\n<li>通过@ComponentScan扫描带有注解@Component @Controller @Service @Repository(dao层专用,spring框架下) @Mapper(Mybatis专用)  的类</li>\n</ul>\n</li>\n<li><strong>void register -&gt; 扫描配置类</strong><ul>\n<li>需手动添加@bean</li>\n<li>@Configuration 下带有@Bean注解的方法<h3 id=\"IOC容器执行Refresh方法加载注册Bean流程\"><a href=\"#IOC容器执行Refresh方法加载注册Bean流程\" class=\"headerlink\" title=\"IOC容器执行Refresh方法加载注册Bean流程\"></a>IOC容器执行Refresh方法加载注册Bean流程</h3><ul>\n<li>加载bean到上下文中(包括解析Bean定义、创建Bean实例、解决依赖关系、初始化Bean以及销毁Bean)</li>\n<li>执行依赖注入</li>\n<li>标注已刷新,完成工作<h3 id=\"了解-Import注解-加载Bean名单-自动装配\"><a href=\"#了解-Import注解-加载Bean名单-自动装配\" class=\"headerlink\" title=\"了解@Import注解: 加载Bean名单(自动装配)\"></a>了解@Import注解: 加载Bean名单(自动装配)</h3></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>@Import注解是spring第三种定义bean的方法, <strong>支持对第三方包的导入</strong></li>\n<li>共有三种实现方法:<ol>\n<li>基础数组: 注解形式通过反射<code>Class.forName()</code>把bean交给IOC容器<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这些在容器中bean名称是该类的全类名 ，比如com.spring.ImBean</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123; 类名.class , 类名.class... &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestDemo</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>实现<code>ImportSelect</code>接口:这种方式也是Spring的用法, 返回值就是我们实际上要导入到容器中的组件全限定类名(Bean名单)【<strong>重点</strong> 】<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Myclass</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImportSelector</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 重写导入Bean名单方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;com.spring.ImBean&quot;</span>, <span class=\"string\">&quot;com.spring.ImBean2&quot;</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>实现<code>ImportBeanDefinitionRegister</code>接口: 跟上面的实现方法接近, 区别在于能修改bean名<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Myclass2</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//指定bean定义信息（包括bean的类型、作用域...）</span></span><br><span class=\"line\">        <span class=\"type\">RootBeanDefinition</span> <span class=\"variable\">rootBeanDefinition</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RootBeanDefinition</span>(ImBean.class);</span><br><span class=\"line\">        <span class=\"comment\">//注册一个bean指定bean名字（id）</span></span><br><span class=\"line\">    beanDefinitionRegistry.registerBeanDefinition(<span class=\"string\">&quot;reNameBean&quot;</span>,rootBeanDefinition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"自动装配分析-重点\"><a href=\"#自动装配分析-重点\" class=\"headerlink\" title=\"自动装配分析(重点)\"></a>自动装配分析(重点)</h2></li>\n</ol>\n</li>\n<li>首先<code>@SpringBootApplication</code>启动类注解带有3个关键注解<ul>\n<li>一个就是下文提到的<code>@EnableAutoConfiguration</code>, 用于自动装配第三方Bean依赖</li>\n<li><code>@ComponentScan</code>用于扫描<code>ClassPath</code>下的本地Bean</li>\n<li><code>@SpringBootConfiguration</code>注解嵌套了一个<code>@Configuration</code>, 实际上它也是一个配置类</li>\n</ul>\n</li>\n<li><strong>@EnableAutoConfiguration</strong>启用Spring Boot的自动配置机制，将第三方依赖bean注入IOC容器</li>\n<li>通过<code>SpringFactoriesLoader</code>从类路径下去读取<code>META-INF/spring.factories</code>文件信息，此文件中有一个key为<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>，定义了一组需要自动配置的bean名单 如下:</li>\n<li>[x] ConfigurationPropertiesAutoConfiguration </li>\n<li>[x] AOPAutoConfiguration</li>\n<li>[x] DataSourceAutoConfiguration</li>\n<li>[x] ElasticsearchAutoConfiguration</li>\n<li>[x] RedisAutoConfiguration</li>\n<li>[x] GsonAutoConfiguration</li>\n<li>[x] HttpMessageConvertersAutoConfiguration</li>\n<li>[x] JacksonAutoConfiguration</li>\n<li>[x] DispathcherAutoConfiguration</li>\n<li>[x] WebMvcAutoConfiguration<h3 id=\"具体的实现流程\"><a href=\"#具体的实现流程\" class=\"headerlink\" title=\"具体的实现流程\"></a>具体的实现流程</h3></li>\n<li><code>@EnableAutoConfiguration</code>只是一个引导注解, 真正实现加载bena名单功能的是实现类<strong>AutoConfigurationImportSelector</strong></li>\n<li>import注解将<code>AutoConfigurationImportSelector</code>这个伪配置类交给IOC<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span>  <span class=\"comment\">// 先是通过import第一种用法:基础数组</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ENABLED_OVERRIDE_PROPERTY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol>\n<li>通过<code>getCandidateConfigurations</code>去加载配置文件的bean全类名名单, </li>\n<li>由<code>getAutoConfigurationEntry</code>做名单过滤, 比如像判断自动转配开关是否打开, 是否设置了排除项, 然后把名单设置到类的成员变量中, </li>\n<li>由<code>selectImports</code>方法去拿到成员变量名单去执行加载Bean的操作, 加载Bean是通过实现import接口重写<code>selectImports</code>方法实现的</li>\n</ol>\n<ul>\n<li>其中加载的配置文件地址  采取逐行读取的方式<code>readline()</code><ul>\n<li>旧地址: META-INF/spring.factories(兼容旧版本) </li>\n<li>新地址: META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DeferredImportSelector实现了了ImportSelect, AutoConfigurationImportSelector实现了DeferredImportSelector</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AutoConfigurationImportSelector</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DeferredImportSelector</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 用于返回空bean名单的空数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] NO_IMPORTS = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">0</span>]; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这个才是存储Bean数组和排除的Bean数组的底层对象,里面是List和Set</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">AutoConfigurationEntry</span> <span class=\"variable\">EMPTY_ENTRY</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AutoConfigurationEntry</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关于底层对象的定义</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AutoConfigurationEntry</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; configurations;  <span class=\"comment\">// 存储bean名单的底层容器</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;String&gt; exclusions;       <span class=\"comment\">// 排除项名单</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 作用: 得到bean名单 全类名 </span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> List&lt;String&gt; <span class=\"title function_\">getCandidateConfigurations</span><span class=\"params\">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 要加载的接口类型  类加载器类型</span></span><br><span class=\"line\">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class=\"built_in\">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class=\"built_in\">this</span>.getBeanClassLoader()); </span><br><span class=\"line\">        Assert.notEmpty(configurations, <span class=\"string\">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 返回bean名单</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> configurations;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 作用: 将得到的bean名单进一步啥筛选</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AutoConfigurationEntry <span class=\"title function_\">getAutoConfigurationEntry</span><span class=\"params\">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断自动装配开关是否打开: 默认spring.boot.enableautoconfiguration=true</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> EMPTY_ENTRY;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">AnnotationAttributes</span> <span class=\"variable\">attributes</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.getAttributes(annotationMetadata);</span><br><span class=\"line\">            <span class=\"comment\">// 返回bean名单</span></span><br><span class=\"line\">            List&lt;String&gt; configurations = <span class=\"built_in\">this</span>.getCandidateConfigurations(annotationMetadata, attributes); </span><br><span class=\"line\">            <span class=\"comment\">// 去重操作: 一般为0</span></span><br><span class=\"line\">            configurations = <span class=\"built_in\">this</span>.removeDuplicates(configurations);</span><br><span class=\"line\">            Set&lt;String&gt; exclusions = <span class=\"built_in\">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class=\"line\">            <span class=\"comment\">// 检查排除项</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.checkExcludedClasses(configurations, exclusions); </span><br><span class=\"line\">            <span class=\"comment\">// 去除排除项</span></span><br><span class=\"line\">            configurations.removeAll(exclusions);</span><br><span class=\"line\">            <span class=\"comment\">// 过滤器过滤bean 逐个检查每个配置类的条件（如@ConditionalOnClass, @ConditionalOnMissingClass)</span></span><br><span class=\"line\">            configurations = <span class=\"built_in\">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class=\"line\">            <span class=\"comment\">// 监听器用在自动配置类被导入到 ApplicationContext 之前，执行一些自定义的处理逻辑</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class=\"line\">            <span class=\"comment\">// 返回底层对象</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AutoConfigurationEntry</span>(configurations, exclusions); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 作用:获取所有符合条件的类[]的全限定类名,判断和准备要导入的自动配置类,交给IOC刷新</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.isEnabled(annotationMetadata)) &#123;  </span><br><span class=\"line\">\t        <span class=\"comment\">// 再次判断自动装配开关是否打开 如果关 则返回空数组</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> NO_IMPORTS;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">AutoConfigurationEntry</span> <span class=\"variable\">autoConfigurationEntry</span> <span class=\"operator\">=</span> \t\t\t\t <span class=\"built_in\">this</span>.getAutoConfigurationEntry(annotationMetadata);\t</span><br><span class=\"line\">            <span class=\"keyword\">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>注意<ul>\n<li>调用<code>getCandidateConfigurations()</code>方法读取外部文件这个操作是<strong>在IOC容器的Refresh()方法中触发的</strong></li>\n<li>也就是说，在IOC容器启动的时候通过调用<code>getCandidateConfigurations()</code>方法把外部文件中指定的类读取进来，然后再使用反射机制(CGLIB或者JDK代理)将它们实例化成为Bean对象载入到IOC容器中<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307293786901730729377814.png\" alt=\"17307293786901730729377814.png|700x440\"><h2 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h2><h3 id=\"Bean的执行流程\"><a href=\"#Bean的执行流程\" class=\"headerlink\" title=\"Bean的执行流程\"></a>Bean的执行流程</h3><strong>核心金句: 在refresh方法内完成 -&gt; <em>读取加载注入刷新</em></strong> </li>\n</ul>\n</li>\n<li>获取bean名单      包括本地bean和第三方依赖bean</li>\n<li>加载类                  CGLIB代理或者是反射Instance</li>\n<li>注入类                  依赖注入一般在所有bean都加载完成以后</li>\n<li>初始化和销毁       调用@PostConstruct、InitializingBean的afterPropertiesSet方法等，以保证Bean的状态正常<br>`这四个阶段并非严格独立，但可以理解为顺序执行的一个过程。每个阶段都会依次触发特定的操作，以确保Bean的正确注册、加载和注入，从而构建一个完整的IOC容器<h3 id=\"BeanFactory\"><a href=\"#BeanFactory\" class=\"headerlink\" title=\"BeanFactory\"></a>BeanFactory</h3></li>\n<li>自定义Bean工厂的核心: <strong>继承了一个抽象模板类, 实现了基础性接口</strong></li>\n<li>使用到了<strong>工厂设计模式</strong>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testBeanFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractApplicationContext</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BeanFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ConfigurableListableBeanFactory beanFactory; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refreshBeanFactory</span><span class=\"params\">()</span> &#123;  <span class=\"comment\">// IOC核心核心方法,读取加载注入刷新</span></span><br><span class=\"line\">        <span class=\"comment\">// 继承自AbstractBeanFactory的实现类</span></span><br><span class=\"line\">        beanFactory = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultListableBeanFactory</span>(); </span><br><span class=\"line\">        <span class=\"comment\">// 调用BeanFactory的注册单例bean方法</span></span><br><span class=\"line\">        beanFactory.registerSingleton(<span class=\"string\">&quot;ImBean&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ImBean</span>());</span><br><span class=\"line\">        System.out.println(beanFactory.containsBean(<span class=\"string\">&quot;ImBean&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>ApplicationContext</code>:是 <code>BeanFactory</code> 的一个子接口，扩展了其功能,项目启动就加载bean,是提前加载<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307676058781730767605785.png\" alt=\"17307676058781730767605785.png|700x600\"></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307841307381730784130182.png\" alt=\"17307841307381730784130182.png|700x180\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17321672134681732167213381.png\" alt=\"17321672134681732167213381.png|700x259\"></p>\n<h3 id=\"BeanPostProcessor\"><a href=\"#BeanPostProcessor\" class=\"headerlink\" title=\"BeanPostProcessor\"></a>BeanPostProcessor</h3><ul>\n<li>Bean后置处理器, 用来做bean加载完成后的增强操作: 如转换bean</li>\n<li>利用后置处理器(实例化, 初始化): 记录日志, 修改bean的属性方法, 返回另一个bean<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">beanUtil</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationContextAware</span>, BeanPostProcessor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApplicationContext applicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.applicationContext = applicationContext;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">postProcessBeforeInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bean <span class=\"keyword\">instanceof</span> interface2Abstract) &#123;</span><br><span class=\"line\">            ((interface2Abstract) bean).setMessage(<span class=\"string\">&quot;bean被拦截了&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String beanName)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> applicationContext.getBean(beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">ContainsBean</span><span class=\"params\">(String beanName)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> applicationContext.containsBean(beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Aware接口\"><a href=\"#Aware接口\" class=\"headerlink\" title=\"Aware接口\"></a>Aware接口</h2></li>\n<li>例如ApplicationContextAware: 允许通过setter方法注入了ApplicationContext实例</li>\n<li>Spring 会在容器初始化该 bean 的时候调用 <code>setApplicationContext(ApplicationContext context)</code> 方法，并将当前的 <code>ApplicationContext</code> 实例传递给该 bean。因此，<code>ApplicationContext</code> 会自动注入到实现了 <code>ApplicationContextAware</code> 的类中，而无需显式使用 <code>@Autowired</code> 注解。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ApplicationContextAware</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Aware</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"SpringMVC执行流程\"><a href=\"#SpringMVC执行流程\" class=\"headerlink\" title=\"SpringMVC执行流程\"></a>SpringMVC执行流程</h2><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17601617070631760161706121.png\" alt=\"17601617070631760161706121.png\"><h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2></li>\n<li>为什么能在主类底下创建Bean:?<ul>\n<li>因为有@SpringBootConfiguration注解 里层又嵌套了一个@Configuration, 表明主类也是一个配置类, 程序会在启动时自动加载配置类的bean</li>\n</ul>\n</li>\n<li>如何保证Bean线程安全<ul>\n<li>不使用无状态的成员变量</li>\n<li>加锁: 利用 <code>synchronized</code> 或 <code>ReentrantLock</code></li>\n<li>使用<code>ThreadLocal</code>替代</li>\n</ul>\n</li>\n<li>为什么一个程序中只需要一个bean工厂?<ol>\n<li>便于对bean进行统一管理,而且ApplicationContext相比较底层的BeanFactory有更多的拓展功能: 支持事件发布与监听(记录日志), 而且是BeanFactory的子接口,具有BeanFactory的所有功能</li>\n<li>保持单例, 避免重复bean的载入</li>\n<li>内存占用和性能的角度</li>\n<li>Spring 的设计理念是通过简化配置来减少开发者的负担。通过一个统一的 <code>ApplicationContext</code>，Spring 实现了自动化和集中化管理，使得开发者无需手动管理多个工厂实例</li>\n</ol>\n</li>\n<li>@Bean是怎么实现注入且单例的?<ul>\n<li><code>@Configuration</code> 注解的类在 Spring 容器启动时会被 CGLIB 代理，目的是确保每个 <code>@Bean</code> 方法在被调用时，返回的是同一个 Bean 实例，而不是每次都创建新的实例</li>\n</ul>\n</li>\n<li><p>如果一个 Bean 被标记为懒加载，那么它不会在 Spring IoC 容器启动时立即实例化?</p>\n<ul>\n<li>首先 Spring 会去创建 A 的 Bean，创建时需要注入 B 的属性；</li>\n<li>由于在 A 上的 B 属性标注了 <code>@Lazy</code> 注解，因此 Spring 会去创建一个 B 的代理对象，将这个代理对象注入到 A 中的 B 属性；</li>\n<li>之后开始执行 B 的实例化、初始化，在注入 B 中的 A 属性时，此时 A 已经创建完毕了，就可以将 A 给注入进去。</li>\n</ul>\n</li>\n<li><p><code>spring.factories</code>中这么多配置，每次启动都要全部加载么？</p>\n<ul>\n<li>不会, 有过滤器进行@Condition注解的判断: 只有存在某些特定的类才能实现加载<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(&#123; RabbitTemplate.class, Channel.class &#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(RabbitProperties.class)</span></span><br><span class=\"line\"><span class=\"meta\">@Import(RabbitAnnotationDrivenConfiguration.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitAutoConfiguration</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>补充:<code>SpringCloud</code>这类注解要常用到条件型注解</li>\n</ul>\n</li>\n<li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li>\n<li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean 的情况下</li>\n<li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</li>\n<li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li>\n<li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下  </li>\n<li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li>\n<li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li>\n<li><code>@ConditionalOnExpression</code>：基于 <code>SpEL</code> 表达式作为判断条件</li>\n<li><code>@ConditionalOnJava</code>：基于 <code>Java</code> 版本作为判断条件</li>\n<li><code>@ConditionalOnJndi</code>：在 <code>JNDI</code> 存在的条件下差在指定的位置</li>\n<li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 <code>Web</code> 项目的条件下</li>\n<li><code>@ConditionalOnWebApplication</code>：当前项目是 <code>Web</code> 项 目的条件下<h2 id=\"Debug\"><a href=\"#Debug\" class=\"headerlink\" title=\"Debug\"></a>Debug</h2><code>annotationMetaData</code>存储的是注解的信息<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307755237431730775521453.png\" alt=\"注解信息.png\"><br>location标注的是配置文件所在地  url是对location做了字符处理得来的<br><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307755677371730775567276.png\" alt=\"17307755677371730775567276.png|700x159\"></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307762407371730776239863.png\" alt=\"17307762407371730776239863.png|700x230\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307769407391730776940482.png\" alt=\"17307769407391730776940482.png\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307779357381730777935451.png\" alt=\"17307779357381730777935451.png\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307780087391730778008460.png\" alt=\"17307780087391730778008460.png\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307782007431730778199872.png\" alt=\"17307782007431730778199872.png\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307788857381730778885604.png\" alt=\"17307788857381730778885604.png\"></p>\n<p><img src=\"https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17307834977441730783497666.png\" alt=\"17307834977441730783497666.png|700x362\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmfw4z0910009uomwh87zd3s7","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z09g000iuomwguj0fd99"},{"post_id":"cmfw4z08i0001uomw9v4zd9qr","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z09l000nuomw5orr246b"},{"post_id":"cmfw4z094000buomw9cb0eq99","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z09o000quomw8dtv60b1"},{"post_id":"cmfw4z09b000fuomw9d4bersn","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z09r000uuomw48835ehm"},{"post_id":"cmfw4z08q0003uomwc54g2cvi","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z09u000yuomw3l6a8xor"},{"post_id":"cmfw4z09f000huomwdojx46tb","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z09w0013uomwfcyke4al"},{"post_id":"cmfw4z09j000muomw365d60dr","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z09y0017uomw6h9q0p1c"},{"post_id":"cmfw4z08z0007uomwgl45d1kr","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0a0001auomw6ye0a9p4"},{"post_id":"cmfw4z09n000puomw75rkaxnr","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0a6001euomwcy53ejb9"},{"post_id":"cmfw4z09q000tuomwgy2wh6rs","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0a8001guomw524hgpnl"},{"post_id":"cmfw4z09t000xuomwbfv519fg","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0ab001juomwgcp683ie"},{"post_id":"cmfw4z09v0012uomw2to7axx3","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0ac001luomw7g8v5ewi"},{"post_id":"cmfw4z09x0016uomw0c967y3o","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0ad001ouomw2pcrdvor"},{"post_id":"cmfw4z09z0019uomw9e3lbvit","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0af001ruomw89996nsl"},{"post_id":"cmfw4z0a5001duomw3wbfhbpv","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0ag001vuomw4nxrby7r"},{"post_id":"cmfw4z0a7001fuomw0o9n6s58","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0ai001yuomw4yvq4shc"},{"post_id":"cmfw4z0aa001iuomw0lkgefxm","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0aj0020uomwdqhp8m9a"},{"post_id":"cmfw4z0ab001kuomw8bewh51p","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0aj0023uomw0h72fjis"},{"post_id":"cmfw4z0ad001nuomwe1wfd7tq","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0ak0024uomw4thxf3vr"},{"post_id":"cmfw4z0ah001xuomw1zce7nd4","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0al002buomw9owf9mtj"},{"post_id":"cmfw4z0b5003uuomwgz5e7m0d","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0b9003yuomwhh7i9erp"},{"post_id":"cmfw4z0b7003vuomw9x8gdzid","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0b90040uomw5lcc9wvy"},{"post_id":"cmfw4z0b8003xuomwgc3yevhj","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmfw4z0ba0043uomwbc2ngtvd"},{"post_id":"cmik3ww9j0000homwgbvse639","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmik3ww9n0003homw1kcvhmdo"},{"post_id":"cmik3ww9o0004homwc2e90gki","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmik3ww9v0007homw3klk4n9x"},{"post_id":"cmik3ww9u0006homwew6jemkn","category_id":"cmfw4z08u0004uomwep9t6btj","_id":"cmik3ww9x0009homw6wc79yok"}],"PostTag":[{"post_id":"cmfw4z08i0001uomw9v4zd9qr","tag_id":"cmfw4z08x0005uomwhmmg25p0","_id":"cmfw4z09r000vuomw5pfcd6fm"},{"post_id":"cmfw4z08i0001uomw9v4zd9qr","tag_id":"cmfw4z095000duomw4nmb76od","_id":"cmfw4z09u000zuomw76ts399q"},{"post_id":"cmfw4z08i0001uomw9v4zd9qr","tag_id":"cmfw4z09i000kuomwdqopcqv9","_id":"cmfw4z09x0014uomwd53pbqs8"},{"post_id":"cmfw4z08q0003uomwc54g2cvi","tag_id":"cmfw4z09p000ruomw6nipgk1w","_id":"cmfw4z0ae001puomwcwci2r7l"},{"post_id":"cmfw4z08q0003uomwc54g2cvi","tag_id":"cmfw4z09u0010uomw108rdu4w","_id":"cmfw4z0af001suomwag8zgj2s"},{"post_id":"cmfw4z08q0003uomwc54g2cvi","tag_id":"cmfw4z0a0001buomwg5u5dolj","_id":"cmfw4z0ag001wuomw9954de8x"},{"post_id":"cmfw4z08q0003uomwc54g2cvi","tag_id":"cmfw4z0a9001huomwbo000zu5","_id":"cmfw4z0ai001zuomw9ipo9qwq"},{"post_id":"cmfw4z08z0007uomwgl45d1kr","tag_id":"cmfw4z0ac001muomwc32fgou8","_id":"cmfw4z0aj0022uomw1dfv4zfy"},{"post_id":"cmfw4z0910009uomwh87zd3s7","tag_id":"cmfw4z0af001tuomw4hme23b6","_id":"cmfw4z0al0027uomw6179h36w"},{"post_id":"cmfw4z0910009uomwh87zd3s7","tag_id":"cmfw4z0aj0021uomw1pml971b","_id":"cmfw4z0al0029uomw8lc07pze"},{"post_id":"cmfw4z094000buomw9cb0eq99","tag_id":"cmfw4z0ak0025uomw3o8d8mno","_id":"cmfw4z0am002cuomwdq4hcqox"},{"post_id":"cmfw4z09b000fuomw9d4bersn","tag_id":"cmfw4z0al002auomwca7a8f0p","_id":"cmfw4z0am002euomwezw779w4"},{"post_id":"cmfw4z09f000huomwdojx46tb","tag_id":"cmfw4z0am002duomw2ltudi1j","_id":"cmfw4z0ao002iuomw8f47ak8w"},{"post_id":"cmfw4z09f000huomwdojx46tb","tag_id":"cmfw4z0an002fuomwak7vdcfr","_id":"cmfw4z0ap002juomwf634618y"},{"post_id":"cmfw4z09f000huomwdojx46tb","tag_id":"cmfw4z0an002guomw4ljg5q9d","_id":"cmfw4z0ap002luomwem2xa8af"},{"post_id":"cmfw4z09j000muomw365d60dr","tag_id":"cmfw4z0ao002huomw0grjavuh","_id":"cmfw4z0ap002muomw63ip9fbi"},{"post_id":"cmfw4z09n000puomw75rkaxnr","tag_id":"cmfw4z0ap002kuomw6a3wg53h","_id":"cmfw4z0aq002ouomw6ctq5e5g"},{"post_id":"cmfw4z09q000tuomwgy2wh6rs","tag_id":"cmfw4z0aq002nuomw5zmy960r","_id":"cmfw4z0ar002ruomwhjfh2qjr"},{"post_id":"cmfw4z09q000tuomwgy2wh6rs","tag_id":"cmfw4z0aq002puomw1n4nfr7z","_id":"cmfw4z0ar002suomwbqzf5i7b"},{"post_id":"cmfw4z09t000xuomwbfv519fg","tag_id":"cmfw4z0ar002quomw9jgkh7s6","_id":"cmfw4z0ar002uuomwajgh37do"},{"post_id":"cmfw4z09v0012uomw2to7axx3","tag_id":"cmfw4z0ar002tuomwgt901n2h","_id":"cmfw4z0as002wuomw2pu9bdqd"},{"post_id":"cmfw4z09x0016uomw0c967y3o","tag_id":"cmfw4z0as002vuomw6ybf67cv","_id":"cmfw4z0at002zuomwbgxv2wce"},{"post_id":"cmfw4z09x0016uomw0c967y3o","tag_id":"cmfw4z0as002xuomw90i5gajq","_id":"cmfw4z0at0030uomwbsanbztw"},{"post_id":"cmfw4z09z0019uomw9e3lbvit","tag_id":"cmfw4z0as002yuomw1vcjddzn","_id":"cmfw4z0au0033uomw0bntd961"},{"post_id":"cmfw4z09z0019uomw9e3lbvit","tag_id":"cmfw4z0at0031uomw3v8dbv0n","_id":"cmfw4z0au0034uomwgglkcbmo"},{"post_id":"cmfw4z0a5001duomw3wbfhbpv","tag_id":"cmfw4z0at0032uomw4d7tf2z1","_id":"cmfw4z0au0036uomw3lnf1wx0"},{"post_id":"cmfw4z0a7001fuomw0o9n6s58","tag_id":"cmfw4z0au0035uomw04eeevpp","_id":"cmfw4z0au0038uomwbfux426x"},{"post_id":"cmfw4z0aa001iuomw0lkgefxm","tag_id":"cmfw4z0au0037uomw66ambv2k","_id":"cmfw4z0aw003cuomw3hfc86ug"},{"post_id":"cmfw4z0aa001iuomw0lkgefxm","tag_id":"cmfw4z0av0039uomw3j0wbucp","_id":"cmfw4z0aw003duomw7r2ah3tf"},{"post_id":"cmfw4z0aa001iuomw0lkgefxm","tag_id":"cmfw4z0av003auomw2f3adz38","_id":"cmfw4z0ax003fuomw1v4852kt"},{"post_id":"cmfw4z0ab001kuomw8bewh51p","tag_id":"cmfw4z0av003buomw7mb95n7z","_id":"cmfw4z0ax003guomwbu7xfnqu"},{"post_id":"cmfw4z0ad001nuomwe1wfd7tq","tag_id":"cmfw4z0aw003euomw4ycicu57","_id":"cmfw4z0ay003iuomw8ibub724"},{"post_id":"cmfw4z0ah001xuomw1zce7nd4","tag_id":"cmfw4z0b2003puomw0j0uh9tf","_id":"cmfw4z0b3003tuomw3ryv0tq2"},{"post_id":"cmfw4z0b8003xuomwgc3yevhj","tag_id":"cmfw4z0au0037uomw66ambv2k","_id":"cmfw4z0b9003zuomwgcmm6abv"},{"post_id":"cmfw4z0b5003uuomwgz5e7m0d","tag_id":"cmfw4z0b8003wuomw579e1gcs","_id":"cmfw4z0ba0042uomwf8khcr7m"},{"post_id":"cmfw4z0b7003vuomw9x8gdzid","tag_id":"cmfw4z0ba0041uomwf42eacx5","_id":"cmfw4z0bb0046uomw7t1udv4i"},{"post_id":"cmfw4z0b7003vuomw9x8gdzid","tag_id":"cmfw4z0ba0044uomw2y5n5q6x","_id":"cmfw4z0bb0047uomw35u82gcz"},{"post_id":"cmfw4z0b7003vuomw9x8gdzid","tag_id":"cmfw4z0ba0045uomw3wqfc558","_id":"cmfw4z0bb0048uomw2xok6vew"},{"post_id":"cmik3ww9j0000homwgbvse639","tag_id":"cmfw4z0ax003huomw16az0p8v","_id":"cmik3ww9m0001homw4eby2asf"},{"post_id":"cmik3ww9j0000homwgbvse639","tag_id":"cmfw4z0aw003euomw4ycicu57","_id":"cmik3ww9n0002homw0l7t9cgi"},{"post_id":"cmfw4z09j000muomw365d60dr","tag_id":"cmik3ww9p0005homw0yd67kas","_id":"cmik3ww9z000chomw533i9ojd"},{"post_id":"cmfw4z09j000muomw365d60dr","tag_id":"cmik3ww9v0008homwdgkt1jo9","_id":"cmik3ww9z000dhomw4yd49zjb"},{"post_id":"cmfw4z09j000muomw365d60dr","tag_id":"cmik3ww9x000ahomwco0tfy9q","_id":"cmik3ww9z000fhomwghz2aid6"},{"post_id":"cmik3ww9o0004homwc2e90gki","tag_id":"cmik3ww9y000bhomwfnbmckza","_id":"cmik3wwa0000hhomw35wo5xvn"},{"post_id":"cmik3ww9o0004homwc2e90gki","tag_id":"cmik3ww9z000ehomwdx20d2oe","_id":"cmik3wwa0000ihomwg4xu1b3y"},{"post_id":"cmfw4z09t000xuomwbfv519fg","tag_id":"cmik3wwa0000ghomwazacdmfp","_id":"cmik3wwa0000lhomw358xe78m"},{"post_id":"cmfw4z09t000xuomwbfv519fg","tag_id":"cmik3wwa0000jhomwfuuseb21","_id":"cmik3wwa0000mhomw2wqhfnus"},{"post_id":"cmik3ww9u0006homwew6jemkn","tag_id":"cmfw4z0az003kuomw64yu7wre","_id":"cmik3wwa1000ohomw5dl5ef90"},{"post_id":"cmik3ww9u0006homwew6jemkn","tag_id":"cmfw4z0ar002tuomwgt901n2h","_id":"cmik3wwa1000phomwalgkfx45"},{"post_id":"cmik3ww9u0006homwew6jemkn","tag_id":"cmfw4z0b1003ouomw8odubilo","_id":"cmik3wwa1000qhomw2rukbvto"},{"post_id":"cmik3ww9u0006homwew6jemkn","tag_id":"cmik3wwa0000khomw4ff98hin","_id":"cmik3wwa1000rhomw5opcdrgc"},{"post_id":"cmfw4z0ab001kuomw8bewh51p","tag_id":"cmik3wwa0000nhomwf3up1no2","_id":"cmik3wwa1000shomwbl6igxlv"}],"Tag":[{"name":"ZeroCopy","_id":"cmfw4z08x0005uomwhmmg25p0"},{"name":"Buffer","_id":"cmfw4z095000duomw4nmb76od"},{"name":"Kernel","_id":"cmfw4z09i000kuomwdqopcqv9"},{"name":"Converter","_id":"cmfw4z09p000ruomw6nipgk1w"},{"name":"DateTimeFormatter","_id":"cmfw4z09u0010uomw108rdu4w"},{"name":"Date","_id":"cmfw4z0a0001buomwg5u5dolj"},{"name":"LocalDateTime","_id":"cmfw4z0a9001huomwbo000zu5"},{"name":"ElasticSearch","_id":"cmfw4z0ac001muomwc32fgou8"},{"name":"Nginx","_id":"cmfw4z0af001tuomw4hme23b6"},{"name":"chuangTu","_id":"cmfw4z0aj0021uomw1pml971b"},{"name":"Linux","_id":"cmfw4z0ak0025uomw3o8d8mno"},{"name":"Cors","_id":"cmfw4z0al002auomwca7a8f0p"},{"name":"RabbitMQ","_id":"cmfw4z0am002duomw2ltudi1j"},{"name":"SnowflakeId","_id":"cmfw4z0an002fuomwak7vdcfr"},{"name":"RocketMQ","_id":"cmfw4z0an002guomw4ljg5q9d"},{"name":"Serializable","_id":"cmfw4z0ao002huomw0grjavuh"},{"name":"SpringCloud","_id":"cmfw4z0ap002kuomw6a3wg53h"},{"name":"session","_id":"cmfw4z0aq002nuomw5zmy960r"},{"name":"cookie","_id":"cmfw4z0aq002puomw1n4nfr7z"},{"name":"SpringSecurity","_id":"cmfw4z0ar002quomw9jgkh7s6"},{"name":"Annotation","_id":"cmfw4z0ar002tuomwgt901n2h"},{"name":"byte","_id":"cmfw4z0as002vuomw6ybf67cv"},{"name":"bit","_id":"cmfw4z0as002xuomw90i5gajq"},{"name":"Cache","_id":"cmfw4z0as002yuomw1vcjddzn"},{"name":"Redis","_id":"cmfw4z0at0031uomw3v8dbv0n"},{"name":"Docker","_id":"cmfw4z0at0032uomw4d7tf2z1"},{"name":"encrypt","_id":"cmfw4z0au0035uomw04eeevpp"},{"name":"Web","_id":"cmfw4z0au0037uomw66ambv2k"},{"name":"Servlet","_id":"cmfw4z0av0039uomw3j0wbucp"},{"name":"CORS","_id":"cmfw4z0av003auomw2f3adz38"},{"name":"proxy","_id":"cmfw4z0av003buomw7mb95n7z"},{"name":"mysql","_id":"cmfw4z0aw003euomw4ycicu57"},{"name":"mybatis","_id":"cmfw4z0ax003huomw16az0p8v"},{"name":"spring","_id":"cmfw4z0az003kuomw64yu7wre"},{"name":"springBoot","_id":"cmfw4z0b1003ouomw8odubilo"},{"name":"Git","_id":"cmfw4z0b2003puomw0j0uh9tf"},{"name":"stream","_id":"cmfw4z0b8003wuomw579e1gcs"},{"name":"stack","_id":"cmfw4z0ba0041uomwf42eacx5"},{"name":"heap","_id":"cmfw4z0ba0044uomw2y5n5q6x"},{"name":"Jvm","_id":"cmfw4z0ba0045uomw3wqfc558"},{"name":"IO","_id":"cmik3ww9p0005homw0yd67kas"},{"name":"InputStream","_id":"cmik3ww9v0008homwdgkt1jo9"},{"name":"OutputStream","_id":"cmik3ww9x000ahomwco0tfy9q"},{"name":"Server","_id":"cmik3ww9y000bhomwfnbmckza"},{"name":"NetworkModels","_id":"cmik3ww9z000ehomwdx20d2oe"},{"name":"CSRF","_id":"cmik3wwa0000ghomwazacdmfp"},{"name":"XSS","_id":"cmik3wwa0000jhomwfuuseb21"},{"name":"BeanFactory","_id":"cmik3wwa0000khomw4ff98hin"},{"name":"AOP","_id":"cmik3wwa0000nhomwf3up1no2"}]}}