---
banner: "[[pixel-banner-image.png]]"
title: SpringCloud微服务
tags:
  - SpringCloud
categories: 编程
date: 2025-03-06T13:55:00
---

# SpringCloud微服务
## 微服务概述
- **核心是Spring框架**，**利用Spring Boot的自动配置**，力图实现最简化的**分布式**应用程序开发
- Spring Cloud 是基于 Spring Boot 实现的，它不能独立创建工程或模块，更不能脱离 Spring Boot 独立运行。
- Spring Cloud 本身并不是一个拿来即可用的框架，它是一套**微服务规范**，**共有两代实现**
	- **Spring Cloud Netflix** 是 Spring Cloud 的第一代实现，主要由 **Eureka**、**Ribbon**、**Feign**、**Hystrix** 等组件组成。
	- **Spring Cloud Alibaba** 是 Spring Cloud 的第二代实现，主要由 **Nacos**、**Sentinel**、**Seata** 等组件组成。
- [依赖版本适配说明文档](https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E)
## `RPC`远程调用
#### 序章
- RPC（Remote Procedure Call，远程过程调用）
	- 是一种分布式系统中的通信方式，允许不同的服务之间像调用本地方法一样调用远程服务
- HttpClient, OKHttp, RestTemplate 都是gRPC的典型HTTP请求客户端
#### RPC和HTTP的区别
- HTTP 是应用层协议，用于传输超文本数据，基于请求-响应模型，常用于 Web 开发、API 调用等场景。
- RPC 是远程过程调用协议，用于实现分布式系统中不同节点之间的通信，基于方法调用模型，常用于构建面向服务的微服务架构。
- 在微服务架构中，Feign 和 Dubbo 都是用于实现远程调用的框架，Feign 基于 HTTP 协议，Dubbo 基于 RPC 协议。
#### 为什么 WebFlux 使用 Netty 而不是 Tomcat？

	✅ **非阻塞 I/O**，支持高并发请求  
	✅ **事件驱动（Reactor 模式）**，更适合 WebSockets、流式处理  
	✅ **适用于 API 网关、微服务架构**（如 Spring Cloud Gateway）
#### 阻塞和非阻塞IO的区别

| 调用方式        | 描述                                                                  | 场景                 | 优缺点             |
| ----------- | ------------------------------------------------------------------- | ------------------ | --------------- |
| 同步调用(阻塞IO)  | 客户端发送请求必须等待服务器返回结果, 如: Tomcat -> SpringMVC -> Servlet               | 需要实时响应的业务，如支付、订单查询 | 阻塞影响性能,但是满足业务需求 |
| 异步调用(非阻塞IO) | 客户端发送请求后，不会阻塞等待，而是立即返回，后续通过回调函数、轮询或者事件通知的方式获取结果。如: WebFlux -> Netty | 高并发、任务队列，如日志收集     | 不等待需要管理回调或轮询    |
| 单向调用        | 客户端只发送请求，不关心返回值                                                     | 日志上报、监控数据          | 高效,但是无法确认是否调用成功 |
| 广播调用        | 请求同时发送给多个服务器                                                        | 配置更新、消息通知          | 需要策略控制（超时、重试等）  |

## `Nacos`
### 序章
- 为什么要有服务注册和发现Nacos
	- 因为如果是单体项目, 模块之间可以用依赖注入的方式互相调用; 但是对于两个已经启动的进程, 必须通过远程调用(Http, gRPC), 但是ip地址是写死的在配置的, 无法集中化管理 
- Nacos 本身就是一个中心化的服务平台, 客户端依赖通过**封装好的接口与 Nacos 服务端交互**，从而实现服务注册、配置拉取等操作
- 全称含义: **Dynamic Naming and Configuration Service** 动态命名与配置服务中心
- 层级结构梳理如下：
	- **命名空间（Namespace） 
	      └─ 分组（Group） 
	            └─ 服务/配置（Data ID）**
![17579852910921757985290713.png|700x396](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17579852910921757985290713.png)
### Eureka和Nacos的区别
- Eureka相比于Nacos没有配置中心, 但是都有服务注册和发现的功能
- Eureka和Nacos的ping健康检测机制不一样
	- Eureka
		- 心跳检测：服务实例每 **30s** 发送一次心跳。
		- 服务清理：服务端每 **60s** 扫描一次，剔除超过 90s 未续约的服务实例
	- Nacos
		- 心跳检测：客户端每 **5s** 上报一次心跳。
		- 服务清理：服务端每 **30s** 检查，超过 15s 无心跳标记为不健康，30s 内无心跳剔除。
### 注意
- 配置`spring.cloud.nacos.discovery`, 就会注册服务到已经启动的 Nacos 注册中心
- `bootstrap.*` 里的配置会先于 `application.*`  **优先加载**（适用于 Nacos 这种外部配置中心), 如果有同名配置则会被覆盖
- 尤其要注意的是所有注册到nacos的服务会自动吃到当前空间下的所有配置, 并且可以**动态刷新**, 但是要在类上加注解`@RefreshScope`
- nacos有**缓存通讯录和ping心跳检测**, 所以即使挂了也不会影响已经运行的服务
- nacos可以做**负载均衡**, 但是要引入依赖, 默认是轮询

![17412603872831741260386317.png|700x464](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412603872831741260386317.png)
### 例子
```yaml
spring:
  profiles:
    active: dev
  cloud:
    nacos:
      # nacos discovery center
      discovery:
        server-addr: ${nacos.address}
        namespace: ${nacos.namespace}

      # nacos config center
      config:
        server-addr: ${nacos.address}
        namespace: ${nacos.namespace}

        # nacos config extension type
        file-extension: ${nacos.fileExtension}

		# properties inject list
        extension-configs:
          - data-id: ${nacos.dataIds[0].one}
            refresh: true
          - data-id: ${nacos.dataIds[1].two}
            refresh: true
          - data-id: ${nacos.dataIds[2].three}
            refresh: true
```
## `GateWay`
#### 序章
- Spring Cloud Gateway是基于**Netty**的异步服务器，允许我们编写一系列过滤器来实现**黑名单**、**权限检查**、**限流**等功能。
- 通过 Predicate **断言来实现 Route 路由的匹配规则**。简单点说，Predicate 是路由转发的判断条件，请求只有满足了 Predicate 的条件，才会被转发到指定的服务上进行处理。
#### 核心概念

| 核心概念          | 描述                                                                                     |
| ------------- | -------------------------------------------------------------------------------------- |
| Route(路由)     | 网关最基本的模块。它**由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成**。                         |
| Predicate(断言) | 路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。 |
| Filter(过滤器)   | 过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对上文的响应进行再处理。                                               |
![17412623069201741262305954.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412623069201741262305954.png)
#### 断言匹配规则
- Route 路由与 Predicate 断言的对应关系为“**一对多**”，**一个路由可以包含多个不同断言**。
- 一个请求想要转发到指定的路由上，就必须同时匹配路由上的所有断言。
- **当一个请求同时满足多个路由的断言条件时，请求只会被首个成功匹配的路由转发****。
- 共有7种匹配断言规则
![17412433659841741243365893.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412433659841741243365893.png)

| 断言          | 示例                                                                                                  | 说明                                                                                                                    |
| ----------- | --------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| **Path**    | - Path=/dept/list/**                                                                                | 当请求路径与 /dept/list/** 匹配时，该请求才能被转发到 <http://localhost:8001> 上。                                                         |
| **Before**  | - Before=2021-10-20T11:47:34.255+08:00[Asia/Shanghai]                                               | 在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之前的请求，才会被转发到 <http://localhost:8001> 上。                                          |
| **After**   | - After=2021-10-20T11:47:34.255+08:00[Asia/Shanghai]                                                | 在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之后的请求，才会被转发到 <http://localhost:8001> 上。                                          |
| **Between** | - Between=2021-10-20T15:18:33.226+08:00[Asia/Shanghai],2021-10-20T15:23:33.226+08:00[Asia/Shanghai] | 在 2021 年 10 月 20 日 15 时 18 分 33.226 秒 到 2021 年 10 月 20 日 15 时 23 分 33.226 秒之间的请求，才会被转发到 <http://localhost:8001> 服务器上。 |
| **Cookie**  | - Cookie=name, c.biancheng.net                                                                      | 携带 Cookie 且 Cookie 的内容为 name=c.biancheng.net 的请求，才会被转发到 <http://localhost:8001> 上。                                    |
| **Header**  | - Header=X-Request-Id,\d+                                                                           | 请求头上携带属性 X-Request-Id 且属性值为整数的请求，才会被转发到 <http://localhost:8001> 上。                                                    |
| **Method**  | - Method=GET                                                                                        | 只有 GET 请求才会被转发到 <http://localhost:8001> 上。                                                                            |
| Host        | -Host=`**.nihao.org,**.host.com`                                                                    | 请求必须是某些域名                                                                                                             |
#### 工作流程
![17579866481091757986646541.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17579866481091757986646541.png)
- **Gateway Web Handler（网关处理器）**：网关处理器是 Spring Cloud Gateway 的核心组件，负责将请求转发到匹配的路由上。它根据路由配置和断言条件进行路由匹配，选择合适的路由进行请求转发。网关处理器还会依次应用配置的过滤器链，对请求进行处理和转换。
- **Gateway Filter Chain（网关过滤器链）**：网关过滤器链由一系列过滤器组成，按照配置的顺序依次执行。每个过滤器可以在请求前、请求后或请求发生错误时进行处理。过滤器链的执行过程可以修改请求、响应以及执行其他自定义逻辑。
## `OpenForeign`
#### 序言
- Spring Cloud OpenFeign把**REST请求封装为Java接口方法**，**实现了一种声明式的RPC服务调用与负载均衡组件**
- 有RequestInterceptor拦截器

| 注解                  | 说明                                                                                                                                            |
| ------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| @FeignClient        | 该注解用于通知 OpenFeign 组件对 @RequestMapping 注解下的接口进行解析，并通过动态代理的方式产生实现类，实现负载均衡和服务调用                                                                  |
| @EnableFeignClients | 该注解用于开启 OpenFeign 功能，OpenFeign 会扫描标有 @FeignClient 注解的接口，生成代理并注册到 Spring 容器中,启动类和配置类中有1个就行 **@EnableFeignClients("com.train.business.feign")** |
#### 解释
1. 声明式 API：Feign 允许开发者使用简单的注解来定义和描述对远程服务的访问。通过使用注解，开发者可以轻松地指定 URL、HTTP 方法、请求参数、请求头等信息，使得远程调用变得非常直观和易于理解。
```java
@FeignClient(name = "example", url = "https://api.example.com")
 public interface ExampleService {
     @GetMapping("/endpoint")
     String getEndpointData();
 }
```
2. 集成负载均衡：Feign 集成了 Ribbon 负载均衡器，可以自动实现客户端的负载均衡。它可以根据服务名和可用实例进行动态路由，并分发请求到不同的服务实例上，提高系统的可用性和可伸缩性。
3. 容错机制：Feign 支持集成 Hystrix 容错框架，可以在调用远程服务时提供容错和断路器功能。当远程服务不可用或响应时间过长时，Feign 可以快速失败并返回预设的响应结果，避免对整个系统造成级联故障
#### OpenFeign 和 RestTemplate 的区别
| 特性   | RestTemplate        | OpenFeign           |
| ---- | ------------------- | ------------------- |
| 调用请求 | 手动拼URL，模板调用         | 声明式接口调用Rest风格，像本地方法 |
| 负载均衡 | 需额外配置 @LoadBalanced | 内置支持                |
| 扩展能力 | 功能单一，需手动封装          | 日志、拦截器、熔断、重试        |
| 开发效率 | 低，代码冗余              | 高，简洁优雅              |
#### OpenFeign 和 Dubbo 的区别
- 定义上
	- feign是一个声明式的用于Web 服务, 简化Http Api调用的框架, 适用于构建 RESTful 风格
	- Dubbo 是一个分布式服务框架，用于构建面向服务的微服务架构。
- 通信方式
	- feign基于 HTTP 协议，使用 RESTful 风格的接口进行定义和调用。
	- Dubbo 默认基于 Netty 作为通信层
- 生态
	- feign天然集成Spring Cloud 生态
#### 例子
```java
/**  
 * 请求是实际服务地址,为了提高效率 
 * 使用feign拦截器要带上请求头token 否则实际服务的拦截器会报错  
 * 注意: 使用PUT请求时,如果max_header_size过小会报400错误  
 * @author cloud_3111  
 * @since 2025-04-15  
 */
@FeignClient(name = "memberService")  // memberService = ip+端口(通过nacos通讯录拿到的)
public interface memberFeign {  
    @PostMapping("/member/ticket/save")  // 完整uri
    Result save(@RequestBody TicketDTO ticketDTO);  
  
}
```
#### 负载均衡算法
1. **轮询算法（Round Robin）**：轮询算法是最简单的负载均衡算法之一。它按照顺序将请求依次分配给每个后端服务器，循环往复。
2. **加权轮询算法（Weighted Round Robin）**：加权轮询算法在轮询算法的基础上增加了权重的概念。每个后端服务器都被赋予一个权重值，权重值越高，被选中的概率就越大。
3. **随机算法（Random）**：随机算法将请求随机分配给后端服务器。每个后端服务器有相等的被选中概率，没有考虑服务器的实际负载情况。这种算法简单快速，适用于后端服务器性能相近且无需考虑请求处理能力的场景。
4. **加权随机算法（Weighted Random）**：加权随机算法在随机算法的基础上引入了权重的概念。每个后端服务器被赋予一个权重值，权重值越高，被选中的概率就越大。这样可以根据服务器的处理能力和性能调整请求的分配比例。
5. **最少连接算法（Least Connection）**：最少连接算法会根据后端服务器**当前的连接数**来决定请求的分配。负载均衡器会选择当前连接数最少的服务器进行请求分配，以保证后端服务器的负载均衡。这种算法适用于后端服务器的处理能力不同或者请求的处理时间不同的场景。
6. **哈希算法（Hash）**：哈希算法会根据请求的某个特定属性（如客户端 IP 地址、请求 URL 等）计算哈希值，然后根据哈希值选择相应的后端服务器。
#### 什么是服务雪崩
- 一个或者多个服务出现故障，如果这时候，依赖的服务还在不断发起请求，或者重试，那么这些请求的压力会不断在下游堆积，导致下游服务的负载急剧增加。不断累计之下，可能会导致故障的进一步加剧，可能会导致级联式的失败，甚至导致整个系统崩溃，这就叫服务雪崩。
- 措施：
	1. Cluster集群部署多个
	2. 限流和熔断：对服务之间的请求进行限流和熔断，以防止过多的请求涌入导致后端服务不可用。
	3. 缓存和降级：合理使用缓存来减轻后端服务的负载压力，并在必要时进行服务降级，保证核心功能的可用性
## `Seata`
### 序言
- 微服务下的 **分布式事务** 处理框架
- Seata的3个核心组件: 
	- `TC`: **事务协调者 Coordinator**, 维护全局和分支事务的状态, 驱动全局事务提交或回滚 
	- `TM`: **事务管理器 Manager**, 定义全局事务的范围, 开启全局事务, 提交或回滚全局事务
	- `RM`: **资源管理器 Manager**, 管理分支事务的资源, 与TC交谈以及注册分支事务和报告分支事务的状态, 启动分支事务的提交与回滚
- `TC` 以 **Seata Server**形式独立部署(8091)，`TM` 和 `RM` 则是以 **Seata Client** 的形式集成在微服务中运行
- **Seata 在开启全局事务时，会在业务逻辑执行过程中捕获异常来判断是否需要回滚**
### 分布式事务的4种模式
#### XA 模式（两阶段提交协议）
- **标准：** 来自于 X/Open 组织的分布式事务标准。
- **流程：**
    1. 第一阶段：**所有资源准备就绪（prepare），但不提交**；
    2. 第二阶段：**协调器发送提交命令，所有资源正式提交**；
- **特点：** 强一致性，自动化程度高；
- **问题：**
    - 阻塞资源，性能较低；
    - 数据库需要支持 XA协议
#### AT 模式（自动事务，Seata默认）
- **核心：** 利用业务操作前后的快照，自动生成**反向 SQL**来实现回滚；
- **流程:** 
	- 每一次全局事务会在seat数据库表**global_table**生成事务记录, 执行完成就删除
	- 每一次全局事务会在seat数据库表**branch_table**生成各自操作持久层的**反向SQL**, 执行完成就删除
	- **全局事务会生成一个全局事务ID也叫XID, 上游服务通过设置拦截器设置Header把XID传递给下游服务, 以确保全局事务的唯一性**
	- **还要保证抛出的异常正确被seata接收到, 不能被自定义的全局异常处理器处理**
	- seata的全局锁和分支事务锁都是通过mysql来做的(key,value,expire)
- **工作机制：**
    1. 前置操作：在数据库执行 SQL 之前记录快照（undo_log）**；
    2. 失败回滚： **自动生成并执行反向 SQL；**
- **特点：**
    - 无需业务侵入；
    - 高性能；
    - 最终一致性；
- **缺点**
	- Seata的反向SQL不支持复杂的嵌套SQL
	- Seata的反向SQL不支持批量更新
- **适用：** 一般业务场景，性能优先。
- **控制台日志记录**
	1. Begin new global transaction + XID  
	日志表示开始一个新的全局事务（Global Transaction），并且系统生成了一个唯一的事务ID（XID）来标识这个全局事务。  
	2. 发生异常, 被Seata捕获, RM生成分支事务  
	在全局事务的执行过程中发生了异常，Seata框架捕获到该异常并进行处理。  
	为了处理事务中的错误，RM（Resource Manager，资源管理器）生成了一个分支事务（Branch Transaction），用于处理失败后的恢复操作。  
	3. RM handle branch rollback process: xid=XID, branchId=分支事务ID  
	RM开始处理分支事务的回滚过程。通过XID和branchId来标识需要回滚的分支事务。  
	4. RM处理分支事务, 开始执行回滚操作，并且删除存储分支事务信息的branch_table表中的相关记录。  
	5. XID branch 分支事务, undo_log deleted with GlobalFinished  
	回滚操作完成后，分支事务的相关undo_log（撤销日志）被删除。  
	undo_log的删除意味着该分支事务的操作已经完全撤销，并且全局事务的状态被标记为GlobalFinished，表示事务已结束。  
	6. Branch Rollbacked result: PhaseTwo_Rollbacked  
	分支事务的回滚已成功完成，系统记录了“第二阶段回滚完成”（PhaseTwo_Rollbacked）。  
	在分布式事务中，Seata一般会分为两个阶段：第一阶段是操作执行，第二阶段是根据事务状态来决定是回滚还是提交。  
	7. Suspending current transaction, xid = XID  
	当前的全局事务被挂起，表示该事务暂时处于非活动状态。通常发生在事务处理结束后，等待最终的结果确认（如提交或回滚）。 
	8. Rollback status: Rollbacked  
	最终，系统报告了回滚操作的状态为“回滚完成”（Rollbacked）。  
	这意味着所有相关的操作都已恢复至初始状态，事务的回滚操作已经成功执行。
![AT模式示意图|700x418](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412609649171741260964467.png)
#### TCC 模式（Try Confirm Cancel）
- **核心：** 显式定义三段操作：
    1. **Try：** 资源预留；
    2. **Confirm：** 真正执行业务提交；
    3. **Cancel：** 回滚预留资源；
- **优点：** 高性能、强业务控制；
- **缺点：** 对业务侵入性强，需要开发者自己实现三段逻辑；
- **适用：** 高并发、高一致性要求的业务，比如支付、库存冻结等。
#### SAGA 模式（长事务拆分）
- **核心：** 将大事务拆分为多个本地子事务，按顺序执行，每个子事务都有对应的补偿操作（非回滚）；
- **流程：**
    - 正向执行每个子事务；
    - 若有失败，按相反顺序执行补偿操作；
- **特点：**
    - 弱一致性（最终一致）；
    - 无需锁定资源；
    - 适合长事务或异步场景（例如订单 + 发货）；
- **实现：** 可用 Seata Saga 模块实现（基于状态机或注解模式）。
### 总结
- 借由**补偿机制**来解决 分布式事务下的 不同服务间 事务回滚不成功的问题(不同服务, 不同数据库)
- 例子: 在business服务中启动@Transactional事务, 但是通过feign调用了member服务,business服务发生异常, 由于不在同一个服务中, 对member服务的回滚失败
- **引入分布式事务导致的性能下降**:
	- 网络通信开销(后端微服务与 TC 通信、RM 上报、TM 协调)
	- 锁竞争导致的时间变长(全局锁、分支事务锁)
	- 日志记录(Undo/Redo日志)也需要开销
- **优化**: 
	- 增加节点
	- 减少使用全局事务
	- 选用合适的seata模式
	- 分库分表
	- 使用缓存
	- 使用队列或者开启异步线程处理特定业务
## `Sentinel`
### 序章
- **Sentinel** 是一款面向**分布式微服务架构**的轻量级 **流量控制与熔断降级** 组件
- 主要以流量为切入点，从**流量控制(限流)**、实时监控、**熔断降级**、系统负载保护等多个维度帮助用户保护服务的稳定性
- 限流是做在被调用方(前端用户), 熔断是做在调用方(后端服务)
### 限流算法
- **静态窗口(默认):也叫计数器**:
	- 静态窗口算法**把时间划分成固定大小的窗口**，每个窗口内都有一个**请求计数器**。当请求数达到限制值时，新的请求将被拒绝。窗口在时间到达后重置。
	- 面对突发性的**流量突增**（即请求集中的情况), 会拒绝全部请求
- **动态窗口**：
	- 静态的升级, 通过 **滑动窗口(动态时间内)** 动态调整限流阈值，更加灵活应对流量波动。
	- **计算开销较大**，每次请求都需要计算滑动窗口内的请求总数。
	- 可以使用 **滑动窗口限流** 进行灵活控制，避免了静态窗口带来的流量爆发问题
- **漏桶算法**：
	- **控制每秒的最大访问请求**，**超过阈值的新请求**会加入队列排队等待，队列慢了就丢弃
	- **有请求丢失问题, 将突发性请求变均匀**
- **令牌桶算法**：
	- 令牌桶算法与漏桶相似，但其**令牌发放速率是可调的**。请求必须先获取一个令牌才能执行操作，桶内的令牌数量有限(容量可控)。**当令牌数量为零时，新的请求被拒绝**
	- **可能出现令牌空缺**，如果令牌速度过慢，短时间内可能会有大量请求被拒绝(**流量突增**)
- **令牌大闸**：
	- 这是对令牌桶算法的扩展，采用了一个令牌池的管理机制，对令牌进行更加精细的控制
### 限流
- 概念: 对**URL**或**请求方法**进行 **QPS** 或**并发线程数**的限制
- 核心原则
	- 资源命名：建议为受保护资源自定义名称，避免直接使用请求路径作为资源名
		- **@SentinelResource(value = "saveOrder", blockHandler = "flowExceptionHandle")**
	- 限流类型：
		- **整体限流**：对所有请求线程统一进行限流判断。
		- **条件限流**：在业务代码中对请求线程做条件判断后，再进行限流。
	- 降级策略：
		- 当请求被限流时，可自定义降级处理逻辑，提供一个兜底信息, 确保用户体验不至于完全断裂。
		- 限流模式（令牌桶或漏桶）Sentinel 使用滑动窗口限流算法来实现限流。
- 流控效果:
	- **快速失败(默认)**
	    - 请求一旦超过限制，**立即被拒绝并返回错误**，不做排队处理。
	    - 优点：响应迅速，占用资源少。
	    - 适用场景：对响应时间敏感的服务。
	- **预热（Warm Up）**
	    - 用于处理系统冷启动时的流量激增问题。
	    - 设置一个预热时长，在该时段内限制**通过速率逐渐上升**，避免服务刚启动就被压垮。
	    - 适用场景：需要冷启动保护的服务（如定时任务、大促活动前）。
	- **排队等待（Rate Limiter + Queueing）**
	    - 请求超过阈值后，不立即拒绝，而是进入队列排队，等待处理。
	    - 可配置最大等待时间。
	    - 适用场景：允许延迟、但希望**尽量不丢请求**的业务（如订单处理、消息投递）。
- 流控模式（控制维度）

| 模式                | 说明                                                  |
| ----------------- | --------------------------------------------------- |
| **QPS 限流**        | 基于单位时间内的请求次数（Queries Per Second）进行控制。超出后按照所选流控效果处理。 |
| **并发线程数限流**       | 控制同时处理请求的线程数，适用于资源敏感的场景。                            |
| **链路限流（链路调用链控制）** | 对指定调用链上的某一资源进行限流，精细控制调用路径下的热点资源。                    |
| **参数限流（热点参数限流）**  | 根据请求参数的值进行限流，常用于热点资源防护，例如某商品ID请求频繁。                 |
| **自定义条件限流**       | 可以结合业务标签或特定字段实现动态限流策略。                              |
### 熔断
- 概念: **当某个服务出现故障或异常时，服务熔断可以快速隔离该服务，确保系统稳定可用**
- 核心原则:
	- 类型
		- **慢调用比例**: 如果调用**响应时间**过长，触发熔断
		- **异常比例**: 根据一定窗口时间出现异常的比例来判断是否熔断
		- **异常数**: 根据一定窗口时间出现异常的数量来判断是否熔断
- 注解保护资源 **@SentinelResource(value = "GET:/api/hello", fallback = "fallback")**
- **熔断降级**: 其实跟限流降级是一样的, 都是在触发限流和熔断的情况下提供兜底方案, 自定义异常信息或者返回信息

| 参数名                  | 说明                                                                             |
| -------------------- | ------------------------------------------------------------------------------ |
| `resource`           | 熔断作用的资源名（建议自定义）                                                                |
| `grade`              | 熔断类型（上面 0/1/2）                                                                 |
| `count`              | 根据类型不同表示不同含义：  <br>• 慢调用：阈值响应时间（ms）  <br>• 异常比例：最大异常比例（如 0.3）  <br>• 异常数：最大异常数 |
| `minRequestAmount`   | 最小请求数，达到该数量后才会触发熔断                                                             |
| `slowRatioThreshold` | 慢调用比例阈值（仅适用于慢调用类型）                                                             |
| `timeWindow`         | 熔断时长（单位：秒）                                                                     |
| `statIntervalMs`     | 统计时间窗口（毫秒）                                                                     |
### 限流和熔断的区别
| 对比项            | 限流（Rate Limiting）              | 熔断（Circuit Breaking）           |
| -------------- | ------------------------------ | ------------------------------ |
| 目的             | **保护服务**不被突发高流量压垮              | **阻断不稳定下游服务**，防止故障放大           |
| 适用对象           | 通常是对**入口请求**做控制（如接口访问、用户请求）    | 通常是对**服务间调用**（如微服务 A → B）做保护   |
| 判断依据           | 请求的 **QPS（每秒请求数）** 或 **并发线程数** | 请求的 **响应时间**、**异常比例、异常数**      |
| 行为             | 达到阈值时：  <br>拒绝请求 或  排队等待       | 达到阈值时：  <br>快速失败，不再发请求给下游      |
| 响应模式           | 通常立即返回或等待排队                    | 熔断期间直接走 fallback               |
| 核心指标           | - QPS  <br>- 并发线程数  <br>- 排队时间 | - 异常比例  <br>- 异常数  <br>- 慢调用比例 |
| 常见应用           | API 网关限流、用户行为限流、热点接口保护         | 微服务之间的调用、远程调用超时/不稳定保护          |
| 配置方式（Sentinel） | 流控规则（FlowRule）                 | 熔断规则（DegradeRule）              |
| 是否允许重试         | 可以（排队模式）                       | 不允许（熔断期直接失败）                   |
|                |                                |                                |
### 注意
- 跟seata一样, 发生异常时被自定义异常处理器处理, 那么就不会被sentinel认为发生了异常(因为响应头的status是200), 也就不会进入降级的逻辑 
- 当某个服务出现故障或异常时，服务熔断可以快速隔离该服务
- 当系统出现异常情况时，服务降级会主动屏蔽一些非核心或可选的功能，而只提供最基本的功能,当服务熔断打开时，Hystrix 可以提供一个备用的降级方法或返回默认值，以保证系统继续正常运行。开发者可以定义降级逻辑，例如返回缓存数据、执行简化的逻辑或调用其他可靠的服务
- 线程池隔离：Hystrix, Sentinel, Feign将每个依赖服务的请求都放在独立的线程池中执行，避免因某个服务的故障导致整个系统的线程资源耗尽。通过线程池隔离，可以提高系统的稳定性和可用性。
## 总结
![17412622159201741262214989.png|700x406](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412622159201741262214989.png)![17412624199221741262419741.png](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17412624199221741262419741.png)