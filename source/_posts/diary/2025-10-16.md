# 2025-10-16
针对项目中的实习经历进行自我拷打

- 简单说一下实习?
	- 那我就简单说一下我负责那两个模块
	- **在保险这块**, 公司为商户提供了保险服务, 我主要负责与白鸽保险第三方接口的对接, 整个流程是在用户点击投保前端会做一个跳转, 接入第三方接口，支付完成后由第三方回调，我再根据回调结果更新数据库, 主要实现了像投保, 查询, 取消的功能,, 其中有一个业务场景就是要在用户进入保险页面时弹出一个免费保险按钮, 而这个按钮的出现条件是判断店铺是否总营销金额超过1000, 我原本的逻辑是通过一整个订单表然后计算营销额, 但是订单表的数量太大, 这样做会导致整个系统卡顿, 为了解决这个问题, 我在订单拓展表添加一个字段, 在用户下单的实时更新这个字段, 性能提高非常明显
	- **烟柜这块**偏向IOT, 主要是公司在便利店里新增了智能烟柜, 用来防止未成年拿烟, 整体流程是是在用户扫码后, 后台通过Redis判断是否通过未成年校验, 如果没有通过的话, 由前端收集姓名, 身份证号和活体视频, 后端调用阿里云人脸核身服务进行校验, 这里用Redis保存任务id和烟柜码, 通过异步回调获取结果,  如果验证通过, 后端通过烟柜码拿到产品key向阿里云MQTT服务器指定Topic推送消息实现远程开门,  同时向微信小程序发送开门提醒, 在测试的时候出现用户频繁开关门导致的柜体状态不同步的问题, 我的优化方案是通过AOP拦截阿里云发送开门消息的方法, 获取返回值确保消息发送成功, 以“设备名+通道号”为key，继电器状态为value，时间戳为score，利用Redis ZSet进行去重和排序, 开启一个延时3s的异步任务, 异步任务的逻辑就是取出最新状态更新数据库, 这种方案类似前端防抖，能有效规避了大量高并发问题
	- 另外, 还在烟柜模块中加入了AI稽查, 用来辅助判断用户是否真的从烟柜里拿了烟, 具体流程是将相关的出入记录id传递到大模型, 大模型再去调用视频流接口实现AI判定是否有拿烟这个动作, 最后与人工判断进行对比, 实现AI+人工混合稽查, 一方面通过结果来对有出入的结果进行复核, 另一方面为大模型训练提供素材, 不断提高大模型的准确度, 为后面的全流程ai铺路

- **保险模块的提问**
	- 对于你说了将外部接口统一封装成独立调用类, 为什么要这么干?
		- 因为接入第三方服务的话, 需要从配置文件中拿到公钥, 私钥, 域名和url地址,接着用RSA对body进行非对称加密, 然后才能用Http工具类发送http请求, 所以封装一个api类我相信是大多数公司都会做的一件事, 减低了耦合性, 提高了开发效率
	- 目前保险模块实现了哪些功能??
		- 投保, 回调处理  -> 查询我的投保 -> 退保 -> 在我的保单中添加免费保险逻辑
	- 你是怎么进行异常和日志的统一处理的?
		- 采用Aop对特定方法进行切面进行日志记录, 可以同时使用log.warn记录
	- 什么是保单的多状态流转?
		- 当用户在查询我的保单时, 会先判断是否有资格领取免费保险, 店铺总销售金额要超过1000元, 如果已经有保险了, 那么根据保单状态返回列表就行, 保单的多状态流转其实是保单从一种状态到另一种状态的切换, 公有7种状态, 我使用到了Stream流简化书写, 避免了繁琐的ifelse
	- 你是怎么通过biz_order_sn来保证幂等性的
		- 在我们作为主方向第三方发送投保请求后, 第三方需要向我们推送投保成功的回调, 通常这个回调会有重试机制, 所以必须通过唯一性字段和redis做去重来保证同一个订单只会被回调一次
			- 在Redis中保存biz_order_sn字段
			- 在数据库中为biz_order_sn字段添加唯一索引
		- 这两种办法都是确保同一个保单不会被处理多次的幂等性解决措施
	- 定时任务是这么做的?
		- 使用Quartz这个任务调度框架, 相比于spring自带的@Scheduled功能更丰富, 并且能支持在不重启服务的情况下对任务进行crud
		- 在每天凌晨5点执行定时任务, 筛选出保单状态为在保中的保单, 判断是否已经过期, 如果过期, 修改保单状态为已过期, 筛选出保单状态为未支付 时间为前一天的保单, 修改保单状态为已取消, 实现了保单的自动化管理, 减少了人工干预

- **烟柜模块的提问**
	- 第三方回调延迟或重复应该怎么办?
		- 因为大部分的核实服务都是异步回调来返回结果的, 所以我首先是对回调结果用Redis做了一个幂等处理, 如果是重复回调的话不再执行业务, 然后返回第三方200表示接收成功, 停止重试
	- 为什么一个继电器设备可以同时控制多个硬件组件
		- 一个继电器设备通常具备多通道设计，每个通道可独立控制对应的硬件组件（如门锁、照明、麦克风等）。通过这种多通道架构，可以在一个 MQTT 长连接下实现对多路设备的统一控制与状态反馈，大幅提升通信效率与系统稳定性
	- 说说你是怎么实现设备状态同步的?  -> 不局限于烟柜
		- 是这样, 我们公司的所有继电器设备以及其他 例如sip设备和自研的K系列主板设备首先是在设备上线的时候主动拉取去获取继电器状态, 如果有状态变更的请求的话, 例如像开关烟柜门这类的, 当在向阿里云IotAmqp服务器推送设备状态变更消息后, 我们会对IotAmqp的Pub方法进行返回值的切面拦截, 判断回调是否为success, 如果是, 则发送异步继电器状态同步延时3s的消息, 可以理解为前端的防抖, 因为我们每次修改继电器状态的时候都会以设备名称加通道Numble为key, 以继电器状态为value, 以时间戳为score, 所以可以利用Redis的Zset进行去重与排序处理, 最后只取出最新的状态进行数据库更新即可, 保证了高并发场景下的状态同步
	- 项目中遇到了什么难点? 你是怎么解决的?
		- 在烟柜模块中, 会出现用户频繁开关门导致的高并发状态不同步的问题, 我的优化是在开启烟柜门时, 通过AOP拦截阿里云发送消息的方法, 获取返回值确保消息发送成功, 以“设备名+通道号”为key，继电器状态为value，时间戳为score，利用Redis ZSet进行去重和排序, 开启一个延时3s的异步任务, 取出最新状态更新数据库, 其中定义一个key标记已经开启了一个任务, 避免大量任务被创建，这种方案类似前端防抖，有效规避了大量高并发问题
	- AI稽查 大模型有几个动作?
		- 两个, 一个是得到出入记录id, 然后拿到出入记录id后通过视频流判断是否有拿烟这个动作; 另一个是返回是否拿烟结果, 保存到数据库
	- 在实现稽查这个模块的时候有遇到什么难点吗? 怎么解决的?
		- 在做将稽查任务下发给稽查客服进行核实的时候, 出现了拿取的出入记录不全的情况
		- 在复查过程中发现, 因为我们取得的出入记录是根据前一天的7点半到今天的7点半, 所有导致一些出入记录跨越了这个时间范围, 可能是由入店时间, 但是没有出店时间, 有些则相反, 所以会导致数据的丢失, 对于这个问题, 我做了加长时间的笼余处理, 从前一天的7点半到今天的8点半, 除此之外, 我利用Redis还对残缺数据对了存储, 第二天再从中取出进行比对后处理
	- 设备状态检测是怎么实现的? -> 针对于自研设备, 阿里云设备由他们自主检测
		-  定时任务：每5分钟执行一次心跳检查; 拿取全部设备时利用取余进行分片检测，避免单次处理过多设备; 利用Redis做防重复检测(3秒内不允许重复检测); 如果检测重试超过一定次数标记该设备离线