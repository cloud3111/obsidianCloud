# 2025-05-16
JUC并发和spring框架的复习

- 并行和并发的区别:
	- 并发是单核执行, 只是看起来是同时, 其实有先后顺序
	- 并行是多核多线程, 真正的同时执行, 并且必须是多核
- 进程和线程的区别: 进程是指一个应用程序, 线程是指进程中的执行单位, 线程具有独立的栈和寄存器
- 线程通讯: JVM中是通过JMM内存模型来实现的, JMM中有主内存, 主内存中有共享变量, 而独立线程的本地内存存放有共享变量的副本, 所以通讯是线程a将本地内存的共享变量副本的值刷新到主内存, 然后线程b读取刷新的主内存, 并同步到自己的本地内存的共享变量副本, 实现线程通讯
- 注意: ThreadLocal线程下的共享变量副本不需要同步, 是线程独占的(ThreadLocal不是共享的)
- 线程的内存占用是1M(占用栈和寄存器), 所以一个进程最多有多少线程取决于方法栈的大小(ThreadStackSize)
- 进程启动有一个主线程main, 有一个gc线程(守护线程), 有一个编译器线程JIT
- 调用 start方法时会执行 run方法，那怎么不直接调用run方法? 因为直接执行run默认在当前线程执行, 而不是创建新线程异步执行(调用 `start()` 后，线程进入就绪状态，等待操作系统调度；一旦调度执行，线程会执行其 `run()` 方法中的代码。)-
- 懒汉式单例则在第一次使用时初始化单例对象，这种方式需要使用双重检查锁(volatile 关键字用来保证可见性，synchronized关键字用来保证同步。)来确保线程安全，而饿汉式是在类加载就创建单例就可以保证线程安全

- 死锁是指两个线程都持有对方的锁, 都在循环等待对方释放锁, 可以通过JStack, JConsole和VisvalVm查询线程状态, 避免死锁的方法是 使用tryLock方法设置超时时间释放, 或者设置线程的执行顺序
	- 线上排查CPU占用高的进程, 使用top查询, 然后使用Jstack pid查看是否有死锁deadlock(直接显示)

- BlockingQueue >是 JUC 包下的一个线程安全队列，支持阻塞式的"生产者-消费者”模型
- 阻塞队列使用 [ReentrantLock](https://javabetter.cn/thread/reentrantLock.html) + Condition 来确保并发安全
- 线程池有5种阻塞队列: 有界队列数组 ArrayBlockingQueue；无界队列链表 LinkedBlockingQueue；优先级队列 PriorityBlockingQueue；延迟队列 DelayQueue；同步队列 SynchronousQueue。使用无界队列虽然可以避免任务被拒绝，但是可能会导致内存耗尽
- 线程池提交execute和 submit有什么区别？submit有回调返回值
- 线程池的线程数应该配置多少合适？
	- 看任务类型: 分CPU密集型和IO密集型
	- CPU密集型的话是指占用算力, 少阻塞, 应该使用较少的线程数, 推荐cpu核心+1就好
	- 如果是IO密集型的话, 经常进行文件读取和网咯请求, 经常阻塞, 为了不耽误时间, 应使用更多的线程数, 推荐使用cpu核心* 2或者更多
- 处理线程池异常: 使用tryCatch捕获, 自定义 ThreadPoolExecutor 重写 afterExecute 方法


- spring框架运用到了很多模式: 比如静态方法创建对象的工厂模式, 构造唯一对象的单例模式, aop切面编程时用到的代理模式
- Web 容器关注的是 Web 层请求的接收与响应，而 Spring 容器关注的是 业务 Bean 的创建和管理
- Spring 容器负责管理 Java 对象（Bean）的生命周期和依赖注入，  
- Web 容器负责管理 Servlet 生命周期、处理 HTTP 请求，是 Web 程序的运行环境。
- 制对象生命周期的不再是引用它的对象，而是容器，这就叫控制反转（Inversion of Control）

- bean的是生命周期: 1实例化(空参构造器) 2属性赋值注入 3初始化(bean前置和后置处理器的处理逻辑) 4使用 5销毁destroy
- 为什么不推荐使用@Autowired? 
	- 因为不能想构造器那样使用final注入不可变对象, 减少错误风险
	- 因为是隐式的, 无法看到具体使用到了那些依赖, 不利于拍错, 比如说循环依赖问题
- @Resource和@Autowired的区别? 
	-  @Resource是jdk的, 优先按照名字注入
	- @Autowired是spring框架的, 优先按照对象类型注入, 如果有多个同一类型的报错建议使用@Qualifier 注解来指定具体的 bean 名称
- bean的作用域: 可以使用@scope指定作用域(singleton, prototype, session, request)
- 单例bean的内容怎么保证线程安全: 1.使用ThreadLocal隔离 2.使用多例bean 3.使用局部变量 4.使用原子类
- 依赖循环问题的解决措施:
	- 使用构造器注入在编译时期就能发现循环问题
	- 使用@Lazy注解实现延迟加载

- CGLIB动态代理和JDK动态代理对比
	- 代理对象生成方式不同: 基于字节码生成子类 基于反射生成$proxy0代理类
	- 方法的调用方式不同: 基于底层super()调用 基于proxy.方法调用
	- 初始化效率: 直接生成子类效率低 反射newInstance效率高
	- 方法执行效率: 执行效率高(直接调用父类方法) 执行效率低
	- 总结: CGLIB 由于主要基于字节码操作，**如果是只要初始化一次且方法要长期被调用,它的性能通常高于 JDK 动态代理,** 不需要频繁修改代理逻辑，因为cglib代理是子类,父类修改了子类也要跟着改, 并且内存占用要高于jdk代理
	- 虽然 CGLIB 在代理类的生成过程中可能消耗更多资源，但在运行时具有较高的性能。对于性能敏感且代理对象创建频率不高的场景，可以考虑使用 CGLIB。
	- JDK 动态代理是 Java 原生支持的，不需要额外引入库。而 CGLIB 需要将 CGLIB 库作为依赖加入项目中。

- 事务的4大特征(和线程安全的3大特征对比): ACID 原子性 一致性 隔离性 持久性
- 事务隔离级别: 读未提交 读已提交(解决脏读) 重复读(解决脏读,不可重复读, MySQL默认) 串行化(解决所有,效率最低)
- 事务传播机制: require(在当前方法中没有事务就创建一个事务, 有加入这个事务, java默认)  require_new(无论是否有事务，都开启一个新的事务, 但是外部事务不会影响到内部事务) nested(如果当前有事务, 内部的调用会创建一个新事务, 如果内部事务回滚，不会影响外部事务，但如果外部事务回滚，嵌套事务也会回滚)
- 注意: 只有通过 Spring 容器的 AOP 代理调用的公开方法（public method）上的`@Transactional`注解才会生效。
- @Transactional失效:  在同类中相互方法调用 不是public修饰 rollbackFor对象错误 propagation参数错误 

| 名称          | 类型  | 是否推荐  | 说明                                         |
| ----------- | --- | ----- | ------------------------------------------ |
| **JUL**     | 实现  | ❌ 不推荐 | JDK 自带，功能弱，格式化难用，扩展性差                      |
| **JCL**     | 门面  | ❌ 不推荐 | Commons Logging，曾被广泛使用，但有“ClassLoader冲突”问题 |
| **Log4j 1** | 实现  | ❌ 弃用  | Apache 的早期实现，性能一般，已停止维护                    |
| **SLF4J**   | 门面  | ✅ 推荐  | 简洁、统一、无依赖冲突，配合 Logback/Log4j2 使用非常稳定       |
| **Logback** | 实现  | ✅ 推荐  | SLF4J 的原生实现，性能好、功能全，支持异步、滚动、格式灵活           |
| **Log4j2**  | 实现  | ✅ 推荐  | Log4j 的升级版，高性能，支持异步日志、分级路由等，配置略复杂          |
- 日志门面使用Slf4j, 具体实现使用logback