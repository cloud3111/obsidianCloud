# 2025-05-12
	# 2025-05-12
今天把简历准备好了, 准备开始背八股准备面试

项目经历的相关知识点尤为重要, 把重点放在重要的知识点上

- [x] 系统知识总览
	- [x] Java基础篇50%
	- [x] Java基础篇100%
- [ ] 重点突出
- [ ] 常见的面试题总结

- JRE（Java Runtime Environment） 由 JVM虚拟机(将java代码编译成.class字节码再转换为二进制机器码并执行) + Java Class Library(Java类库) 组成
- JDK（Java Development Kit） 由 JRE  + 开发工具(javac, javap, jar) 组成;
- 跨平台: 一次编译成字节码, 在其他操作系统上安转JDK就可以执行
- JAVA代码的执行流程: 编译 -> 解释 -> 运行, 其中JVM起到了编译和解释的作用, 而运行由操作系统来执行
- JIT 即时编译器: 首先要理解一个思想, java的字节码是按整体编译而来的, 而转换成机器码的过程则是逐行, 所以在解释的时候JIT就发挥作用了, 将热点字节码代码 转换成 机器码 作为缓存 直接执行, 不需要每次解释都要经过jvm
- java是解释型语言: 按照上面的思想, 找个翻译，翻译一段执行一段, 而不是一次性将字节码转换为机器码直接执行, 跨平台特性和执行慢的特性
- Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码，通过JVM解释成机器码之后才能运行。不同平台下编译生成的字节码是一样的，但是由JVM解释成的机器码却不一样在不同操作系统不一样

- 一个int是4个byte == 32个bit; 而char是2个byte == 16个bit 
- 8个基本数据结构: byte short int long, 大整数每次以2的几次方递增 1 2 4 8, float是对标int整数的单精度小数, double是对标long整数的双精度小数, 以及boolean, boolean类型为1或者4个字节, 没有明确规定多少字节  `char` 在 Java 中占两个字节
- 绝大多数编程语言和操作系统使用的是“字节流”，而不是比特流。在 应用层、编程语言、文件处理、网络通信中，字节流几乎是标准。比如较为常用的 inPutStream, outPutStream, 磁盘, 文件系统都是以字节为单位, 只有在物理层, 通讯协议等较为底层的方面采用比特流
- 基础数据类型与引用数据类型, 类型转换和隐式类型转换, 封箱和拆箱
- &逻辑与 是 二进制的bit位运算: 相同才为1  (hash - 1)&size -> 哈希函数
- 冷知识: String 不是 8大基本数据类型,  它是一个对象，在 `java.lang.String` 类中定义
```java
// 用位运算来做乘法
十进制：2      → 二进制：0000 0010
左移3位：2 << 3 → 二进制：0001 0000 → 十进制：16

用 二进制 来直观地看看 `(h = key.hashCode()) ^ (h >>> 16)` 是怎么“搅拌”高低位的
h = 1010_1100_1111_0000_1111_0000_0000_0001
// 右移16位 低位丢弃 高位补蛋
h >>> 16 = 0000_0000_0000_0000_1010_1100_1111_0000
// ^ 为异或符号: 两符号相同为0 不同为1  00 11得0  10 01 得1
异或结果(^):  1010_1100_1111_0000_0101_1100_1111_0001
```
- 一个int占4byte == 32bit, 所以当左移右移大于int占有的bit位时, 需要先通过%取余再移动, 例如: 左移 42 位相当于左移 10 位（42%32=10）
- java自增++的原理就是用一个temp来过渡: 
```java
int i = 1;
i = i++;
sout(i); // 答案是1, 因为这里是temp的值

int i = 1；
int temp = i;
i++；
i = temp;
System.out.println(i);
```
- 避免精度丢失的方法: 使用BigDecimal, 64 位 long 整型是最大的整数类型, 而bigDecimal底层采用了int [] 所以才能保证数值的扩充, 但是效率低下
- 如果要将一个数据类型转化为另一个超出范围的数据类型的话, 会发生下溢和截断, 负数也有可能
- a = a + b 与 a += b 的区别:  后者如果超出范围支持强制类型转化  极端的思想
	- 当给 Integer.MAX_VALUE 加 1 时，会发生溢出，变成 Integer.MIN_VALUE

思路: 定义 + 区别
- 封装, 继承, 多态: 方便使用实例调用属性与方法, 减少代码书写量, 定义了接口规范
	- 封装的含义: 把属性和方法封装到一个对象当中, 不允许外部对象直接访问对象的内部信息, 但是可以提供一些可以被外界访问的方法来操作属性
- 重载和重写: 重载是同方法名但是方法参数的不同, 重写是子类重写定义且覆盖父类方法, 区别是重载在同一个类中, 重写发生在父类和子类中
- this 表示当前对象的引用,你可以通过它来访问当前对象的字段,方法和构造器
- super 关键字用来指代父类的对象,通过 super 可以访问父类的字段,方法和构造器
- 抽象类和接口的区别: 接口和抽象类都是一种规范, 但是范围不一样, 一个类只能继承一个抽象类, 但是能实现多个接口, 而且接口相互之间能通过继承相互联系, 接口a可以继承接口b, 但是最主要的区别是:
	- 一个类只能继承一个类，因为 Java 不支持多继承
	- 抽象类为多个类提供一个标准的框架, 包括这个框架的初始化
	- 接口则是为多个类提供一种行为准则, 使得多个类在这个准则下实现行为多样化
	- 抽象类的方法可以有方法体, 接口不行
- static关键字允许你在没用创建对象的情况下调用属性方法
- 引用变量也就是指针放在栈中, 而对象放在堆中, 静态变量放在静态区
- 静态代码块通常用来初始化一些静态变量，它会优先于 `main()` 方法执行, 如果没用main就会报找不到主类 NoClassDefFoundError 的错误
- final关键字变量不允许变动, 方法不允许重写, 在修饰一个引用变量时, 如果是基本数据类型则不可变, 如果是引用对象的内容可以变动 -> 因为final修饰的是一个地址值, 保证地址值不可变就行
- 当 final 修饰一个类时，表明这个类不能被继承   当 final 修饰一个方法时，表明这个方法不能被重写
- equal比较的内容是否变动, 必须重写方法
- 根据 Java 规范，两个使用 equals() 方法来判断相等的对象，必须具有相同的 hash code。
- Java 中的任何类都包含有 `hashCode()` 函数   不是java的所有对象都是以hash桶结构存储在堆当中, 堆是线性内存空间, 只有hashMap和hashSet才使用桶存储, 每个对象都有hashcode()是因为所有类都默认继承自 Object类, Object类又定义了hashCode方法来通过地址值给每一个对象赋一个int类型的hashCode, 以此来保证访问的身份凭证, 又因为通过hashCode拿对象的效率高 -> 核心思想：先用 `hashCode()` 快速定位，再用 `equals()` 精确匹配
- 重写了 `equals()`，必须对应重写 `hashCode()`，否则会破坏哈希结构的查找逻辑, 而且有hashCode就会有哈希冲突, 可能会出现查找对象的重复
- 引用拷贝, 浅拷贝和深拷贝区别: 引用拷贝是指无论是基本数据类型还是引用类型, 用的都是同一个指针指向的同一个堆实例对象, 如果是浅拷贝的话, 则是指针会不同, 而深拷贝指针和对象都不同
![17604205238051760420522819.png|700x191](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17604205238051760420522819.png)
- new对象的4种方式: 1.new 2.反射(在运行时创建对象) 3.实现 Cloneable 接口并重写 clone 方法拷贝实现 4.将对象转换为字节流，再通过反序列化从字节流中恢复对象。需要实现 Serializable 接口
- 按照约定，相等的对象必须具有相等的哈希码。如果重写了 equals 方法，就应该重写 hashCode 方法。可以使用 [Objects.hash()](https://javabetter.cn/common-tool/Objects.html#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84hashcode) 方法来生成哈希码。

- Integer包装类型的缓存池存放的是 -128~127
	- 别忘了编译器的自动封箱拆箱, 所以 Integer a = 1 会自动变成 Integer a = Integer.valueOf(1)   如果是 new Integer(1) 和 new Integer(1)那么也不会是相同的
	- Integer.valueOf(1)其实拿到的是同一个对象
- 可以通过`-Djava.lang.Integer.IntegerCache.high=1000` 来调整缓存池的最大值
- `Byte`,`Short`,`Integer`,`Long` 对于这 4 种包装类默认创建了数值 -128，127 的相应类型的缓存数据，`Character` 创建了数值在 0,127 范围的缓存数据，`Boolean` 直接返回 `TRUE` or `FALSE`
- 切记他们都是xxx.valueOf的时候使用到了缓存
- String类型内部底层char 数组使用final修饰, 表示String的值不可变 
- 字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象
- 手动使用 StringBuilder 来进行拼接效率高
- 如果字符串常量池中不存在字符串对象 “abc”，在堆内存中再创建其中一个字符串实例对象, 然后在字符串常量池中创建字符串对象 "abc"
![17604313738031760431373649.png|700x350](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17604313738031760431373649.png)
- 对于不想进行序列化的变量，使用 `transient` 关键字修饰。
- `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`

- 为什么LinkedList不能实现randomAccess接口, 而ArrayList就可以?
	- 因为ArrayList的底层是一串连续的存储空间, 而LinkedList则是采用链表指针, 故不支持快速访问条件(通过元素序号快速访问元素对象)
- 一般来说, 我们在项目中是用不到LinkedList的, 就连LinkedList的作者也说不会使用LinkedList, 因为LinkedList需要多占用前后两个指针的存储空间, 使用LinkedList的场景可以用ArrayList替代, 查询效率更高 

- 当你需要使用栈或者队列时，可以考虑使用_LinkedList_，一方面是因为Java官方已经声明不建议使用_Stack_类，更遗憾的是，Java里根本没有一个叫做_Queue_的类(它是个接口名字)。关于栈或队列，现在的首选是_ArrayDeque_，它有着比_LinkedList_(当作栈或队列使用时)有着更好的性能, 首选_ArrayDeque_了(次选是_LinkedList_)