# 2025-09-23
	今天回顾了一遍后发现自己还有些地方没掌握好，所以打算再把这几天学的内容重新过一遍
## Leetcode算法
- [ ] 两数之和  采用哈希表做缓存, 用`findValue = target - nums[i]`匹配求值
- [ ] 字母异位词分组  用一个哈希表保存HashMap<排序之后的字母, 字母组合集合>,重点是循环每个字符并Arrays.sort(charArray)
- [ ] 最长连续序列  利用HashSet无重复的查询, 查询是否有前值和后值
- [ ] 移动零  起点双指针解决问题
- [ ] 盛最多水的容器  头尾双指针, 关键是判断哪边低就++或--, 求的是面积
- [ ] 三数之和  排序, for+while去缩小cur下的窗口  0值运用
![17586143684711758614367648.png|491x164](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17586143684711758614367648.png)
- [ ] 无重复字符的最长子串  前后双指针, 利用HashSet特性判断contains和删除前值和后值就行
- [ ] 找到字符串中所有字母异位词  起点双指针 哈希表保存需要的字符 哈希表保存当前的字符 注意value存的是字符出现的次数
- [ ] 和为 K 的子数组  前缀和 哈希表 key为前缀和 value为出现频率
- [ ] 最大子数组和  利用前缀和 O(2n) 第一次for求出所有前缀和 第二次for慢慢减
- [ ] 合并区间 先对所有的左值左排序`Arrays.sort(intervals, (p,q) -> p[0] -q[0])`主要是工具类api的运用
- [ ] 轮转数组  主要是取余 切分为两部分 分别对这两部分做移动
- [ ] 除自身以外数组的乘积  上下三角 切记乘积的初始值是1不是0
![17586201514661758620151354.png|560x329](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17586201514661758620151354.png)
- [ ] 相交链表   一个HashSet搞定 在另一个链表中有包含就是相交点
- [ ] 反转链表  修改指针指向 注意这里使用的是前后双指针
![17586307724671758630772328.png|700x260](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17586307724671758630772328.png)
- [ ] 回文链表  将复链表制到数组中用头尾双指针 向中间靠拢 判断是否有相同的值
- [ ] 环形链表 环形链表Ⅱ  用HashSet判断是否有相同的地址值 注意不要是value
- [ ] 合并两个有序链表   一次while判断在两个链表中的指针值大小, 将结果保存到新链表中
- [ ] 两数相加  定义一个carry进位 取余与除法
- [ ] 删除链表的倒数第N个结点  用一个循环计算链表长度 链表的删除节点
- [ ] 两两交换链表中的节点  前后双指针 然后两两交换即可
- [ ] 随机链表的复制  深度拷贝 用一个新Node节点替代原来的节点 并且nextValue和randomValue也要相同
![17586761663681758676165872.png|700x537](https://fastly.jsdelivr.net/gh/cloud3111/cloudWallpaper@main/17586761663681758676165872.png)
- [ ] 排序链表  将链表移植到列表中, 再进行排序  注意如果容器是`int[]`, `Arrays.sort(int[] a, int fromIndex, int toIndex)`排序是对所有申请空间做排序, 而不是只对占用空间
- [ ] LRU缓存  调用`LinkedHashMap`的api底层是一个双向链表, 相比普通的哈希表多了可排序的特性 并且支持LRU(删除最近最少使用的值)`removeEldestEntry`
- [ ] 二叉树的中序遍历  树支持前序中序后序遍历(递归和栈循环)  根左右 左根右 左右根
- [ ] 二叉树的最大深度  `return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;`
- [ ] 翻转二叉树  把每个节点推入栈, 循环中取出一个 判断左右
- [ ] 对称二叉树  把当前的节点左右节点推入栈, 循环中取出左右, 判断左右的4种情况
- 总结
	- for指向的当前值可以当做指针
	- 滑动窗口套用公式
		- for while , for控制左窗口, while控制右窗口
	- 其实哈希加双指针就可以解决很多问题, 再不行就根据题目找出规律加个判断
	- 指针
		- 如果是`cur = pre`表示把`pre`赋值给`cur`
		- 如果是`cur.next = pre`表示cur指向是pre
		- 主要看前面的属性是什么类型 是值还是指针